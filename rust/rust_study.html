<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="hwu96hHsSnPefhY5oj_Q2reBfC1YuVkwbsuPeuAjSls"><meta name="baidu-site-verification" content="codeva-1TKHma47RE"><script>!function(t,e,n,c,r,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/cnl2uzz0vb?ref=bwt",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,a)}(window,document,"clarity","script")</script><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CPingFang+SC:300,300italic,400,400italic,700,700italic%7CMicrosoft+YaHei:300,300italic,400,400italic,700,700italic%7Csans-serif:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.pengtech.net","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":"enable","bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="1. 第一章: Rust简介1.1. 为什么要用RustRust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换C&#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.Rust是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器"><meta property="og:type" content="article"><meta property="og:title" content="Rust 编程语言入门教程"><meta property="og:url" content="https://www.pengtech.net/rust/rust_study.html"><meta property="og:site_name" content="鹏叔的技术博客"><meta property="og:description" content="1. 第一章: Rust简介1.1. 为什么要用RustRust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换C&#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.Rust是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-10-02T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-01T18:12:12.572Z"><meta property="article:author" content="鹏叔"><meta property="article:tag" content="Rust"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.pengtech.net/rust/rust_study.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.pengtech.net/rust/rust_study.html","path":"rust/rust_study.html","title":"Rust 编程语言入门教程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Rust 编程语言入门教程 | 鹏叔的技术博客</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZZTM0Y954E"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-ZZTM0Y954E","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?1da0f55a32eb17a877b1b18efa3d0406"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i> <span class="site-title h1">鹏叔的技术博客</span> <i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">日拱一卒，功不唐捐!</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-angular"><a href="/angular/" rel="section"><i class="fa fa-th fa-fw"></i>angular</a></li><li class="menu-item menu-item-material-design"><a href="/material-design/" rel="section"><i class="fa fa-th fa-fw"></i>material-design</a></li><li class="menu-item menu-item-linux"><a href="/linux/" rel="section"><i class="fa fa-cube fa-fw"></i>linux</a></li><li class="menu-item menu-item-gitlab"><a href="/gitlab/" rel="section"><i class="fa fa-th fa-fw"></i>gitlab</a></li><li class="menu-item menu-item-frontend"><a href="/frontend/" rel="section"><i class="fa fa-mobile fa-fw"></i>frontend</a></li><li class="menu-item menu-item-backend"><a href="/backend/" rel="section"><i class="fa fa-mobile fa-fw"></i>backend</a></li><li class="menu-item menu-item-vscode"><a href="/vscode/" rel="section"><i class="fa fa-th fa-fw"></i>vscode</a></li><li class="menu-item menu-item-hexo"><a href="/hexo/" rel="section"><i class="fa fa-sitemap fa-fw"></i>hexo</a></li><li class="menu-item menu-item-java"><a href="/java/" rel="section"><i class="fa fa-coffee fa-fw"></i>java</a></li><li class="menu-item menu-item-golang"><a href="/golang/" rel="section"><i class="fa fa-cloud fa-fw"></i>golang</a></li><li class="menu-item menu-item-v2raya"><a href="/v2rayA/" rel="section"><i class="fa fa-cloud fa-fw"></i>v2rayA</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AC%AC%E4%B8%80%E7%AB%A0-Rust%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">1. 第一章: Rust简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Rust"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 为什么要用Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 与其他语言比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Rust%E7%89%B9%E5%88%AB%E6%93%85%E9%95%BF%E7%9A%84%E9%A2%86%E5%9F%9F"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. Rust特别擅长的领域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Rust%E4%B8%8EFirefox"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. Rust与Firefox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Rust%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%A1%88%E4%BE%8B"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. Rust的用户和案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Rust%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. Rust的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Rust%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. Rust的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E6%B3%A8%E6%84%8F"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. 注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-%E5%8F%82%E8%80%83%E6%95%99%E6%9D%90"><span class="nav-number">1.9.</span> <span class="nav-text">1.9. 参考教材</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%89%E8%A3%85Rust"><span class="nav-number">2.</span> <span class="nav-text">2. 安装Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%89%E8%A3%85rust"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 安装rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%85%8D%E7%BD%AERust"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 配置Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%9B%BF%E6%8D%A2%E9%95%9C%E5%83%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1. 替换镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%9B%B4%E6%96%B0Rust"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. 更新Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%8D%B8%E8%BD%BDRust"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. 卸载Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="nav-number">2.5.</span> <span class="nav-text">2.5. 验证安装是否成功</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AArust%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">3. 第二章：第一个rust程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-hello-world"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. hello world</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Rust-%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. Rust 程序解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E6%98%AF%E5%8D%95%E7%8B%AC%E7%9A%84%E4%B8%A4%E6%AD%A5"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. 编译和运行是单独的两步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-hello-cargo"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. hello cargo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-cargo-%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1. cargo 介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E4%BD%BF%E7%94%A8Cargo%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2. 使用Cargo创建项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E6%9E%84%E5%BB%BACargo%E9%A1%B9%E7%9B%AE"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3. 构建Cargo项目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="nav-number">3.5.</span> <span class="nav-text">3.5. 猜数字游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1. 声明变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2. 引入依赖包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">4.</span> <span class="nav-text">4. 第三章 通用的编程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. 变量和可变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2. 变量和常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-shadowing-%E9%9A%90%E8%97%8F"><span class="nav-number">4.3.</span> <span class="nav-text">4.3. shadowing (隐藏)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Rust%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">4.4. Rust数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1. 标量类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">4.4.1.1. 整数类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.5.</span> <span class="nav-text">4.5. 浮点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.6.</span> <span class="nav-text">4.6. 数值操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.7.</span> <span class="nav-text">4.7. 布尔类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.8.</span> <span class="nav-text">4.8. 字符类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.9.</span> <span class="nav-text">4.9. 复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-1-Tuple"><span class="nav-number">4.9.1.</span> <span class="nav-text">4.9.1. Tuple</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-9-1-1-%E5%88%9B%E5%BB%BAtuple"><span class="nav-number">4.9.1.1.</span> <span class="nav-text">4.9.1.1. 创建tuple</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-9-1-2-%E8%8E%B7%E5%8F%96tuple%E7%9A%84%E5%85%83%E7%B4%A0%E5%80%BC"><span class="nav-number">4.9.1.2.</span> <span class="nav-text">4.9.1.2. 获取tuple的元素值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-2-%E8%AE%BF%E9%97%AEtuple%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">4.9.2.</span> <span class="nav-text">4.9.2. 访问tuple的元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E6%95%B0%E7%BB%84"><span class="nav-number">4.10.</span> <span class="nav-text">4.10. 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">4.10.1.</span> <span class="nav-text">4.10.1. 声明一个数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-2-%E6%95%B0%E7%BB%84%E7%9A%84%E7%94%A8%E5%A4%84"><span class="nav-number">4.10.2.</span> <span class="nav-text">4.10.2. 数组的用处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-3-%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.10.3.</span> <span class="nav-text">4.10.3. 数组的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-4-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">4.10.4.</span> <span class="nav-text">4.10.4. 访问数组的元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-3-4-%E5%87%BD%E6%95%B0"><span class="nav-number">4.11.</span> <span class="nav-text">4.11. 3.4 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.11.1.</span> <span class="nav-text">4.11.1. 函数的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-2-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5-statement-%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F-expression"><span class="nav-number">4.11.2.</span> <span class="nav-text">4.11.2. 函数中的语句(statement)和表达式(expression)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-3-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.11.3.</span> <span class="nav-text">4.11.3. 函数的返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-%E6%B3%A8%E9%87%8A"><span class="nav-number">4.12.</span> <span class="nav-text">4.12. 注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">4.13.</span> <span class="nav-text">4.13. 控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-13-1-if-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.13.1.</span> <span class="nav-text">4.13.1. ｉf 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-13-2-%E5%9C%A8let%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8if"><span class="nav-number">4.13.2.</span> <span class="nav-text">4.13.2. 在let语句中使用if</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-14-Rust%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.14.</span> <span class="nav-text">4.14. Rust的循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-14-1-loop-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.14.1.</span> <span class="nav-text">4.14.1. loop 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-14-2-while%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.14.2.</span> <span class="nav-text">4.14.2. while条件循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-15-for-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="nav-number">4.15.</span> <span class="nav-text">4.15. for 循环遍历集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-16-Range"><span class="nav-number">4.16.</span> <span class="nav-text">4.16. Range</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A-%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">5.</span> <span class="nav-text">5. 第四章： 所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">5.1.</span> <span class="nav-text">5.1. 4.1 什么是所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Stack-vs-Heap"><span class="nav-number">5.2.</span> <span class="nav-text">5.2. Stack vs Heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%89%80%E6%9C%89%E6%9D%83%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.3.</span> <span class="nav-text">5.3. 所有权存在的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D"><span class="nav-number">5.4.</span> <span class="nav-text">5.4. 所有权，内存与分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1. 所有权规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.5.</span> <span class="nav-text">5.5. 变量作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-string-%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1. string 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-1-%E5%88%9B%E5%BB%BAString%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">5.5.1.1. 创建String类型的值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F-%E7%A7%BB%E5%8A%A8-move"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2. 变量和数据交互的方式: 移动 move</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F-%E5%85%8B%E9%9A%86-Clone"><span class="nav-number">5.5.3.</span> <span class="nav-text">5.5.3. 变量和数据交互的方式: 克隆(Clone)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-4-Stack%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A-%E5%A4%8D%E5%88%B6"><span class="nav-number">5.5.4.</span> <span class="nav-text">5.5.4. Stack上的数据： 复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-5-%E4%B8%80%E4%BA%9B%E6%8B%A5%E6%9C%89copy-trait%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.5.5.</span> <span class="nav-text">5.5.5. 一些拥有copy trait的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-6-%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.6.</span> <span class="nav-text">5.5.6. 所有权与函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-7-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.5.7.</span> <span class="nav-text">5.5.7. 返回值与作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-8-%E5%A6%82%E4%BD%95%E8%AE%A9%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AA%E5%80%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E8%8E%B7%E5%BE%97%E5%85%B6%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9F"><span class="nav-number">5.5.8.</span> <span class="nav-text">5.5.8. 如何让函数使用某个值，但是不获得其所有权？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8"><span class="nav-number">5.6.</span> <span class="nav-text">5.6. 引用和借用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1. 可变引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2-%E6%82%AC%E7%A9%BA%E5%BC%95%E7%94%A8Dangling-References"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2. 悬空引用Dangling References</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-3-%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3. 引用的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E5%88%87%E7%89%87"><span class="nav-number">5.7.</span> <span class="nav-text">5.7. 切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="nav-number">5.7.1.</span> <span class="nav-text">字符串切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E8%BE%BE"><span class="nav-number">5.7.2.</span> <span class="nav-text">将字符串切片作为参数传达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%87%E7%89%87"><span class="nav-number">5.7.3.</span> <span class="nav-text">其他类型的切片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Struct"><span class="nav-number">6.</span> <span class="nav-text">5. Struct</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%8C%96struct"><span class="nav-number">6.1.</span> <span class="nav-text">定义并实例化struct</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFstruct"><span class="nav-number">6.1.1.</span> <span class="nav-text">什么是struct</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89struct"><span class="nav-number">6.2.</span> <span class="nav-text">定义struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96struct"><span class="nav-number">6.3.</span> <span class="nav-text">实例化struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96struct%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="nav-number">6.4.</span> <span class="nav-text">获取struct里面的某个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.5.</span> <span class="nav-text">struct作为函数的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AE%80%E5%86%99"><span class="nav-number">6.6.</span> <span class="nav-text">字段初始化简写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text">struct 更新语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Rust-web%E6%A1%86%E6%9E%B6"><span class="nav-number">7.</span> <span class="nav-text">6. Rust web框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%90%8E%E8%AE%B0"><span class="nav-number">8.</span> <span class="nav-text">7. 后记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-web%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">8.1.</span> <span class="nav-text">7.1. web框架选择参考文档</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="鹏叔" src="/imgs/avatar.gif"><p class="site-author-name" itemprop="name">鹏叔</p><div class="site-description" itemprop="description">鹏叔的技术博客, 鹏叔的技术博客, 收集鹏叔在日常工作中整理的技术博客, 内容包括前端javascript, material design, typescript, css, html, 后端golang, java, 数据库等.</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">249</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">76</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/guoapeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;guoapeng" rel="noopener external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:guoapeng@gmail.com" title="E-Mail → mailto:guoapeng@gmail.com" rel="noopener external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener external nofollow" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://philoenglish.com/" title="https:&#x2F;&#x2F;philoenglish.com" target="_blank">菲利英语</a></li></ul></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.pengtech.net/rust/rust_study.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/imgs/avatar.gif"><meta itemprop="name" content="鹏叔"><meta itemprop="description" content="鹏叔的技术博客, 鹏叔的技术博客, 收集鹏叔在日常工作中整理的技术博客, 内容包括前端javascript, material design, typescript, css, html, 后端golang, java, 数据库等."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鹏叔的技术博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Rust 编程语言入门教程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-03 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-03T00:00:00+08:00">2021-10-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-05-02 02:12:12" itemprop="dateModified" datetime="2024-05-02T02:12:12+08:00">2024-05-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/backend/" itemprop="url" rel="index"><span itemprop="name">backend</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="1-第一章-Rust简介"><a href="#1-第一章-Rust简介" class="headerlink" title="1. 第一章: Rust简介"></a>1. 第一章: Rust简介</h2><h3 id="1-1-为什么要用Rust"><a href="#1-1-为什么要用Rust" class="headerlink" title="1.1. 为什么要用Rust"></a>1.1. 为什么要用Rust</h3><p>Rust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.<br>它可以用来替换C/C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.<br>Rust是一种通用的编程语言, 但是它更善于以下场景:<br>需要运行时的速度<br>需要内存安全<br>更好的利用多处理器</p><span id="more"></span><h3 id="1-2-与其他语言比较"><a href="#1-2-与其他语言比较" class="headerlink" title="1.2. 与其他语言比较"></a>1.2. 与其他语言比较</h3><p>C/C++ 性能非常好, 但类型系统和内存都不太安全.<br>JAVA/C#, 拥有GC, 能保证内存安全, 也有很多优秀特性, 但是性能不行<br>RUST:<br>安全<br>无需GC<br>易于维护, 调试, 代码安全高效</p><h3 id="1-3-Rust特别擅长的领域"><a href="#1-3-Rust特别擅长的领域" class="headerlink" title="1.3. Rust特别擅长的领域"></a>1.3. Rust特别擅长的领域</h3><p>高性能webservice<br>webassembly<br>命令行工具<br>网络编程<br>嵌入式设备<br>系统编程</p><h3 id="1-4-Rust与Firefox"><a href="#1-4-Rust与Firefox" class="headerlink" title="1.4. Rust与Firefox"></a>1.4. Rust与Firefox</h3><ul><li><p>Rust最初是Mozilla公司的一个研究性项目, firefox是Rust产品应用的一个重要例子.Mozilla 一直以来都在用rust创建一个名为servo的实验性浏览器引擎, 其中的所有内容都是并行执行的.<br>目前servo的部分功能已经被集成到firefox里面了<br>firefox原来的量子版就包含了servo的css渲染引擎</p></li><li><p>rust使得firefox在这方便得到了巨大的性能改进</p></li></ul><h3 id="1-5-Rust的用户和案例"><a href="#1-5-Rust的用户和案例" class="headerlink" title="1.5. Rust的用户和案例"></a>1.5. Rust的用户和案例</h3><ul><li>google: 新操作系统Fuschia, 其中Rust代码量大约30%</li><li>Amazon: 基于Linux开发的直接可以在裸机, 虚拟机上运行容器的操作系统.</li><li>System76: 纯Rust开发了下一代安全操作系统Redox</li><li>蚂蚁金服: 库操作系统Occlum</li><li>斯坦福和密歇根大学: 嵌入式实时操作系统, 应用于google的加密产品.</li><li>微软: 正在使用Rust重写windows系统中的一些低级组件.</li><li>微软: winRT/Rust项目</li><li>Dropbox, yelp, Coursera, LINE, Cloudflare, Atlassian, npm, Ceph, 百度, 华为, Sentry, Deno</li></ul><h3 id="1-6-Rust的优点"><a href="#1-6-Rust的优点" class="headerlink" title="1.6. Rust的优点"></a>1.6. Rust的优点</h3><ul><li>性能</li><li>安全性</li><li>无所畏惧的并发</li></ul><h3 id="1-7-Rust的缺点"><a href="#1-7-Rust的缺点" class="headerlink" title="1.7. Rust的缺点"></a>1.7. Rust的缺点</h3><ul><li>难学</li></ul><h3 id="1-8-注意"><a href="#1-8-注意" class="headerlink" title="1.8. 注意"></a>1.8. 注意</h3><p>Rust有很多独有的概念, 它们和现在大多主流语言都不同.</p><ul><li>所以学习Rust必须从基础概念一步一步学, 否则会懵.</li></ul><h3 id="1-9-参考教材"><a href="#1-9-参考教材" class="headerlink" title="1.9. 参考教材"></a>1.9. 参考教材</h3><p>The Rust programming language<br>Rust权威指南</p><h2 id="2-安装Rust"><a href="#2-安装Rust" class="headerlink" title="2. 安装Rust"></a>2. 安装Rust</h2><h3 id="2-1-安装rust"><a href="#2-1-安装rust" class="headerlink" title="2.1. 安装rust"></a>2.1. 安装rust</h3><ul><li>Rust官网: <a target="_blank" rel="noopener" href="https://www.rust-lang.org/">https://www.rust-lang.org</a></li><li>Linux or Mac:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf| sh</span><br></pre></td></tr></table></figure><ul><li><p>windows: 按<a target="_blank" rel="noopener" href="https://www.rust-lang.org/tools/install">官网安装指引操作</a></p><ul><li><p>下载安装程序，<a target="_blank" rel="noopener" href="https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe">下载RUSTUP-INIT.exe 32位安装程序</a> 或 <a target="_blank" rel="noopener" href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">下载RUSTUP-INIT.exe 64位安装程序</a></p></li><li><p>然后运行程序并按照屏幕上的说明进行操作。</p></li><li><p>当提示您安装<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio C++ build tools</a>时，您可能需要安装这些工具。</p></li><li><p>完成安装后需要将 &lt;home_dir&gt;/bin/.cargo 添加到Path环境变量, 这样在任何位置都可以执行rustc, cargo 和rustup命令了</p></li></ul></li><li><p>windows subsystem for Linux:</p><p>搭建WSL可参考我的博客<br><a href="https://www.pengtech.net/windows/wsl_install.html">Windows下搭建WSL Linux开发环境</a></p><p>安装rust可使用如下命令命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-配置Rust"><a href="#2-2-配置Rust" class="headerlink" title="2.2. 配置Rust"></a>2.2. 配置Rust</h3><h4 id="2-2-1-替换镜像"><a href="#2-2-1-替换镜像" class="headerlink" title="2.2.1. 替换镜像"></a>2.2.1. 替换镜像</h4><p>安装完成后需要将crates.io替换成国内镜像.</p><p>访问<a target="_blank" rel="noopener" href="https://crates.io/">https://crates.io</a>非常缓慢，github 的仓库也经常不能访问，建议大家切换到国内镜像站。镜像站实时缓存，托管在码云的 gitee 仓库每隔30分钟与 github 同步。</p><p>配置方式</p><ul><li>在 .cargo 目录新建文件config</li></ul><blockquote><p>注意：新安装的电脑中没有这个文件，需要手动创建config文件，并且该文件没有后缀名</p></blockquote><p>编辑文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry=&quot;https://github.com/rust-lang/crates.io-index&quot; #这行可以不要,只是说明原始地址</span><br><span class="line">replace-with=&#x27;crates-cn&#x27;</span><br><span class="line"></span><br><span class="line">[source.crates-cn]</span><br><span class="line">registry=&quot;https://gitee.com/crates/crates.io-index.git&quot;</span><br></pre></td></tr></table></figure><p>如果使用中科大USTC的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with=<span class="string">&#x27;ustc&#x27;</span></span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry=<span class="string">&quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完保存后执行build即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><h3 id="2-3-更新Rust"><a href="#2-3-更新Rust" class="headerlink" title="2.3. 更新Rust"></a>2.3. 更新Rust</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure><h3 id="2-4-卸载Rust"><a href="#2-4-卸载Rust" class="headerlink" title="2.4. 卸载Rust"></a>2.4. 卸载Rust</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure><h3 id="2-5-验证安装是否成功"><a href="#2-5-验证安装是否成功" class="headerlink" title="2.5. 验证安装是否成功"></a>2.5. 验证安装是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><ul><li>结果格式: rustc x.y. z (abcabcabc yyyy-mm-dd)</li><li>会显示最新稳定版的: 版本号, commit hash, commit日期</li><li>当前我安装的版本为 rustc 1.56.1 (59eed8a2a 2021-11-01)</li></ul><h2 id="3-第二章：第一个rust程序"><a href="#3-第二章：第一个rust程序" class="headerlink" title="3. 第二章：第一个rust程序"></a>3. 第二章：第一个rust程序</h2><h3 id="3-1-hello-world"><a href="#3-1-hello-world" class="headerlink" title="3.1. hello world"></a>3.1. hello world</h3><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure><p>编译完成后将会输出可执行文件main,<br>运行程序使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="3-2-Rust-程序解析"><a href="#3-2-Rust-程序解析" class="headerlink" title="3.2. Rust 程序解析"></a>3.2. Rust 程序解析</h3><ul><li>定义函数 fn main() {}<br>没有参数, 没有返回值</li><li>main 函数很特别 : 他是每一个Rust 可执行程序 最先运行的代码</li><li>打印文本: println!(“hello, world!”)<ul><li>rust 的缩进是4个空格而不是tab</li><li>println! 是一个Rust macro(宏), 如果是函数的话就没有感叹号(!)</li><li>“hello world” 是字符串, 它是println!的参数</li><li>这行代码以;结尾</li></ul></li></ul><h3 id="3-3-编译和运行是单独的两步"><a href="#3-3-编译和运行是单独的两步" class="headerlink" title="3.3. 编译和运行是单独的两步"></a>3.3. 编译和运行是单独的两步</h3><ul><li><p>运行rust程序之前需要先编译, 命令为: rustc 源文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译程序</span></span><br><span class="line">rustc main.rs</span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure></li><li><p>编译成功后, 会生成一个二进制文件例如main</p><ul><li>在window上还会生成一个.pdb文件, 里面包含调试信息</li></ul></li><li><p>Rust是ahead-of-time(AOT)预编译的语言</p><ul><li>可以先编译程序, 然后把可执行文件交给别人运行(无需安装Rust)</li></ul></li><li><p>rustc只适合简单的Rust程序, 当文件比较多, 项目管理还是需要使用Cargo</p></li></ul><h3 id="3-4-hello-cargo"><a href="#3-4-hello-cargo" class="headerlink" title="3.4. hello cargo"></a>3.4. hello cargo</h3><h4 id="3-4-1-cargo-介绍"><a href="#3-4-1-cargo-介绍" class="headerlink" title="3.4.1. cargo 介绍"></a>3.4.1. cargo 介绍</h4><ul><li>Cargo 是Rust的构建系统和包管理工具<ul><li>构建代码, 下载依赖的库, 构建这些库</li></ul></li><li>安装Rust的同时会自动安装Cargo, 所以这里不需要额外的步骤去安装Cargo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cargo</span> --version</span><br><span class="line">cargo 1.56.0 (4ed5d137b 2021-10-04)</span><br></pre></td></tr></table></figure><h4 id="3-4-2-使用Cargo创建项目"><a href="#3-4-2-使用Cargo创建项目" class="headerlink" title="3.4.2. 使用Cargo创建项目"></a>3.4.2. 使用Cargo创建项目</h4><ul><li><p>创建项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br></pre></td></tr></table></figure></li><li><p>创建完成后项目的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tree</span> -a .      </span><br><span class="line">hello_cargo</span><br><span class="line"></span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── .git</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── description</span><br><span class="line">│   ├── HEAD</span><br><span class="line">........省略部分目录...........</span><br><span class="line">├── .gitignore</span><br><span class="line">└── src</span><br><span class="line">      └── main.rs</span><br></pre></td></tr></table></figure><p>目录结构说明：<br>Cargo.toml:</p><ul><li>TOML(Tom’s obvious, Minimal Language)格式，是Cargo的配置格式</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure></li><li><p>[package], 是一个项目信息区域，表示下方内容是用来配置包（package）的．</p><ul><li>name: 项目名</li><li>version: 项目版本</li><li>authors: 项目作者</li><li>edition: The Rust edition</li><li>更多参数说明请参考<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/manifest.html">The Manifest Format</a></li></ul></li><li><p>[dependencies], 另一个区域的开始，它会列出项目的依赖项．</p></li><li><p>在Rust里面，代码的包称作<a target="_blank" rel="noopener" href="https://philoenglish.com/query/crate">crate</a>(板条箱,装货箱;如果<a target="_blank" rel="noopener" href="https://philoenglish.com/query/cargo">cargo</a>是装货物的集装箱,Crate板条箱就是装载整批货物的小箱子)</p><p>src/main.rs</p><ul><li>cargo生成的main.rs在src目录下</li><li>而Cargo.toml在项目顶层下</li><li>源代码都应该在src目录下</li><li>顶层目录可以放置：README, 许可信息, 配置文件和其它与程序源代码无关的文件</li><li>如果创建项目时没有使用cargo, 也可以把项目转化为使用cargo:<ul><li>把源代码文件移动到src下</li><li>创建Cargo.toml并填写相应的配置</li></ul></li></ul></li></ul><h4 id="3-4-3-构建Cargo项目"><a href="#3-4-3-构建Cargo项目" class="headerlink" title="3.4.3. 构建Cargo项目"></a>3.4.3. 构建Cargo项目</h4><ul><li>cargo build<br>创建可执行文件：target/debug/hello_cargo (linux/macos)或者 target\debug\hello_cargo.exe (windows)</li><li>第一次运行cargo build会在顶层目录生成cargo.lock文件<ul><li>该文件负责追踪项目依赖的精确版本</li><li>不需要手动修改该文件</li></ul></li><li>构建和运行cargo项目<ul><li>cargo run<ul><li>cargo run, 编译代码+执行结果</li><li>如果之前编译成功过，并且源代码没有改变，那么就会直接运行二进制文件</li></ul></li></ul></li><li>cargo check<ul><li>cargo check, 检查代码，确保能通过编译，但是不产生任何可执行文件</li></ul></li><li>cargo buid -release<ul><li>编译时会进行优化</li><li>代码会运行的更快, 但是编译时间更长</li><li>会在target/release 而不是target/debug生成可执行文件</li></ul></li><li>两种配置，一种是开发用的，一种是发布用的</li></ul><h3 id="3-5-猜数字游戏"><a href="#3-5-猜数字游戏" class="headerlink" title="3.5. 猜数字游戏"></a>3.5. 猜数字游戏</h3><h4 id="3-5-1-声明变量"><a href="#3-5-1-声明变量" class="headerlink" title="3.5.1. 声明变量"></a>3.5.1. 声明变量</h4><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* let声明一个变量</span></span><br><span class="line"><span class="comment">* mut 声明变量为可变变量, </span></span><br><span class="line"><span class="comment">* 默认情况下变量是不可变的, 除非显示使用mut指明变量为可变变量</span></span><br><span class="line"><span class="comment">* = 赋值操作</span></span><br><span class="line"><span class="comment">* 注意申明时没有指定变量类型, 变量类型是根据赋初始值时进行推导的</span></span><br><span class="line"><span class="comment">* String是由rust 的标准库所提供的类型，内部是使用utf-8编码</span></span><br><span class="line"><span class="comment">* :: 符号表明new是String类型的关联函数，关联函数相当与其他语言中的静态方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* io是rust标准库中的一个包名</span></span><br><span class="line"><span class="comment">* stdin()方法会返回一个Ｓtdin对象, 标准输入对象</span></span><br><span class="line"><span class="comment">* read_line 是标准输入对象的一个方法，调用该方法时，需要提供一个可变字符串变量，用于接收用户输入</span></span><br><span class="line"><span class="comment">* &amp; 取地址符号，表示传递引用, 表示这个参数是一个引用reference，通过引用我们就可以在不同地方，访问程序的统一块内存区域</span></span><br><span class="line"><span class="comment">* &amp;mut表示这个引用是可变的, 如果不加mut, 表明这个引用也是不可变的</span></span><br><span class="line"><span class="comment">* read_line函数返回的是一个i0:Result&lt;usize&gt;对象，expect是result对象的一个方法</span></span><br><span class="line"><span class="comment">*  result是一个枚举类型, 其有两种类型的返回结果, 一种是err, 一种ok</span></span><br><span class="line"><span class="comment">*  如果返回的result为err, 该expect就会将错误信息输出到终端</span></span><br><span class="line"><span class="comment">* 如果返回结果是ok类型, expect就会提取出result中附加的值并将这个值作为结果返回给用户</span></span><br><span class="line"><span class="comment">* 如果不调用expect方法, 编译时将会收到rusult未被使用的警告</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line"><span class="comment">//&#123;&#125; 是一个占位符，输出时将会替换成相对应的变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;你猜测的数时｛｝&quot;</span>, guess);</span><br></pre></td></tr></table></figure><h4 id="3-5-2-引入依赖包"><a href="#3-5-2-引入依赖包" class="headerlink" title="3.5.2. 引入依赖包"></a>3.5.2. 引入依赖包</h4><ul><li>rust中的依赖包被称为crate<br>crate分为两种, 一种是二进制格式的可执行文件; 一种是源文件,也被称为library crate</li><li>rust的crate仓库为crates.io, 可以访问<a target="_blank" rel="noopener" href="https://crates.io/">该网站</a>获得相应的crate</li><li>cargo 引入依赖的方式</li><li>在dependencies 区域添加依赖的crate名称和版本如下所示.</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Cargo.toml</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;^0.7.0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>示例代码</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng; <span class="comment">//trait</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> secret_num = rand::thread_rng().gen_range(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="comment">//rust循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guess = <span class="built_in">String</span>::new();</span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> guess).expect(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;你猜测的数是: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">        <span class="comment">//shadow</span></span><br><span class="line">        <span class="keyword">let</span> guess:<span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="literal">Err</span>(ex) =&gt; &#123;</span><br><span class="line">                <span class="comment">//rust异常处理</span></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;解析错误 &#123;&#125; &#123;&#125;&quot;</span>, guess, ex);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// rust条件运算</span></span><br><span class="line">        <span class="keyword">match</span> guess.cmp(&amp;secret_num) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>), <span class="comment">//arm</span></span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-第三章-通用的编程概念"><a href="#4-第三章-通用的编程概念" class="headerlink" title="4. 第三章 通用的编程概念"></a>4. 第三章 通用的编程概念</h2><h3 id="4-1-变量和可变性"><a href="#4-1-变量和可变性" class="headerlink" title="4.1. 变量和可变性"></a>4.1. 变量和可变性</h3><ul><li><p>声明变量使用let 关键字</p></li><li><p>默认情况下，变量是不可变的(immutable)<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x =<span class="number">5</span>;  <span class="comment">// x 为不可变变量</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// 注意: 这里会有编译错误</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>声明变量时, 在变量前面加上mut, 就可以使变量可变．</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x =<span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-变量和常量"><a href="#4-2-变量和常量" class="headerlink" title="4.2. 变量和常量"></a>4.2. 变量和常量</h3><ul><li>常量(constant), 常量在绑定值以后也是不可变的, 但是它与不可变的变量有很多区别：<ul><li>不可以使用mut, 常量永远都是不可变的</li><li>声明常量使用const关键字, 它的类型必须被标注</li><li>常量可以在任何作用域内进行声明, 包括全局作用域</li><li>常量只可以绑定到常量表达式, 无法绑定到函数的调用结果或只能在运行时才能计算出的值</li></ul></li><li>在程序运行期间, 常量在其声明的作用域内一直有效</li><li>命名规范: Rust里常量使用全大写字母, 每个单词之间用下划线分开, 例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="built_in">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-shadowing-隐藏"><a href="#4-3-shadowing-隐藏" class="headerlink" title="4.3. shadowing (隐藏)"></a>4.3. shadowing (隐藏)</h3><ul><li><p>可以使用相同的名字声明新的变量, 新的变量就会shadow（隐藏）之前声明的同名变量</p><ul><li><p>在后续代码中这个变量名代表的就是新的变量</p></li><li><p>shadow和把变量标记为mut是不一样的<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">//定义不可变变量x</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">// x = 6 // 如果这里给x赋值会报错</span></span><br><span class="line">  <span class="comment">// 但是如果我们声明一个同名的新的变量，就可以编译通过</span></span><br><span class="line">  <span class="comment">// 我们甚至可以改变x的数据类型, 甚至可以定义新的同名但是不同的可变性的变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//新的同名变量 </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">//不同可变性的同名变量</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="string">&quot;my love&quot;</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  x = <span class="string">&quot;hello kitty&quot;</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-4-Rust数据类型"><a href="#4-4-Rust数据类型" class="headerlink" title="4.4. Rust数据类型"></a>4.4. Rust数据类型</h3><ul><li><p>Rust 是静态编译语言, 在编译时必须知道变量的类型</p><ul><li><p>基于使用的值, 编译器通常能够推断出它的具体类型</p></li><li><p>但如果可能的类型比较多(例如把String 转为整数的parse方法)，就必须添加类型的标注，否则编会报错．<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="string">&quot;42&quot;</span>.parse().expect(<span class="string">&quot;not a number&quot;</span>)</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, guess)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-4-1-标量类型"><a href="#4-4-1-标量类型" class="headerlink" title="4.4.1. 标量类型"></a>4.4.1. 标量类型</h4><ul><li>一个标量类型代表一个单个的值</li><li>Rust有四个主要的标量类型：<ul><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ul></li></ul><h5 id="4-4-1-1-整数类型"><a href="#4-4-1-1-整数类型" class="headerlink" title="4.4.1.1. 整数类型"></a>4.4.1.1. 整数类型</h5><ul><li><p>整数类型分为无符合整数类型,</p><ul><li>无符号整数类型以ｕ开头</li><li>有符号整数类型以i开头</li></ul></li><li><p>Rust 的整数类型列表如图：</p><ul><li>每种长度都有对应的有符号型和无符号型．</li></ul></li><li><p>有符号范围</p><ul><li>(负的2的n-1次方-1) 到(2的n-1次方-1)</li></ul></li><li><p>无符号范围</p><ul><li>0 到2的n次方 -1</li></ul></li><li><p>isize 和 usize类型</p><ul><li><p>isize和usize类型的位数由程序运行的计算机的架构所决定</p></li><li><p>如果是64位的计算机，那就是64位的</p></li><li><p>如果是32位的计算机，那就是32位的</p></li><li><p>使用isize或者usize的场景是对某种集合进行索引操作</p><table><thead><tr><th align="left">length</th><th align="left">signed</th><th align="left">unsigned</th></tr></thead><tbody><tr><td align="left">8-bit</td><td align="left">i8</td><td align="left">u8</td></tr><tr><td align="left">16-bit</td><td align="left">i16</td><td align="left">u16</td></tr><tr><td align="left">32-bit</td><td align="left">i32</td><td align="left">u32</td></tr><tr><td align="left">64-bit</td><td align="left">i64</td><td align="left">i64</td></tr><tr><td align="left">128-bit</td><td align="left">i128</td><td align="left">u128</td></tr><tr><td align="left">arch</td><td align="left">isize</td><td align="left">usize</td></tr></tbody></table></li><li><p>整数的字面值</p><ul><li><p>除了byte类型外, 所有的数值字面值都允许使用类型后缀<br>例如： 57u8: 值为57 类型为u8</p><ul><li><p>整数的默认类型就是i32:</p><ul><li>总体来说速度很快, 即使在64位系统中</li></ul><table><thead><tr><th align="left">NumberLiteral</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left">Decimal</td><td align="left">Oxff</td></tr><tr><td align="left">Hex</td><td align="left">Oo77</td></tr><tr><td align="left">Binary</td><td align="left">Ob1111_0000</td></tr><tr><td align="left">Byte (u8 only)</td><td align="left">b’A’</td></tr></tbody></table></li></ul></li></ul></li><li><p>整数溢出<br>例如：u8的范围是0-255, 如果你把一个u8变量的值设为256, 那么：</p><ul><li>调试模式下编译：rust会检查整数溢出, 如果发生溢出, 程序编译时就会panic</li><li>在发布模式下(–release)编译：rust不会检查可能导致panic的整数溢出<ul><li>在这种模式下如果发生溢出：rust会执行环绕操作<br>256变成0, 257变成1…. 但是不会导致panic</li></ul></li></ul></li></ul></li></ul><h3 id="4-5-浮点类型"><a href="#4-5-浮点类型" class="headerlink" title="4.5. 浮点类型"></a>4.5. 浮点类型</h3><ul><li>rust 有两种基础的浮点类型，也就是含有小数部分的类型<ul><li>f32, 32位, 单精度</li><li>f64, 64位，双精度</li></ul></li><li>rust的浮点类型使用了IEEE-754标准来表述</li><li>f64是默认类型，因为在现代cpu上f64和32的运算速度差不多，而且精度更高<br>例子:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2.0</span> <span class="comment">//默认为f64</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">f32</span> = <span class="number">3.0</span>; <span class="comment">//f32</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-6-数值操作"><a href="#4-6-数值操作" class="headerlink" title="4.6. 数值操作"></a>4.6. 数值操作</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">5</span>+<span class="number">10</span>;   <span class="comment">//i32</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="number">95.5</span>-<span class="number">4.3</span>; <span class="comment">//f64</span></span><br><span class="line"><span class="keyword">let</span> product = <span class="number">4</span>*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> quotient = <span class="number">56.7</span>/<span class="number">32.2</span>  <span class="comment">//f64</span></span><br><span class="line"><span class="keyword">let</span> reminder = <span class="number">54</span>%<span class="number">5</span> </span><br></pre></td></tr></table></figure><h3 id="4-7-布尔类型"><a href="#4-7-布尔类型" class="headerlink" title="4.7. 布尔类型"></a>4.7. 布尔类型</h3><ul><li>Rust的布尔类型有两个值: true和false</li><li>占用一个字节(Byte)的大小</li><li>符号是bool</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">//编译器推断类型</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//显示指定类型</span></span><br><span class="line">  <span class="keyword">let</span> s: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-8-字符类型"><a href="#4-8-字符类型" class="headerlink" title="4.8. 字符类型"></a>4.8. 字符类型</h3><p>rust语言中char类型被用来描述语言中最基础的单个字符．<br>字符类型的字面值使用单引号<br>占用４字节大小<br>是Unicode标量值, 可以表示比ASCII多得多的字符内容：拼音, 中日文, 零长度空白字符，emoji表情等．</p><ul><li>其范围为<ul><li>U+0000到U+D7FF</li><li>U+E000到U+10FFFF</li></ul></li><li>但是unicode中并没有字符的概念, 所以直觉上认为的字符也许与Rust中的概念并不相符</li></ul><h3 id="4-9-复合类型"><a href="#4-9-复合类型" class="headerlink" title="4.9. 复合类型"></a>4.9. 复合类型</h3><ul><li>复合类型可以将多个值放在一个类型里</li><li>Rust提供了两种基础的复合类型: 元组(Tuple), 数组</li></ul><h4 id="4-9-1-Tuple"><a href="#4-9-1-Tuple" class="headerlink" title="4.9.1. Tuple"></a>4.9.1. Tuple</h4><ul><li>Tuple可以将多个类型的多个值放在一个类型里</li><li>Tuple的长度是固定的: 一旦声明就无法改变</li></ul><h5 id="4-9-1-1-创建tuple"><a href="#4-9-1-1-创建tuple" class="headerlink" title="4.9.1.1. 创建tuple"></a>4.9.1.1. 创建tuple</h5><ul><li>在小括号里, 将值用逗号分开</li><li>Tuple中的每个位置都对应一个类型，tuple中各元素的类型不必相同</li><li>实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="4-9-1-2-获取tuple的元素值"><a href="#4-9-1-2-获取tuple的元素值" class="headerlink" title="4.9.1.2. 获取tuple的元素值"></a>4.9.1.2. 获取tuple的元素值</h5><ul><li>可以使用模式匹配来解构(destructure)一个Tuple来获取元素的值</li><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">//这里使用模式匹配解构tup的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, x, y, z)</span><br></pre></td></tr></table></figure><h4 id="4-9-2-访问tuple的元素"><a href="#4-9-2-访问tuple的元素" class="headerlink" title="4.9.2. 访问tuple的元素"></a>4.9.2. 访问tuple的元素</h4><ul><li>在tuple变量使用点标记法，后接元素的索引号</li><li>实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="4-10-数组"><a href="#4-10-数组" class="headerlink" title="4.10. 数组"></a>4.10. 数组</h3><ul><li>数组也可以将多个值放在一个类型里</li><li>数组中每个元素的类型必须相同</li><li>数组的长度也是固定的</li></ul><h4 id="4-10-1-声明一个数组"><a href="#4-10-1-声明一个数组" class="headerlink" title="4.10.1. 声明一个数组"></a>4.10.1. 声明一个数组</h4><ul><li>在中括号里, 各值用逗号分开</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-10-2-数组的用处"><a href="#4-10-2-数组的用处" class="headerlink" title="4.10.2. 数组的用处"></a>4.10.2. 数组的用处</h4><ul><li>如果想让你的数据存放在栈(stack)上, 而不是堆(heap)上，或者想保证有固定数量的元素, 这时使用数组更有好处．</li><li>数组没有Vector灵活(以后再讲)<ul><li>Vector和数组类似，它是由标准库提供的</li><li>Vector的长度是可以改变的</li><li>如果你不确定应该使用数组还是vector, 那么估计你应该用vector.</li></ul></li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> months = [<span class="string">&quot;January&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Fabruary&quot;</span>,</span><br><span class="line">            ......</span><br><span class="line">            <span class="string">&quot;December&quot;</span></span><br><span class="line">            ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-10-3-数组的类型"><a href="#4-10-3-数组的类型" class="headerlink" title="4.10.3. 数组的类型"></a>4.10.3. 数组的类型</h4><ul><li>数组的类型以这种形式来表示: [类型; 长度]<ul><li>例如: let a: [i32; 5] = [1, 2, 3, 4, 5];</li></ul></li><li>另外一种声明数组的方法<br>如果数组的没一个元素值都相同, 那么可以在:<br>在中括号里指定初始值<br>然后是一个;<br>最后是数组的长度<br>例如： let a = [3; 5]; 它相当于：let a = [3, 3, 3, 3, 3]</li></ul><h4 id="4-10-4-访问数组的元素"><a href="#4-10-4-访问数组的元素" class="headerlink" title="4.10.4. 访问数组的元素"></a>4.10.4. 访问数组的元素</h4><ul><li><p>数组是stack上分配的单个块的内存</p></li><li><p>可以使用索引来访问数组的元素</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = months[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> second = months[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>如果访问的索引超出了数组的范围, 那么</p><ul><li>编译会通过</li><li>运行会报错(runtime时会panic) Rust不会允许其继续访问相应地址的内存<br>说明：<br>在简单的情况下，编译会报错，但是在复杂情况下，编译不会报错<br>例如</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> month = months[index]; <span class="comment">//此时编译会报错</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = [<span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> month = months[index[<span class="number">0</span>]]; <span class="comment">//此时编译不会报错, 运行时会发生panic</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-11-3-4-函数"><a href="#4-11-3-4-函数" class="headerlink" title="4.11. 3.4 函数"></a>4.11. 3.4 函数</h3><ul><li>声明函数使用fn关键字</li><li>依照惯例，针对函数和变量名，rust使用snake case命名规范:<ul><li><p>所有的字母都是小写的, 单词之间使用下划线分开</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  another_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;another function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-11-1-函数的参数"><a href="#4-11-1-函数的参数" class="headerlink" title="4.11.1. 函数的参数"></a>4.11.1. 函数的参数</h4><ul><li>parameters, arguments</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  another_function(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-11-2-函数中的语句-statement-和表达式-expression"><a href="#4-11-2-函数中的语句-statement-和表达式-expression" class="headerlink" title="4.11.2. 函数中的语句(statement)和表达式(expression)"></a>4.11.2. 函数中的语句(statement)和表达式(expression)</h4><ul><li>函数体由一系列语句组成, 可选的由一个表达式结束</li><li>Rust是一个基于表达式的语言</li><li>语句是执行一些动作的指令</li><li>表达式会计算产生一个值</li><li>函数的定义也是语句</li><li>语句不返回值，所以不可以使用let将一个语句－赋给一个变量</li></ul><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>; </span><br><span class="line">  <span class="keyword">let</span> y = &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//x+3; //注意这里有个分号，它是语句而不是表达式, 但是这个语句有些特殊, 它的值等于一个空的tuple 即（）</span></span><br><span class="line">    x+<span class="number">3</span> <span class="comment">//这里没有分号, 它是一个表达式, 表达式的值为5 它是整个block的返回值, 该值将会被赋给变量y</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-11-3-函数的返回值"><a href="#4-11-3-函数的返回值" class="headerlink" title="4.11.3. 函数的返回值"></a>4.11.3. 函数的返回值</h4><ul><li>在-&gt;符号后边声明函数返回值的类型, 但是不可以为返回值命名</li><li>在Rust里面, 返回值就是函数体里面最后一个表达式的值</li><li>若想提前返回, 需使用return 关键字, 并指定一个值<ul><li>大多数函数都是默认使用最后一个表达式为返回值<br>例子:</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">five</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = five();</span><br><span class="line">  println(<span class="string">&quot;the value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-注释"><a href="#4-12-注释" class="headerlink" title="4.12. 注释"></a>4.12. 注释</h3><p>单行注释<br>多行注释<br>文档注释</p><h3 id="4-13-控制流"><a href="#4-13-控制流" class="headerlink" title="4.13. 控制流"></a>4.13. 控制流</h3><h4 id="4-13-1-if-表达式"><a href="#4-13-1-if-表达式" class="headerlink" title="4.13.1. ｉf 表达式"></a>4.13.1. ｉf 表达式</h4><ul><li><p>if 表达式允许你根据条件来执行不同的代码分支</p><ul><li>这个条件必须是bool类型</li></ul></li><li><p>if 表达式中, 与条件相关联的代码块就叫做分支(arm)</p></li><li><p>可选的, 在后面可以加上一个else表达式</p></li><li><p>但是如果使用了多余一个else if, 那么最好使用match来重构代码</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子：else if</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisaible by 4&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisaible by 3&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisaible by 3 or 4&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-13-2-在let语句中使用if"><a href="#4-13-2-在let语句中使用if" class="headerlink" title="4.13.2. 在let语句中使用if"></a>4.13.2. 在let语句中使用if</h4><ul><li>因为if是一个表达式, 所以可以将它放在let语句中等号的右边(例子)<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> condition = ture;</span><br><span class="line">  <span class="keyword">let</span> muber = <span class="keyword">if</span> condition &#123;<span class="number">5</span>&#125; <span class="keyword">else</span> &#123;<span class="number">6</span>&#125;; <span class="comment">//相对于其它语言中的三元表达式</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The value of number is &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-14-Rust的循环"><a href="#4-14-Rust的循环" class="headerlink" title="4.14. Rust的循环"></a>4.14. Rust的循环</h3><ul><li>Rust提供了３中循环：loop, while 和 for.</li></ul><h4 id="4-14-1-loop-循环"><a href="#4-14-1-loop-循环" class="headerlink" title="4.14.1. loop 循环"></a>4.14.1. loop 循环</h4><p>loop关键字告诉Rust反复地执行一块代码，直到你喊停为止<br>可以在loop循环中使用break关键字来告诉程序何时停止循环<br>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> resut = <span class="keyword">loop</span> &#123;</span><br><span class="line">     counter += <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">       <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-14-2-while条件循环"><a href="#4-14-2-while条件循环" class="headerlink" title="4.14.2. while条件循环"></a>4.14.2. while条件循环</h4><ul><li>另外一种常见的循环模式是每次执行循环体之前都判断一次条件．</li><li>while条件循环就是为这种模式而生的</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number = number -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="4-15-for-循环遍历集合"><a href="#4-15-for-循环遍历集合" class="headerlink" title="4.15. for 循环遍历集合"></a>4.15. for 循环遍历集合</h3><ul><li><p>可以使用while 或 loop 来遍历数组, 但是易出错且低效．</p></li><li><p>使用for循环更简洁紧凑, 它可以针对集合中的每一个元素来执行一些代码</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">  <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于for循环的安全，简洁性，所以它在Rust里用的最多</p></li></ul><h3 id="4-16-Range"><a href="#4-16-Range" class="headerlink" title="4.16. Range"></a>4.16. Range</h3><ul><li>标准库提供</li><li>指定一个开始数字和一个结束数字，Range可以生成它们之间的数字(不包含介绍)</li><li>rev方法可以反转range</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-第四章：-所有权"><a href="#5-第四章：-所有权" class="headerlink" title="5. 第四章： 所有权"></a>5. 第四章： 所有权</h2><h3 id="5-1-4-1-什么是所有权"><a href="#5-1-4-1-什么是所有权" class="headerlink" title="5.1. 4.1 什么是所有权"></a>5.1. 4.1 什么是所有权</h3><ul><li>Rust的核心特性就是所有权</li><li>所有程序在运行时都必须管理它们使用计算机内存的方式<ul><li>有些语言有垃圾收集机制，在程序运行时, 它们不断地寻找不再使用的内存</li><li>在其他语言中，程序员必须显示地分配和释放内存</li><li>Rust采用了第三种方式</li><li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则．</li><li>当程序运行时，所有权特性不会减慢程序运行速度</li></ul></li></ul><h3 id="5-2-Stack-vs-Heap"><a href="#5-2-Stack-vs-Heap" class="headerlink" title="5.2. Stack vs Heap"></a>5.2. Stack vs Heap</h3><ul><li>Stack按值的接收顺序来存储，按相反的顺序将它们移除(后进先出, LIFO)<ul><li>添加数据叫做压入栈</li><li>移除数据叫做弹出栈</li></ul></li><li>所有存储在stack上的数据必须拥有已知的固定的大小<ul><li>编译时大小未知的数据或运行时大小可能变化的数据必须存放在heap上</li></ul></li><li>Heap内存组织性差一些<ul><li>当你把数据放入heap时, 你会请求一定数量的空间</li><li>操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li><li>这个过程叫做在heap上进行分配, 有时仅仅称为分配</li><li>把值压到stack上不叫分配</li><li>因为指针是已知固定大小的, 可以把指针存放在stack上．<br>但如果想要实际数据，你必须使用指针来定位</li><li>把数据压倒stack上要比在heap上分配快得多：<ul><li>因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在stack的顶端</li></ul></li><li>在heap上分配空间需要做更多的工作：<ul><li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配</li><li>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据</li><li>对于现代的处理器来说, 由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快．</li></ul></li><li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些(stack上)</li><li>如果数据之间的距离比较远，那么处理速度就会慢一些(heap上)<ul><li>在heap上分配大量的空间也是需要时间的</li></ul></li><li>当你的代码调用函数时，值被传入到函数(也包括指向heap的指针)．函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出．</li></ul></li></ul><h3 id="5-3-所有权存在的原因"><a href="#5-3-所有权存在的原因" class="headerlink" title="5.3. 所有权存在的原因"></a>5.3. 所有权存在的原因</h3><ul><li>所有权解决的问题<ul><li>跟踪代码的哪些部分正在使用heap的哪些数据</li><li>最小化heap上的重复数据量</li><li>清理heap上未使用的数据以避免空间不足</li></ul></li><li>一旦你懂得了所有权，那么就不需要经常去想stack或heap了</li><li>但是知道管理heap数据是所有权存在的原因，这有助于解释它为什么会这样工作．</li></ul><h3 id="5-4-所有权，内存与分配"><a href="#5-4-所有权，内存与分配" class="headerlink" title="5.4. 所有权，内存与分配"></a>5.4. 所有权，内存与分配</h3><h4 id="5-4-1-所有权规则"><a href="#5-4-1-所有权规则" class="headerlink" title="5.4.1. 所有权规则"></a>5.4.1. 所有权规则</h4><ul><li>每个值都有一个变量，这个变量是该值的所有者</li><li>每个值同时只能有一个所有者</li><li>当所有者超出作用域的时候，该值将被删除</li></ul><h3 id="5-5-变量作用域"><a href="#5-5-变量作用域" class="headerlink" title="5.5. 变量作用域"></a>5.5. 变量作用域</h3><ul><li>scope就是程序中一个项目的有效范围</li><li>例子<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">//s 不可以</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>; <span class="comment">// s可用</span></span><br><span class="line">           <span class="comment">//可以对s进行相关操作</span></span><br><span class="line">&#125; <span class="comment">//s 作用域到此结束，s不再可用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-5-1-string-类型"><a href="#5-5-1-string-类型" class="headerlink" title="5.5.1. string 类型"></a>5.5.1. string 类型</h4><ul><li>String 比那些基础标量数据类型更复杂</li><li>字符串字面值: 程序里手写的那些字符串值．它们是不可变的</li><li>Rust还有第二种字符串类型: String<ul><li>在heap上分配，能够存储在编译时未知数量的文本</li></ul></li></ul><h5 id="5-5-1-1-创建String类型的值"><a href="#5-5-1-1-创建String类型的值" class="headerlink" title="5.5.1.1. 创建String类型的值"></a>5.5.1.1. 创建String类型的值</h5><ul><li>可以使用from函数从字符串字面值创建出String类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);<span class="comment">// :: 表示from是String类型下的函数</span></span><br></pre></td></tr></table></figure><p>这类字符串是可以被修改的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  s.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">  pringln!(s);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>字符串字面值，在编译时就知道它的内容, 其文本内容直接被编码到最终的可执行文件里</li><li>速度快，高效，得益于其不可变性</li><li>String类型，为了支持可变性, 需要在heap上分配内存来保存编译时未知的文本内容：</li><li>操作系统必须在运行时来请求内存<ul><li>这步通过调用String::from来实现</li></ul></li><li>当用完String之后，需要使用某种方式将内存返回给操作系统<ul><li>这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存</li><li>没有GC的语言中，就需要我们去识别内存何时不再使用，并调用代码将它释放<ul><li>如果忘了，那就浪费内存．</li><li>如果提前做了，变量就会非法</li><li>如果做了两次，也是bug. 必须一次分配对应一次释放</li></ul></li><li>rust采用了不同的方式: 对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的归还给操作系统．</li><li>drop函数</li></ul></li></ul><h4 id="5-5-2-变量和数据交互的方式-移动-move"><a href="#5-5-2-变量和数据交互的方式-移动-move" class="headerlink" title="5.5.2. 变量和数据交互的方式: 移动 move"></a>5.5.2. 变量和数据交互的方式: 移动 move</h4><ul><li><p>多个变量可以与同一个数据使用一种独特的方式来交互</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure><p>整数是已知且固定大小的简单的值, 这两个５被压到了stack中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure><p>一个String 由３部分组成：</p><ul><li>一个指向存放字符串内容的内存的指针</li><li>一个长度</li><li>一个容量</li></ul></li><li><p>上面这些东西被放在stack上.</p></li><li><p>存放字符串内容的部分在heap上</p></li><li><p>长度len, 就是存放字符串内容所需的字节数</p></li><li><p>当把s1 赋值给S2, String 的数据被复制了一份</p></li><li><p>在stack上复制了一份指针, 长度, 容量</p></li><li><p>并没有复制指针所指向的heap上的数据</p></li><li><p>当变量离开作用域时，Rust会自动调用Drop函数，并将变量使用的heap内存释放．<br>当S1, S2离开作用域时, 它们都会尝试释放相同的内存</p></li><li><p>二次释放(double free) bug<br>为了保证内存安全：</p></li><li><p>Rust没有尝试复制被分配的内存</p></li><li><p>Rust让s1失效</p><ul><li><p>当s1离开作用域的时候, rust不需要释放任何东西</p></li><li><p>试试看当s2创建后，再使用s1是什么效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> s2 = s1;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">//这里会有编译错误，这里s1已经失效了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>浅拷贝(shallow copy)</li><li>深拷贝(deep copy)</li><li>你也许会将复制, 指针, 长度, 容量视为浅拷贝, 但是由于Rust让s1失效了, 所以我们用一个新的术语：移动move</li><li>隐藏了一个设计原则，Rust不会自动创建数据的深拷贝</li><li>就运行时性能而言, 任何自动赋值的操作都是廉价的</li></ul></li></ul></li></ul><h4 id="5-5-3-变量和数据交互的方式-克隆-Clone"><a href="#5-5-3-变量和数据交互的方式-克隆-Clone" class="headerlink" title="5.5.3. 变量和数据交互的方式: 克隆(Clone)"></a>5.5.3. 变量和数据交互的方式: 克隆(Clone)</h4><ul><li>如果真想对heap上面的String 数据进行深拷贝, 而不仅仅是stack上的数据，可以使用clone方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-4-Stack上的数据：-复制"><a href="#5-5-4-Stack上的数据：-复制" class="headerlink" title="5.5.4. Stack上的数据： 复制"></a>5.5.4. Stack上的数据： 复制</h4><ul><li>Copy trait, 可以容易想到整数这样完全放在stack上面的类型<br>如果一个类型实现了Copy这个trait,那么旧的变量在赋值后仍然可用</li><li>如果一个类型或者该类型的一部分实现了Drop trait,那么Rust不允许让它再去实现Copy trait了</li></ul><h4 id="5-5-5-一些拥有copy-trait的类型"><a href="#5-5-5-一些拥有copy-trait的类型" class="headerlink" title="5.5.5. 一些拥有copy trait的类型"></a>5.5.5. 一些拥有copy trait的类型</h4><ul><li>任何简单标量的组合类型都可以是copy的</li><li>任何需要分配内存或某种资源的都不是copy的</li><li>一些拥有Copy trait的类型<ul><li>所有的整数类型, 例如u32<ul><li>bool</li><li>char</li><li>所有的浮点类型, 例如f64</li><li>tuple 元组, 如果其所有的字段都是Copy的<br>(i32, i32) 是<br>(i32, String) 不是</li></ul></li></ul></li></ul><h4 id="5-5-6-所有权与函数"><a href="#5-5-6-所有权与函数" class="headerlink" title="5.5.6. 所有权与函数"></a>5.5.6. 所有权与函数</h4><ul><li>在语义上, 将值传递给函数和把值赋给变量是类似的：</li><li>将值传递给函数将发生移动或复制</li></ul><h4 id="5-5-7-返回值与作用域"><a href="#5-5-7-返回值与作用域" class="headerlink" title="5.5.7. 返回值与作用域"></a>5.5.7. 返回值与作用域</h4><ul><li>函数在返回值的过程中同样也会发生所有权的转移</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = gives_ownership();</span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> s3 = take_and_gives_back(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  some_string</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  a_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个变量的所有权总是遵循同样的模式：<ul><li>把一个值赋给其它变量时就会发生移动</li><li>当一个包含heap数据的变量离开作用域时，它的值就会被Drop函数清理，除非数据的所有权移动到另一个变量上了</li></ul></li></ul><h4 id="5-5-8-如何让函数使用某个值，但是不获得其所有权？"><a href="#5-5-8-如何让函数使用某个值，但是不获得其所有权？" class="headerlink" title="5.5.8. 如何让函数使用某个值，但是不获得其所有权？"></a>5.5.8. 如何让函数使用某个值，但是不获得其所有权？</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> length = s.len();</span><br><span class="line">  (s，length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-引用和借用"><a href="#5-6-引用和借用" class="headerlink" title="5.6. 引用和借用"></a>5.6. 引用和借用</h3><ul><li>以下例子中参数的类型是&amp;String而不是String</li><li>&amp;符号就表示引用：允许你引用某些值而不取得所有权</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把引用作为函数参数这个行为叫做借用<br>是否可以修改借用的东西？不行<br>和变量一样，引用默认也是不可变的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= calculate_length(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.push_str(<span class="string">&quot;, world!&quot;</span>) <span class="comment">//编译期就会报错, can&#x27;t borrow *s as mutable, as it&#x27;s behind a &#x27;&amp;&#x27; reference</span></span><br><span class="line">  s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-1-可变引用"><a href="#5-6-1-可变引用" class="headerlink" title="5.6.1. 可变引用"></a>5.6.1. 可变引用</h4><p>可变引用有一个重要的限制： 在特定作用域内，对某一块数据, 只能有一个可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> s1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  <span class="keyword">let</span> s2 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 这里会报编译错误 can&#x27;t borrow s as mutable more than once at a time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这样做的好处是可在编译时防止数据竞争</li></ul><p>以下三种行为下会发生数据竞争：</p><ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li><li>可以通过创建新的作用域, 来允许非同时的创建多个可变引用(例子)</li><li>不可以同时拥有一个可变引用和一个不变的引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> len = calculate_length(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Then length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.push_str(<span class="string">&quot;, world&quot;</span>)</span><br><span class="line">  s.len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-6-2-悬空引用Dangling-References"><a href="#5-6-2-悬空引用Dangling-References" class="headerlink" title="5.6.2. 悬空引用Dangling References"></a>5.6.2. 悬空引用Dangling References</h4><ul><li>悬空指针(Dangling Pointer): 一个指针引用了内存中的某个地址, 而这块内存可能已经释放并分配给其它人使用了．</li><li>在Rust里, 编译器可保证引用永远都不是悬空引用：<ul><li>如果你引用了某些数据, 编译器将保证在引用离开作用域之前数据不会离开作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> r = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// 这里编译器会报错，因为s出了此作用域将会被释放，而返回值是一个指向已经被释放区域的指针，这会导致问题，而rust在编译期就杜绝了这种错误．</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-6-3-引用的规则"><a href="#5-6-3-引用的规则" class="headerlink" title="5.6.3. 引用的规则"></a>5.6.3. 引用的规则</h4><ul><li>在任何给定的时刻, 只能满足下列条件之一:<ul><li>一个可变的引用</li><li>任何数量不可变的引用</li></ul></li></ul><h3 id="5-7-切片"><a href="#5-7-切片" class="headerlink" title="5.7. 切片"></a>5.7. 切片</h3><p>Rust的另一种不持有所有权的数据类型: 切片(slice)</p><p>一道题, 编写一个函数</p><ul><li>它接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个单词</li><li>如果函数没有找到任何空格, 那么整个字符串就被返回</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> wordIndex = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;string) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s.len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><ul><li>字符串切片是指向字符串中一部分内容的引用</li><li>例子</li><li>形式：[开始索引..结束索引]<ul><li>开始索引就是切片起始位置的索引值</li><li>结束索引是终止位置的下一个索引值</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> hello= &amp;s[<span class="number">0</span>..<span class="number">5</span>]  <span class="comment">// 或者&amp;s[..5]</span></span><br><span class="line">      <span class="keyword">let</span> world= &amp;s[<span class="number">6</span>..<span class="number">11</span>] <span class="comment">// 或者&amp;s[6..]</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, hello, world)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>字符串切片的范围索引必须发生在有效的UTF-8 字符边界内。</li><li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> wordIndex = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;string) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="将字符串切片作为参数传达"><a href="#将字符串切片作为参数传达" class="headerlink" title="将字符串切片作为参数传达"></a>将字符串切片作为参数传达</h4><ul><li>fn first_word(s: &amp;String) -&gt; &amp;str {</li><li>有经验的Rust开发者会采用&amp;str作为参数类型，因为这样就可以同时接收字符串和&amp;str类型的参数了</li><li>fn first_word(s: &amp;str) -&gt; &amp;str {<ul><li>使用字符串切片，直接调用该函数</li><li>使用String, 可以创建一个完整的String切片来调用该函数</li></ul></li><li>定义函数时使用字符串切片来代替字符串引用会使得我们的API更加通用，且不丧失任何功能。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> wordIndex = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="其他类型的切片"><a href="#其他类型的切片" class="headerlink" title="其他类型的切片"></a>其他类型的切片</h4><ul><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">  <span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>]  <span class="comment">//&amp;[i32]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-Struct"><a href="#5-Struct" class="headerlink" title="5. Struct"></a>5. Struct</h2><h3 id="定义并实例化struct"><a href="#定义并实例化struct" class="headerlink" title="定义并实例化struct"></a>定义并实例化struct</h3><h4 id="什么是struct"><a href="#什么是struct" class="headerlink" title="什么是struct"></a>什么是struct</h4><ul><li>struct结构体<ul><li>自定义的数据类型</li><li>为相关联的值命名， 打包=&gt;有意义的组合</li></ul></li></ul><h3 id="定义struct"><a href="#定义struct" class="headerlink" title="定义struct"></a>定义struct</h3><ul><li>使用struct关键字， 并为整个struct命名</li><li>在花括号内， 为所有字段(Field)定义名称和类型</li></ul><p>例如：</p><p>struct User {<br>username: String,<br>email: String,<br>sign_in_count: u64,<br>active: bool,<br>}</p><h3 id="实例化struct"><a href="#实例化struct" class="headerlink" title="实例化struct"></a>实例化struct</h3><ul><li>想要使用struct, 需要创建struct的实例：<ul><li>为每个字段指定具体值</li><li>无需按声明的顺序进行指定</li></ul></li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">&quot;acb@126.com&quot;</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">556</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取struct里面的某个值"><a href="#获取struct里面的某个值" class="headerlink" title="获取struct里面的某个值"></a>获取struct里面的某个值</h3><ul><li>使用点标记法：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">  email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="built_in">String</span>::from(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  active: <span class="literal">true</span>,</span><br><span class="line">  sign_in_count: <span class="number">556</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">&quot;anotheremail@example.com&quot;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的。rust不允许我们声明struct中一部分字段可变，而另一部分字段不可变。</p><h3 id="struct作为函数的返回值"><a href="#struct作为函数的返回值" class="headerlink" title="struct作为函数的返回值"></a>struct作为函数的返回值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">  User &#123;</span><br><span class="line">    email: email,</span><br><span class="line">    username: username,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h3><ul><li>当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">  User&#123;</span><br><span class="line">     email,</span><br><span class="line">     username,</span><br><span class="line">     active: <span class="literal">true</span>,</span><br><span class="line">     sign_in_count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="struct-更新语法"><a href="#struct-更新语法" class="headerlink" title="struct 更新语法"></a>struct 更新语法</h3><ul><li>当你想基于某个struct实例来创建一个新实例的时候，可以使用struct的更新语法</li></ul><p>不使用更新语法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">  email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="built_in">String</span>::from(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  active: user1.active,</span><br><span class="line">  sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用更新语法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">  email: <span class="built_in">String</span>::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="built_in">String</span>::from(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  ..user1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-Rust-web框架"><a href="#6-Rust-web框架" class="headerlink" title="6. Rust web框架"></a>6. Rust web框架</h2><p>2022年可选择的三个Rust Web框架：actix-web、warp和axum。</p><ul><li><a target="_blank" rel="noopener" href="https://crates.io/crates/actix-web">actix-web</a>：4.0.0-rc.35,134,720Actix Web 是一个功能强大、实用且速度极快的 Rust Web 框架</li><li><a target="_blank" rel="noopener" href="https://crates.io/crates/warp">Warp</a>: 0.3.24,114,095以翘曲的速度服务于网络</li><li><a target="_blank" rel="noopener" href="https://crates.io/crates/axum">axum</a>: 专注于人体工程学和模块化的 Web 框架（由 tokio 团队提供）</li></ul><p>比较：</p><ul><li>axum有最干净的 API，它建立在hyper之上，它（当然）是 Rust 中经过测试最可靠的 HTTP 堆栈，并且因为它是由 tokio 团队开发的。但它的年轻可能会让一些人感到不舒服。</li><li>对于较大的项目，我认为这actix-web是无可争议的赢家。这就是为什么它是我选择Bloom的原因。</li><li>对于较小的项目（最多 50 条路由）warp，尽管它有原始的 API，但它非常好，因为它也是建立在其之上的hyper，因此受益于它的可靠性和性能。</li></ul><p>详细比较：</p><ul><li>JSON反序列化：所有框架都使用泛型来提供简单的 JSON 反序列化。话虽如此，我发现两者都axum可以actix-web更直接地与他们的助手一起使用来自动提取类型化的正文有效负载。</li><li>路由：axum是明显的赢家，紧随其后的是actix-web，然后是warp有利于组合的功能性 API，这与我们通常对 Web 框架的期望相去甚远。</li><li>中间件：warp， 毫无疑问…</li><li>状态：在构建 Web 服务时，您需要共享一些变量，例如数据库连接池或一些用于外部服务的客户端。所有框架的人机工程学都非常相似。</li></ul><h2 id="7-后记"><a href="#7-后记" class="headerlink" title="7. 后记"></a>7. 后记</h2><p>本文原文位于<a href="https://www.pengtech.net/rust/rust_study.html">鹏叔的技术博客 - Rust 编程语言入门教程</a>, 若需要获取最近更新, 请访问原文.</p><h3 id="7-1-web框架选择参考文档"><a href="#7-1-web框架选择参考文档" class="headerlink" title="7.1. web框架选择参考文档"></a>7.1. web框架选择参考文档</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398232138">两张图展示当前 Rust Web 生态</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/cfy_banq/article/details/123107652">2022年选择哪个Rust Web框架</a></p></div><footer class="post-footer"><div class="reward-container"><div>您的支持是我创作深度好文的源动力!</div><button>赞赏</button><div class="post-reward"><div><img src="/imgs/rewards/wechatpay.jpg" alt="鹏叔 微信"> <span>微信</span></div><div><img src="/imgs/rewards/alipay.jpg" alt="鹏叔 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>鹏叔</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.pengtech.net/rust/rust_study.html" title="Rust 编程语言入门教程">https://www.pengtech.net/rust/rust_study.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/Rust/" rel="tag"><i class="fa fa-tag"></i> Rust</a></div><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a href="/hexo/hexo_create_site.html" rel="next" title="使用Hexo搭建自己的博客网站">使用Hexo搭建自己的博客网站 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">鹏叔</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.3m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">19:54</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener external nofollow" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener external nofollow" target="_blank">NexT.Mist</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-615fe625918d4f20" async></script></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.2/dist/mermaid.min.js","integrity":"sha256-UIQPVkGifpwMvDH5yGgORJ9sSTDq38zz6BGU6dNaKhM="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"guoapeng/guoapeng.github.io","issue_term":"pathname","theme":"github-light","cdn":"https://utteranc.es/client.js"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>