<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Rust 编程语言入门教程 - 鹏叔的技术博客</title><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" as="style" onload="this.rel=&#039;stylesheet&#039;"><link rel="manifest" href="/manifest.json"><meta name="application-name" content="鹏叔的技术博客"><meta name="msapplication-TileImage" content="/images/favicon-16x16-next.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="鹏叔的技术博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1. 第一章: Rust简介1.1. 为什么要用RustRust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换C&amp;#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.Rust是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器"><meta property="og:type" content="blog"><meta property="og:title" content="鹏叔的技术博客"><meta property="og:url" content="https://pengtech.net/"><meta property="og:site_name" content="鹏叔的技术博客"><meta property="og:description" content="1. 第一章: Rust简介1.1. 为什么要用RustRust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换C&amp;#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.Rust是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pengtech.net/img/og_image.png"><meta property="article:published_time" content="2021-10-02T16:00:00.000Z"><meta property="article:modified_time" content="2024-08-06T10:05:40.317Z"><meta property="article:author" content="eagle"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://pengtech.net/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://pengtech.net/rust/rust_study.html"},"headline":"Rust 编程语言入门教程","image":["https://pengtech.net/img/og_image.png"],"datePublished":"2021-10-02T16:00:00.000Z","dateModified":"2024-08-06T10:05:40.317Z","author":{"@type":"Person","name":"鹏叔"},"publisher":{"@type":"Organization","name":"鹏叔的技术博客","logo":{"@type":"ImageObject","url":{"text":"鹏叔的技术博客"}}},"description":"1. 第一章: Rust简介1.1. 为什么要用RustRust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换C&#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.Rust是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器"}</script><link rel="canonical" href="https://pengtech.net/rust/rust_study.html"><link rel="alternate" href="/atom.xml" title="鹏叔的技术博客" type="application/atom+xml"><link rel="icon" href="/images/favicon-16x16-next.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ZZTM0Y954E" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-ZZTM0Y954E")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><meta name="follow.it-verification-code" content="FDYm0CxLRXUa9hVlR3zQ"><script>!function(){function e(){var e,t,a;location.hash&&(e="#"+CSS.escape(location.hash.substring(1)),t=document.querySelector(`.tabs a[href="${e}"]`))&&(a=t.parentElement.parentElement,Array.from(a.children).forEach(e=>e.classList.remove("is-active")),Array.from(a.querySelectorAll("a")).map(e=>document.getElementById(e.getAttribute("href").substring(1))).forEach(e=>e.classList.add("is-hidden")),t&&t.parentElement.classList.add("is-active"),a=document.querySelector(e))&&a.classList.remove("is-hidden")}e(),window.addEventListener("hashchange",e,!1)}()</script><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">鹏叔的技术博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/angular/">angular</a><a class="navbar-item" href="/material-design/">material-design</a><a class="navbar-item" href="/linux/">linux</a><a class="navbar-item" href="/gitlab/">gitlab</a><a class="navbar-item" href="/frontend/">frontend</a><a class="navbar-item" href="/backend/">backend</a><a class="navbar-item" href="/vscode/">vscode</a><a class="navbar-item" href="/java/">java</a><a class="navbar-item" href="/golang/">golang</a><a class="navbar-item" href="/v2rayA/">v2rayA</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/tools/">工具</a><a class="navbar-item" href="/friends/">友链</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-10-02T16:00:00.000Z" title="2021/10/3 00:00:00">2021-10-03</time>发表</span><span class="level-item"><time datetime="2024-08-06T10:05:40.317Z" title="2024/8/6 18:05:40">2024-08-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/language/">language</a><span> / </span><a class="link-muted" href="/categories/language/rust/">rust</a></span><span class="level-item">1 小时读完 (大约10395个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Rust 编程语言入门教程</h1><div class="content"><h2 id="1-第一章-Rust简介"><a href="#1-第一章-Rust简介" class="headerlink" title="1. 第一章: Rust简介"></a>1. 第一章: Rust简介</h2><h3 id="1-1-为什么要用Rust"><a href="#1-1-为什么要用Rust" class="headerlink" title="1.1. 为什么要用Rust"></a>1.1. 为什么要用Rust</h3><p>Rust是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.<br>它可以用来替换C&#x2F;C++, Rust和他们具有同样的性能, 但是很多常见的bug在编译时就可以被消灭.<br>Rust是一种通用的编程语言, 但是它更善于以下场景:<br>需要运行时的速度<br>需要内存安全<br>更好的利用多处理器</p><span id="more"></span><h3 id="1-2-与其他语言比较"><a href="#1-2-与其他语言比较" class="headerlink" title="1.2. 与其他语言比较"></a>1.2. 与其他语言比较</h3><p>C&#x2F;C++ 性能非常好, 但类型系统和内存都不太安全.<br>JAVA&#x2F;C#, 拥有GC, 能保证内存安全, 也有很多优秀特性, 但是性能不行<br>RUST:<br>安全<br>无需GC<br>易于维护, 调试, 代码安全高效</p><h3 id="1-3-Rust特别擅长的领域"><a href="#1-3-Rust特别擅长的领域" class="headerlink" title="1.3. Rust特别擅长的领域"></a>1.3. Rust特别擅长的领域</h3><p>高性能webservice<br>webassembly<br>命令行工具<br>网络编程<br>嵌入式设备<br>系统编程</p><h3 id="1-4-Rust与Firefox"><a href="#1-4-Rust与Firefox" class="headerlink" title="1.4. Rust与Firefox"></a>1.4. Rust与Firefox</h3><ul><li><p>Rust最初是Mozilla公司的一个研究性项目, firefox是Rust产品应用的一个重要例子.Mozilla 一直以来都在用rust创建一个名为servo的实验性浏览器引擎, 其中的所有内容都是并行执行的.<br>目前servo的部分功能已经被集成到firefox里面了<br>firefox原来的量子版就包含了servo的css渲染引擎</p></li><li><p>rust使得firefox在这方便得到了巨大的性能改进</p></li></ul><h3 id="1-5-Rust的用户和案例"><a href="#1-5-Rust的用户和案例" class="headerlink" title="1.5. Rust的用户和案例"></a>1.5. Rust的用户和案例</h3><ul><li>google: 新操作系统Fuschia, 其中Rust代码量大约30%</li><li>Amazon: 基于Linux开发的直接可以在裸机, 虚拟机上运行容器的操作系统.</li><li>System76: 纯Rust开发了下一代安全操作系统Redox</li><li>蚂蚁金服: 库操作系统Occlum</li><li>斯坦福和密歇根大学: 嵌入式实时操作系统, 应用于google的加密产品.</li><li>微软: 正在使用Rust重写windows系统中的一些低级组件.</li><li>微软: winRT&#x2F;Rust项目</li><li>Dropbox, yelp, Coursera, LINE, Cloudflare, Atlassian, npm, Ceph, 百度, 华为, Sentry, Deno</li></ul><h3 id="1-6-Rust的优点"><a href="#1-6-Rust的优点" class="headerlink" title="1.6. Rust的优点"></a>1.6. Rust的优点</h3><ul><li>性能</li><li>安全性</li><li>无所畏惧的并发</li></ul><h3 id="1-7-Rust的缺点"><a href="#1-7-Rust的缺点" class="headerlink" title="1.7. Rust的缺点"></a>1.7. Rust的缺点</h3><ul><li>难学</li></ul><h3 id="1-8-注意"><a href="#1-8-注意" class="headerlink" title="1.8. 注意"></a>1.8. 注意</h3><p>Rust有很多独有的概念, 它们和现在大多主流语言都不同.</p><ul><li>所以学习Rust必须从基础概念一步一步学, 否则会懵.</li></ul><h3 id="1-9-参考教材"><a href="#1-9-参考教材" class="headerlink" title="1.9. 参考教材"></a>1.9. 参考教材</h3><p>The Rust programming language<br>Rust权威指南</p><h2 id="2-安装Rust"><a href="#2-安装Rust" class="headerlink" title="2. 安装Rust"></a>2. 安装Rust</h2><h3 id="2-1-安装rust"><a href="#2-1-安装rust" class="headerlink" title="2.1. 安装rust"></a>2.1. 安装rust</h3><ul><li>Rust官网: <a target="_blank" rel="noopener" href="https://www.rust-lang.org/">https://www.rust-lang.org</a></li><li>Linux or Mac:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf| sh</span><br></pre></td></tr></table></figure><ul><li><p>windows: 按<a target="_blank" rel="noopener" href="https://www.rust-lang.org/tools/install">官网安装指引操作</a></p><ul><li><p>下载安装程序，<a target="_blank" rel="noopener" href="https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe">下载RUSTUP-INIT.exe 32位安装程序</a> 或 <a target="_blank" rel="noopener" href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">下载RUSTUP-INIT.exe 64位安装程序</a></p></li><li><p>然后运行程序并按照屏幕上的说明进行操作。</p></li><li><p>当提示您安装<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio C++ build tools</a>时，您可能需要安装这些工具。</p></li><li><p>完成安装后需要将 &lt;home_dir&gt;&#x2F;bin&#x2F;.cargo 添加到Path环境变量, 这样在任何位置都可以执行rustc, cargo 和rustup命令了</p></li></ul></li><li><p>windows subsystem for Linux:</p><p>搭建WSL可参考我的博客<br><a href="https://pengtech.net/windows/wsl_install.html">Windows下搭建WSL Linux开发环境</a></p><p>安装rust可使用如下命令命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-配置Rust"><a href="#2-2-配置Rust" class="headerlink" title="2.2. 配置Rust"></a>2.2. 配置Rust</h3><h4 id="2-2-1-替换镜像"><a href="#2-2-1-替换镜像" class="headerlink" title="2.2.1. 替换镜像"></a>2.2.1. 替换镜像</h4><p>安装完成后需要将crates.io替换成国内镜像.</p><p>访问<a target="_blank" rel="noopener" href="https://crates.io/">https://crates.io</a>非常缓慢，github 的仓库也经常不能访问，建议大家切换到国内镜像站。镜像站实时缓存，托管在码云的 gitee 仓库每隔30分钟与 github 同步。</p><p>配置方式</p><ul><li>在 .cargo 目录新建文件config</li></ul><blockquote><p>注意：新安装的电脑中没有这个文件，需要手动创建config文件，并且该文件没有后缀名</p></blockquote><p>编辑文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry=&quot;https://github.com/rust-lang/crates.io-index&quot; #这行可以不要,只是说明原始地址</span><br><span class="line">replace-with=&#x27;crates-cn&#x27;</span><br><span class="line"></span><br><span class="line">[source.crates-cn]</span><br><span class="line">registry=&quot;https://gitee.com/crates/crates.io-index.git&quot;</span><br></pre></td></tr></table></figure><p>如果使用中科大USTC的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with=<span class="string">&#x27;ustc&#x27;</span></span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry=<span class="string">&quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完保存后执行build即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><h3 id="2-3-更新Rust"><a href="#2-3-更新Rust" class="headerlink" title="2.3. 更新Rust"></a>2.3. 更新Rust</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure><h3 id="2-4-卸载Rust"><a href="#2-4-卸载Rust" class="headerlink" title="2.4. 卸载Rust"></a>2.4. 卸载Rust</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure><h3 id="2-5-验证安装是否成功"><a href="#2-5-验证安装是否成功" class="headerlink" title="2.5. 验证安装是否成功"></a>2.5. 验证安装是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><ul><li>结果格式: rustc x.y. z (abcabcabc yyyy-mm-dd)</li><li>会显示最新稳定版的: 版本号, commit hash, commit日期</li><li>当前我安装的版本为 rustc 1.56.1 (59eed8a2a 2021-11-01)</li></ul><h2 id="3-第二章：第一个rust程序"><a href="#3-第二章：第一个rust程序" class="headerlink" title="3. 第二章：第一个rust程序"></a>3. 第二章：第一个rust程序</h2><h3 id="3-1-hello-world"><a href="#3-1-hello-world" class="headerlink" title="3.1. hello world"></a>3.1. hello world</h3><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure><p>编译完成后将会输出可执行文件main,<br>运行程序使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><h3 id="3-2-Rust-程序解析"><a href="#3-2-Rust-程序解析" class="headerlink" title="3.2. Rust 程序解析"></a>3.2. Rust 程序解析</h3><ul><li>定义函数 fn main() {}<br>没有参数, 没有返回值</li><li>main 函数很特别 : 他是每一个Rust 可执行程序 最先运行的代码</li><li>打印文本: println!(“hello, world!”)<ul><li>rust 的缩进是4个空格而不是tab</li><li>println! 是一个Rust macro(宏), 如果是函数的话就没有感叹号(!)</li><li>“hello world” 是字符串, 它是println!的参数</li><li>这行代码以;结尾</li></ul></li></ul><h3 id="3-3-编译和运行是单独的两步"><a href="#3-3-编译和运行是单独的两步" class="headerlink" title="3.3. 编译和运行是单独的两步"></a>3.3. 编译和运行是单独的两步</h3><ul><li><p>运行rust程序之前需要先编译, 命令为: rustc 源文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译程序</span></span><br><span class="line">rustc main.rs</span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure></li><li><p>编译成功后, 会生成一个二进制文件例如main</p><ul><li>在window上还会生成一个.pdb文件, 里面包含调试信息</li></ul></li><li><p>Rust是ahead-of-time(AOT)预编译的语言</p><ul><li>可以先编译程序, 然后把可执行文件交给别人运行(无需安装Rust)</li></ul></li><li><p>rustc只适合简单的Rust程序, 当文件比较多, 项目管理还是需要使用Cargo</p></li></ul><h3 id="3-4-hello-cargo"><a href="#3-4-hello-cargo" class="headerlink" title="3.4. hello cargo"></a>3.4. hello cargo</h3><h4 id="3-4-1-cargo-介绍"><a href="#3-4-1-cargo-介绍" class="headerlink" title="3.4.1. cargo 介绍"></a>3.4.1. cargo 介绍</h4><ul><li>Cargo 是Rust的构建系统和包管理工具<ul><li>构建代码, 下载依赖的库, 构建这些库</li></ul></li><li>安装Rust的同时会自动安装Cargo, 所以这里不需要额外的步骤去安装Cargo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cargo</span> --version</span><br><span class="line">cargo 1.56.0 (4ed5d137b 2021-10-04)</span><br></pre></td></tr></table></figure><h4 id="3-4-2-使用Cargo创建项目"><a href="#3-4-2-使用Cargo创建项目" class="headerlink" title="3.4.2. 使用Cargo创建项目"></a>3.4.2. 使用Cargo创建项目</h4><ul><li><p>创建项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br></pre></td></tr></table></figure></li><li><p>创建完成后项目的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tree</span> -a .      </span><br><span class="line">hello_cargo</span><br><span class="line"></span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── .git</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── description</span><br><span class="line">│   ├── HEAD</span><br><span class="line">........省略部分目录...........</span><br><span class="line">├── .gitignore</span><br><span class="line">└── src</span><br><span class="line">      └── main.rs</span><br></pre></td></tr></table></figure><p>目录结构说明：<br>Cargo.toml:</p><ul><li>TOML(Tom’s obvious, Minimal Language)格式，是Cargo的配置格式</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure></li><li><p>[package], 是一个项目信息区域，表示下方内容是用来配置包（package）的．</p><ul><li>name: 项目名</li><li>version: 项目版本</li><li>authors: 项目作者</li><li>edition: The Rust edition</li><li>更多参数说明请参考<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/manifest.html">The Manifest Format</a></li></ul></li><li><p>[dependencies], 另一个区域的开始，它会列出项目的依赖项．</p></li><li><p>在Rust里面，代码的包称作<a target="_blank" rel="noopener" href="https://philoenglish.com/query/crate">crate</a>(板条箱,装货箱;如果<a target="_blank" rel="noopener" href="https://philoenglish.com/query/cargo">cargo</a>是装货物的集装箱,Crate板条箱就是装载整批货物的小箱子)</p><p>src&#x2F;main.rs</p><ul><li>cargo生成的main.rs在src目录下</li><li>而Cargo.toml在项目顶层下</li><li>源代码都应该在src目录下</li><li>顶层目录可以放置：README, 许可信息, 配置文件和其它与程序源代码无关的文件</li><li>如果创建项目时没有使用cargo, 也可以把项目转化为使用cargo:<ul><li>把源代码文件移动到src下</li><li>创建Cargo.toml并填写相应的配置</li></ul></li></ul></li></ul><h4 id="3-4-3-构建Cargo项目"><a href="#3-4-3-构建Cargo项目" class="headerlink" title="3.4.3. 构建Cargo项目"></a>3.4.3. 构建Cargo项目</h4><ul><li>cargo build<br>创建可执行文件：target&#x2F;debug&#x2F;hello_cargo (linux&#x2F;macos)或者 target\debug\hello_cargo.exe (windows)</li><li>第一次运行cargo build会在顶层目录生成cargo.lock文件<ul><li>该文件负责追踪项目依赖的精确版本</li><li>不需要手动修改该文件</li></ul></li><li>构建和运行cargo项目<ul><li>cargo run<ul><li>cargo run, 编译代码+执行结果</li><li>如果之前编译成功过，并且源代码没有改变，那么就会直接运行二进制文件</li></ul></li></ul></li><li>cargo check<ul><li>cargo check, 检查代码，确保能通过编译，但是不产生任何可执行文件</li></ul></li><li>cargo buid -release<ul><li>编译时会进行优化</li><li>代码会运行的更快, 但是编译时间更长</li><li>会在target&#x2F;release 而不是target&#x2F;debug生成可执行文件</li></ul></li><li>两种配置，一种是开发用的，一种是发布用的</li></ul><h3 id="3-5-猜数字游戏"><a href="#3-5-猜数字游戏" class="headerlink" title="3.5. 猜数字游戏"></a>3.5. 猜数字游戏</h3><h4 id="3-5-1-声明变量"><a href="#3-5-1-声明变量" class="headerlink" title="3.5.1. 声明变量"></a>3.5.1. 声明变量</h4><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* let声明一个变量</span></span><br><span class="line"><span class="comment">* mut 声明变量为可变变量, </span></span><br><span class="line"><span class="comment">* 默认情况下变量是不可变的, 除非显示使用mut指明变量为可变变量</span></span><br><span class="line"><span class="comment">* = 赋值操作</span></span><br><span class="line"><span class="comment">* 注意申明时没有指定变量类型, 变量类型是根据赋初始值时进行推导的</span></span><br><span class="line"><span class="comment">* String是由rust 的标准库所提供的类型，内部是使用utf-8编码</span></span><br><span class="line"><span class="comment">* :: 符号表明new是String类型的关联函数，关联函数相当与其他语言中的静态方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* io是rust标准库中的一个包名</span></span><br><span class="line"><span class="comment">* stdin()方法会返回一个Ｓtdin对象, 标准输入对象</span></span><br><span class="line"><span class="comment">* read_line 是标准输入对象的一个方法，调用该方法时，需要提供一个可变字符串变量，用于接收用户输入</span></span><br><span class="line"><span class="comment">* &amp; 取地址符号，表示传递引用, 表示这个参数是一个引用reference，通过引用我们就可以在不同地方，访问程序的统一块内存区域</span></span><br><span class="line"><span class="comment">* &amp;mut表示这个引用是可变的, 如果不加mut, 表明这个引用也是不可变的</span></span><br><span class="line"><span class="comment">* read_line函数返回的是一个i0:Result&lt;usize&gt;对象，expect是result对象的一个方法</span></span><br><span class="line"><span class="comment">*  result是一个枚举类型, 其有两种类型的返回结果, 一种是err, 一种ok</span></span><br><span class="line"><span class="comment">*  如果返回的result为err, 该expect就会将错误信息输出到终端</span></span><br><span class="line"><span class="comment">* 如果返回结果是ok类型, expect就会提取出result中附加的值并将这个值作为结果返回给用户</span></span><br><span class="line"><span class="comment">* 如果不调用expect方法, 编译时将会收到rusult未被使用的警告</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line"><span class="comment">//&#123;&#125; 是一个占位符，输出时将会替换成相对应的变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;你猜测的数时｛｝&quot;</span>, guess);</span><br></pre></td></tr></table></figure><h4 id="3-5-2-引入依赖包"><a href="#3-5-2-引入依赖包" class="headerlink" title="3.5.2. 引入依赖包"></a>3.5.2. 引入依赖包</h4><ul><li>rust中的依赖包被称为crate<br>crate分为两种, 一种是二进制格式的可执行文件; 一种是源文件,也被称为library crate</li><li>rust的crate仓库为crates.io, 可以访问<a target="_blank" rel="noopener" href="https://crates.io/">该网站</a>获得相应的crate</li><li>cargo 引入依赖的方式</li><li>在dependencies 区域添加依赖的crate名称和版本如下所示.</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Cargo.toml</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;^0.7.0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>示例代码</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng; <span class="comment">//trait</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_num</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="comment">//rust循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;你猜测的数是: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">        <span class="comment">//shadow</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(ex) =&gt; &#123;</span><br><span class="line">                <span class="comment">//rust异常处理</span></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;解析错误 &#123;&#125; &#123;&#125;&quot;</span>, guess, ex);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// rust条件运算</span></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_num) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>), <span class="comment">//arm</span></span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-第三章-通用的编程概念"><a href="#4-第三章-通用的编程概念" class="headerlink" title="4. 第三章 通用的编程概念"></a>4. 第三章 通用的编程概念</h2><h3 id="4-1-变量和可变性"><a href="#4-1-变量和可变性" class="headerlink" title="4.1. 变量和可变性"></a>4.1. 变量和可变性</h3><ul><li><p>声明变量使用let 关键字</p></li><li><p>默认情况下，变量是不可变的(immutable)<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> =<span class="number">5</span>;  <span class="comment">// x 为不可变变量</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// 注意: 这里会有编译错误</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>声明变量时, 在变量前面加上mut, 就可以使变量可变．</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-变量和常量"><a href="#4-2-变量和常量" class="headerlink" title="4.2. 变量和常量"></a>4.2. 变量和常量</h3><ul><li><p>常量(constant), 常量在绑定值以后也是不可变的, 但是它与不可变的变量有很多区别：</p><ul><li>不可以使用mut, 常量永远都是不可变的</li><li>声明常量使用const关键字, 它的类型必须被标注</li><li>常量可以在任何作用域内进行声明, 包括全局作用域</li><li>常量只可以绑定到常量表达式, 无法绑定到函数的调用结果或只能在运行时才能计算出的值</li></ul></li><li><p>在程序运行期间, 常量在其声明的作用域内一直有效</p></li><li><p>命名规范: Rust里常量使用全大写字母, 每个单词之间用下划线分开, 例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-shadowing-隐藏"><a href="#4-3-shadowing-隐藏" class="headerlink" title="4.3. shadowing (隐藏)"></a>4.3. shadowing (隐藏)</h3><ul><li>可以使用相同的名字声明新的变量, 新的变量就会shadow（隐藏）之前声明的同名变量<ul><li><p>在后续代码中这个变量名代表的就是新的变量</p></li><li><p>shadow和把变量标记为mut是不一样的<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">//定义不可变变量x</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">// x = 6 // 如果这里给x赋值会报错</span></span><br><span class="line">  <span class="comment">// 但是如果我们声明一个同名的新的变量，就可以编译通过</span></span><br><span class="line">  <span class="comment">// 我们甚至可以改变x的数据类型, 甚至可以定义新的同名但是不同的可变性的变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//新的同名变量 </span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  <span class="comment">//不同可变性的同名变量</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="string">&quot;my love&quot;</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">  x = <span class="string">&quot;hello kitty&quot;</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-4-Rust数据类型"><a href="#4-4-Rust数据类型" class="headerlink" title="4.4. Rust数据类型"></a>4.4. Rust数据类型</h3><ul><li>Rust 是静态编译语言, 在编译时必须知道变量的类型<ul><li><p>基于使用的值, 编译器通常能够推断出它的具体类型</p></li><li><p>但如果可能的类型比较多(例如把String 转为整数的parse方法)，就必须添加类型的标注，否则编会报错．<br>例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;not a number&quot;</span>)</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, guess)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-4-1-标量类型"><a href="#4-4-1-标量类型" class="headerlink" title="4.4.1. 标量类型"></a>4.4.1. 标量类型</h4><ul><li>一个标量类型代表一个单个的值</li><li>Rust有四个主要的标量类型：<ul><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ul></li></ul><h5 id="4-4-1-1-整数类型"><a href="#4-4-1-1-整数类型" class="headerlink" title="4.4.1.1. 整数类型"></a>4.4.1.1. 整数类型</h5><ul><li>整数类型分为无符合整数类型,<ul><li>无符号整数类型以ｕ开头</li><li>有符号整数类型以i开头</li></ul></li><li>Rust 的整数类型列表如图：<ul><li>每种长度都有对应的有符号型和无符号型．</li></ul></li><li>有符号范围<ul><li>(负的2的n-1次方-1) 到(2的n-1次方-1)</li></ul></li><li>无符号范围<ul><li>0 到2的n次方 -1</li></ul></li><li>isize 和 usize类型<ul><li><p>isize和usize类型的位数由程序运行的计算机的架构所决定</p></li><li><p>如果是64位的计算机，那就是64位的</p></li><li><p>如果是32位的计算机，那就是32位的</p></li><li><p>使用isize或者usize的场景是对某种集合进行索引操作</p><table><thead><tr><th align="left">length</th><th align="left">signed</th><th align="left">unsigned</th></tr></thead><tbody><tr><td align="left">8-bit</td><td align="left">i8</td><td align="left">u8</td></tr><tr><td align="left">16-bit</td><td align="left">i16</td><td align="left">u16</td></tr><tr><td align="left">32-bit</td><td align="left">i32</td><td align="left">u32</td></tr><tr><td align="left">64-bit</td><td align="left">i64</td><td align="left">i64</td></tr><tr><td align="left">128-bit</td><td align="left">i128</td><td align="left">u128</td></tr><tr><td align="left">arch</td><td align="left">isize</td><td align="left">usize</td></tr></tbody></table></li><li><p>整数的字面值</p><ul><li>除了byte类型外, 所有的数值字面值都允许使用类型后缀<br>例如： 57u8: 值为57 类型为u8<ul><li><p>整数的默认类型就是i32:</p><ul><li>总体来说速度很快, 即使在64位系统中</li></ul><table><thead><tr><th align="left">NumberLiteral</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left">Decimal</td><td align="left">Oxff</td></tr><tr><td align="left">Hex</td><td align="left">Oo77</td></tr><tr><td align="left">Binary</td><td align="left">Ob1111_0000</td></tr><tr><td align="left">Byte (u8 only)</td><td align="left">b’A’</td></tr></tbody></table></li></ul></li></ul></li><li><p>整数溢出<br>例如：u8的范围是0-255, 如果你把一个u8变量的值设为256, 那么：</p><ul><li>调试模式下编译：rust会检查整数溢出, 如果发生溢出, 程序编译时就会panic</li><li>在发布模式下(–release)编译：rust不会检查可能导致panic的整数溢出<ul><li>在这种模式下如果发生溢出：rust会执行环绕操作<br>256变成0, 257变成1…. 但是不会导致panic</li></ul></li></ul></li></ul></li></ul><h3 id="4-5-浮点类型"><a href="#4-5-浮点类型" class="headerlink" title="4.5. 浮点类型"></a>4.5. 浮点类型</h3><ul><li><p>rust 有两种基础的浮点类型，也就是含有小数部分的类型</p><ul><li>f32, 32位, 单精度</li><li>f64, 64位，双精度</li></ul></li><li><p>rust的浮点类型使用了IEEE-754标准来表述</p></li><li><p>f64是默认类型，因为在现代cpu上f64和32的运算速度差不多，而且精度更高<br>例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span> <span class="comment">//默认为f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">//f32</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-6-数值操作"><a href="#4-6-数值操作" class="headerlink" title="4.6. 数值操作"></a>4.6. 数值操作</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span>+<span class="number">10</span>;   <span class="comment">//i32</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span>-<span class="number">4.3</span>; <span class="comment">//f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span>*<span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span>/<span class="number">32.2</span>  <span class="comment">//f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">reminder</span> = <span class="number">54</span>%<span class="number">5</span> </span><br></pre></td></tr></table></figure><h3 id="4-7-布尔类型"><a href="#4-7-布尔类型" class="headerlink" title="4.7. 布尔类型"></a>4.7. 布尔类型</h3><ul><li><p>Rust的布尔类型有两个值: true和false</p></li><li><p>占用一个字节(Byte)的大小</p></li><li><p>符号是bool</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">//编译器推断类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//显示指定类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-8-字符类型"><a href="#4-8-字符类型" class="headerlink" title="4.8. 字符类型"></a>4.8. 字符类型</h3><p>rust语言中char类型被用来描述语言中最基础的单个字符．<br>字符类型的字面值使用单引号<br>占用４字节大小<br>是Unicode标量值, 可以表示比ASCII多得多的字符内容：拼音, 中日文, 零长度空白字符，emoji表情等．</p><ul><li>其范围为<ul><li>U+0000到U+D7FF</li><li>U+E000到U+10FFFF</li></ul></li><li>但是unicode中并没有字符的概念, 所以直觉上认为的字符也许与Rust中的概念并不相符</li></ul><h3 id="4-9-复合类型"><a href="#4-9-复合类型" class="headerlink" title="4.9. 复合类型"></a>4.9. 复合类型</h3><ul><li>复合类型可以将多个值放在一个类型里</li><li>Rust提供了两种基础的复合类型: 元组(Tuple), 数组</li></ul><h4 id="4-9-1-Tuple"><a href="#4-9-1-Tuple" class="headerlink" title="4.9.1. Tuple"></a>4.9.1. Tuple</h4><ul><li>Tuple可以将多个类型的多个值放在一个类型里</li><li>Tuple的长度是固定的: 一旦声明就无法改变</li></ul><h5 id="4-9-1-1-创建tuple"><a href="#4-9-1-1-创建tuple" class="headerlink" title="4.9.1.1. 创建tuple"></a>4.9.1.1. 创建tuple</h5><ul><li>在小括号里, 将值用逗号分开</li><li>Tuple中的每个位置都对应一个类型，tuple中各元素的类型不必相同</li><li>实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="4-9-1-2-获取tuple的元素值"><a href="#4-9-1-2-获取tuple的元素值" class="headerlink" title="4.9.1.2. 获取tuple的元素值"></a>4.9.1.2. 获取tuple的元素值</h5><ul><li>可以使用模式匹配来解构(destructure)一个Tuple来获取元素的值</li><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">//这里使用模式匹配解构tup的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, x, y, z)</span><br></pre></td></tr></table></figure><h4 id="4-9-2-访问tuple的元素"><a href="#4-9-2-访问tuple的元素" class="headerlink" title="4.9.2. 访问tuple的元素"></a>4.9.2. 访问tuple的元素</h4><ul><li>在tuple变量使用点标记法，后接元素的索引号</li><li>实例</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="4-10-数组"><a href="#4-10-数组" class="headerlink" title="4.10. 数组"></a>4.10. 数组</h3><ul><li>数组也可以将多个值放在一个类型里</li><li>数组中每个元素的类型必须相同</li><li>数组的长度也是固定的</li></ul><h4 id="4-10-1-声明一个数组"><a href="#4-10-1-声明一个数组" class="headerlink" title="4.10.1. 声明一个数组"></a>4.10.1. 声明一个数组</h4><ul><li><p>在中括号里, 各值用逗号分开</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-10-2-数组的用处"><a href="#4-10-2-数组的用处" class="headerlink" title="4.10.2. 数组的用处"></a>4.10.2. 数组的用处</h4><ul><li><p>如果想让你的数据存放在栈(stack)上, 而不是堆(heap)上，或者想保证有固定数量的元素, 这时使用数组更有好处．</p></li><li><p>数组没有Vector灵活(以后再讲)</p><ul><li>Vector和数组类似，它是由标准库提供的</li><li>Vector的长度是可以改变的</li><li>如果你不确定应该使用数组还是vector, 那么估计你应该用vector.</li></ul></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">months</span> = [<span class="string">&quot;January&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Fabruary&quot;</span>,</span><br><span class="line">            ......</span><br><span class="line">            <span class="string">&quot;December&quot;</span></span><br><span class="line">            ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-10-3-数组的类型"><a href="#4-10-3-数组的类型" class="headerlink" title="4.10.3. 数组的类型"></a>4.10.3. 数组的类型</h4><ul><li>数组的类型以这种形式来表示: [类型; 长度]<ul><li>例如: let a: [i32; 5] &#x3D; [1, 2, 3, 4, 5];</li></ul></li><li>另外一种声明数组的方法<br>如果数组的没一个元素值都相同, 那么可以在:<br>在中括号里指定初始值<br>然后是一个;<br>最后是数组的长度<br>例如： let a &#x3D; [3; 5]; 它相当于：let a &#x3D; [3, 3, 3, 3, 3]</li></ul><h4 id="4-10-4-访问数组的元素"><a href="#4-10-4-访问数组的元素" class="headerlink" title="4.10.4. 访问数组的元素"></a>4.10.4. 访问数组的元素</h4><ul><li><p>数组是stack上分配的单个块的内存</p></li><li><p>可以使用索引来访问数组的元素</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = months[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span> = months[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>如果访问的索引超出了数组的范围, 那么</p><ul><li>编译会通过</li><li>运行会报错(runtime时会panic) Rust不会允许其继续访问相应地址的内存<br>说明：<br>在简单的情况下，编译会报错，但是在复杂情况下，编译不会报错<br>例如</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">index</span> = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">month</span> = months[index]; <span class="comment">//此时编译会报错</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">index</span> = [<span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">month</span> = months[index[<span class="number">0</span>]]; <span class="comment">//此时编译不会报错, 运行时会发生panic</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-11-3-4-函数"><a href="#4-11-3-4-函数" class="headerlink" title="4.11. 3.4 函数"></a>4.11. 3.4 函数</h3><ul><li>声明函数使用fn关键字</li><li>依照惯例，针对函数和变量名，rust使用snake case命名规范:<ul><li><p>所有的字母都是小写的, 单词之间使用下划线分开</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;another function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-11-1-函数的参数"><a href="#4-11-1-函数的参数" class="headerlink" title="4.11.1. 函数的参数"></a>4.11.1. 函数的参数</h4><ul><li><p>parameters, arguments</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the value of x is &#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-11-2-函数中的语句-statement-和表达式-expression"><a href="#4-11-2-函数中的语句-statement-和表达式-expression" class="headerlink" title="4.11.2. 函数中的语句(statement)和表达式(expression)"></a>4.11.2. 函数中的语句(statement)和表达式(expression)</h4><ul><li>函数体由一系列语句组成, 可选的由一个表达式结束</li><li>Rust是一个基于表达式的语言</li><li>语句是执行一些动作的指令</li><li>表达式会计算产生一个值</li><li>函数的定义也是语句</li><li>语句不返回值，所以不可以使用let将一个语句－赋给一个变量</li></ul><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; </span><br><span class="line">  <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//x+3; //注意这里有个分号，它是语句而不是表达式, 但是这个语句有些特殊, 它的值等于一个空的tuple 即（）</span></span><br><span class="line">    x+<span class="number">3</span> <span class="comment">//这里没有分号, 它是一个表达式, 表达式的值为5 它是整个block的返回值, 该值将会被赋给变量y</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-11-3-函数的返回值"><a href="#4-11-3-函数的返回值" class="headerlink" title="4.11.3. 函数的返回值"></a>4.11.3. 函数的返回值</h4><ul><li>在-&gt;符号后边声明函数返回值的类型, 但是不可以为返回值命名</li><li>在Rust里面, 返回值就是函数体里面最后一个表达式的值</li><li>若想提前返回, 需使用return 关键字, 并指定一个值<ul><li>大多数函数都是默认使用最后一个表达式为返回值<br>例子:</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">  <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line">  <span class="title function_ invoke__">println</span>(<span class="string">&quot;the value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-注释"><a href="#4-12-注释" class="headerlink" title="4.12. 注释"></a>4.12. 注释</h3><p>单行注释<br>多行注释<br>文档注释</p><h3 id="4-13-控制流"><a href="#4-13-控制流" class="headerlink" title="4.13. 控制流"></a>4.13. 控制流</h3><h4 id="4-13-1-if-表达式"><a href="#4-13-1-if-表达式" class="headerlink" title="4.13.1. ｉf 表达式"></a>4.13.1. ｉf 表达式</h4><ul><li><p>if 表达式允许你根据条件来执行不同的代码分支</p><ul><li>这个条件必须是bool类型</li></ul></li><li><p>if 表达式中, 与条件相关联的代码块就叫做分支(arm)</p></li><li><p>可选的, 在后面可以加上一个else表达式</p></li><li><p>但是如果使用了多余一个else if, 那么最好使用match来重构代码</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子：else if</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisaible by 4&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisaible by 3&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisaible by 3 or 4&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-13-2-在let语句中使用if"><a href="#4-13-2-在let语句中使用if" class="headerlink" title="4.13.2. 在let语句中使用if"></a>4.13.2. 在let语句中使用if</h4><ul><li><p>因为if是一个表达式, 所以可以将它放在let语句中等号的右边(例子)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">condition</span> = ture;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">muber</span> = <span class="keyword">if</span> condition &#123;<span class="number">5</span>&#125; <span class="keyword">else</span> &#123;<span class="number">6</span>&#125;; <span class="comment">//相对于其它语言中的三元表达式</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The value of number is &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-14-Rust的循环"><a href="#4-14-Rust的循环" class="headerlink" title="4.14. Rust的循环"></a>4.14. Rust的循环</h3><ul><li>Rust提供了３中循环：loop, while 和 for.</li></ul><h4 id="4-14-1-loop-循环"><a href="#4-14-1-loop-循环" class="headerlink" title="4.14.1. loop 循环"></a>4.14.1. loop 循环</h4><p>loop关键字告诉Rust反复地执行一块代码，直到你喊停为止<br>可以在loop循环中使用break关键字来告诉程序何时停止循环<br>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">resut</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">     counter += <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">       <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;The result is: &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-14-2-while条件循环"><a href="#4-14-2-while条件循环" class="headerlink" title="4.14.2. while条件循环"></a>4.14.2. while条件循环</h4><ul><li><p>另外一种常见的循环模式是每次执行循环体之前都判断一次条件．</p></li><li><p>while条件循环就是为这种模式而生的</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    number = number -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="4-15-for-循环遍历集合"><a href="#4-15-for-循环遍历集合" class="headerlink" title="4.15. for 循环遍历集合"></a>4.15. for 循环遍历集合</h3><ul><li><p>可以使用while 或 loop 来遍历数组, 但是易出错且低效．</p></li><li><p>使用for循环更简洁紧凑, 它可以针对集合中的每一个元素来执行一些代码</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于for循环的安全，简洁性，所以它在Rust里用的最多</p></li></ul><h3 id="4-16-Range"><a href="#4-16-Range" class="headerlink" title="4.16. Range"></a>4.16. Range</h3><ul><li><p>标准库提供</p></li><li><p>指定一个开始数字和一个结束数字，Range可以生成它们之间的数字(不包含介绍)</p></li><li><p>rev方法可以反转range</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-第四章：-所有权"><a href="#5-第四章：-所有权" class="headerlink" title="5. 第四章： 所有权"></a>5. 第四章： 所有权</h2><h3 id="5-1-4-1-什么是所有权"><a href="#5-1-4-1-什么是所有权" class="headerlink" title="5.1. 4.1 什么是所有权"></a>5.1. 4.1 什么是所有权</h3><ul><li>Rust的核心特性就是所有权</li><li>所有程序在运行时都必须管理它们使用计算机内存的方式<ul><li>有些语言有垃圾收集机制，在程序运行时, 它们不断地寻找不再使用的内存</li><li>在其他语言中，程序员必须显示地分配和释放内存</li><li>Rust采用了第三种方式</li><li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则．</li><li>当程序运行时，所有权特性不会减慢程序运行速度</li></ul></li></ul><h3 id="5-2-Stack-vs-Heap"><a href="#5-2-Stack-vs-Heap" class="headerlink" title="5.2. Stack vs Heap"></a>5.2. Stack vs Heap</h3><ul><li>Stack按值的接收顺序来存储，按相反的顺序将它们移除(后进先出, LIFO)<ul><li>添加数据叫做压入栈</li><li>移除数据叫做弹出栈</li></ul></li><li>所有存储在stack上的数据必须拥有已知的固定的大小<ul><li>编译时大小未知的数据或运行时大小可能变化的数据必须存放在heap上</li></ul></li><li>Heap内存组织性差一些<ul><li>当你把数据放入heap时, 你会请求一定数量的空间</li><li>操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址</li><li>这个过程叫做在heap上进行分配, 有时仅仅称为分配</li><li>把值压到stack上不叫分配</li><li>因为指针是已知固定大小的, 可以把指针存放在stack上．<br>但如果想要实际数据，你必须使用指针来定位</li><li>把数据压倒stack上要比在heap上分配快得多：<ul><li>因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在stack的顶端</li></ul></li><li>在heap上分配空间需要做更多的工作：<ul><li>操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配</li><li>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中的数据</li><li>对于现代的处理器来说, 由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快．</li></ul></li><li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些(stack上)</li><li>如果数据之间的距离比较远，那么处理速度就会慢一些(heap上)<ul><li>在heap上分配大量的空间也是需要时间的</li></ul></li><li>当你的代码调用函数时，值被传入到函数(也包括指向heap的指针)．函数本地的变量被压到stack上，当函数结束后，这些值会从stack上弹出．</li></ul></li></ul><h3 id="5-3-所有权存在的原因"><a href="#5-3-所有权存在的原因" class="headerlink" title="5.3. 所有权存在的原因"></a>5.3. 所有权存在的原因</h3><ul><li>所有权解决的问题<ul><li>跟踪代码的哪些部分正在使用heap的哪些数据</li><li>最小化heap上的重复数据量</li><li>清理heap上未使用的数据以避免空间不足</li></ul></li><li>一旦你懂得了所有权，那么就不需要经常去想stack或heap了</li><li>但是知道管理heap数据是所有权存在的原因，这有助于解释它为什么会这样工作．</li></ul><h3 id="5-4-所有权，内存与分配"><a href="#5-4-所有权，内存与分配" class="headerlink" title="5.4. 所有权，内存与分配"></a>5.4. 所有权，内存与分配</h3><h4 id="5-4-1-所有权规则"><a href="#5-4-1-所有权规则" class="headerlink" title="5.4.1. 所有权规则"></a>5.4.1. 所有权规则</h4><ul><li>每个值都有一个变量，这个变量是该值的所有者</li><li>每个值同时只能有一个所有者</li><li>当所有者超出作用域的时候，该值将被删除</li></ul><h3 id="5-5-变量作用域"><a href="#5-5-变量作用域" class="headerlink" title="5.5. 变量作用域"></a>5.5. 变量作用域</h3><ul><li><p>scope就是程序中一个项目的有效范围</p></li><li><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">//s 不可以</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>; <span class="comment">// s可用</span></span><br><span class="line">           <span class="comment">//可以对s进行相关操作</span></span><br><span class="line">&#125; <span class="comment">//s 作用域到此结束，s不再可用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-5-1-string-类型"><a href="#5-5-1-string-类型" class="headerlink" title="5.5.1. string 类型"></a>5.5.1. string 类型</h4><ul><li>String 比那些基础标量数据类型更复杂</li><li>字符串字面值: 程序里手写的那些字符串值．它们是不可变的</li><li>Rust还有第二种字符串类型: String<ul><li>在heap上分配，能够存储在编译时未知数量的文本</li></ul></li></ul><h5 id="5-5-1-1-创建String类型的值"><a href="#5-5-1-1-创建String类型的值" class="headerlink" title="5.5.1.1. 创建String类型的值"></a>5.5.1.1. 创建String类型的值</h5><ul><li>可以使用from函数从字符串字面值创建出String类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// :: 表示from是String类型下的函数</span></span><br></pre></td></tr></table></figure><p>这类字符串是可以被修改的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">  pringln!(s);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>字符串字面值，在编译时就知道它的内容, 其文本内容直接被编码到最终的可执行文件里</li><li>速度快，高效，得益于其不可变性</li><li>String类型，为了支持可变性, 需要在heap上分配内存来保存编译时未知的文本内容：</li><li>操作系统必须在运行时来请求内存<ul><li>这步通过调用String::from来实现</li></ul></li><li>当用完String之后，需要使用某种方式将内存返回给操作系统<ul><li>这步，在拥有GC的语言中，GC会跟踪并清理不再使用的内存</li><li>没有GC的语言中，就需要我们去识别内存何时不再使用，并调用代码将它释放<ul><li>如果忘了，那就浪费内存．</li><li>如果提前做了，变量就会非法</li><li>如果做了两次，也是bug. 必须一次分配对应一次释放</li></ul></li><li>rust采用了不同的方式: 对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的归还给操作系统．</li><li>drop函数</li></ul></li></ul><h4 id="5-5-2-变量和数据交互的方式-移动-move"><a href="#5-5-2-变量和数据交互的方式-移动-move" class="headerlink" title="5.5.2. 变量和数据交互的方式: 移动 move"></a>5.5.2. 变量和数据交互的方式: 移动 move</h4><ul><li><p>多个变量可以与同一个数据使用一种独特的方式来交互</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>整数是已知且固定大小的简单的值, 这两个５被压到了stack中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>一个String 由３部分组成：</p><ul><li>一个指向存放字符串内容的内存的指针</li><li>一个长度</li><li>一个容量</li></ul></li><li><p>上面这些东西被放在stack上.</p></li><li><p>存放字符串内容的部分在heap上</p></li><li><p>长度len, 就是存放字符串内容所需的字节数</p></li><li><p>当把s1 赋值给S2, String 的数据被复制了一份</p></li><li><p>在stack上复制了一份指针, 长度, 容量</p></li><li><p>并没有复制指针所指向的heap上的数据</p></li><li><p>当变量离开作用域时，Rust会自动调用Drop函数，并将变量使用的heap内存释放．<br>当S1, S2离开作用域时, 它们都会尝试释放相同的内存</p></li><li><p>二次释放(double free) bug<br>为了保证内存安全：</p></li><li><p>Rust没有尝试复制被分配的内存</p></li><li><p>Rust让s1失效</p><ul><li><p>当s1离开作用域的时候, rust不需要释放任何东西</p></li><li><p>试试看当s2创建后，再使用s1是什么效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">//这里会有编译错误，这里s1已经失效了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>浅拷贝(shallow copy)</li><li>深拷贝(deep copy)</li><li>你也许会将复制, 指针, 长度, 容量视为浅拷贝, 但是由于Rust让s1失效了, 所以我们用一个新的术语：移动move</li><li>隐藏了一个设计原则，Rust不会自动创建数据的深拷贝</li><li>就运行时性能而言, 任何自动赋值的操作都是廉价的</li></ul></li></ul></li></ul><h4 id="5-5-3-变量和数据交互的方式-克隆-Clone"><a href="#5-5-3-变量和数据交互的方式-克隆-Clone" class="headerlink" title="5.5.3. 变量和数据交互的方式: 克隆(Clone)"></a>5.5.3. 变量和数据交互的方式: 克隆(Clone)</h4><ul><li>如果真想对heap上面的String 数据进行深拷贝, 而不仅仅是stack上的数据，可以使用clone方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-4-Stack上的数据：-复制"><a href="#5-5-4-Stack上的数据：-复制" class="headerlink" title="5.5.4. Stack上的数据： 复制"></a>5.5.4. Stack上的数据： 复制</h4><ul><li>Copy trait, 可以容易想到整数这样完全放在stack上面的类型<br>如果一个类型实现了Copy这个trait,那么旧的变量在赋值后仍然可用</li><li>如果一个类型或者该类型的一部分实现了Drop trait,那么Rust不允许让它再去实现Copy trait了</li></ul><h4 id="5-5-5-一些拥有copy-trait的类型"><a href="#5-5-5-一些拥有copy-trait的类型" class="headerlink" title="5.5.5. 一些拥有copy trait的类型"></a>5.5.5. 一些拥有copy trait的类型</h4><ul><li>任何简单标量的组合类型都可以是copy的</li><li>任何需要分配内存或某种资源的都不是copy的</li><li>一些拥有Copy trait的类型<ul><li>所有的整数类型, 例如u32<ul><li>bool</li><li>char</li><li>所有的浮点类型, 例如f64</li><li>tuple 元组, 如果其所有的字段都是Copy的<br>(i32, i32) 是<br>(i32, String) 不是</li></ul></li></ul></li></ul><h4 id="5-5-6-所有权与函数"><a href="#5-5-6-所有权与函数" class="headerlink" title="5.5.6. 所有权与函数"></a>5.5.6. 所有权与函数</h4><ul><li>在语义上, 将值传递给函数和把值赋给变量是类似的：</li><li>将值传递给函数将发生移动或复制</li></ul><h4 id="5-5-7-返回值与作用域"><a href="#5-5-7-返回值与作用域" class="headerlink" title="5.5.7. 返回值与作用域"></a>5.5.7. 返回值与作用域</h4><ul><li>函数在返回值的过程中同样也会发生所有权的转移</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">take_and_gives_back</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  some_string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">  a_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个变量的所有权总是遵循同样的模式：<ul><li>把一个值赋给其它变量时就会发生移动</li><li>当一个包含heap数据的变量离开作用域时，它的值就会被Drop函数清理，除非数据的所有权移动到另一个变量上了</li></ul></li></ul><h4 id="5-5-8-如何让函数使用某个值，但是不获得其所有权？"><a href="#5-5-8-如何让函数使用某个值，但是不获得其所有权？" class="headerlink" title="5.5.8. 如何让函数使用某个值，但是不获得其所有权？"></a>5.5.8. 如何让函数使用某个值，但是不获得其所有权？</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line">  (s，length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-引用和借用"><a href="#5-6-引用和借用" class="headerlink" title="5.6. 引用和借用"></a>5.6. 引用和借用</h3><ul><li>以下例子中参数的类型是&amp;String而不是String</li><li>&amp;符号就表示引用：允许你引用某些值而不取得所有权</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把引用作为函数参数这个行为叫做借用<br>是否可以修改借用的东西？不行<br>和变量一样，引用默认也是不可变的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span>（s2, len）= <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;the length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>) <span class="comment">//编译期就会报错, can&#x27;t borrow *s as mutable, as it&#x27;s behind a &#x27;&amp;&#x27; reference</span></span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-1-可变引用"><a href="#5-6-1-可变引用" class="headerlink" title="5.6.1. 可变引用"></a>5.6.1. 可变引用</h4><p>可变引用有一个重要的限制： 在特定作用域内，对某一块数据, 只能有一个可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 这里会报编译错误 can&#x27;t borrow s as mutable more than once at a time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这样做的好处是可在编译时防止数据竞争</li></ul><p>以下三种行为下会发生数据竞争：</p><ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li><li>可以通过创建新的作用域, 来允许非同时的创建多个可变引用(例子)</li><li>不可以同时拥有一个可变引用和一个不变的引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Then length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>)</span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-6-2-悬空引用Dangling-References"><a href="#5-6-2-悬空引用Dangling-References" class="headerlink" title="5.6.2. 悬空引用Dangling References"></a>5.6.2. 悬空引用Dangling References</h4><ul><li><p>悬空指针(Dangling Pointer): 一个指针引用了内存中的某个地址, 而这块内存可能已经释放并分配给其它人使用了．</p></li><li><p>在Rust里, 编译器可保证引用永远都不是悬空引用：</p><ul><li>如果你引用了某些数据, 编译器将保证在引用离开作用域之前数据不会离开作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// 这里编译器会报错，因为s出了此作用域将会被释放，而返回值是一个指向已经被释放区域的指针，这会导致问题，而rust在编译期就杜绝了这种错误．</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-6-3-引用的规则"><a href="#5-6-3-引用的规则" class="headerlink" title="5.6.3. 引用的规则"></a>5.6.3. 引用的规则</h4><ul><li>在任何给定的时刻, 只能满足下列条件之一:<ul><li>一个可变的引用</li><li>任何数量不可变的引用</li></ul></li></ul><h3 id="5-7-切片"><a href="#5-7-切片" class="headerlink" title="5.7. 切片"></a>5.7. 切片</h3><p>Rust的另一种不持有所有权的数据类型: 切片(slice)</p><p>一道题, 编写一个函数</p><ul><li>它接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个单词</li><li>如果函数没有找到任何空格, 那么整个字符串就被返回</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">wordIndex</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;string) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><ul><li>字符串切片是指向字符串中一部分内容的引用</li><li>例子</li><li>形式：[开始索引..结束索引]<ul><li>开始索引就是切片起始位置的索引值</li><li>结束索引是终止位置的下一个索引值</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">hello</span>= &amp;s[<span class="number">0</span>..<span class="number">5</span>]  <span class="comment">// 或者&amp;s[..5]</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">world</span>= &amp;s[<span class="number">6</span>..<span class="number">11</span>] <span class="comment">// 或者&amp;s[6..]</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, hello, world)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>字符串切片的范围索引必须发生在有效的UTF-8 字符边界内。</li><li>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">wordIndex</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;string) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="将字符串切片作为参数传达"><a href="#将字符串切片作为参数传达" class="headerlink" title="将字符串切片作为参数传达"></a>将字符串切片作为参数传达</h4><ul><li>fn first_word(s: &amp;String) -&gt; &amp;str {</li><li>有经验的Rust开发者会采用&amp;str作为参数类型，因为这样就可以同时接收字符串和&amp;str类型的参数了</li><li>fn first_word(s: &amp;str) -&gt; &amp;str {<ul><li>使用字符串切片，直接调用该函数</li><li>使用String, 可以创建一个完整的String切片来调用该函数</li></ul></li><li>定义函数时使用字符串切片来代替字符串引用会使得我们的API更加通用，且不丧失任何功能。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">wordIndex</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, wordIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="其他类型的切片"><a href="#其他类型的切片" class="headerlink" title="其他类型的切片"></a>其他类型的切片</h4><ul><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>]  <span class="comment">//&amp;[i32]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-Struct"><a href="#5-Struct" class="headerlink" title="5. Struct"></a>5. Struct</h2><h3 id="定义并实例化struct"><a href="#定义并实例化struct" class="headerlink" title="定义并实例化struct"></a>定义并实例化struct</h3><h4 id="什么是struct"><a href="#什么是struct" class="headerlink" title="什么是struct"></a>什么是struct</h4><ul><li>struct结构体<ul><li>自定义的数据类型</li><li>为相关联的值命名， 打包&#x3D;&gt;有意义的组合</li></ul></li></ul><h3 id="定义struct"><a href="#定义struct" class="headerlink" title="定义struct"></a>定义struct</h3><ul><li>使用struct关键字， 并为整个struct命名</li><li>在花括号内， 为所有字段(Field)定义名称和类型</li></ul><p>例如：</p><p>struct User {<br>username: String,<br>email: String,<br>sign_in_count: u64,<br>active: bool,<br>}</p><h3 id="实例化struct"><a href="#实例化struct" class="headerlink" title="实例化struct"></a>实例化struct</h3><ul><li>想要使用struct, 需要创建struct的实例：<ul><li>为每个字段指定具体值</li><li>无需按声明的顺序进行指定</li></ul></li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;acb@126.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">556</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取struct里面的某个值"><a href="#获取struct里面的某个值" class="headerlink" title="获取struct里面的某个值"></a>获取struct里面的某个值</h3><ul><li>使用点标记法：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">  email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  active: <span class="literal">true</span>,</span><br><span class="line">  sign_in_count: <span class="number">556</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的。rust不允许我们声明struct中一部分字段可变，而另一部分字段不可变。</p><h3 id="struct作为函数的返回值"><a href="#struct作为函数的返回值" class="headerlink" title="struct作为函数的返回值"></a>struct作为函数的返回值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">  User &#123;</span><br><span class="line">    email: email,</span><br><span class="line">    username: username,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h3><ul><li>当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">  User&#123;</span><br><span class="line">     email,</span><br><span class="line">     username,</span><br><span class="line">     active: <span class="literal">true</span>,</span><br><span class="line">     sign_in_count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="struct-更新语法"><a href="#struct-更新语法" class="headerlink" title="struct 更新语法"></a>struct 更新语法</h3><ul><li>当你想基于某个struct实例来创建一个新实例的时候，可以使用struct的更新语法</li></ul><p>不使用更新语法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">  email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  active: user1.active,</span><br><span class="line">  sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用更新语法的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">  email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">  ..user1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-Rust-web框架"><a href="#6-Rust-web框架" class="headerlink" title="6. Rust web框架"></a>6. Rust web框架</h2><p>2022年可选择的三个Rust Web框架：actix-web、warp和axum。</p><ul><li><a target="_blank" rel="noopener" href="https://crates.io/crates/actix-web">actix-web</a>：4.0.0-rc.35,134,720Actix Web 是一个功能强大、实用且速度极快的 Rust Web 框架</li><li><a target="_blank" rel="noopener" href="https://crates.io/crates/warp">Warp</a>: 0.3.24,114,095以翘曲的速度服务于网络</li><li><a target="_blank" rel="noopener" href="https://crates.io/crates/axum">axum</a>: 专注于人体工程学和模块化的 Web 框架（由 tokio 团队提供）</li></ul><p>比较：</p><ul><li>axum有最干净的 API，它建立在hyper之上，它（当然）是 Rust 中经过测试最可靠的 HTTP 堆栈，并且因为它是由 tokio 团队开发的。但它的年轻可能会让一些人感到不舒服。</li><li>对于较大的项目，我认为这actix-web是无可争议的赢家。这就是为什么它是我选择Bloom的原因。</li><li>对于较小的项目（最多 50 条路由）warp，尽管它有原始的 API，但它非常好，因为它也是建立在其之上的hyper，因此受益于它的可靠性和性能。</li></ul><p>详细比较：</p><ul><li>JSON反序列化：所有框架都使用泛型来提供简单的 JSON 反序列化。话虽如此，我发现两者都axum可以actix-web更直接地与他们的助手一起使用来自动提取类型化的正文有效负载。</li><li>路由：axum是明显的赢家，紧随其后的是actix-web，然后是warp有利于组合的功能性 API，这与我们通常对 Web 框架的期望相去甚远。</li><li>中间件：warp， 毫无疑问…</li><li>状态：在构建 Web 服务时，您需要共享一些变量，例如数据库连接池或一些用于外部服务的客户端。所有框架的人机工程学都非常相似。</li></ul><h2 id="7-后记"><a href="#7-后记" class="headerlink" title="7. 后记"></a>7. 后记</h2><p>本文原文位于<a href="https://pengtech.net/rust/rust_study.html">鹏叔的技术博客 - Rust 编程语言入门教程</a>, 若需要获取最近更新, 请访问原文.</p><h3 id="7-1-web框架选择参考文档"><a href="#7-1-web框架选择参考文档" class="headerlink" title="7.1. web框架选择参考文档"></a>7.1. web框架选择参考文档</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/398232138">两张图展示当前 Rust Web 生态</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/cfy_banq/article/details/123107652">2022年选择哪个Rust Web框架</a></p></div><div class="card"><div class="card-content" style="padding-left:0;font-size:1.1rem"><h2 style="font-size:1.5rem;margin-bottom:.5rem">相关文章</h2><span><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/rust/install_rust_on_windows.html" title="在各种操作系统上安装和配置Rust" rel="bookmark">在各种操作系统上安装和配置Rust</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/rust/vscode_rust_ide.html" title="在VSCode配置Rust环境" rel="bookmark">在VSCode配置Rust环境</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/sass/sass_notes.html" title="sass学习笔记" rel="bookmark">sass学习笔记</a></h3></div></li></ul></span></div></div><div class="article-licensing box"><div class="licensing-title"><p>Rust 编程语言入门教程</p><p><a href="https://pengtech.net/rust/rust_study.html">https://pengtech.net/rust/rust_study.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>鹏叔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-08-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div></article></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/hexo/hexo_create_site.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用Hexo搭建自己的博客网站</span></a></div></nav></div><div class="card" id="comments"><div class="card-content"><span class="title is-5">评论</span><script src="https://utteranc.es/client.js" repo="guoapeng/guoapeng.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="鹏叔的技术博客"></figure><p class="title is-size-4 is-block" style="line-height:inherit">鹏叔的技术博客</p><p class="is-size-6 is-block">日拱一卒，功不唐捐!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System, Galaxy.</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">260</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">85</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/guoapeng" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/guoapeng"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Mail" href="mailto:guoapeng@gmail.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WmRzSTRLOENhYXVqeVBHRTVyT2wrR0hrdDhDL0JIWDBBNmovOUJXRE1oZExjV1haM0c3cGxHNlhBV3NvQkFOVC9INHF6aGZlUGpwTzcrTGFDRnZEL3NQck9IYzFiYkxiTVVTb2hnL1VaVmJKY09VTHVpbnVBYjJEVXQwNGZMN3R8cWhjVW1qVStTNlBWWGpMM1UydWpHOUNMcGUzbS9PcHgrZEI1UWpqckZYRT0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">友情链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://philoenglish.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">菲利英语</span></span><span class="level-right"><span class="level-item tag">philoenglish.com</span></span></a></li><li><a class="level is-mobile" href="https://ngrevive.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Angular复兴</span></span><span class="level-right"><span class="level-item tag">ngrevive.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/IM/"><span class="level-start"><span class="level-item">IM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">45</span></span></a><ul><li><a class="level is-mobile" href="/categories/OS/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile" href="/categories/OS/windows/"><span class="level-start"><span class="level-item">windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/database/mariadb/"><span class="level-start"><span class="level-item">mariadb</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/database/postgresql/"><span class="level-start"><span class="level-item">postgresql</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/devops/"><span class="level-start"><span class="level-item">devops</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul><li><a class="level is-mobile" href="/categories/devops/ansible/"><span class="level-start"><span class="level-item">ansible</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/devops/build-tools/"><span class="level-start"><span class="level-item">build tools</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/devops/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/devops/gitlab/"><span class="level-start"><span class="level-item">gitlab</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/devops/k8s/"><span class="level-start"><span class="level-item">k8s</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/language/"><span class="level-start"><span class="level-item">language</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/language/golang/"><span class="level-start"><span class="level-item">golang</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/language/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/language/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/language/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/network/dns/"><span class="level-start"><span class="level-item">dns</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/network/frp/"><span class="level-start"><span class="level-item">frp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/network/v2ray/"><span class="level-start"><span class="level-item">v2ray</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/network/vpn/"><span class="level-start"><span class="level-item">vpn</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/others/"><span class="level-start"><span class="level-item">others</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/others/English/"><span class="level-start"><span class="level-item">English</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/others/marketing/"><span class="level-start"><span class="level-item">marketing</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/others/movies/"><span class="level-start"><span class="level-item">movies</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tools/"><span class="level-start"><span class="level-item">tools</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/tools/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/tools/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/tools/maven/"><span class="level-start"><span class="level-item">maven</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/tools/vscode/"><span class="level-start"><span class="level-item">vscode</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/web/"><span class="level-start"><span class="level-item">web</span></span><span class="level-end"><span class="level-item tag">134</span></span></a><ul><li><a class="level is-mobile" href="/categories/web/CMS/"><span class="level-start"><span class="level-item">CMS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/web/SEO/"><span class="level-start"><span class="level-item">SEO</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/web/angular/"><span class="level-start"><span class="level-item">angular</span></span><span class="level-end"><span class="level-item tag">61</span></span></a></li><li><a class="level is-mobile" href="/categories/web/angularjs/"><span class="level-start"><span class="level-item">angularjs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/web/browser/"><span class="level-start"><span class="level-item">browser</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/web/build-tools/"><span class="level-start"><span class="level-item">build tools</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/web/components/"><span class="level-start"><span class="level-item">components</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/web/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/web/design/"><span class="level-start"><span class="level-item">design</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/web/html/"><span class="level-start"><span class="level-item">html</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/web/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/web/material-design/"><span class="level-start"><span class="level-item">material design</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/web/nodejs/"><span class="level-start"><span class="level-item">nodejs</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/web/others/"><span class="level-start"><span class="level-item">others</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/web/tauri/"><span class="level-start"><span class="level-item">tauri</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Angular/"><span class="tag">Angular</span><span class="tag">68</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CMS/"><span class="tag">CMS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fedora/"><span class="tag">Fedora</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GORM/"><span class="tag">GORM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gemini-AI/"><span class="tag">Gemini AI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IDEA/"><span class="tag">IDEA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Macos/"><span class="tag">Macos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Material/"><span class="tag">Material</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Matrix/"><span class="tag">Matrix</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NAS/"><span class="tag">NAS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NPM/"><span class="tag">NPM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nodejs/"><span class="tag">Nodejs</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OS/"><span class="tag">OS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redhat/"><span class="tag">Redhat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SEO/"><span class="tag">SEO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Seo/"><span class="tag">Seo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angularjs/"><span class="tag">angularjs</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/backend/"><span class="tag">backend</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bootstrap/"><span class="tag">bootstrap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/browser/"><span class="tag">browser</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chartjs/"><span class="tag">chartjs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/database/"><span class="tag">database</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design/"><span class="tag">design</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/element-web/"><span class="tag">element-web</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fedora/"><span class="tag">fedora</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/firefox/"><span class="tag">firefox</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gitlab/"><span class="tag">gitlab</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gradle/"><span class="tag">gradle</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">63</span></a></div><div class="control"><a class="tags has-addons" href="/tags/k8s/"><span class="tag">k8s</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/life/"><span class="tag">life</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">44</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/marketing/"><span class="tag">marketing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/material-design/"><span class="tag">material design</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagination/"><span class="tag">pagination</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pgadmin/"><span class="tag">pgadmin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pnpm/"><span class="tag">pnpm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/product/"><span class="tag">product</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sass/"><span class="tag">sass</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sentry/"><span class="tag">sentry</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/source-control/"><span class="tag">source_control</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring boot</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/strapi/"><span class="tag">strapi</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tailwindcss/"><span class="tag">tailwindcss</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tauri/"><span class="tag">tauri</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tmux/"><span class="tag">tmux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/v2ray/"><span class="tag">v2ray</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/v2rayA/"><span class="tag">v2rayA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/v2rayN/"><span class="tag">v2rayN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/v2rayNG/"><span class="tag">v2rayNG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/virualbox/"><span class="tag">virualbox</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmware/"><span class="tag">vmware</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">60</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack/"><span class="tag">webpack</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/websocket/"><span class="tag">websocket</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/windows/"><span class="tag">windows</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wordpress/"><span class="tag">wordpress</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-第一章-Rust简介"><span class="level-left"><span class="level-item">1. 第一章: Rust简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-为什么要用Rust"><span class="level-left"><span class="level-item">1.1. 为什么要用Rust</span></span></a></li><li><a class="level is-mobile" href="#1-2-与其他语言比较"><span class="level-left"><span class="level-item">1.2. 与其他语言比较</span></span></a></li><li><a class="level is-mobile" href="#1-3-Rust特别擅长的领域"><span class="level-left"><span class="level-item">1.3. Rust特别擅长的领域</span></span></a></li><li><a class="level is-mobile" href="#1-4-Rust与Firefox"><span class="level-left"><span class="level-item">1.4. Rust与Firefox</span></span></a></li><li><a class="level is-mobile" href="#1-5-Rust的用户和案例"><span class="level-left"><span class="level-item">1.5. Rust的用户和案例</span></span></a></li><li><a class="level is-mobile" href="#1-6-Rust的优点"><span class="level-left"><span class="level-item">1.6. Rust的优点</span></span></a></li><li><a class="level is-mobile" href="#1-7-Rust的缺点"><span class="level-left"><span class="level-item">1.7. Rust的缺点</span></span></a></li><li><a class="level is-mobile" href="#1-8-注意"><span class="level-left"><span class="level-item">1.8. 注意</span></span></a></li><li><a class="level is-mobile" href="#1-9-参考教材"><span class="level-left"><span class="level-item">1.9. 参考教材</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-安装Rust"><span class="level-left"><span class="level-item">2. 安装Rust</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-安装rust"><span class="level-left"><span class="level-item">2.1. 安装rust</span></span></a></li><li><a class="level is-mobile" href="#2-2-配置Rust"><span class="level-left"><span class="level-item">2.2. 配置Rust</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-替换镜像"><span class="level-left"><span class="level-item">2.2.1. 替换镜像</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-更新Rust"><span class="level-left"><span class="level-item">2.3. 更新Rust</span></span></a></li><li><a class="level is-mobile" href="#2-4-卸载Rust"><span class="level-left"><span class="level-item">2.4. 卸载Rust</span></span></a></li><li><a class="level is-mobile" href="#2-5-验证安装是否成功"><span class="level-left"><span class="level-item">2.5. 验证安装是否成功</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-第二章：第一个rust程序"><span class="level-left"><span class="level-item">3. 第二章：第一个rust程序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-hello-world"><span class="level-left"><span class="level-item">3.1. hello world</span></span></a></li><li><a class="level is-mobile" href="#3-2-Rust-程序解析"><span class="level-left"><span class="level-item">3.2. Rust 程序解析</span></span></a></li><li><a class="level is-mobile" href="#3-3-编译和运行是单独的两步"><span class="level-left"><span class="level-item">3.3. 编译和运行是单独的两步</span></span></a></li><li><a class="level is-mobile" href="#3-4-hello-cargo"><span class="level-left"><span class="level-item">3.4. hello cargo</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-4-1-cargo-介绍"><span class="level-left"><span class="level-item">3.4.1. cargo 介绍</span></span></a></li><li><a class="level is-mobile" href="#3-4-2-使用Cargo创建项目"><span class="level-left"><span class="level-item">3.4.2. 使用Cargo创建项目</span></span></a></li><li><a class="level is-mobile" href="#3-4-3-构建Cargo项目"><span class="level-left"><span class="level-item">3.4.3. 构建Cargo项目</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-5-猜数字游戏"><span class="level-left"><span class="level-item">3.5. 猜数字游戏</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-5-1-声明变量"><span class="level-left"><span class="level-item">3.5.1. 声明变量</span></span></a></li><li><a class="level is-mobile" href="#3-5-2-引入依赖包"><span class="level-left"><span class="level-item">3.5.2. 引入依赖包</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#4-第三章-通用的编程概念"><span class="level-left"><span class="level-item">4. 第三章 通用的编程概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-变量和可变性"><span class="level-left"><span class="level-item">4.1. 变量和可变性</span></span></a></li><li><a class="level is-mobile" href="#4-2-变量和常量"><span class="level-left"><span class="level-item">4.2. 变量和常量</span></span></a></li><li><a class="level is-mobile" href="#4-3-shadowing-隐藏"><span class="level-left"><span class="level-item">4.3. shadowing (隐藏)</span></span></a></li><li><a class="level is-mobile" href="#4-4-Rust数据类型"><span class="level-left"><span class="level-item">4.4. Rust数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-4-1-标量类型"><span class="level-left"><span class="level-item">4.4.1. 标量类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-5-浮点类型"><span class="level-left"><span class="level-item">4.5. 浮点类型</span></span></a></li><li><a class="level is-mobile" href="#4-6-数值操作"><span class="level-left"><span class="level-item">4.6. 数值操作</span></span></a></li><li><a class="level is-mobile" href="#4-7-布尔类型"><span class="level-left"><span class="level-item">4.7. 布尔类型</span></span></a></li><li><a class="level is-mobile" href="#4-8-字符类型"><span class="level-left"><span class="level-item">4.8. 字符类型</span></span></a></li><li><a class="level is-mobile" href="#4-9-复合类型"><span class="level-left"><span class="level-item">4.9. 复合类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-9-1-Tuple"><span class="level-left"><span class="level-item">4.9.1. Tuple</span></span></a></li><li><a class="level is-mobile" href="#4-9-2-访问tuple的元素"><span class="level-left"><span class="level-item">4.9.2. 访问tuple的元素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-10-数组"><span class="level-left"><span class="level-item">4.10. 数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-10-1-声明一个数组"><span class="level-left"><span class="level-item">4.10.1. 声明一个数组</span></span></a></li><li><a class="level is-mobile" href="#4-10-2-数组的用处"><span class="level-left"><span class="level-item">4.10.2. 数组的用处</span></span></a></li><li><a class="level is-mobile" href="#4-10-3-数组的类型"><span class="level-left"><span class="level-item">4.10.3. 数组的类型</span></span></a></li><li><a class="level is-mobile" href="#4-10-4-访问数组的元素"><span class="level-left"><span class="level-item">4.10.4. 访问数组的元素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-11-3-4-函数"><span class="level-left"><span class="level-item">4.11. 3.4 函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-11-1-函数的参数"><span class="level-left"><span class="level-item">4.11.1. 函数的参数</span></span></a></li><li><a class="level is-mobile" href="#4-11-2-函数中的语句-statement-和表达式-expression"><span class="level-left"><span class="level-item">4.11.2. 函数中的语句(statement)和表达式(expression)</span></span></a></li><li><a class="level is-mobile" href="#4-11-3-函数的返回值"><span class="level-left"><span class="level-item">4.11.3. 函数的返回值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-12-注释"><span class="level-left"><span class="level-item">4.12. 注释</span></span></a></li><li><a class="level is-mobile" href="#4-13-控制流"><span class="level-left"><span class="level-item">4.13. 控制流</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-13-1-if-表达式"><span class="level-left"><span class="level-item">4.13.1. ｉf 表达式</span></span></a></li><li><a class="level is-mobile" href="#4-13-2-在let语句中使用if"><span class="level-left"><span class="level-item">4.13.2. 在let语句中使用if</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-14-Rust的循环"><span class="level-left"><span class="level-item">4.14. Rust的循环</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-14-1-loop-循环"><span class="level-left"><span class="level-item">4.14.1. loop 循环</span></span></a></li><li><a class="level is-mobile" href="#4-14-2-while条件循环"><span class="level-left"><span class="level-item">4.14.2. while条件循环</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-15-for-循环遍历集合"><span class="level-left"><span class="level-item">4.15. for 循环遍历集合</span></span></a></li><li><a class="level is-mobile" href="#4-16-Range"><span class="level-left"><span class="level-item">4.16. Range</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-第四章：-所有权"><span class="level-left"><span class="level-item">5. 第四章： 所有权</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-4-1-什么是所有权"><span class="level-left"><span class="level-item">5.1. 4.1 什么是所有权</span></span></a></li><li><a class="level is-mobile" href="#5-2-Stack-vs-Heap"><span class="level-left"><span class="level-item">5.2. Stack vs Heap</span></span></a></li><li><a class="level is-mobile" href="#5-3-所有权存在的原因"><span class="level-left"><span class="level-item">5.3. 所有权存在的原因</span></span></a></li><li><a class="level is-mobile" href="#5-4-所有权，内存与分配"><span class="level-left"><span class="level-item">5.4. 所有权，内存与分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-4-1-所有权规则"><span class="level-left"><span class="level-item">5.4.1. 所有权规则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-5-变量作用域"><span class="level-left"><span class="level-item">5.5. 变量作用域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-5-1-string-类型"><span class="level-left"><span class="level-item">5.5.1. string 类型</span></span></a></li><li><a class="level is-mobile" href="#5-5-2-变量和数据交互的方式-移动-move"><span class="level-left"><span class="level-item">5.5.2. 变量和数据交互的方式: 移动 move</span></span></a></li><li><a class="level is-mobile" href="#5-5-3-变量和数据交互的方式-克隆-Clone"><span class="level-left"><span class="level-item">5.5.3. 变量和数据交互的方式: 克隆(Clone)</span></span></a></li><li><a class="level is-mobile" href="#5-5-4-Stack上的数据：-复制"><span class="level-left"><span class="level-item">5.5.4. Stack上的数据： 复制</span></span></a></li><li><a class="level is-mobile" href="#5-5-5-一些拥有copy-trait的类型"><span class="level-left"><span class="level-item">5.5.5. 一些拥有copy trait的类型</span></span></a></li><li><a class="level is-mobile" href="#5-5-6-所有权与函数"><span class="level-left"><span class="level-item">5.5.6. 所有权与函数</span></span></a></li><li><a class="level is-mobile" href="#5-5-7-返回值与作用域"><span class="level-left"><span class="level-item">5.5.7. 返回值与作用域</span></span></a></li><li><a class="level is-mobile" href="#5-5-8-如何让函数使用某个值，但是不获得其所有权？"><span class="level-left"><span class="level-item">5.5.8. 如何让函数使用某个值，但是不获得其所有权？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-6-引用和借用"><span class="level-left"><span class="level-item">5.6. 引用和借用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-6-1-可变引用"><span class="level-left"><span class="level-item">5.6.1. 可变引用</span></span></a></li><li><a class="level is-mobile" href="#5-6-2-悬空引用Dangling-References"><span class="level-left"><span class="level-item">5.6.2. 悬空引用Dangling References</span></span></a></li><li><a class="level is-mobile" href="#5-6-3-引用的规则"><span class="level-left"><span class="level-item">5.6.3. 引用的规则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-7-切片"><span class="level-left"><span class="level-item">5.7. 切片</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符串切片"><span class="level-left"><span class="level-item">字符串切片</span></span></a></li><li><a class="level is-mobile" href="#将字符串切片作为参数传达"><span class="level-left"><span class="level-item">将字符串切片作为参数传达</span></span></a></li><li><a class="level is-mobile" href="#其他类型的切片"><span class="level-left"><span class="level-item">其他类型的切片</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#5-Struct"><span class="level-left"><span class="level-item">5. Struct</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义并实例化struct"><span class="level-left"><span class="level-item">定义并实例化struct</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是struct"><span class="level-left"><span class="level-item">什么是struct</span></span></a></li></ul></li><li><a class="level is-mobile" href="#定义struct"><span class="level-left"><span class="level-item">定义struct</span></span></a></li><li><a class="level is-mobile" href="#实例化struct"><span class="level-left"><span class="level-item">实例化struct</span></span></a></li><li><a class="level is-mobile" href="#获取struct里面的某个值"><span class="level-left"><span class="level-item">获取struct里面的某个值</span></span></a></li><li><a class="level is-mobile" href="#struct作为函数的返回值"><span class="level-left"><span class="level-item">struct作为函数的返回值</span></span></a></li><li><a class="level is-mobile" href="#字段初始化简写"><span class="level-left"><span class="level-item">字段初始化简写</span></span></a></li><li><a class="level is-mobile" href="#struct-更新语法"><span class="level-left"><span class="level-item">struct 更新语法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-Rust-web框架"><span class="level-left"><span class="level-item">6. Rust web框架</span></span></a></li><li><a class="level is-mobile" href="#7-后记"><span class="level-left"><span class="level-item">7. 后记</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-web框架选择参考文档"><span class="level-left"><span class="level-item">7.1. web框架选择参考文档</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-08-12T16:00:00.000Z">2024-08-13</time></p><p class="title"><a href="/golang/golang_google_translate_api.html">GoLang调用 google translate API 实现中英互译</a></p><p class="categories"><a href="/categories/language/">language</a> / <a href="/categories/language/golang/">golang</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-08-09T16:00:00.000Z">2024-08-10</time></p><p class="title"><a href="/matrix/build_element-web_on_local.html">本地编译并启动 element-web</a></p><p class="categories"><a href="/categories/IM/">IM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-07-29T16:00:00.000Z">2024-07-30</time></p><p class="title"><a href="/network/install_v2rayA_on_Windows.html">Windows 上安装与配置 v2rayA</a></p><p class="categories"><a href="/categories/network/">network</a> / <a href="/categories/network/v2ray/">v2ray</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-07-28T16:00:00.000Z">2024-07-29</time></p><p class="title"><a href="/network/v2rayNG_install_and_config.html">Android上安装与配置v2rayNG</a></p><p class="categories"><a href="/categories/network/">network</a> / <a href="/categories/network/v2ray/">v2ray</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-07-25T16:00:00.000Z">2024-07-26</time></p><p class="title"><a href="/javascript/js_allow_selection.html">使用 JavaScript 开启被禁用的网页选择功能</a></p><p class="categories"><a href="/categories/web/">web</a> / <a href="/categories/web/javascript/">javascript</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">鹏叔的技术博客</a><p class="is-size-7"><span>&copy; 2024 鹏叔</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Follow on GitHub" href="https://github.com/guoapeng"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>