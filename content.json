{"posts":[{"title":"Gemini AI介绍","text":"Gemini AI 是 Google DeepMind 正在开发的大型语言模型 (LLM)。它仍在开发中，但预计会比目前最先进的 ChatGPT 4 更强大。Gemini AI 是建立在 DeepMind 于 2016 年开发的早期人工智能系统 AlphaGo 中使用的技术和技巧之上的。这意味着 Gemini AI 预计将拥有强大的计划和解决问题的能力。 Gemini AI 是一个强大的工具，有潜力用于各种应用。Gemini AI 的一些潜在用例包括： 聊天机器人：Gemini AI 可用于创建更现实、更有吸引力的聊天机器人。虚拟助理：Gemini AI 可用于创建虚拟助理，帮助用户完成安排预约、预订和查找信息等任务。内容生成：Gemini AI 可用于生成创意内容，例如文章、博客文章和脚本。数据分析：Gemini AI 可用于分析大型数据集并识别模式和趋势。医疗诊断：Gemini AI 可以帮助医生诊断疾病。金融交易：Gemini AI 可用于做出交易决策。 1. Gemini AI 的工作原理Gemini AI 是一种神经网络，经过海量文本和代码数据集的训练。该数据集包括书籍、文章、代码库和其他形式的文本。神经网络能够学习该数据集中单词和短语之间的模式和关系。这使得 Gemini AI 能够生成文本、翻译语言、编写不同类型的创意内容，并以翔实的方式回答您的问题。 2. 如何使用Gemini AIGemini AI 目前尚未向公众开放，但预计将在未来发布。当它发布时，它可能会通过基于云的 API 提供。这意味着开发人员将能够在自己的应用程序中使用 Gemini AI。 要使用 Gemini AI，开发者需要首先创建一个帐户并获取 API 密钥。一旦获得 API 密钥，开发者就可以使用它来调用 Gemini AI API。该 API 将允许程序与 Gemini AI 交互并使用其功能。 以下是有关如何安装或开始使用 Gemini AI 的一些步骤： 访问 Gemini AI 网站并创建一个帐户。 创建帐户后，您将获得一个 API 密钥。 安装适合您的编程语言的 Gemini AI 客户端库。 在您的代码中，导入 Gemini AI 客户端库并使用您的 API 密钥对其进行初始化。 调用 Gemini AI API 来生成文本、翻译语言、编写不同类型的创意内容或以翔实的方式回答您的问题。 有关如何安装和使用 Gemini AI 的更详细说明，请参阅 Gemini AI 文档。 3. Gemini AI 的未来Gemini AI 仍在开发中，但它有潜力彻底改变我们与计算机交互的方式。未来，Gemini AI 可用于创建更真实、更具吸引力的聊天机器人、虚拟助手和其他形式的人工智能软件。Gemini AI 还可以通过分析大型数据集并识别模式和趋势来提高我们对周围世界的理解。 4. 总结Gemini AI 是一个强大的工具，有潜力用于各种应用。它仍在开发中，但它有可能彻底改变我们与计算机交互的方式。未来，Gemini AI 可用于创建更真实、更具吸引力的聊天机器人、虚拟助手和其他形式的人工智能软件。Gemini AI 还可以通过分析大型数据集并识别模式和趋势来提高我们对周围世界的理解。","link":"/ai/gemini_ai_introduction.html"},{"title":"Windows上安装与配置Android SDK","text":"1. Android SDK 介绍Android SDK 是软件开发工具包，可让您创建 Android 应用程序。它包括一系列工具、API、文档和示例代码，可帮助您构建、测试和部署 Android 应用程序。 Android SDK 包括以下组件： Android 操作系统的 API 和库 Android SDK 包含 Android 操作系统的 API 和库。这些 API 和库提供访问 Android 系统功能的途径，例如用户界面、网络、存储和位置。 编译器和工具链 Android SDK 包含用于编译 Android 应用程序的编译器和工具链。这些工具可将您的代码转换为可以在 Android 设备上运行的二进制文件。 模拟器和设备驱动程序 Android SDK 包含用于在模拟器或真实设备上运行 Android 应用程序的模拟器和设备驱动程序。模拟器可让您在没有实际设备的情况下测试您的应用程序。 测试框架 Android SDK 包含用于测试 Android 应用程序的测试框架。这些测试可帮助您确保您的应用程序正确运行。 2. 安装 Android SDK要使用 Android SDK，您需要下载并安装它。您可以从 Android 开发网站下载 Android SDK。 2.1. Android studioWindows 的系统要求如下： 要求 最小值 推荐 OS 64 位 Microsoft Windows 8 最新的 64 位版 Windows RAM 8 GB RAM 至少有 16 GB 的 RAM CPU x86_64 CPU 架构；第 2 代 Intel Core 或更高版本，或者支持 Windows Hypervisor Framework 的 AMD CPU。 最新的 Intel Core 处理器 磁盘可用空间 8 GB（IDE 和 Android SDK 及模拟器） 具有 16 GB 或更多容量的固态硬盘 屏幕分辨率 1280 x 800 1920 x 1080 2.1.1. 下载 Android studio安装前先下载 Android Studio 魔法可以从这里获得 Windows 上安装与配置 v2rayA。 2024 最新 v2rayA 安装与配置教程 for Windows、Macos、Linux、Android。 如果有魔法，可以到 Android 官方网站，下载页面Android Studio进行下载， 没有魔法，可以从androiddevtools下载相应的 Android Studio 安装文件。 下载最新版本即可。推荐下载.exe 文件 例如 android-studio-2022.3.1.21-windows.exe。 2.1.2. 安装 Android studio 如果您下载了 .exe 文件（推荐），请双击以启动该文件。 如果您下载了 .zip 文件： 解压缩 .zip。 将 android-studio 文件夹复制到 Program Files 文件夹中。 打开 android-studio &gt; bin 文件夹。 启动 studio64.exe（对于 64 位计算机）或 studio.exe（对于 32 位计算机）。 按照 Android Studio 中设置向导的指示操作，并安装推荐的 SDK 软件包。 2.2. 下载 Android SDK如果有魔法，可以到 Android 官方网站下载安装包google Android SDK 工具 没有魔法，可以从androiddevtools下载 如需从 Android Studio 打开 SDK 管理器，请依次点击 Tools &gt; SDK Manager 或点击工具栏中的 SDK Manager 图标 。如果您没有使用 Android Studio，则可使用 sdkmanager 命令行工具来下载工具。 想要获取魔法可以访问鹏叔的博客空间首页 已安装的软件包如有更新，其旁边的复选框中会显示短划线图标 。 如需更新某个软件包或安装新软件包，请选中相应复选框。如需卸载某个软件包，请点击以清除对应的复选框。待下载的更新在左侧列中以下载图标 表示。待执行的移除项以红色 X 标记 表示。 如需更新所选的软件包，请点击 Apply 或 OK，然后同意所有许可协议。 3. 配置 Android SDK我们建议您在使用命令行时为 ANDROID_HOME 设置环境变量。 Android SDK 环境变量 环境变量 说明 ANDROID_HOME 设置 SDK 安装目录的路径。设置后，该值通常不会更改，并且可以由同一台计算机上的多个用户共享。ANDROID_SDK_ROOT 也指向 SDK 安装目录，但已废弃。如果您继续使用它，Android Studio 和 Android Gradle 插件将检查旧变量和新变量是否一致。 ANDROID_USER_HOME 为 Android SDK 中包含的工具设置用户偏好设置目录的路径。 默认为 $HOME/.android/。某些较旧的工具（例如 Android Studio 4.3 及更低版本）不会读取 ANDROID_USER_HOME。如需替换这些旧工具的用户偏好设置位置，请将 ANDROID_SDK_HOME 设置为要在其下创建 .android 目录的父目录。 REPO_OS_OVERRIDE 当您使用 sdkmanager 为与当前计算机不同的操作系统下载软件包时，请将此变量设置为 windows、macosx 或 linux。 此外，请设置命令搜索路径以加入 %ANDROID_HOME%/tools、%ANDROID_HOME%/emulator，%ANDROID_HOME%/tools/bin 和 %ANDROID_HOME%/platform-tools，查找最常见的工具。 具体步骤因所用操作系统而异，但如需查看一般指导信息，请参阅如何设置环境变量。 4. 安装 NDK(可选)4.1. 如何安装 NDK自动安装 打开 Android Studio。 在菜单栏中，依次单击 Tools &gt; SDK Manager。 在 SDK Tools 标签页中，选中 NDK (Side by side) 复选框。 单击 OK。 Android Studio 将下载并安装 NDK 到默认位置 手动安装 从 Android NDK 下载页面: https://developer.android.com/ndk/downloads 下载 NDK 软件包。 解压缩 NDK 软件包。 将 NDK 解压缩后的目录添加到系统环境变量。 4.2. 如何配置 NDKWindows 添加环境变量, NDK_HOME=%ANDROID_HOME%/ndk/26.1.10909125 将 NDK_HOME 添加到命令搜索路径 PATH 5. 参考文档使用 SDK 管理器更新工具 SDK 工具 Android 开发环境环境变量设置","link":"/android/android_sdk_install.html"},{"title":"Fedora 上安装与配置 Android studio","text":"本文讲述如何在Fedora上安装Android studio. 1. 准备环境1.1. 安装Java123sudo dnf install -y java-17-openjdk-devel 验证Java是否安装成功 123456$ java -versionopenjdk version &quot;17.0.5&quot; 2022-10-18OpenJDK Runtime Environment (Red_Hat-17.0.5.0.8-2.fc35) (build 17.0.5+8)OpenJDK 64-Bit Server VM (Red_Hat-17.0.5.0.8-2.fc35) (build 17.0.5+8, mixed mode, sharing) 2. 下载Android studio从Android官方网站下载Android studio 123wget -O /tmp/android-studio-2022.3.1.21-linux.tar.gz https://redirector.gvt1.com/edgedl/android/studio/ide-zips/2022.3.1.21/android-studio-2022.3.1.21-linux.tar.gz 3. 安装Android studio解压缩安装文件到/usr/local/android-studio 123sudo tar -xvzf /tmp/android-studio-2022.3.1.21-linux.tar.gz -C /usr/local/ 4. 安装ndk(可选)仅当需要NDK时才需要安装 以当前用户身份打开Android studio 1/usr/local/android-studio/bin/studio.sh 选择SDK Manager =&gt; Android SDK =&gt; SDK Tools 勾选NDK(side by side)，apply, 等待安装完成。 5. 配置Android studio123456export ANDROID_HOME=~/Android/Sdk# NDK可选配置，仅当安装了NDK后需要配置export NDK_HOME=$ANDROID_HOME/ndk/26.1.10909125export PATH=$PATH:/usr/local/android-studio/bin:$ANDROID_HOME/tools:$ANDROID_HOME/tools/bin:$ANDROID_HOME/platform-tools 6. troubleshooting问题1： Unable to detect graphics environment 原因分析： 在这种情况下，你也无法运行Android studio或任何其他图形应用程序——这表明这不是一个与Android相关的问题。例如，如果您以root身份而不是以当前登录到图形会话的用户身份ssh到localhost就会遇到这样的问题。 解決办法有两种： 如果可以通过图形用户界面登陆linux, 则以该用户的身份登陆到图形用户界面，再以该用户执行脚本例如/usr/local/android-studio/bin/studio.sh，此时即可打开图形应用。 如果该用户无权限登陆图形用户界面，或者该用户是CI/CD之类的自动化脚步的用户。本身就工作在文本界面的。 那么需要当前登录到图形会话的用户开放权限 1234#使所有用户都能访问Xserverxhost +# 或者 仅仅允许授权的ip访问Xserverxhost + 192.168.80.80 在文本界面执行命令的用户需要在执行脚本前设置display 1234# 先设置dispalyexport DISPLAY=':0'# 再执行脚步/usr/local/android-studio/bin/studio.sh 解决办法： 重新打开一个的终端 参考Pycharm Startup Error: Unable to detect graphics environment 7. 参考文档Installing Android Studio on Fedora 39/38/37/36/35 如何设置环境变量","link":"/android/fedora_install_android_studio.html"},{"title":"一步一步升级到Angular 16","text":"Angular 16 于 2023 年 5 月 3 日发布. 今天，我计划向您介绍如何升级到 Angular 16。 1. 升级前准备升级前到 Angular 16 之前, 请确保当前 Angular 已经升级到 Angular 15, 并完成了 Angular 15 所有的迁移任务. 如果没有完成 Angular 13 到 14, 以及 14 到 15 的升级任务, 可以参考我的博客从 Angular 13 升级到 Angular 15 升级前需要了解 Angular 16 与 Typescript, nodejs 等的版本兼容信息. 可以参考Actively supported versions Actively supported versions ANGULAR NODE.JS TYPESCRIPT RXJS 16.1.x || 16.2.x ^16.14.0 || ^18.10.0 &gt;=4.9.3 &lt;5.2.0 ^6.5.3 || ^7.4.0 16.0.x ^16.14.0 || ^18.10.0 &gt;=4.9.3 &lt;5.1.0 ^6.5.3 || ^7.4.0 15.1.x || 15.2.x ^14.20.0 || ^16.13.0 || ^18.10.0 &gt;=4.8.2 &lt;5.0.0 ^6.5.3 || ^7.4.0 15.0.x ^14.20.0 || ^16.13.0 || ^18.10.0 ~4.8.2 ^6.5.3 || ^7.4.0 14.2.x || 14.3.x ^14.15.0 || ^16.10.0 &gt;=4.6.2 &lt;4.9.0 ^6.5.3 || ^7.4.0 14.0.x || 14.1.x ^14.15.0 || ^16.10.0 &gt;=4.6.2 &lt;4.8.0 ^6.5.3 || ^7.4.0 1.1. 升级 Nodejs可以参考我的博客安装并配置 nodejs, 进行安装升级和配置. 对于 Angular 16 来说, 建议升级到 v16.14.2 或者 v18.10.0 1.2. 升级 Angular 以及 Typescript升级 Nodejs 后, 需要重新安装配置 angular cli, 此步骤可用参考我的博客Angular CLI 安装和使用, Angular 建议安装最新版本 16.2.10 总结下来也就以下几步: 12345678# 安装 typescriptnpm i -g typescript@4.9.3# 安装 Angular CLInpm install -g @angular/cli@16.2.10# 或者cnpm install -g @angular/cli@16.2.10 2. 升级 Angular 到 v16前面得准备工作完成后, 接下来就是重要得步骤, 升级 Angular 应用程序了. 升级前建议您先到https://update.angular.io/?l=3&amp;v=15.0-16.0 阅读一下有哪些更新, 以及官方建议的步骤, 做到心中有数. 另外建议备份程序, 切换到新的分支, 如果不成功, 可以立即回撤. 2.1. 升级 angular cli, core 和 cdk首先运行以下命令, 通常情况下不会成功, 但是会列出一些依赖关系问题, 确定一下依赖关系不存在严重问题, 可以使用–force 选项继续更新. 123ng update @angular/core@16.2.10 @angular/cdk@16.2.10 @angular/cli@16.2.10 然后先升级 angular cli, core 123ng update @angular/core@16.2.10 @angular/cli@16.2.10 --force 再升级 CDK 123ng update @angular/cdk@16.2.10 如果项目中使用了 angular material, 需要将其升级到对应的版本 123ng update @angular/material@16.2.10 3. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 4. 参考文档Upgrade to Angular 16 step by step","link":"/angular/Upgrade_to_Angular_16.html"},{"title":"一步一步升级到Angular 17","text":"Angular 16 于 2023 年 11 月 8 日发布. 今天，我计划向您介绍如何升级到 Angular 17。 1. 升级前准备升级前到 Angular 17 之前, 请确保当前 Angular 已经升级到 Angular 16, 并完成了 Angular 16 所有的迁移任务. 如果没有完成 Angular 13 到 14, 14 到 15, 以及 15 到 16 的升级任务, 可以参考我的博客从 Angular 13 升级到 Angular 15 | 鹏叔的技术博客，一步一步升级到 Angular 16 升级前需要了解 Angular 17 与 Typescript, nodejs 等的版本兼容信息. 可以参考Actively supported versions Actively supported versions ANGULAR NODE.JS TYPESCRIPT RXJS 17.1.0 ^18.13.0 || ^20.9.0 &gt;=5.2.0 &lt;5.4.0 ^6.5.3 || ^7.4.0 17.0.x ^18.13.0 || ^20.9.0 &gt;=5.2.0 &lt;5.3.0 ^6.5.3 || ^7.4.0 16.1.x || 16.2.x ^16.14.0 || ^18.10.0 &gt;=4.9.3 &lt;5.2.0 ^6.5.3 || ^7.4.0 16.0.x ^16.14.0 || ^18.10.0 &gt;=4.9.3 &lt;5.1.0 ^6.5.3 || ^7.4.0 15.1.x || 15.2.x ^14.20.0 || ^16.13.0 || ^18.10.0 &gt;=4.8.2 &lt;5.0.0 ^6.5.3 || ^7.4.0 15.0.x ^14.20.0 || ^16.13.0 || ^18.10.0 ~4.8.2 ^6.5.3 || ^7.4.0 1.1. 升级 Nodejs可以参考我的博客安装并配置 nodejs, 进行安装升级和配置. 对于 Angular 17 来说, 建议升级到 v18.13.0 或者 v20.9.0 1.2. 升级 Angular 以及 Typescript升级 Nodejs 后, 需要重新安装配置 angular cli, 此步骤可用参考我的博客Angular CLI 安装和使用, Angular 建议安装最新版本 16.2.10 总结下来也就以下几步: 12345678# 安装 typescriptnpm i -g typescript@5.3.2# 安装 Angular CLInpm install -g @angular/cli@17.3.2# 或者cnpm install -g @angular/cli@17.3.2 2. 升级 Angular 到 v17前面得准备工作完成后, 接下来就是重要得步骤, 升级 Angular 应用程序了. 升级前建议您先到https://update.angular.io/?l=3&amp;v=16.0-17.0 阅读一下有哪些更新, 以及官方建议的步骤, 做到心中有数. 另外建议备份程序, 切换到新的分支, 如果不成功, 可以立即回撤. 2.1. 升级 angular cli, core 和 cdk首先运行以下命令, 通常情况下不会成功, 但是会列出一些依赖关系问题, 确定一下依赖关系不存在严重问题, 可以使用–force 选项继续更新. 123ng update @angular/core@17 @angular/cli@17 2.2. 升級依賴包升級完 Angular 內核以及 cli 以后，再升级第三方依赖包，例如： 12345&quot;ngx-markdown&quot;: &quot;^16.0.0&quot;, ==&gt; &quot;ngx-markdown&quot;: &quot;^17.1.1&quot;,&quot;ngx-owl-carousel-o&quot;: &quot;^16.0.0&quot;, ==&gt; &quot;ngx-owl-carousel-o&quot;: &quot;^17.0.0&quot;,&quot;ngx-quill&quot;: &quot;^23.0.0&quot;, ==&gt; &quot;ngx-quill&quot;: &quot;^25.1.2&quot;, 3. 修改 angular.json 配置3.1. 修改 builderng build 从单纯编译 client-side application 变成既要编译 client-side 又要编译 server-side application 1234567 &quot;architect&quot;: { &quot;build&quot;: {- &quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;,+ &quot;builder&quot;: &quot;@angular-devkit/build-angular:application&quot;, 3.2. 修改 polyfills 配置polyfills 由之前的字符串型变成了数组型 12345678- &quot;polyfills&quot;: &quot;src/polyfills.ts&quot;,+ &quot;browser&quot;: &quot;src/main.ts&quot;,+ &quot;polyfills&quot;: [+ &quot;src/polyfills.ts&quot;,+ &quot;zone.js&quot;+ ], 3.3. 修改 PWA 配置如果项目 enable 了 pwa, 则需要修改 pwa 配置，pwa 由以前的两个属性缩减为了一个属性。 123- &quot;serviceWorker&quot;: true,- &quot;ngswConfigPath&quot;: &quot;ngsw-config.json&quot;+ &quot;serviceWorker&quot;: &quot;ngsw-config.json&quot; 3.4. 替换 browser target123456789101112&quot;configurations&quot;: { &quot;production&quot;: {- &quot;browserTarget&quot;: &quot;angular-demo:build:production&quot;+ &quot;buildTarget&quot;: &quot;angular-demo:build:production&quot; }, &quot;development&quot;: {- &quot;browserTarget&quot;: &quot;angular-demo:build:development&quot;- },+ &quot;buildTarget&quot;: &quot;angular-demo:build:development&quot;+ } 3.5. 升级 Angular universal在版本 17 nguniversal 已被移到 Angular CLI repo 中。代码已经被重构和重命名（现在主要在@angular/ssr 下），但核心功能和架构没有改变。 现在 Angular CLI 直接支持服务器端渲染和构建时预渲染等通用功能，不需要与 Universal 单独集成。 如果项目中使用了 Angular universal, 还需要一些手工操作来升级 Angular universal。 3.5.1. 修改 package.json从 angular v17 开始，@nguniversal 项目已经被整合到 Angular 主项目，所以需要替换相关依赖包，以及修改 ssr 相关配置。 删除@nguniversal/express-engine，引入@angular/ssr 12- &quot;@nguniversal/express-engine&quot;: &quot;16.2.0&quot;,+ &quot;@angular/ssr&quot;: &quot;^17.3.2&quot;, 3.5.2. 修改 angular.json 配置1234567&quot;server&quot;: &quot;src/main.server.ts&quot;,&quot;prerender&quot;: true,&quot;ssr&quot;: { &quot;entry&quot;: &quot;server.ts&quot;} 3.5.3. 修改 tsconfig.app.json123456789 &quot;files&quot;: [ &quot;src/main.ts&quot;,+ &quot;src/main.server.ts&quot;,+ &quot;server.ts&quot;, &quot;src/polyfills.ts&quot; ], 4. trouble shooting4.1. issue 112Dynamic require is not supportedError: Cannot find module './landing-page.component-UB6FKJPP.mjs' 参考： Dynamic require is not supported 解决办法： 删除.browserslist 文件 4.2. issue 3123ReferenceError: localStorage is not defined 解决办法参考： Angular 服务器端渲染应用的一个错误消息 localStorage is not defined 使用 Angular 的依赖注入（Dependency Injection, DI）Angular 提供了一种机制，允许你在应用程序中使用浏览器的 API，而不需要直接访问全局对象。你可以使用 Angular 的 DI 系统来注入 localStorage。 123456789101112import { Component, Inject, NgModule } from &quot;@angular/core&quot;;import { LOCAL_STORAGE } from &quot;@ng-web-apis/common&quot;;@Component({ // ...})export class SomeComponent { constructor(@Inject(LOCAL_STORAGE) private localStorage: Storage) { // 现在你可以安全地使用localStorage const item = this.localStorage.getItem(&quot;key&quot;); }} 服务器端渲染时使用 UNIVERSAL_LOCAL_STORAGE在服务器端渲染时，你需要提供一个 localStorage 的实现。你可以使用@ng-web-apis/universal 包中的 UNIVERSAL_LOCAL_STORAGE 来实现这一点。 1234567891011import { NgModule } from &quot;@angular/core&quot;;import { ServerModule } from &quot;@angular/platform-server&quot;;import { AppComponent } from &quot;./app.component&quot;;import { UNIVERSAL_LOCAL_STORAGE } from &quot;@ng-web-apis/universal&quot;;@NgModule({ imports: [ServerModule /* ...其他模块... */], providers: [UNIVERSAL_LOCAL_STORAGE], bootstrap: [AppComponent],})export class AppServerModule {} 条件渲染和自定义指令如果你的应用中有某些功能只在客户端运行，你可以使用条件渲染来避免在服务器端渲染这些功能。例如，你可以使用*ngIf 指令或者创建自定义指令来实现这一点。 12345678910111213141516171819202122232425import { Component, Inject, PLATFORM_ID } from '@angular/core';import { isPlatformServer } from '@angular/common';@Component({ selector: 'ram-root', template: '&lt;some-comp *ngIf=&quot;isServer&quot;&gt;&lt;/some-comp&gt;', styleUrls: ['./app.component.less']})export class AppComponent { isServer = isPlatformServer(this.platformId); constructor(@Inject(PLATFORM_ID) private platformId: Object) {}}4. 环境检测和默认值在某些情况下，你可能需要在代码中检测当前环境是否为服务器端，如果是，则提供一个默认值或者空对象，避免访问localStorage。let storage = {};if (typeof localStorage !== 'undefined') { storage = localStorage;} else { // 为服务器环境提供默认实现或者空对象}// 现在你可以安全地使用storage对象const item = storage.getItem('key'); 使用第三方库还有一些第三方库可以帮助你处理服务器端渲染时的 localStorage 问题，例如@ngx-webstorage/core 或者 ngx-store. 通过以上方法，你可以有效地解决 Angular 17 中 localStorage is not defined 的问题，确保你的应用在服务器端渲染时也能正常工作。记得在实际部署和开发过程中，根据你的应用需求和架构选择合适的解决方案。 4.3. issue 31NG02801: Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application. 原因参考： https://stackoverflow.com/questions/77512654/angular-detected-that-httpclient-is-not-configured-to-use-fetch-apis-angul 解决方案： 修改 app.config.ts,添加 provideHttpClient(withFetch()), 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 参考文档Upgrade to Angular 16 step by step","link":"/angular/Upgrade_to_Angular_17.html"},{"title":"Angular实现登录保护","text":"1. 前言一个网站，通常都会包含公开页面和受保护页面两种，如果是 OA 或者企业应用网站，甚至可能全部都是保护页面，访问者需要在进行身份认证后，才能正常的浏览相关页面。 在本实验中, 我们会创建一个登录页面, 一个受保护的页面, 和一个面向公众公开的信息页面. 当用户访问受保护页面时, 需要先登录再访问, 而公众公开页面不需要登录即可访问. 2. 创建一个 angular 应用创建一个名为 test 的新 angular 项目 1ng new test 执行完以上命令, angular cli 将为我们创建基本的项目骨架.对于项目的结构的详解, 可以参考鹏叔的博客空间关于创建 Angular 项目 3. 创建页面创建三个页面, 一个命名为 public, 一个为 private, 一个为 login, public 页面无需登录即可访问, 而 private 页面需要先登录然后才能访问,当用户在未登录的情况下访问 private, 则被导航到 login 页面被要求登录. 创建 public page, anuglar 的每一个页面都对于于一个 component, 所以创建页面也就是创建 component 123456$ ng g component components/publicCREATE src/app/components/public/public.component.html (21 bytes)CREATE src/app/components/public/public.component.spec.ts (626 bytes)CREATE src/app/components/public/public.component.ts (275 bytes)CREATE src/app/components/public/public.component.css (0 bytes)UPDATE src/app/app.module.ts (407 bytes) 创建 private page 12345678$ ng g component components/privateCREATE src/app/components/private/private.component.html (22 bytes)CREATE src/app/components/private/private.component.spec.ts (633 bytes)CREATE src/app/components/private/private.component.ts (279 bytes)CREATE src/app/components/private/private.component.css (0 bytes)UPDATE src/app/app.module.ts (504 bytes) 创建 login page 123456$ ng g component components/loginCREATE src/app/components/login/login.component.html (20 bytes)CREATE src/app/components/login/login.component.spec.ts (619 bytes)CREATE src/app/components/login/login.component.ts (271 bytes)CREATE src/app/components/login/login.component.css (0 bytes)UPDATE src/app/app.module.ts (835 bytes) 4. 添加路由4.1. 引入@angular/router 包1npm i --save @angular/router 4.2. 创建路由配置前面提到每一个页面都会对应一个 component, 当用户访问 angular SPA 应用时, 当路径匹配到路由中配置的路径时, 就会将该路径对应的 component 加载到根组件 AppComponent 的&lt;router-outlet&gt;&lt;/router-outlet&gt;节点.在 src/app 目录下创建一个名为 app.routes.ts 的文件, 在配置文件中添加两条路由配置如下. 12345678910111213141516171819import { Routes } from &quot;@angular/router&quot;;import { PublicComponent } from &quot;./components/public/public.component&quot;;import { PrivateComponent } from &quot;./components/private/private.component&quot;;import { LoginComponent } from &quot;./components/login/login.component&quot;;export const rootRouterConfig: Routes = [ { path: &quot;login&quot;, // http://localhost:4200/login component: LoginComponent, }, { path: &quot;public&quot;, // http://localhost:4200/public component: PublicComponent, }, { path: &quot;private&quot;, // http://localhost:4200/private component: PrivateComponent, },]; 4.3. 加载路由配置并在 app.module.ts 中引入该模块.根路由模块包含了路由所需的使用服务，它以路由配置为参数，调用 RouterModule.forRoot()app.module.ts 1234567891011121314151617181920// 在根模块中导入路由配置import { rootRouterConfig } from &quot;./app.routes&quot;; // 注意没有.ts// 需要调用RouterModule.forRoot()方法import { RouterModule } from &quot;@angular/router&quot;;// 创建路由模块// 根路由模块默认提供的路由策略为PathLocationStrategy（另外一个是HashLocationStrategy）。// PathLocationStrategy路由策略需要一个base路径，设置base路径有2种方式，最简单的是在index.html中设置&lt;base&gt;// 如果要创建HashLocationStrategy 可以使用如下方式创建, 即需要传递options {useHash: true}// const rootRouterModule: ModuleWithProviders = RouterModule.forRoot(rootRouterConfig, {useHash: true});const rootRouterModule: ModuleWithProviders = RouterModule.forRoot(rootRouterConfig);// 然后将路由模块导入AppModule@NgModule({ declarations: [], imports: [rootRouterModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} 修改根组件一般情况下，这个指令是放在根组件中。app.conponent.html 123&lt;section class=&quot;container&quot;&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;/section&gt; 5. 路由进阶 - 身份认证首先我们添加一个 AuthGuard, 此 Guard 的职责就是坚持用户是否登录, 如果未登录则将用户导航到登陆页面. 1$ng g guard guards/Auth 然后实现 canActivate 接口src\\app\\guards\\auth.guard.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344import { Injectable } from &quot;@angular/core&quot;;import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot, UrlTree,} from &quot;@angular/router&quot;;import { Observable } from &quot;rxjs&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class AuthGuard implements CanActivate { constructor(private router: Router) {} canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot ): | Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { console.log(&quot;AuthGuard#canActivate called&quot;); if (this.isLoggedIn()) { // l已登录，返回Ture console.log(&quot;AuthGuard: 用户已登陆。&quot;); return true; } // 未登陆，重定向URL到登录页面，包含返回URL参数，然后返回False this.router.navigate([&quot;/login&quot;], { queryParams: { returnUrl: state.url } }); return false; } private isLoggedIn(): boolean { //随机返回Ture /False let loggedIn: boolean = false; if (!loggedIn) { console.log(&quot;AuthGuard: 用户未登陆。&quot;); } return loggedIn; }} 这样一个简单的 AuthGuard 就实现了, 在这个身份验证 guard 中, 我们强制的将 loggedIn 状态设置为 false, 让用户处于未登录状态, 来模拟用户未登录状态先, 访问 private 页面被导航到登录页面. 有了 AuthGuard 后, 我们修改一下路由配置, 让其守护 private 页面, 保证只有登录用户才让访问 private 页面.修改 app.routes.ts 12345{ path: 'private', // http://localhost:4200/private component: PrivateComponent, canActivate: [AuthGuard]}, 同时修改一下 app.module.ts, 在 application 启动时加载 AuthGuard 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Angular 2.0 SPA 应用 - 身份认证 2Angular2 使用 Guard 和 Resolve 进行验证和权限控制","link":"/angular/angular2_auth.html"},{"title":"创建Angular项目","text":"1. 说明本项目使用的 angular, nodejs, npm, cnpm 版本如下 12345678910111213141516$ ng versionAngular CLI: 16.2.10Node: 18.13.0Package Manager: npm 8.19.3OS: linux x64Angular:...Package Version------------------------------------------------------@angular-devkit/architect 0.1602.10 (cli-only)@angular-devkit/core 16.2.10 (cli-only)@angular-devkit/schematics 16.2.10 (cli-only)@schematics/angular 16.2.10 (cli-only) 2. 打开命令行工具找到你要创建项目的目录3. 创建项目3.1. 创建项目命令1ng new &lt;工作空间名称&gt; 3.2. 创建项目示例12ng new &lt;workspace_name&gt;# e.g. ng new angulardemo 如果要跳过依赖安装, 可以添加--skip-install 12ng new --skip-install &lt;workspace_name&gt;# e.g. ng new --skip-install angular-demo 3.3. 输入参数执行以上命令是, 系统会询问两个问题 是否添加路由.如果创建项目的目的为了体验 angular 的指令, 模板, 语法, 编译过程等等, 不涉及页面跳转, 可以不需要添加路由.如果需要涉及到页面之间的跳转, 则需要添加路由功能. &gt; 如果创建项目过程中下载依赖包不成功, 可以停止, 然后手动输入`cnpm install`安装依赖包 &gt; 使用--skip-install选项. 由于npm install经常会出现卡住没有反应的现象, 在创建项目过程中可以跳过安装依赖, 等项目结构创建完成后手动安装依赖包 &gt; 此时可以添加选项 --skip-install 例如 `ng new angulardemo --skip-install` stylesheet 样式格式现代 web 开发, 已经不止 css 一种样式语法, stylesheet 技术也在不断的进步和升级. angular 集成的 stylesheet 包括传统的 css 样式, less, sass, scss, stylus. 这里可以选择自己擅长的技术. 选择样式意为着 angular cli 会帮我们添加相应依赖, 解析器, 配置. 在实际开发过程中, 我们也可以混合使用以上技术. 这些样式最终会被解析器, 编译成浏览器可以识别的 css 代码. &gt; 如果要在命令行中指定css预处理器, 可以选项`--style` 例如 `ng new angulardemo --style=scss` 来指定 3.4. 项目目录结构介绍执行完以上命令后系统会为我们创建很多文件. 下面对这些文件进行简单介绍.执行完以上命令后, 使用 tree 命令查看项目的目录结构树大致如下. 1tree 123456789101112131415161718192021├-angular-demo ├── angular.json ├── package.json ├── README.md ├── src │ ├── app │ │ ├── app.component.html │ │ ├── app.component.scss │ │ ├── app.component.spec.ts │ │ ├── app.component.ts │ │ ├── app.module.ts │ │ └── app-routing.module.ts │ ├── assets │ ├── favicon.ico │ ├── index.html │ ├── main.ts │ └── styles.scss ├── tsconfig.app.json ├── tsconfig.json └── tsconfig.spec.json 3.4.1. 一级目录介绍 目录 说明 node_modules 在 npm install安装依赖包时，第三方依赖包存放在 node_modules 下 src 应用源代码目录 .angular.json Angular 命令行工具的配置文件。后期可能会去修改它， 引一些其他的第三方的包 比如 jquery 等 package.json 这是一个标准的 npm 工具的配置文件，这个文件里面列出了该应用程序所使用的第三方依赖包。实际上我们在新建项目的时候，等了半天就是在下载第三方依赖包。下载完成后会放在 node_modules 这个目录中，后期我们可能会修改这个文件。 package-lock.json package-lock.json 是在 npm install时候生成一份文件，用以记录当前状态下实际安装的各个 npm package 的具体来源和版本号. README.md 项目说明文件 tsconfig.json 是 typescript 的配置文件，用于配置 typescript 编译的一些选项. tsconfig.app.json tsconfig.app.json 是 tsconfig.json 的扩展. TypeScript 编译器的配置,添加第三方依赖的时候会修改这个文件, 用于指定编译,打包,运行时的一些 ts 选项. tsconfig.spec.json tsconfig.spec.json 也是 tsconfig.json 的扩展, 用于指定运行测试时的一些 ts 选项. 3.4.2. 二级目录介绍src 目录： 目录 说明 app 目录 包含应用的组件和模块，我们要写的代码都在这个目录 assets 目录 资源目录，存储静态资源的 比如图片 favicon.ico favicon.ico 是一个图标文件，也被称为“网站图标”、“页面图标”。 index.html 整个应用的根 html，程序启动就是访问这个页面 main.ts 整个项目的入口点，Angular 通过这个文件来启动项目 styles.css 主要是放一些全局的样式 3.4.3. 三级目录介绍src/app 目录 app 目录是我们要编写的代码目录。我们写的代码都是放在这个目录。 一个 Angular 程序至少需要一个模块和一个组件。在我们新建项目的时候命令行已经默认生成出来了。 在 src/app 下可以建立更多子目录, 来存放相应的元素, 比如 component 存放到 src/app/components 下, service 存放到 src/app/services 下, pipe 存放到 src/app/pipes 目录下. 3.4.4. 项目是如何启动的上一节我们讲到了 angular 项目的目录结构, 在如此复杂的目录结构中, 我们第一想了解, 也是应该了解的是项目的入口文件是哪个? 如果是做 c, c++, java 约定俗成的是找 main 方法. 在 web1.0, 2.0 开发中是找 index.html. 以下是项目生成后的 index.html, 从该文件中我们能一眼看出项目的入口文件在哪里吗?有人说, 我一眼能看出是&lt;app-root&gt;&lt;/app-root&gt;, 如果你认为项目的入口是 app-root 这个 component 的话, 那就是踏入了一个陷阱, 或者被误导了, 或者是一种想当然. 无论是 angularjs 的class='app'也好, 还是 vue 的&lt;app /&gt;也好, react 的&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;, 这些主 component 或者根 component 的渲染都不是项目入口位置. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;AngularDemo&lt;/title&gt; &lt;base href=&quot;/&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;/body&gt;&lt;/html&gt; 如果对以上观点有疑问，可以打开 app-root 这个 component 看看.从根 component 我们能看出, 服务是从哪里加载的吗, 路由是哪里加载的吗, 项目依赖的模块有哪些吗? 答案是不能, 而根 component 也只是众多普通 component 中的一个. 12345678910import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;],})export class AppComponent { title = &quot;angular-demo&quot;;} 而项目真正的入口实际上是 src/main.ts, 所以在 angular 开发中. 我们依然要找 main, 而这个 main 不是 main 方法或函数, 而是一个 main.ts 文件. 1234567import { platformBrowserDynamic } from &quot;@angular/platform-browser-dynamic&quot;;import { AppModule } from &quot;./app/app.module&quot;;platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =&gt; console.error(err)); 这里的 main.ts, 也是一个默认的入口文件, 他是在 angular.json 的配置文件中指定的. 也就是说, 入口文件也是可以被修改的, 但是为了项目更好的可维护性，如非必要建议不要去修改入口文件的名字.本来入口文件就很难找到了, 还要将其修改为一个更难理解的名字, 对 new joiner 是很不友好的, 毕竟项目需要更多的 new joiner 来维护, 改成一个更不约定俗成的名字, 对于新手无异于是当头棒喝. 对于一个 angular 老手来说, 当我们打开一个 angular 项目后, 还是要看看 angular.json 的指定的主文件到底是不是 src/main.js 12345678910111213141516171819&quot;options&quot;: { &quot;outputPath&quot;: &quot;dist/angular-demo&quot;, &quot;index&quot;: &quot;src/index.html&quot;, &quot;main&quot;: &quot;src/main.ts&quot;, &quot;polyfills&quot;: [ &quot;zone.js&quot; ], &quot;tsConfig&quot;: &quot;tsconfig.app.json&quot;, &quot;inlineStyleLanguage&quot;: &quot;scss&quot;, &quot;assets&quot;: [ &quot;src/favicon.ico&quot;, &quot;src/assets&quot; ], &quot;styles&quot;: [ &quot;src/styles.scss&quot; ], &quot;scripts&quot;: [] }, 知道了 main.ts 是入口文件后, 我们很容易就会发现, 项目启动使用的是下面这一行代码.很容易猜测到 AppModule 里面应该会包含更多的信息, 怎么做到的? 靠得是一个开发者的嗅觉? :), 这是事后诸葛亮的的说法.当然是靠探索精神, 当你拿到这样一段代码后, 当然要开始探索, 首先 ctrl+click 进 platformBrowserDynamic 发现是 angular 的 api, 不是一下下就能懂的.然后在 ctrl+click 进 AppModule, 一下就看到了 component, services. 当然回过头来我们也要刨析一下 platformBrowserDynamic 和 bootstrapModule, 但是这里我们先刨析 app.module.ts 这个文件. 123platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =&gt; console.error(err)); 声明的第一部分 platformBrowserDynamic()创建了一个平台。Angular 文档将该平台描述为： 网页上 Angular 的入口点。每个页面都只有一个平台，并且该页面上运行的每个 Angular 应用程序所共有的服务（例如反射）都绑定在其范围内。 Angular 还有一个running application instance的概念，您通常可以使用令牌注入该实例 ApplicationRef。一个平台上可能有许多应用程序。每个应用程序都是从基于 Module 定义使用 bootstrapModule 创建的。正如示例中 main.ts 所做的一样, 首先创建一个平台，然后创建应用程序实例。 创建应用程序时，Angular 会检查模块（ 例如： AppModule）的 bootstrap 属性用于引导应用程序的： 1234567@NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} bootstrap 属性通常引用您想要用来引导应用程序的组件。然后 Angular 在 DOM 中找到引导组件的选择器元素并初始化该组件。 打开 app.module.ts, 可以看到, 项目的 bootstrap(引导程序)是 AppComponent.从这里我们可以看出, 项目需要首先加载 AppComponent, BrowserModule, 然后启动 AppComponent, 由于 main.ts 会被编译挂载到 index.html 的&lt;script&gt;&lt;/script&gt;区域.所以 angular 会在 index.html 中根据 AppComponent 的选择器selector: 'app-root' 找到&lt;app-root&gt;&lt;/app-root&gt;所处的位置渲染根 component. 至此我们基本了解 angular 的启动过程了. bootstrap 的数据类型是 array, 所以很明显, bootstrap 属性可以指定多个 component, 回到 index.html, 说明 angular 是支持多根组件的, 也即 index.html 中可以指定多个根组件&lt;app-root&gt;&lt;/app-root&gt; 打开编译后的 index.html 文件, 我们可以看到更加清晰的 angular SPA 程序的启动加载过程.首先向服务器请求 index.html, 然后加载 runtime.js, polyfills.js, 异步加载 styles.js, vendor.js, main.js,最后渲染 app-root 组件. 如果路径是子目录, 例如http://localhost:4200/login 则涉及到 angular 路由的知识, 将在我的另一篇文章 angular 路由中讲到, 关注鹏叔的博客空间,查找更多 angular 相关文章. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;AngularDemo&lt;/title&gt; &lt;base href=&quot;/&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;script src=&quot;runtime.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;polyfills.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;styles.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;vendor.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.4.5. 重点文件介绍3.4.5.1. angular.json 文件详解angular.json 也叫 Angular 工作空间配置，在 Angular 6 以前该配置的文件名为 angular-cli.json 是 angular cli 的配置文件，Angular 6 以后进行了重命名，但是主要职责还是作为 Angular cli 的配置文件。 在了解 angular.json 配置文件之前我们需要首先了解 Angular 中的三个概念： 工作空间(Workspace) 应用(Application) 类库(Library) 当我们使用ng new [name]实际创建的是一个工作空间(Workspace), angular.json 文件位于工作空间(Workspace)根目录。 一个工作空间(Workspace), 可以包含多个 Application 和 library, application 可以使用ng generate application命令创建， library 可以使用ng generate library命令创建。 当我们使用ng new [name]创建工作空间(Workspace)时，该命令也会创建一个默认的 application. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114{ &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;, // JSON Schema 是一个允许我们注解和验证JSON数据格式的工具。Angular CLI使用它来强化对于Angular Workspace schema的解释说明。 &quot;version&quot;: 1, // 配置文件的版本 &quot;newProjectRoot&quot;: &quot;projects&quot;, // 这个属性定义了由CLI创建的新的内部应用和库放置的位置。默认值为`projects` &quot;projects&quot;: { //包含工作区中每个库或应用程序的配置信息。 &quot;angular-demo&quot;: { // 项目名称 &quot;projectType&quot;: &quot;application&quot;, //项目类型 &quot;schematics&quot;: { // 作为Angular DevKit的一部分，用来转换、创建 或者 更新项目开发的工作流工具。 &quot;@schematics/angular:component&quot;: { &quot;style&quot;: &quot;scss&quot; // 创建component时，使用scss样式格式 } }, &quot;root&quot;: &quot;&quot;, // 该项目文件的根目录，相对于工作空间目录。初始应用程序为空，它位于工作区的根目录。 &quot;sourceRoot&quot;: &quot;src&quot;, // 该项目源文件的根目录。 &quot;prefix&quot;: &quot;app&quot;, // Angular 在创建的选择器前面添加的字符串。可以进行定制以识别应用程序或功能区域。 &quot;architect&quot;: { // 任何项目都可以自定义 自动化命令，如 打包、serve、test、lint等等。这些都是基于prebuilt builders ，叫做Architect Targets。 // 配置ng build命令选项的默认值。有关详细信息，请参阅[构建目标部分](https://angular.io/guide/workspace-config#build-target) &quot;build&quot;: { // 用于创建此目标的构建工具的 npm 包。应用程序的默认构建器 ( ng build myApp) 是@angular-devkit/build-angular:application， // 它使用esbuild包捆绑器。 // 每个目标对象都指定了该目标的 builder，它是 architect 所运行工具的 npm 包 &quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;, // 此部分包含默认构建目标选项，但是会被命令行选项覆盖。请参阅[默认构建目标部分](https://angular.io/guide/workspace-config#default-build-targets)。 &quot;options&quot;: { &quot;outputPath&quot;: &quot;dist/angular-demo&quot;, &quot;index&quot;: &quot;src/index.html&quot;, &quot;main&quot;: &quot;src/main.ts&quot;, // js 垫片 &quot;polyfills&quot;: [&quot;zone.js&quot;], &quot;tsConfig&quot;: &quot;tsconfig.app.json&quot;, &quot;inlineStyleLanguage&quot;: &quot;scss&quot;, // 包含一些用于添加到项目的全局上下文中的静态文件路径 // 每个 build 目标配置都可以包含一个 assets 数组，它列出了当你构建项目时要复制的文件或文件夹。 // 默认情况下，会复制 src/assets/ 文件夹和 src/favicon.ico &quot;assets&quot;: [&quot;src/favicon.ico&quot;, &quot;src/assets&quot;], // 包含一些要添加到项目全局上下文中的样式文件(即全局样式) &quot;styles&quot;: [&quot;src/styles.scss&quot;], // 包含一些 JavaScript 脚本文件，用于添加到项目的全局上下文中。 // 这些脚本的加载方式和在 index.html 的 &lt;script&gt; 标签中添加是完全一样的。 &quot;scripts&quot;: [] }, // 此部分定义不同目标环境的备用构建配置。它包含针对每个目标环境的配置，该部分为该预期环境设置默认选项 &quot;configurations&quot;: { &quot;production&quot;: { // 全部或部分应用的默认尺寸预算的类型和阈值。 // 当构建的输出达到或超过阈值大小时，你可以将构建器配置为报告警告或错误 &quot;budgets&quot;: [ { &quot;type&quot;: &quot;initial&quot;, &quot;maximumWarning&quot;: &quot;500kb&quot;, &quot;maximumError&quot;: &quot;1mb&quot; }, { &quot;type&quot;: &quot;anyComponentStyle&quot;, &quot;maximumWarning&quot;: &quot;2kb&quot;, &quot;maximumError&quot;: &quot;4kb&quot; } ], &quot;outputHashing&quot;: &quot;all&quot; }, &quot;development&quot;: { &quot;buildOptimizer&quot;: false, &quot;optimization&quot;: false, &quot;vendorChunk&quot;: true, &quot;extractLicenses&quot;: false, &quot;sourceMap&quot;: true, &quot;namedChunks&quot;: true } }, // 默认情况下，该ng build命令使用production配置，该配置应用了多项构建优化 // 包括：捆绑文件，尽量减少多余的空白，删除注释和死代码，重写代码以使用简短的、损坏的名称，也称为缩小 &quot;defaultConfiguration&quot;: &quot;production&quot; }, &quot;serve&quot;: { // 覆盖构建默认值并为ng serve命令提供额外的服务默认值。除了ng build命令可用的选项之外，它还添加了与serve应用程序相关的选项。 &quot;builder&quot;: &quot;@angular-devkit/build-angular:dev-server&quot;, &quot;configurations&quot;: { &quot;production&quot;: { &quot;browserTarget&quot;: &quot;angular-demo:build:production&quot; }, &quot;development&quot;: { &quot;browserTarget&quot;: &quot;angular-demo:build:development&quot; } }, &quot;defaultConfiguration&quot;: &quot;development&quot; }, &quot;extract-i18n&quot;: { // 为 ng xi18n 命令所用到的 ng-xi18n 工具选项配置了默认值 &quot;builder&quot;: &quot;@angular-devkit/build-angular:extract-i18n&quot;, &quot;options&quot;: { &quot;browserTarget&quot;: &quot;angular-demo:build&quot; } }, &quot;test&quot;: { // 覆盖测试时的构建选项默认值，并为 ng test 命令提供额外的默认值以供运行测试 &quot;builder&quot;: &quot;@angular-devkit/build-angular:karma&quot;, &quot;options&quot;: { &quot;polyfills&quot;: [&quot;zone.js&quot;, &quot;zone.js/testing&quot;], &quot;tsConfig&quot;: &quot;tsconfig.spec.json&quot;, &quot;inlineStyleLanguage&quot;: &quot;scss&quot;, &quot;assets&quot;: [&quot;src/favicon.ico&quot;, &quot;src/assets&quot;], &quot;styles&quot;: [&quot;src/styles.scss&quot;], &quot;scripts&quot;: [] } } } } }} 3.4.6. 刨析一个 component创建 component 可以使用 1ng g c component_path/component_name 这里的 g 表示 generate 生成的以上, c 表示 component, 最好使用 component_path 给 component 指定一个保存路径, 不至于使得项目过于扁平, 而使得 component 文件散落在项目根目录下. 命令执行完成后, 在 component_path/component_name 目录下会指定创建 html, style, 测试文件, typescript 等组件相关的文件. 3.5. 启动项目3.5.1. 启动项目可以使用如下命令1ng serve --open –open 指定该选项会在服务器启动后自动打开项目首页,也可以手动在浏览器端输入网站访问项目首页http://localhost:4200/ 4. 创建新组件(component)4.1. 使用命令行创建新组建1234ng g component path/component_name# 例如ng g component components/news 另外使用 ng g 可以创建以下 angular 元素: appshell application class component directive enum guard interface library module pipe service serviceworker universal 关于 Angular Universal 可以参考我的博文Angular universal 服务器端渲染与预渲染 5. angular 数据绑定这里我们创建一个 component, 并将其命名为 TestDataBindingComponent, 用于测试数据绑定. 1ng new component components/TestDataBinding 命令说明: ng 是 angular cli 的主命令 new 为新建 angular 元素的子命令 component 为 angular 元素的类型, 更多元素可以参考上一节的 angular 元素列表 components/TestDataBinding 其中 components 为元素的存放路径, TestDataBinding 为元素名称, 元素名称不必添加 component 后缀, angular 会自动在创建元素时添加 component 后缀作为完整的元素名称. 执行以上命令后, angular 会在 components 目录下创建一个名为 test-data-bingding 的子目录, 里面会存储与 conponent 相关的 typescript, 样式文件, html 文件, 以及测试文件. 同时该命令会修改 src/app/app.module.ts, 自动添加对该 component 的引用. 如果执行以上命令后, 发现拼写, 或者路径有误, 需要反悔时, 只需要删除 components/test-data-bingding 整个目录, 并修改 src/app/app.module.ts 将相关引用删除, 即可彻底清除该 component. 当然在熟悉 angular 的原理以后, 发现问题可以做局部的修改, 这里不做展开. 6. 相关阅读最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Angular 工作空间配置（angular.json） Angular workspace configuration angular.json 简单解释","link":"/angular/angular2_create_project.html"},{"title":"Angular guard介绍","text":"1. 前言我们在开发 web 应用时，在服务器端都会控制某种或某个用户是否有权限调用某个接口。在前端，我们除了根据用户的角色或其他特性来控制一些页面元素是否显示以外，也需要控制用户是否能够进入某些页面（例如通过直接输入 URL 的方式直接进入）。要控制是否显示，我们可以使用 *ngIf 、 [hidden] 等方式。而对于控制用户能否进入某个页面，Angular2 的路由框架也提供了非常方便的方式来实现这个功能。 Angular2 提供了 2 种组件， Guard 和 Resolve 。 Guard 顾名思义就是用来保护一个路径。可以用来判断用户只有在满足一定的条件的情况下才能打开这个路径对应的页面。 Resolve 用来在进入某个路径之前先获取数据。 2. GuardGuard 其实是一系列接口，只要你实现了它的方法，配置了这些 Guard ，Angular 路由框架就会根据这个方法返回的 true 或 false 来判断是否激活这个路由。它包括几种类型： 1、CanActivate这种类型的 Guard 用来控制是否允许进入当前的路径。2、CanActivateChild这种类型的 Guard 用来控制是否允许进入当前路径的所有子路径。3、CanDeactivate用来控制是否能离开当前页面进入别的路径4、CanLoad用于控制一个异步加载的子模块是否允许被加载。以 CanActivate 为例，这个接口的定义如下： 123exportinterface CanActivate { canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;} 这个接口定义了一个方法，当你实现这个接口，并把它配置到某一个路由上以后，当用户进入这个路由的路径之前，就会调用它里面的 canActivate() 方法，它第一个参数，就是将要激活的路由，第二个参数是路由器当前的状态。它返回一个布尔型的结果，或者是布尔型的 Promise 或 Observable 。 3. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客","link":"/angular/angular2_guard.html"},{"title":"Angular CLI 安装和使用","text":"1. Angular 介绍关于 Angular 版本，Angular 官方已经统一命名 Angular 1.x 同一为 Angular JS；Angular 2.x 及以上统称 Angular； CLI 是 Command Line Interface 的简写，是一种命令行接口，实现自动化开发流程. 它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布。 官方文档：https://angular.io GitHub：https://github.com/angular/angular-cli Angular Material：https://material.angular.io/ 2. 安装前的准备工作安装前阅读一下 angular 版本兼容性说明文档, 确定需要安装的版本以及依赖包的版本. 避免使用过程中出现各种奇怪的错误. 本教程以 Angular 16 为例 2.1. 2.1 首先确认安装了 node.js 和 npm,cnpm1234// 显示当前node和npm版本$ node -v$ npm -v// node 版本高于v16.14.2 npm版本高于8.5.0 如果没有安装 node 可以参考我的博客文章 - nodejs 安装可以参考 安装并配置 nodejs | 鹏叔的技术博客 2.2. 2.2 确认是否安装了 git123# 显示当前git版本$ git --versiongit version 2.40.0 如果没有安装 git 可以参考我的博客文章 - Windows 上安装 git2.x 2.3. 2.3 全局安装 typescript（可选）版本可以根据实践情况调整, 但是要保证与 nodejs 以及将要安装的 Angular 版本兼容.兼容列表可以查询https://angular.io/guide/versions 123456# npm 全局安装typescript$ npm i -g typescript@4.9.3# 验证 typescript是否安装成功$ tsc -vVersion 4.9.3 3. 安装 Angular CLI3.1. 3.1 安装 Angular CLI1234# 安装指定版本的Angular clinpm install -g @angular/cli@16.2.10# 或者cnpm install -g @angular/cli@16.2.10 经过不算漫长的等待，你的 Angular CLI 就装好了。确认一下： 12345678910111213141516171819202122232425$ ng v// 出现下面画面说明安装成功，如果不成功你可能需要uninstall一下，再重新来过 _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | '_ \\ / _` | | | | |/ _` | '__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/Angular CLI: 16.2.10Node: 16.14.2Package Manager: npm 8.5.0OS: win32 x64Angular:...Package Version------------------------------------------------------@angular-devkit/architect 0.1602.10 (cli-only)@angular-devkit/core 16.2.10 (cli-only)@angular-devkit/schematics 16.2.10 (cli-only)@schematics/angular 16.2.10 (cli-only) 至此 Angular 完整完成, 如果安装过程中遇到问题需要卸载重装或者需要升级, 可以参考以下步骤. 4. 卸载 Angular CLI1npm uninstall -g @angular/cli 5. 升级 Angular CLI首先卸载 Angular CLI 1npm uninstall -g @angular/cli 然后安装新版本的 Angular CLI 123npm cache clean -fnpm install -g @angular/cli@latest //升级到最新版本npm install -g @angular/cli@版本号 //升级到指定版本 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Angular CLI 安装和使用","link":"/angular/angular2_installation.html"},{"title":"如何从Angularjs 升级到 Angular","text":"1. 前言原文: Upgrading from AngularJS to Angular Author: AngularJS 官方 译者：philoenglish.com 团队 关键字： Angularjs Angular Angular1.x Angular2.x migration 迁移， 升级 这里的 Angular 是指 Angular 2.x, 而 AngularJS 是指 AngularJS 1.x 版本。 Angular (通常是指 “Angular 2+” 或 “Angular v2 及更高版本”) 是一个基于 TypeScript 的 开源 Web 应用框架 由 Google 的 Angular 团队以及社区共同领导。Angular 是由 AngularJS 的同一个开发团队完全重写的。 2. Angular 和 AngularJS 之间的区别在设计上，Angular 是 AngularJS 的完全重写。 Angular 没有“作用域”或控制器的概念，其架构中的主要角色是一些层次化的组件。 Angular 具有不同的表达式语法，主要是用 “[ ]” 来表示属性绑定，以及用 “( )” 来表示事件绑定 模块化 – 许多核心功能都已模块化 Angular 建议使用 Microsoft 的 TypeScript 语言，该语言引入了如下特性： 静态类型，包括 泛型 装饰器，语法上类似于注解 TypeScript 是 ECMAScript 6 (ES6) 的超集，并且与 ECMAScript 5 (即: JavaScript) 向下兼容。 动态加载 异步模板编译 RxJS 提供了迭代式回调。RxJS 在状态可见性和调试方面有局限，不过可以使用诸如 ngReact 或 ngrx 之类的响应式第三方库来解决这些问题 支持 Angular Universal，它可以在服务器上运行 Angular 应用程序 3. 升级注意事项 虽然 AngularJS 版本很低了，但是用 AngularJS 应用程序很棒。在迁移到 Angular 之前，请务必根据自身的实际情况考虑是否升级的必要性， 以及所需花费的时间和精力是否合算。 本指南介绍了用于将 AngularJS 项目高效迁移到 Angular 平台的内置工具。 某些应用程序将比其他应用程序更容易升级，并且有很多方法可以使自己更容易升级。甚至可以在开始升级过程之前准备 AngularJS 应用程序并将其与 Angular 的技术栈， 架构模式对齐。这些准备步骤都是为了让代码更分离、更易于维护，并且更好地与现代开发工具保持一致。这意味着除了使升级更容易之外，您还将改进现有的 AngularJS 应用程序。 成功升级的关键之一是以增量方式进行升级，方法是在同一应用程序中并行运行两个框架，并将 AngularJS 组件逐个移植到 Angular。这样，即使是大型和复杂的应用程序，也可以在不中断其他业务的情况下进行升级，因为工作可以协作完成，并且可以在一段时间内分散。Angular 中的升级模块旨在使增量升级无缝衔接。 4. 升级前准备工作 当前有很多方法可以规划 AngularJS 应用程序的结构。当您开始将这些应用程序升级到 Angular 时，可以考虑将一些面向未来的工具或应用程序先应用到当前的 AngularJS 应用程序上，这样会使得迁移过程比不使用这些工具或程序或使用其它蹩脚的工具更轻松一些。 5. 遵循 AngularJS 风格指南AngularJS 风格指南收集了已被证明可以产生更简洁、更易于维护的 AngularJS 应用程序的模式和实践。它包含了大量有关如何编写和组织 AngularJS 代码的资料以及一些反例。 Angular 是 AngularJS 最佳部分的重新构想版本。从这个意义上说，它的目标与 AngularJS 的风格指南相同：保留 AngularJS 的良好部分，并避免坏部分。 遵循风格指南有助于使您的 AngularJS 应用程序与 Angular 更加紧密地保持一致, 其中有一些规则可以使得通过 Angular upgrade/static 模块模式进行增量升级变得更加轻松： 规则 1： 一个组件应该只有一个文件。 这样不仅使得导航和查找组件更容易易，而且还允许一次性将其迁移到不同语言不同框架。在此示例应用程序中，每个控制器、组件、服务和筛选器都位于其自己的源文件中。 规则 2： 文件夹按功能组织文件和模块化规则， 不同的功能模块应该存放在一起， 不同功能模块应该在不同的模块中， 功能应该是判断相识性的依据。 当应用程序以功能特性组织时，可以一次迁移一个功能。即使不是为了升级， 这也是对规划应用的结构有益的忠告。 对于不符合 AngularJS 风格指南的应用程序， 强烈建议是先遵循 AngularJS 风格指南， 再开始迁移。 6. 使用打包工具当您将应用程序打散为一个组件一个文件后， 您通常最终会得到一个包含大量较小的文件的项目结构。这是一种比少量大文件更整洁的组织方式，但是如果您必须将所有这些文件加载到浏览器时，则效果不佳，特别是当您还必须维护他们之间的依赖关系时时。这就是为什么需要开始使用打包工具的原因。 使用诸如 SystemJS， Webpack， gulp， grunt 或 Browserify 之类的打包工具，我们可以使用 TypeScript 或 ES2015 的内置模块系统。您可以使用导入和导出功能，这些功能显式指定哪些代码可以并且将在应用程序的不同部分之间共享。对于 ES5 应用程序，您可以使用 CommonJS 样式要求和 module.exports 功能。在这两种情况下，模块加载器将负责以正确的顺序加载应用程序所需的所有代码。 在将应用投入生产时，模块装载机还可以更轻松地将它们全部打包到成 bundle 包。 7. 迁移到 typescript如果 Angular 升级计划的一部分是同时使用 TypeScript，那么甚至在升级本身开始之前引入 TypeScript 编译器也是有意义的。这意味着在实际升级过程中，需要学习和思考的事情少了一件事。这也意味着你可以开始在 AngularJS 代码中使用 TypeScript 功能。由于 TypeScript 是 ECMAScript 2015 的超集，而 ECMAScript 2015 又是 ECMAScript 5 的超集，因此”切换到”TypeScript 并不一定需要安装 TypeScript 编译器并将文件从 .js 重命名为.ts。但是，当然，仅仅这样做并不是非常有用或令人兴奋。诸如下面的其他步骤可以给我们带来更多的收益： 对于使用 module loader 的应用程序，TypeScript 导入和导出（实际上是 ECMAScript 2015 导入和导出）可用于将代码组织到模块中。 类型注释可以逐渐添加到现有函数和变量中，以固定其类型并获得诸如构建时错误检查，出色的自动完成支持和内联文档等好处。 ES2015 的 JavaScript 功能，如箭头函数，lets 和 consts，默认函数参数和解构赋值也可以逐步添加，以使代码更具表现力。 service 和 controller 可以转换为类。这样，它们将更接近成为 Angular 服务和组件类，这将使升级更轻松。 8. 使用 Component Directives在 Angular 中，Component 是构建用户界面的主要组成部分。将 UI 的不同部分定义为组件，并将它们组合成完整的页面。 您也可以在 AngularJS 中使用 Component directive 做相同的事情。 这些是定义自己的模板，控制器和输入/输出绑定的指令 - 与 Angular 组件定义的内容相同。与使用 ng 控制器、ng 包含和作用域继承等较低级别功能构建的应用程序相比，使用组件指令构建的应用程序更容易迁移到 Angular。 8.1. 要与 Angular 兼容，AngularJS Component directive 应该配置如下属性 restrict: ‘E’组件通常用作元素。 scope: {} - 隔离作用域。在 Angular 中，组件始终与周围环境隔离，您也可以在 AngularJS 中执行此操作。 bindToController： {}.组件输入和输出应绑定到控制器，而不是使用$scope。 controller 和 controllerAs， 组件有自己的控制器。 template or templateUrl， 组件有自己的模板。 8.2. Component directive 还可以使用以下属性 transclude：true/{}，如果组件需要超越来自其他地方的内容。 require，如果组件需要与某个父组件的控制器进行通信。 8.3. 组件指令不应使用以下属性 compile, 这在 Angular 中不受支持。 replace: true, Angular 从不将组件元素替换为组件模板。此属性在 AngularJS 中也被弃用。 priority 和 terminal。虽然 AngularJS 组件可以使用这些，但它们不在 Angular 中使用，最好不要再使用这两个属性。 8.4. 一个能与 Angular 完全一致的 AngularJS Component directive 示例12345678910111213141516171819202122hero - detail.directive.ts;export function heroDetailDirective() { return { restrict: &quot;E&quot;, scope: {}, bindToController: { hero: &quot;=&quot;, deleted: &quot;&amp;&quot;, }, template: ` &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt; &lt;button ng-click=&quot;$ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt; `, controller: function HeroDetailController() { this.onDelete = () =&gt; { this.deleted({ hero: this.hero }); }; }, controllerAs: &quot;$ctrl&quot;, };} 从 AngularJS 1.5 开始引入了 Component，可以更轻松地定义此类 Component directive。将此 Component API 用于组件指令是一个好主意，原因如下： 它需要较少的样板代码。 它强制使用 controllerAs 这种组件的最佳实践。 它具有更好的默认值， 例如 scope 和 restrict 等为指令属性。 8.5. 上面的 Component directive 示例在使用 Component 表示时如下所示12345678910111213141516export const heroDetail = { bindings: { hero: &quot;&lt;&quot;, deleted: &quot;&amp;&quot;, }, template: ` &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt; &lt;button ng-click=&quot;$ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt; `, controller: function HeroDetailController() { this.onDelete = () =&gt; { this.deleted(this.hero); }; },}; Controller 生命周期钩子方法$onInit（）、$onDestroy（）和$onChanges（）是从 AngularJS 1.5 开始引入的其他方便的功能。它们在 Angular 中几乎都有完全相同的功能，因此围绕它们组织组件生命周期逻辑将简化最终的 Angular 升级过程。 9. 借助 ngUpgrade 包进行升级工作Angular 中的 ngUpgrade 包是一个非常有用的升级工具。有了它，您可以在同一应用程序中混合使用 AngularJS 和 Angular 组件，并使它们无缝衔接。这意味着您不必一次完成所有升级工作，因为在过渡期间，两个框架之间存在自然共存。 AngularJS 的生命周期将于 2021 年 12 月 31 日结束。ngUpgrade 现在处于功能完整可用状态。我们继续发布 ngUpgrade 的安全和错误修复直到 2022 年 12 月 31 日。 9.1. ngUpgrade 工作原理ngUpgrade 提供的主要工具之一称为 UpgradeModule。这是一个包含用于引导和支持 Angular 和 AngularJS 混合开发的实用程序模块。 当你使用 ngUpgrade 时，你真正要做的是同时运行 AngularJS 和 Angular。所有 Angular 代码都在 Angular 框架中运行，AngularJS 代码在 AngularJS 框架中运行。这两者都拥有框架的完整功能和特性。不是模拟仿真，因此您可以期望同时拥有两个框架的所有功能和自然行为。 除此之外，由一个框架管理的组件和服务可以与另一个框架中的组件和服务进行交互。这主要包括：依赖注入、DOM 和数据感知。 9.1.1. 依赖注入依赖注入在 AngularJS 和 Angular 中都是前端开发的前沿技术和核心功能，但是这两个框架在实际工作方式上存在一些重要的差异。 ANGULARJS ANGULAR 依赖关系注入的 tokens 始终是字符串 依赖关系注入的 tokens 可以具有不同的类型。它们通常是类, 它们也可能是字符串。 全局仅有一个 injector。即使在多模块应用程序中，所有内容都导入一个大的命名空间中. 有一个 injector 的树状结构，每个组件都有一个根 injector 和一个附加的 injector。 即使有这样大的差异，您仍然可以拥有依赖注入互操作性。upgrade/static 解决了这些差异，使一切可以无缝工作：您可以通过升级 AngularJS service 来将其注入 Angular 代码。每个单例服务能在框架之间共享。在 Angular 中，这些服务将始终位于根注入器中，并可供所有组件使用。 您也可以通过降级 Angular 服务来将其注入 AngularJS 代码。只有来自 Angular 根注入器的服务才能降级。同样，相同的单例实例服务在框架之间共享。注册降级的服务时，必须显式指定要在 AngularJS 中使用的字符串 token。 9.1.2. 组件 和 DOM在混合模式的 DOM 中，有来自 AngularJS 的组件和指令也有 Angular 的组件和指令。这些组件通过使用各自框架的双向通道相互通信，通过 ngUpgrade 组件进行桥接。也还可以通过共享的对象进行通信， 比如共享服务。 关于混合应用程序，要了解的关键是： DOM 中的每个元素都由两个框架中的一个拥有。另一个框架忽略了它。如果一个元素归 AngularJS 所有，Angular 会将其视为不存在，反之亦然。 因此，通常混合应用程序作为 AngularJS 应用程序开始启动，由 AngularJS 处理 root template，例如，index.html。然后，当遇到 Angular 指令或组件时 Angular 才参与进来， 相应指令或组件后续也由 Angular 负责管理,即使 template 包含任意数量的 Angular 组件和指令， 也能被管理起来。 除此之外，两个框架之间的组件还可以进行交互。 您通过以下两种方式之一跨越两个框架之间的边界： 通过使用一个框架元素使用另一个框架中的元素， 例如 在 AngularJS 的模板中使用 Angular 组件 ，或在 Angular 模板中使用 AngularJS 组件。 通过包含或投影来自其他框架的内容。ngUpgrade 将 AngularJS transclusion 和 Angular 内容投影的相关概念桥接在一起。 每当在一个框架的模板中使用属于另一个框架的组件时，都会在框架边界之间发生切换。但是，这种切换仅发生在该组件的模板中的元素上， 不会涉及到其他部分。例如使用 AngularJS 模板中的 Angular 定义的组件的场景，如下所示： 1&lt;a-component&gt;&lt;/a-component&gt; 虽然 DOM 元素&lt;a-component&gt;是一个 Angular 组件指令， 但是此元素将由 AngularJS 托管，因为它是在 AngularJS 模板中使用的。这也意味着您也可以将其替换为其他 AngularJS 指令，但不能替换为 Angular 指令。但是在&lt;a-component&gt;的模板中内部，Angular 将会介入其中， 其元素内部可以使用 Angular 组件， 当然也可以使用 AngularJS 组件。 当您使用 Angular 模板中使用 AngularJS 组件指令时，以上同样的规则也适用 Angular 模板， 以此类推。 9.2. 修改数据感知方式scope.$apply() 是 AngularJS 检测更改和更新数据绑定的方式。在发生每个事件后，将调用 scope.$apply() 这由框架自动完成，或由您手动完成。 在 Angular 中，事情是不同的。虽然更改检测仍然在每次事件发生后发生，但需要调用 scope.$apply() 即可实现此目的。这是因为所有 Angular 代码都在称为 Angular Zone 中运行。Angular 总是知道代码何时完成，因此它也知道何时应该启动更改检测。代码本身不必调用 scope.$apply() 或类似的东西。 在混合应用程序中，UpgradeModule 桥接了 AngularJS 和 Angular 方法。以下是发生的情况： 应用程序中发生的所有事情都在 Angular 区域内运行。无论事件起源于 AngularJS 还是 Angular 代码，都是如此。该区域会在每次事件发生被 Angular 感知到。 在 Angular Zone 每一轮代码执行之后， UpgradeModule 都会调用 AngularJS 的 $rootScope.$apply（）方法 。 还会在每次事件发生后触发 AngularJS 更改检测。 实际上您不需要调用 $apply()，无论它是在 AngularJS 还是 Angular 中。UpgradeModule 为我们做到了这一点。您仍然可以调用 $apply()，因此无需从现有代码中删除此类调用。这些调用只会在混合应用程序中触发额外的 AngularJS 更改检测检查。 当使用降级 Angular 组件，然后从 AngularJS 使用组件时，将使用 AngularJS 更改检测来监视该组件的输入。当这些输入发生更改时，将设置组件中的相应属性。您还可以通过在组件中实现 OnChanges 接口来挂钩到更改中，就像在组件中未降级时一样。 相应地，当您升级 AngularJS 组件并从 Angular 使用它时，为组件指令的 scope （或 bindToController）定义的所有绑定都将挂接到 Angular 更改检测中。它们将被视 Angular inputs。当它们变化时，它们的值将写入已升级组件的作用域（或控制器）。 9.3. 使用 UpgradeModule 结合 Angular NgModulesAngularJS 和 Angular 都有自己的模块概念，以帮助将应用程序组织成内聚的功能块。 在体系结构和实现方面有很大的不同, 它们有细节上的差异。在 AngularJS 中，将服务，控制器等添加到 angular.module 属性。而在 Angular 中，您可以创建一个或多个带有 NgModule decorator 的类，来定义模块和它们的依赖关系。差异从那里开始的。 在混合应用程序中，您至少需要一个来自 AngularJS 和一个来自 Angular 的模块。您需要在 NgModule 中导入 UpgradeModule，然后使用它来加载 AngularJS 模块。 9.4. 启动混合应用要引导混合应用程序，必须引导应用程序的每个 Angular 和 AngularJS 部件。您必须首先引导 Angular 然后让 UpgradeModule 接下来引导 AngularJS 。 在 AngularJS 应用中，你有一个根模块，根模块也将用于引导 AngularJS 应用。app.module.ts 123angular.module(&quot;heroApp&quot;, []).controller(&quot;MainCtrl&quot;, function () { this.message = &quot;Hello world&quot;;}); 纯 AngularJS 应用程序可以通过在 HTML 页面上的某个地方使用 ng-app 指令自动引导。但对于混合应用程序，您需要自己写代码使用 UpgradeModule 来引导。因此，修改 AngularJS 应用使用代码调用 angular.bootstrap 进行引导是一个很好的初步步骤， 做好是能在升级到混合应用之前这样引导。 假设您当前的引导方式是这样的， 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;base href=&quot;/&quot; /&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;app/ajs-ng-app/app.module.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=&quot;heroApp&quot; ng-strict-di&gt; &lt;div id=&quot;message&quot; ng-controller=&quot;MainCtrl as mainCtrl&quot;&gt; {{ mainCtrl.message }} &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 你可以从 HTML 中删除 ng-app 和 ng-strict-di 指令，而是切换到从 JavaScript 调用 angular.bootstrap，像这样： 1angular.bootstrap(document.body, [&quot;heroApp&quot;], { strictDi: true }); 要开始将 AngularJS 应用程序转换为混合应用程序，您需要加载 Angular 框架。 至于如何加载 Angular 框架,可以参考这篇文章Setup for Upgrading to AngularJS中的详细说明。 根据项目的需求，从项目QuickStart github repository拷贝一些代码来使用. 您还需要使用 npm 安装@angular/upgrade –save 来安装@angular/upgrade 软件包，并为@angular/upgrade/static 软件包添加映射： 要构建混合应用， 有一个 npm 包是必须安装的， 他们分别是@angular/upgrade 1npm install @angular/upgrade --save 然后要在配置文件中添加一条映射：systemjs.config.js 1'@angular/upgrade/static': 'npm:@angular/upgrade/fesm2015/static.mjs', 接着要创建一个模块文件 app.module.ts， 引入并配置 NgModule class 12345678910111213import { NgModule } from &quot;@angular/core&quot;;import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { UpgradeModule } from &quot;@angular/upgrade/static&quot;;@NgModule({ imports: [BrowserModule, UpgradeModule],})export class AppModule { constructor(private upgrade: UpgradeModule) {} ngDoBootstrap() { this.upgrade.bootstrap(document.body, [&quot;heroApp&quot;], { strictDi: true }); }} 在 NgModule decorator 配置中， 至少需要导入 BrowserModule, 这是每个基于 Angular 浏览器的应用程序都必须具有的模块, 还从@angular/upgrade/static 导入 UpgradeModule，UpgradeModule 用于升级和降级服务和组件需要用到的模块。 在 AppModule 的构造函数中，使用依赖关系注入来获取 UpgradeModule 实例，并使用它来引导 AppModule.ngDoBootstrap 方法中的 AngularJS 应用程序。upgrade.bootstrap 方法采用与 angular.bootstrap 完全相同的参数 注意： 您无需将 bootstrap 声明添加到@NgModule 装饰器上，因为 AngularJS 将掌管应用程序的 root template。 现在，您可以使用 AppModuleBrowserDynamic.bootstrapModule 方法引导 AppModule。 123import { platformBrowserDynamic } from &quot;@angular/platform-browser-dynamic&quot;;platformBrowserDynamic().bootstrapModule(AppModule); 这一步完成后， 恭喜你！您正在运行混合应用程序！现有的 AngularJS 代码与以前一样工作，您已准备好开始添加 Angular 代码。 10. 在 AngularJS 代码使用 Angular Components运行混合应用后，可以开始逐步升级代码。执行此操作的更常见模式之一是在 AngularJS 上下文中使用 Angular 组件。这可能是一个全新的组件，或者以前是 AngularJS 但已经为 Angular 重写的组件。 假设您有一个 Angular 组件如下，用于显示有关 Hero 的信息：hero-detail.component.ts 12345678910import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;hero-detail&quot;, template: ` &lt;h2&gt;Windstorm details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt; `,})export class HeroDetailComponent {} 如果你想在 Anguarjs 代码中使用这个组件, 你需要使用 downgradeComponent()方法先将 angular 组件降级, 得到一个 Angular 一个 AngularJS 的 directive 后将它注册到 AngularJS module, 这样就可以在 AngularJS 模板中使用了. 123456789101112import { HeroDetailComponent } from &quot;./hero-detail.component&quot;;/* . . . */import { downgradeComponent } from &quot;@angular/upgrade/static&quot;;angular.module(&quot;heroApp&quot;, []).directive( &quot;heroDetail&quot;, downgradeComponent({ component: HeroDetailComponent, }) as angular.IDirectiveFactory); 默认情况下，对于每个 AngularJS $digest 周期， Angular 数据感知将在组件上运行。如果只想在输入更改时运行数据感知，则可以在调用 downgradeComponent（）时将 propagateDigest 设置为 false。 由于 HeroDetailComponent 是一个 Angular 组件，因此您还必须将其添加到 AppModule 中的声明中。 123456789101112import { HeroDetailComponent } from &quot;./hero-detail.component&quot;;@NgModule({ imports: [BrowserModule, UpgradeModule], declarations: [HeroDetailComponent],})export class AppModule { constructor(private upgrade: UpgradeModule) {} ngDoBootstrap() { this.upgrade.bootstrap(document.body, [&quot;heroApp&quot;], { strictDi: true }); }} 所有 Angular 组件、指令和管道都必须在 NgModule 中声明。 最终结果是一个名为 heroDetail 的 AngularJS 指令创建成功，您可以像 AngularJS 模板中的任何其他指令一样使用它。 1&lt;hero-detail&gt;&lt;/hero-detail&gt; 注意： heroDetail 是一个 AngularJS 元素指令（restrict：‘E’）。AngularJS 元素指令根据其名称进行匹配。降级的 Angular 组件的 selector 元数据将被忽略。 当然，大多数组件都不是这么简单。他们中的许多人都有 input 和 output，将他们与外部世界联系起来。具有输入和输出的 Angular hero 组件可能如下所示： 123456789101112131415161718import { Component, EventEmitter, Input, Output } from &quot;@angular/core&quot;;import { Hero } from &quot;../hero&quot;;@Component({ selector: &quot;hero-detail&quot;, template: ` &lt;h2&gt;{{ hero.name }} details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{ hero.id }}&lt;/div&gt; &lt;button (click)=&quot;onDelete()&quot;&gt;Delete&lt;/button&gt; `,})export class HeroDetailComponent { @Input() hero!: Hero; @Output() deleted = new EventEmitter&lt;Hero&gt;(); onDelete() { this.deleted.emit(this.hero); }} 这些输入和输出可以从 AngularJS 模板提供，downgradeComponent()（）方法负责连接它们： 即使您位于 AngularJS 模板中，您也使用 Angular 属性语法来绑定输入和输出。这是降级组件的要求。表达式本身仍然是 AngularJS 正则表达式。 10.1. 使用降级组件的 KEBAB-CASE 写法对于降级的组件使用 Angular 属性语法的规则时，有一个值得注意的例外。当属性名称由多个单词组成时。在 Angular 中，您可以使用 camelCase 绑定这些属性： 12[myHero]=&quot;hero&quot;(heroDeleted)=&quot;handleHeroDeleted($event)&quot; 但是，在 AngularJS 模板中使用它们时，您必须使用 kebab-case： 12[my-hero]=&quot;hero&quot;(hero-deleted)=&quot;handleHeroDeleted($event)&quot; 看出差别来了吗？ AngularJS 模板中使用中划线分割， 而 Angular 是驼峰风格。 由于这是一个 AngularJS template，您仍然可以在元素上使用其他 AngularJS 指令，即使它具有 Angular 绑定属性。例如，您可以使用 ng-repeat 轻松创建组件的多个副本： 12345678&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt; &lt;hero-detail [hero]=&quot;hero&quot; (deleted)=&quot;mainCtrl.onDelete($event)&quot; ng-repeat=&quot;hero in mainCtrl.heroes&quot; &gt; &lt;/hero-detail&gt;&lt;/div&gt; 11. 在 Angular 代码使用 AngularJS Components因此，您可以编写一个 Angular 组件，然后从 AngularJS 代码中使用它。当您开始从较低级别的组件迁移并逐步向上移动时，这很有用。但在某些情况下，以相反的顺序做事会更方便：从更高级别的组件开始，然后向下工作。这也可以使用 upgrade/static 来完成。您可以升级 AngularJS 组件指令，然后从 Angular 使用它们。 并非所有种类的 AngularJS 指令都可以升级。该指令实际上必须是组件指令，具有准备指南中描述的特征。为了确保兼容性， 最安全的选择是使用 AngularJS 1.5 或以上的版本。 下面是一个可升级组件示例，该组件仅具有模板和控制器： 1234567export const heroDetail = { template: ` &lt;h2&gt;Windstorm details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt; `, controller: function HeroDetailController() {},}; 您可以使用 UpgradeComponent 类将此组件升级到 Angular 元素。 方法是通过继承 UpgradeComponent 来创建 Angular 指令并在其构造函数执行父类的构造方法， 这样您将拥有一个完全升级的 AngularJS 组件，可在 Angular 内部使用。剩下的就是将其添加到 AppModule 的声明数组中。 1234567891011import { Directive, ElementRef, Injector, SimpleChanges } from &quot;@angular/core&quot;;import { UpgradeComponent } from &quot;@angular/upgrade/static&quot;;@Directive({ selector: &quot;hero-detail&quot;,})export class HeroDetailDirective extends UpgradeComponent { constructor(elementRef: ElementRef, injector: Injector) { super(&quot;heroDetail&quot;, elementRef, injector); }} 12345678910111213@NgModule({ imports: [BrowserModule, UpgradeModule], declarations: [ HeroDetailDirective, /* . . . */ ],})export class AppModule { constructor(private upgrade: UpgradeModule) {} ngDoBootstrap() { this.upgrade.bootstrap(document.body, [&quot;heroApp&quot;], { strictDi: true }); }} 升级后的组件是一个 Angular 指令，而不是组件，因为 Angular 不知道 AngularJS 将在它下面创建元素。据 Angular 所知，升级后的组件只是一个指令——一个标签——Angular 不必关心它的元素内部的内容。 升级后的组件还可以具有输入和输出，如原始 AngularJS 组件指令的作用域/控制器绑定所定义。使用 Angular 模板中的组件时，请按照以下规则使用 Angular 模板语法提供输入和输出： BINDING DEFINITION TEMPLATE SYNTAX Attribute binding myAttribute: ‘@myAttribute’ &lt;my-component myAttribute=&quot;value&quot;&gt; Expression binding myOutput: ‘&amp;myOutput’ &lt;my-component (myOutput)=&quot;action()&quot;&gt; One-way binding myValue: ‘&lt;myValue’ &lt;my-component [myValue]=&quot;anExpression&quot;&gt; Two-way binding myValue: ‘=myValue’ As a two-way binding: &lt;my-component [(myValue)]=&quot;anExpression&quot;&gt; Since most AngularJS two-way bindings actually only need a one-way binding in practice, &lt;my-component [myValue]=&quot;anExpression&quot;&gt; is often enough. 例如，想象一个带有一个输入和一个输出的英雄细节 AngularJS 组件指令： 12345678910111213141516export const heroDetail = { bindings: { hero: &quot;&lt;&quot;, deleted: &quot;&amp;&quot;, }, template: ` &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt; &lt;button ng-click=&quot;$ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt; `, controller: function HeroDetailController() { this.onDelete = () =&gt; { this.deleted(this.hero); }; },}; 您可以将此组件升级到 Angular，在升级指令中注释输入和输出，然后使用 Angular 模板语法提供输入和输出： 12345678910111213141516171819202122import { Directive, ElementRef, Injector, Input, Output, EventEmitter,} from &quot;@angular/core&quot;;import { UpgradeComponent } from &quot;@angular/upgrade/static&quot;;import { Hero } from &quot;../hero&quot;;@Directive({ selector: &quot;hero-detail&quot;,})export class HeroDetailDirective extends UpgradeComponent { @Input() hero: Hero; @Output() deleted: EventEmitter&lt;Hero&gt;; constructor(elementRef: ElementRef, injector: Injector) { super(&quot;heroDetail&quot;, elementRef, injector); }} 12. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 13. 参考文档Upgrading from AngularJS to Angular Angular 官网 Angular 官方文档 Angular 中文文档 Angular 教程_Angular8 Angular9 Angular12 入门实战视频教程-2021 年更新【IT 营】 Angular1.x + TypeScript 编码风格 @component 无法注入_详解 Angular 依赖注入","link":"/angular/angular2_migration.html"},{"title":"深度刨析NgModule","text":"1. 前言我们今天要学习的是 Angular2 的模块系统,一般情况下我们使用一个根模块去启动我们的应用,然后使用许多的功能模块去丰富我们的应用,扩展我们应用的功能.这些全部依靠我们的 NgModule 装饰器,接下来我们就来好好学习一下这个装饰器. 当然在这个过程中你会遇到一些新的指令,概念等等;但是别慌,我们会在以后的文章中一个一个的详细讲解呢. 2. @NgModule 的重要作用在 Angular 中，NgModule 有以下几个重要的作用： NgModule 最根本的意义是帮助开发者组织业务代码，开发者可以利用 NgModule 把关系比较紧密的组件组织到一起，这是首要的。NgModule 用来控制组件、指令、管道等的可见性，处于同一个 NgModule 里面的组件默认互相可见，而对于外部的组件来说，只能看到 NgModule 导出（ exports ）的内容 这一特性非常类似 Java 里面 package 的概念。也就是说，如果你定义的 NgModule 不 exports 任何内容，那么外部使用者即使 import 了你这个模块，也没法使用里面定义的任何内容。 3. NgModule API在进入详细讲解之前, 我们首先来熟悉一下 NgModule 的 API. NgModule 源码位于 angular 项目的 packages\\core\\src\\metadata\\ng_module.ts 文件中. 12345678910111213141516171819202122232425262728293031interface NgModule { // providers: 需要使用的 Service 都放在这里. 这个选项是一个数组,需要我们列出我们这个模块的一些需要共用的服务 // 然后我们就可以在这个模块的各个组件中通过依赖注入使用了. providers: Provider[]; // declarations: 数组类型的选项, 用来声明属于这个模块的指令,管道等等. // 然后我们就可以在这个模块中使用它们了. // （Angular中没有模块级别的service，所有在NgModule中声明的Provider都是注册在根级别的Dependency Injector中） declarations: Array&lt;Type&lt;any&gt; | any[]&gt;; // imports: 用来导入外部模块。数组类型的选项,我们的模块需要依赖的一些外部模块,这样做的目的使我们这个模块 // 可以直接使用别的模块提供的一些指令,组件等等. imports: Array&lt;Type&lt;any&gt; | ModuleWithProviders | any[]&gt;; // exports: 数组类型的选项,我们这个模块需要导出的一些组件,指令,模块等; // 如果别的模块导入了我们这个模块, // 那么别的模块就可以直接使用我们在这里导出的组件,指令模块等. exports: Array&lt;Type&lt;any&gt; | any[]&gt;; // entryComponents: 数组类型的选项,指定一系列的组件,这些组件将会在这个模块定义的时候进行编译 // Angular会为每一个组件创建一个ComponentFactory然后把它存储在ComponentFactoryResolver entryComponents: Array&lt;Type&lt;any&gt; | any[]&gt;; // bootstrap: 定义启动组件。数组类型选项, 指定了这个模块启动的时候应该启动的组件.当然这些组件会被自动的加入到entryComponents中去 bootstrap: Array&lt;Type&lt;any&gt; | any[]&gt;; // schemas: 不属于Angular的组件或者指令的元素或者属性都需要在这里进行声明. schemas: Array&lt;SchemaMetadata | any[]&gt;; // id: 字符串类型的选项,模块的隐藏ID,它可以是一个名字或者一个路径;用来在getModuleFactory区别模块,如果这个属性是undefined // 那么这个模块将不会被注册. id: string; // jit存在时，AOT编译器将忽略此模块。 // 它保留在分布式代码中，JIT编译器会尝试编译它 // 在运行时，在浏览器中。 // 为了确保正确的行为，应用程序必须导入“@angular/compiler”。 jit: boolean;} angular 15 以前, 每个应用至少有一个根模块，按照惯例，根模块的名字一般都叫 AppModule，如果你没有非常特别的理由，就不要随意改这个名字了，这相当于一个惯例。Angular 15 及以后版本可以定义 standalone 组件, 可以不隶属于任何模块. NgModule 和 ES6 Module ES6 里面的模块是通过 export 和 import 来进行声明的，它们是语法层面的内容；而 NgModule 完全不是这个概念，从上面的作用列表你也能看出来。最重要的一点，目前，ES6 里面的 import 只能静态引入模块，并不能异步动态加载模块。 NgModule 可以配合 Router 来进行异步模块加载。模块的定义方式会影响依赖注入机制：对于直接 import 的同步模块，无论你把 @Injectable 类型的组件定义在哪个模块里面，它都是全局可见的。 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 5. 参考文档ANGULAR2 NGMODULE 模块详解 angular 模块 @NgModule 的使用及理解","link":"/angular/angular2_ngmodule.html"},{"title":"Angular2中的路由","text":"1. Angular2 中的路由Angular2 中建立路由的 5 个步骤. 2. 安装@angular/router首先第一件事，我们需要安装 Angular Router。你可以通过运行以下命令进行安装. 1npm i --save @angular/router 以上命令执行后，将会自动下载 @angular/router 模块到 node_modules 文件夹中。 3. 配置路由在 src/app 下新建一个 app.routes.ts 文件Angular2 中路由要解决的是 URL 与页面的对应关系（比如 URL 是http://localhost:4200/all-people，那么页面显示的就应该是allPeople画面，URL是http://localhost:4200/first-come，页面显示的就应该是firstCome画面）。在 Angular2 中页面是由组件组成的（Angular2 中的根模块对应的根组件就表示了整个应用，应用也可以说成只有一个组件，也就是一个页面，这就是单页面应用的由来吧），所以路由解决的是 URL 与组件的对应关系。 这个需要一个数据，它用来表示 url 与组件的对应关系，Angular2 中把这个数据叫作“路由配置” 1234567891011121314import { Routes } from &quot;@angular/router&quot;;import { AllPeopleComponent } from &quot;./all-people/all-people.component&quot;;import { HomePageComponent } from &quot;./home-page/home-page.component&quot;;export const rootRouterConfig: Routes = [ { path: &quot;&quot;, // http://localhost:4200 component: HomePageComponent, }, { path: &quot;all-people&quot;, // http://localhost:4200/all-people component: AllPeopleComponent, },]; 4. 加载路由配置根路由模块包含了路由所需的使用服务，它以路由配置为参数，调用 RouterModule.forRoot()app.module.ts 123456789101112131415161718192021import { ModuleWithProviders, NgModule } from &quot;@angular/core&quot;;// 在根模块中导入路由配置import { rootRouterConfig } from &quot;./app.routes&quot;; // 注意没有.ts// 需要调用RouterModule.forRoot()方法import { RouterModule } from &quot;@angular/router&quot;;// 创建路由模块// 根路由模块默认提供的路由策略为PathLocationStrategy（另外一个是HashLocationStrategy）。// PathLocationStrategy路由策略需要一个base路径，设置base路径有2种方式，最简单的是在index.html中设置&lt;base&gt;// 如果要创建HashLocationStrategy 可以使用如下方式创建, 即需要传递options {useHash: true}// const rootRouterModule: ModuleWithProviders = RouterModule.forRoot(rootRouterConfig, {useHash: true});const rootRouterModule: ModuleWithProviders&lt;RouterModule&gt; = RouterModule.forRoot(rootRouterConfig);// 然后将路由模块导入AppModule@NgModule({ declarations: [], imports: [rootRouterModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} 5. 添加组件存放的区域这个指令就是在页面上预留一个区域，当 url 改变时匹配路由配置中的 path，匹配成功后就将与 path 对应的 component 加载到这个区域里。 一般情况下，这个指令是放在根组件中。app.conponent.html 123&lt;section class=&quot;container&quot;&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;/section&gt; 到目前为止，一个简单的路由就基本配置完成了，只要在 url 中输入正确的 path，就能显示对应的组件。 6. 路由跳转如上说的，路由跳转就是为了不要手动改变 url，最常见的就是点击事件改变 url，实现路由跳转，显示组件。 路由跳转有两种方式：指令跳转和代码跳转。 指令跳转指的是使用 RouterlLink 指令，该指令接收一个链接参数数组，当事件被触发时，数组中的所有元素与路由配置中的 path 接收的数组中的元素进行一一对比，全都相等时得以匹配。 RouterLink 有一个好的方法，可以指定 routerLinkActive = “className”，也就是当 RouterLink 被激活时可以给相应的 html 元素添加 clas 类。神奇地是，routerLinkActive 可以作用于父级元素。 1234567891011121314151617&lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt; &lt;a [routerLink]=&quot;['/all-people']&quot; routerLinkActive=&quot;active&quot;&gt;allPeople&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a [routerLink]=&quot;['/first-come']&quot; routerLinkActive=&quot;active&quot;&gt;firstCome&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a [routerLink]=&quot;['/last-leave']&quot; routerLinkActive=&quot;active&quot;&gt;lastLeave&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a [routerLink]=&quot;['/form']&quot; routerLinkActive=&quot;active&quot;&gt;newPerson&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a [routerLink]=&quot;['/bugManage']&quot; routerLinkActive=&quot;active&quot;&gt;bugManage&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 需要特别注意的是：RouterLink 指令仅响应 click 事件（码源分析以后补上），要想响应其他（比如延迟显示）事件，就要用到代码跳转。 7. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 8. 参考文档Angular2 中的路由（简单总结） Angular 4.x 路由快速入门学习","link":"/angular/angular2_route.html"},{"title":"Angular 14 有哪些更新","text":"我们很高兴地宣布 Angular v14 发布！从类型化表单和独立组件到 Angular CDK（组件开发工具包）中的新原语，我们很高兴分享每个功能如何使 Angular 变得更强大。 自上一个版本以来，我们完成了两项主要的征求意见请求搞 (RFC)，这为整个 Angular 社区提供了针对提议的更改提供设计反馈的机会。因此，我们的严格类型反应表单 RFC解决了我们的#1 GitHub 问题，并且我们的独立 API RFC引入了一种更简单的方法来编写 Angular 应用程序。 我们还将 Angular 组织中存储库中的默认分支重命名为 main，以履行我们对包容性社区的承诺。 此外，此版本还包括由社区成员直接贡献的许多功能和错误修复，从添加路由器强类型到更多 tree-shakable 错误消息。我们很高兴强调 RFC 和社区如何继续使 Angular 成为更多开发人员的选择和拥有更好的开发人员体验！ 1. 使用独立组件简化 AngularAngular 独立组件旨在通过减少对 NgModule 的需求来简化 Angular 应用程序的编写。在 v14 中，独立组件处于开发者预览版中。它们已准备好在您的应用程序中用于探索和开发，但不是稳定的 API，并且可能会在我们典型的向后兼容性模型之外发生变化。 12345678910111213141516171819202122232425262728293031import { Component } from &quot;@angular/core&quot;;import { CommonModule } from &quot;@angular/common&quot;; // includes NgIf and TitleCasePipeimport { bootstrapApplication } from &quot;@angular/platform-browser&quot;;import { MatCardModule } from &quot;@angular/material/card&quot;;import { ImageComponent } from &quot;./app/image.component&quot;;import { HighlightDirective } from &quot;./app/highlight.directive&quot;;@Component({ selector: &quot;app-root&quot;, standalone: true, imports: [ ImageComponent, HighlightDirective, // import standalone Components, Directives and Pipes CommonModule, MatCardModule, // and NgModules ], template: ` &lt;mat-card *ngIf=&quot;url&quot;&gt; &lt;app-image-component [url]=&quot;url&quot;&gt;&lt;/app-image-component&gt; &lt;h2 app-highlight&gt;{{ name | titlecase }}&lt;/h2&gt; &lt;/mat-card&gt; `,})export class ExampleStandaloneComponent { name = &quot;emma&quot;; url = &quot;www.emma.org/image&quot;;}// Bootstrap a new Angular application using our `ExampleStandaloneComponent` as a root component.bootstrapApplication(ExampleStandaloneComponent); 对于带有standalone: true的独立组件、指令或管道，可以直接在@Component()组件声明中 import，而无需通过@NgModule()来 import. 而且在@Component()中也可以引入一个模块, 这样 Angular 独立组件不仅可以引用 standalone 形式的独立组件、指令或管道也可以兼容以 module 形式组织的旧的物件. 探索新的 Stackblitz 演示应用程序，了解有关如何使用独立组件构建 Angular 应用程序的更多信息。 在开发者预览版中，我们希望利用 open source 来为发布稳定的 standalone API 做好充分准备。使用ng generate component &lt;name&gt; --standalone来为您的应用添加第一个独立组件，然后前往我们的 GitHub 存储库提供反馈吧。 在接下来的几个月中，我们将继续构建 schematics（例如ng new &lt;app-name&gt; --standalone），并编写更多关于如何使用这样新特性的案例和如何掌握它的学习旅程。请记住，由于目前处于开发者预览中，随着我们不断继续完善我们的设计，有些使用方式可能会在正式稳定版中发生变化。 您可以在两个 RFC 和公开设计审查中阅读有关当前实现背后的设计思想的更多信息。请务必在此处和Twitter上关注我们，以获取独立 API 的未来更新。 2. 类型化的 Angular 表单Angular v14 解决了 Angular 的 GitHub 顶级问题：为 Angular Reactive Forms 包实现严格类型。 类型化表单确保表单控件、组和数组内的值在整个 API 表面上都是类型安全的。这使得表单更安全，特别是对于深度嵌套的复杂情况。 12345678910111213141516171819const cat = new FormGroup({ name: new FormGroup({ first: new FormControl(&quot;Barb&quot;), last: new FormControl(&quot;Smith&quot;), }), lives: new FormControl(9),});// Type-checking for forms values!// TS Error: Property 'substring' does not exist on type 'number'.let remainingLives = cat.value.lives.substring(1); //这里直接报编译错误// Optional and required controls are enforced!// TS Error: No overload matches this call.cat.removeControl(&quot;lives&quot;);// FormGroups are aware of their child controls.// name.middle is never on catlet catMiddleName = cat.get(&quot;name.middle&quot;); 此功能是公开征求意见和设计审查的结果，它建立在 Angular 社区贡献者（包括 Sonu Kapoor、Netanel Basel 和 Cédric Exbrayat ）之前的原型设计、工作和测试的基础上。 用于迁移到这一新功能的 update schematics 允许增量迁移 input 表单，因此您可以逐步向现有表单添加 input 内容，并具有完全向后兼容性。ng update 将用无类型版本替换所有表单类（例如 FormGroup-&gt; UntypedFormGroup）。然后，您可以按照自己的节奏启用类型（例如 UntypedFormGroup-&gt; FormGroup）。 12345678910111213141516171819// v13 untyped formconst cat = new FormGroup({ name: new FormGroup( first: new FormControl('Barb'), last: new FormControl('Smith'), ), lives: new FormControl(9)});// v14 untyped form after running `ng update`const cat = new UntypedFormGroup({ name: new UntypedFormGroup( first: new UntypedFormControl('Barb'), last: new UntypedFormControl('Smith'), ), lives: new UntypedFormControl(9)}); 为了利用新的类型支持，我们建议搜索 Untyped 表单控件的实例并尽可能迁移到新类型的表单 API 界面。 12345678910// v14 partial typed form, migrating `UntypedFormGroup` -&gt; `FormGroup`const cat = new FormGroup({ name: new FormGroup( first: new UntypedFormControl('Barb'), last: new UntypedFormControl('Smith'), ), lives: new UntypedFormControl(9)}); 我们建议新应用程序使用 Form*类，除非该类有意为非类型化（例如，FormArray 同时具有数字和字符串的 a）。在文档中了解更多信息。 3. 简化的最佳实践Angular v14 带来了内置功能，使开发人员能够构建高质量的应用程序，从路由到代码编辑器，从 angular.io 上的新的更改检测指南开始。 4. 简化的页面标题可访问性另一个最佳实践是确保应用程序的页面标题能够唯一地传达页面的内容。v13.2 通过 Angular Router 中的新 Route.title 属性简化了这一过程。但是在 v14 版本中添加 title 不必这么麻烦了，并且是强类型的，这要归功于 Marko Stanimirović 的惊人社区贡献。 1234567891011const routes: Routes = [{ path: 'home', component: HomeComponent title: 'My App - Home' // &lt;-- Page title}, { path: 'about', component: AboutComponent, title: 'My App - About Me' // &lt;-- Page title}]; 您通过提供自定义 TitleStrategy, 来配置更加复杂的标题设置逻辑. 123456789101112131415161718192021222324252627const routes: Routes = [{ path: 'home', component: HomeComponent}, { path: 'about', component: AboutComponent, title: 'About Me' // &lt;-- Page title}];@Injectable()export class TemplatePageTitleStrategy extends TitleStrategy { override updateTitle(routerState: RouterStateSnapshot) { const title = this.buildTitle(routerState); if (title !== undefined) { document.title = `My App - ${title}`; } else { document.title = `My App - Home`; };};@NgModule({ … providers: [{provide: TitleStrategy, useClass: TemplatePageTitleStrategy}]})class MainModule {} 在这些示例中，导航到“/about”会将文档标题设置为“我的应用程序 - 关于我”，而导航到“/home”会将文档标题设置为“我的应用程序 - 主页”。 您可以在 Google I/O 2022 研讨会上了解有关使用 Angular 进行无障碍构建的更多信息。 5. 加强的开发人员诊断工具新的扩展诊断提供了一个可扩展的框架，使您可以更深入地了解模板以及如何改进它们。诊断为您的模板提供编译时警告和精确、可操作的建议，在运行时之前捕获错误。 我们对它为开发人员在未来添加诊断功能引入的灵活框架感到兴奋。 在 v13.2 中，我们包含内置的扩展诊断功能，以帮助开发人员捕获两个最常见的模板错误。 5.1. 捕获双向数据绑定上的无效“Banana in a box”错误开发人员常见的语法错误是在双向绑定中翻转方括号和圆括号，([])将[()]. 由于()排序看起来像香蕉，[]排序看起来像盒子，因此我们将其称为“盒子里的香蕉”错误，因为香蕉应该放在盒子里。 虽然此错误在技术上是有效的语法，但我们的 CLI 可以认识到这很少不是开发人员想要的。在 v13.2 版本中，我们引入了有关此错误的详细消息传递以及有关如何解决此问题的指南，所有这些都在 CLI 和代码编辑器中进行。 123456Warning: src/app/app.component.ts:7:25 - warning NG8101: In the two-way binding syntax the parentheses should be inside the brackets, ex. '[(fruit)]=&quot;favoriteFruit&quot;'. Find more at https://angular.io/guide/two-way-binding7 &lt;app-favorite-fruit ([fruit])=&quot;favoriteFruit&quot;&gt;&lt;/app-favorite-fruit&gt; ~~~~~~~~~~~~~~~~~~~~~~~~~ 5.2. 捕获不可空值的空值合并扩展诊断还会引发 Angular 模板中无用的无效合并运算符(??)的错误。具体来说，当输入不是“可为空”时，即表示其类型不包括 null 或 undefined 时，会引发此错误。 ng build 扩展诊断在、ng serve 和 期间使用 Angular 语言服务实时显示为警告。诊断可在 tsconfig.json 中配置，您可以在其中指定诊断是否应为 warning、error 或 suppress。 123456789101112131415161718{ &quot;angularCompilerOptions&quot;: { &quot;extendedDiagnostics&quot;: { // The categories to use for specific diagnostics. &quot;checks&quot;: { // Maps check name to its category. &quot;invalidBananaInBox&quot;: &quot;error&quot;, &quot;nullishCoalescingNotNullable&quot;: &quot;warning&quot; }, // The category to use for any diagnostics not listed in `checks` above. &quot;defaultCategory&quot;: &quot;suppress&quot; }, ... }, ...} 在我们的文档和扩展诊断博客文章中了解有关扩展诊断的更多信息。 5.3. Tree-shakeable 错误消息当我们继续编写Angular 调试指南时， Ramesh Thiruchelvam 为社区贡献了添加新的运行时错误代码。强大的错误代码使您可以更轻松地参考和查找有关如何调试错误的信息。 这允许构建优化器从生产包中 tree-shake 错误消息（长字符串），同时保留错误代码。 12345678910111213141516@Component({...})class MyComponent {}@Directive({...})class MyDirective extends MyComponent {} // throws an error at runtime// Before v14 the error is a string:&gt; Directives cannot inherit Components. Directive MyDirective is attempting to extend component MyComponent.// Since v14 the error code makes this tree-shakeable:&gt; NG0903: Directives cannot inherit Components. Directive MyDirective is attempting to extend component MyComponent.// v14 production bundles preserve the error code, tree-shaking strings and making the bundle XX smaller:&gt; NG0903 要调试生产错误，我们建议前往参考指南并在开发环境中重现错误，以便查看完整的字符串。我们将继续逐步重构现有错误，以便在未来的版本中利用这种新格式。 6. 更多内置改进v14 包括对最新 TypeScript 4.7 版本的支持，现在默认以 ES2020 为目标，这使得 CLI 可以在不降级的情况下发布更小的代码。 此外，我们还想强调三个特色： 6.1. 绑定到 protected 的组件成员变量在 v14 中，您现在可以直接从模板绑定到受保护的组件成员，这要感谢 Zack Elliott 的贡献！ 1234567@Component({ selector: &quot;my-component&quot;, template: &quot;{{ message }}&quot;, // Now compiles!})export class MyComponent { protected message: string = &quot;Hello world&quot;;} 这使您可以更好地控制可重用组件的公共 API 界面。 6.2. 嵌入式视图中的可选注入器ViewContainerRef.createEmbeddedView v14 中添加了在通过和创建嵌入视图时传入可选注入器的支持 TemplateRef.createEmbeddedView。注入器允许在特定模板内自定义依赖注入行为。 这使得能够使用更清晰的 API 来编写可重用组件以及 Angular CDK 中的组件原生类型。 123viewContainer.createEmbeddedView(templateRef, context, { injector: injector,}); 6.3. NgModel OnPush 模型最后，Artur Androsovych 的社区贡献解决了一个热门问题，并确保 NgModel 更改反映在 OnPush 组件的 UI 中。 123456@Component({ selector: &quot;my-component&quot;, template: ` &lt;child [ngModel]=&quot;value&quot;&gt;&lt;/child&gt; `, changeDetection: ChangeDetectionStrategy.OnPush,})class MyComponent {} 7. 内置原始类型和工具CDK 和工具改进为更强大的开发环境提供了构建块，从 CDK 菜单原语到 CLI 自动完成。 Angular 的组件开发工具包提供了一整套用于构建 Angular 组件的工具。在 v14 中，我们将 CDK 菜单和对话框提升至稳定！ 此版本包括新的 CDK 原始类型，可用于基于 WAI-ARIA 菜单和菜单栏设计模式创建更易于访问的自定义组件。 12345678&lt;ul cdkTargetMenuAim cdkMenuBar&gt; &lt;li cdkMenuItem [cdkMenuTriggerFor]=&quot;file&quot;&gt;File&lt;/li&gt;&lt;/ul&gt;&lt;ng-template #file&gt; &lt;ul cdkMenu cdkTargetMenuAim&gt; &lt;li cdkMenuItem&gt;Open&lt;/li&gt; &lt;/ul&gt;&lt;/ng-template&gt; 8. hasHarness 和组件测试工具中的 getHarnessOrNullv14 为 HarnessLoader 添加了新方法用于检查 harness 是否存在并返回 harness 实例（如果存在）。组件测试工具继续提供一种灵活的方式来为组件编写更好的测试。 9. Angular CLI 增强功能标准化 CLI 参数解析意味着整个 Angular CLI 具有更高的一致性，现在每个标志都使用–lower-skewer-case 格式。我们删除了已弃用的驼峰式大小写参数支持，并添加了对组合别名使用的支持。 好奇这意味着什么？运行 ng –help 以获得更清晰的输出来解释您的选项 9.1. NG 命令自动补全意外输入 ng sevre 而不是 ng serve 经常发生。拼写错误是命令行提示符引发错误的最常见原因之一。为了解决这个问题，v14 的新功能 ng completion 引入了实时提前输入自动完成功能！ 为了确保所有 Angular 开发人员都了解这一点，CLI 将提示您在 v14 中的第一次命令执行期间选择自动完成。您也可以手动运行 ng completion，CLI 会自动为您进行设置。 9.2. NG analyticsCLI 的 analytics 命令允许您控制分析设置和打印分析信息。更详细的输出可以清楚地传达您的分析配置，并为我们的团队提供遥测数据，以告知我们的项目优先级。当您打开它时，它会非常有帮助！ 9.3. ng 缓存ng cache 提供了一种从命令行控制和打印缓存信息的方法。您可以启用、禁用或从磁盘删除，以及打印统计信息和信息。 10. Angular DevTools 可离线使用并可在 Firefox 中使用感谢 Keith Li 的社区贡献，Angular DevTools 调试扩展现在支持离线使用。对于 Firefox 用户，请在 Mozilla 附加组件中找到该扩展。 11. 实验性 ESM 应用程序构建最后，v14 引入了一个基于 esbuild 的实验性构建系统 ng build，该系统编译纯 ESM 输出。 要在您的应用程序中尝试此操作，请更新您的浏览器构建器 angular.json： 12345&quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;&quot;builder&quot;: &quot;@angular-devkit/build-angular:browser-esbuild&quot; 随着我们不断增加对 Sass 等样式表预处理器的支持，我们的团队很高兴收集有关您应用程序性能的反馈。 12. 下一步是什么随着此版本的发布，我们还更新了公开路线图，以反映当前和未来团队项目和探索的状态。 您可以在 Angular 博客和#GoogleIO 的 State of Angular 中了解有关我们团队未来计划的更多信息： 感谢所有每天构建、创新和激励我们的出色开发人员 — 我们对 Angular 的发展方向感到兴奋！ 前往 update.angular.io 并通过@Angular 向我们发送推文，了解您的#ngUpdate 体验！ 13. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular 专题 | 鹏叔的技术博客","link":"/angular/angular_14_update.html"},{"title":"Angular 15 有哪些更新?","text":"在过去的一年里，我们删除了 Angular 的旧版编译器和渲染管道，这使得在过去几个月内实现了一系列开发人员体验的改进。Angular v15 是这方面的巅峰之作，它进行了数十项改进，带来了更好的开发人员体验和性能。 1. Standalone APIs 现已从开发者预览版毕业在 v14 中，我们引入了新的 Standalone API，使开发人员能够在不使用 NgModule 的情况下构建应用程序。我们很高兴地告诉大家，这些 API 已从开发者预览版毕业，现在已成为稳定 API 的一部分。从现在开始，我们将按照语义版本控制逐步发展它们。 作为确保独立 API 准备好毕业的一部分，我们确保独立组件可以跨 Angular 工作，并且它们现在可以在 HttpClient, Angular Elements、路由等中完全工作。 独立 API 允许您使用单个组件引导应用程序： 1234567891011121314import { bootstrapApplication } from &quot;@angular/platform-browser&quot;;import { ImageGridComponent } from &quot;./image-grid&quot;;@Component({ standalone: true, selector: &quot;photo-gallery&quot;, imports: [ImageGridComponent], template: ` … &lt;image-grid [images]=&quot;imageList&quot;&gt;&lt;/image-grid&gt; `,})export class PhotoGalleryComponent { // component logic}bootstrapApplication(PhotoGalleryComponent); 2. Router 和 HttpClient tree-shakable standalone API您可以使用新的路由器独立 API 构建多路由应用程序！要声明根路由，您可以使用以下命令： 1234567export const appRoutes: Routes = [ { path: &quot;lazy&quot;, loadChildren: () =&gt; import(&quot;./lazy/lazy.routes&quot;).then((routes) =&gt; routes.lazyRoutes), },]; lazyRoutes 声明于： 12345import { Routes } from &quot;@angular/router&quot;;import { LazyComponent } from &quot;./lazy.component&quot;;export const lazyRoutes: Routes = [{ path: &quot;&quot;, component: LazyComponent }]; 最后，appRoutes 注册在 bootstrapApplication 中： 123bootstrapApplication(AppComponent, { providers: [provideRouter(appRoutes)],}); API 的另一个好处 provideRouter 是它时 tree-shakable 的！Bundlers 可以在构建时删除路由器未使用的功能。在使用新 API 进行的测试中，我们发现从 Bundle 包中删除这些未使用的功能可以使应用程序捆绑包中的路由器代码大小减少 11%。 3. 组合指令 API指令组合 API 将代码重用提升到另一个水平！此功能的灵感来自 GitHub 上最受欢迎的功能请求，要求提供向 host 元素添加指令的功能。 组合指令 API 使开发人员能够使用指令增强 host 元素，并为 Angular 配备强大的代码重用策略，这要归功于我们的编译器。指令组合 API 仅适用于独立指令。 让我们看一个简单的例子： 123456789101112@Component({ selector: &quot;mat-menu&quot;, hostDirectives: [ HasColor, { directive: CdkMenu, inputs: [&quot;cdkMenuDisabled: disabled&quot;], outputs: [&quot;cdkMenuClosed: closed&quot;], }, ],})class MatMenu {} 在上面的代码片段中，我们 MatMenu 使用两个指令进行增强：HasColor 和 CdkMenu。MatMenu 重用 HasColor 的所有输入、输出和关联逻辑，并且仅重用来自 CdkMenu 的选定输入和输出逻辑。 这种技术可能会让您想起某些编程语言中的多重继承或特征，不同之处在于我们有解决名称冲突的机制，并且它适用于用户界面原语。 4. 图像指令现已稳定我们发布了 Angular 图像指令的开发者预览版，该指令是我们与 Chrome Aurora 在 v14.2 中合作开发的。 我们很高兴地告诉大家，它现在已经稳定了！Land’s End 对此功能进行了实验，并在灯塔实验室测试中观察到 LCP 提高了 75% 。 v15 版本还包括一些针对 image 指令的新功能： 自动 srcset 生成：该指令通过为您生成属性来确保请求适当大小的图像。这可以减少图像的下载时间。 填充模式[实验特性]：此模式使图像填充其父容器，从而无需声明图像的宽度和高度。如果您不知道图像的大小或者想要迁移 CSS 背景图像以使用该指令，那么这是一个方便的工具。 NgOptimizedImage 您可以直接在组件或 NgModule 中使用独立指令： 12345678910111213141516import { NgOptimizedImage } from '@angular/common';// Include it into the necessary NgModule@NgModule({ imports: [NgOptimizedImage],})class AppModule {}// ... or a standalone Component@Component({ standalone: true imports: [NgOptimizedImage],})class MyStandaloneComponent {} 要在组件中使用它，只需将图像的 src 属性替换为 ngSrc，并确保为 LCP 图像指定 priority 属性。 您可以在我们的文档中找到更多信息。 5. 函数式路由器守卫与 tree-shakable 独立路由器 API 一起使用时，我们致力于减少防护中的模板文件。让我们看一个示例，其中我们定义了一个守卫来验证用户是否已登录： 12345678910111213@Injectable({ providedIn: &quot;root&quot; })export class MyGuardWithDependency implements CanActivate { constructor(private loginService: LoginService) {} canActivate() { return this.loginService.isLoggedIn(); }}const route = { path: &quot;somePath&quot;, canActivate: [MyGuardWithDependency],}; LoginService 实现了大部分逻辑，在守卫中我们只调用 isLoggedIn(). 尽管守卫非常简单，但我们有很多样板代码。 使用新的功能性路由器守卫，您可以将此代码重构为： 1234const route = { path: &quot;admin&quot;, canActivate: [() =&gt; inject(LoginService).isLoggedIn()],}; 我们在守卫声明中表达了整个守卫逻辑。函数式路由器守卫也是可组合的——您可以创建类似工厂的函数来接受配置并返回防护或解析器函数。您可以在 GitHub 上找到串行运行路由器防护的示例。 6. Router unwraps 默认导入为了使路由器更简单并进一步减少样板文件，路由器现在在延迟加载时自动解包默认导出。 假设您有以下内容 LazyComponent： 1234567@Component({ standalone: true, template: '...'})export default class LazyComponent { ... } 在此更改之前，要延迟加载独立组件，您必须： 123456{ path: 'lazy', loadComponent: () =&gt; import('./lazy-file').then(m =&gt; m.LazyComponent),} 现在，路由器将查找默认导出，如果找到，则自动使用它，这将路由声明简化为： 1234{ path: 'lazy', loadComponent: () =&gt; import('./lazy-file'),} 7. 更好的堆栈跟踪我们从年度开发者调查中获得了很多见解，因此我们要感谢您花时间分享您的想法！深入研究开发人员面临的调试体验难题，我们发现错误消息需要一些改进。 Angular 开发人员的调试难题 我们与 Chrome DevTools 合作解决了这个问题！让我们看一下您可能在 Angular 应用程序上使用的示例堆栈跟踪： 123456789101112131415ERROR Error: Uncaught (in promise): ErrorError at app.component.ts:18:11 at Generator.next (&lt;anonymous&gt;) at asyncGeneratorStep (asyncToGenerator.js:3:1) at _next (asyncToGenerator.js:25:1) at _ZoneDelegate.invoke (zone.js:372:26) at Object.onInvoke (core.mjs:26378:33) at _ZoneDelegate.invoke (zone.js:371:52) at Zone.run (zone.js:134:43) at zone.js:1275:36 at _ZoneDelegate.invokeTask (zone.js:406:31) at resolvePromise (zone.js:1211:31) at zone.js:1118:17 at zone.js:1134:33 这段代码有两个主要问题： 只有一行与开发人员编写的代码相对应。其他一切都来自第三方依赖项（Angular 框架、Zone.js、RxJS） 没有关于什么用户交互导致错误的信息 Chrome DevTools 团队创建了一种机制，通过 Angular CLI 注释源映射来忽略来自 node_modules 的脚本。我们还合作开发了异步堆栈标记 API，该 API 允许我们将独立的预定异步任务连接到单个堆栈跟踪中。Jia Li 将 Zone.js 与异步堆栈标记 API 集成，这使我们能够提供链接的堆栈跟踪。 这两项更改极大地改善了开发人员在 Chrome DevTools 中看到的堆栈跟踪： 1234567891011ERROR Error: Uncaught (in promise): ErrorError at app.component.ts:18:11 at fetch (async) at (anonymous) (app.component.ts:4) at request (app.component.ts:4) at (anonymous) (app.component.ts:17) at submit (app.component.ts:15) at AppComponent_click_3_listener (app.component.html:4) 在这里您可以跟踪从 AppComponent 按下按钮一直到出现错误的执行过程。您可以在此处阅读有关改进的更多信息。 8. 将基于 MDC 的组件发布到稳定版我们很高兴地宣布基于 Web material design 组件 (MDC) 的 Angular material 组件的重构现已完成！这一更改使 Angular 能够更接近 Material Design 规范，重用 Material Design 团队开发的原语代码，并使我们能够在最终确定 style token 后采用 Material 3。 对于许多组件，我们更新了样式和 DOM 结构，其他组件我们从头开始重写。我们保留了新组件的大部分 TypeScript API 和组件/指令选择器与旧实现相同。 我们迁移了数千个 Google 项目，这使我们能够使外部迁移路径变得顺畅，并记录所有组件中更改的完整列表。 由于新的 DOM 和 CSS，您可能会发现应用程序中的某些样式需要调整，特别是当您的 CSS 覆盖任何迁移组件上的内部元素的样式时。 每个新组件的旧实现现已弃用，但仍可通过“legacy”导入使用。例如，您可以 mat-button 通过导入旧按钮模块来导入旧的实现。 1import { MatLegacyButtonModule } from &quot;@angular/material/legacy-button&quot;; 请访问迁移指南以获取更多信息。 我们将许多组件移至后台使用 design token 和 CSS 变量，这将为应用程序采用 Material 3 组件样式提供一条平滑的路径。 9. 组件方面的更多改进我们解决了第四个投票最多的问题——滑块中的范围选择支持。 要获取范围输入，请使用： 1234&lt;mat-slider&gt; &lt;input matSliderStartThumb /&gt; &lt;input matSliderEndThumb /&gt;&lt;/mat-slider&gt; 此外，所有组件现在都有一个 API 来自定义 density，这解决了另一个热门的 GitHub 问题。 您现在可以通过自定义主题来指定所有组件的默认 density： 1234567891011121314@use '@angular/material' as mat;$theme: mat.define-light-theme(( color: ( primary: mat.define-palette(mat.$red-palette), accent: mat.define-palette(mat.$blue-palette), ), typography: mat.define-typography-config(), density: -2,));@include mat.all-component-themes($theme); 新版本的组件包括广泛的可访问性改进，包括更好的对比度、增加的触摸目标尺寸和改进的 ARIA 语义。 9.1. CDK 列表框组件开发工具包 (CDK) 提供了一组用于构建 UI 组件的行为原语。在 v15 中，我们引入了另一个可以根据您的用例进行自定义的原语 — CDK 列表框： 该@angular/cdk/listbox 模块提供指令来帮助创建基于 WAI ARIA 列表框模式的自定义列表框交互。 通过使用，@angular/cdk/listbox 您可以获得无障碍体验的所有预期行为，包括双向布局支持、键盘交互和焦点管理。所有指令都将其关联的 ARIA 角色应用于其宿主元素。 10. 实验性 esbuild 支持的改进在 v14 中，我们宣布对 esbuild 提供实验性支持 ng build，以实现更快的构建时间并简化我们的管道。 在 v15 中，我们现在有了实验性的 Sass、SVG 模板、文件替换和 ng build –watch 支持！请通过以下位置更新您的构建器来尝试 esbuild angular.json： 将 browser builder 12&quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot; 修改为 browser-esbuild browser 1&quot;builder&quot;: &quot;@angular-devkit/build-angular:browser-esbuild&quot; 11. 语言服务中的自动导入语言服务现在可以自动导入您在模板中使用但尚未添加到独立组件或 NgModule 中的组件。 12. CLI 改进在 Angular CLI 中，我们引入了对 standalone 稳定 API 的支持。现在，您可以通过 ng g 组件生成一个新的独立组件——standalone。我们还肩负着简化 ng new 输出的使命。作为第一步，我们通过删除 test.ts、polyfills.ts 和 environments 来减少配置。现在，您可以在 polyfills 部分的 angular.json 中直接指定您的 polyfills： 12345&quot;polyfills&quot;: [ &quot;zone.js&quot;] 为了进一步减少配置开销，我们现在使用.browserlist 来定义目标 ECMAScript 版本。 13. 社区贡献亮点我们很高兴与大家分享，自 v14 发布以来，我们收到了来自框架、组件和 CLI 的 210 多人的贡献！在本节中，我想重点介绍其中的两个。 13.1. 提供配置 DatePipe 默认选项的功能Matthias Weiß 的此功能允许您全局更改 DatePipe 的默认格式配置。下面是新 bootstrapApplication API 的示例： 12345678bootstrapApplication(AppComponent, { providers: [ { provide: DATE_PIPE_DEFAULT_OPTIONS, useValue: { dateFormat: &quot;shortDate&quot; }, }, ],}); 上面的配置将为您在应用程序中使用 DatePipe 的所有位置启用 shortDate 格式。 13.2. 在 SSR 期间为优先级图像添加＜ link ＞预加载标签为了确保尽快加载优先图像，Jay Bell 在图像指令中添加了一项功能，在使用 Angular Universal 时为其添加了&lt;link rel=“preload”&gt;标签。如果您已经启用了 image 指令，您则无需在执行任何操作。如果已将图像指定为优先，则指令将自动预加载该图像。 14. 弃用主要版本使我们能够使框架朝着简单、更好的开发人员体验和与 web 平台保持一致的方向发展。 在分析了谷歌内部数千个项目后，我们发现很少有人使用在大多数情况下被滥用的模式。因此，我们反对providedIn：“any”是一个选项，除了框架内部的少数深奥案例外，它的用途非常有限。 我们也在弃用providedIn: NgModule。它没有广泛的用途，在大多数情况下使用不正确，在您应该更喜欢providedIn:'root'的情况下。如果您确实应该将提供程序的范围限定为特定的 NgModule，请改用 NgModule.providers。 随着 CSS 布局的不断发展，团队将停止发布新版本的@angular/flex 布局。我们将在明年继续提供安全和浏览器兼容性修复程序。您可以在我们的“现代 CSS”系列的第一篇博客文章中了解更多信息。 15. 对接下来的事情感到兴奋Ivy 在 2020 年的推出带来了许多全面的改进，你可以发现这些改进已经在推广。可选 NgModules 就是一个很好的例子。它有助于减少初学者在关键学习过程中需要处理的概念，并通过独立指令支持指令组合 API 等高级功能。 接下来，我们将在服务器端渲染管道和反应性方面进行改进，同时全面提高生活质量！ 迫不及待地想与您分享下一步的进展！ 16. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular合集 | 鹏叔的技术博客","link":"/angular/angular_15_update.html"},{"title":"Angular 16 有哪些更新?","text":"六个月前，我们通过将 standalone API 从开发者预览版中升级到稳定版，在 Angular 的简单性和开发者体验方面达到了一个重要的里程碑。今天，我们很高兴与大家分享，我们将继续保持 Angular 的势头，推出自 Angular 首次推出以来最大规模的版本, 在反应性、服务器端渲染和工具方面取得了巨大飞跃。所有这些都伴随着针对功能请求的数十项用户体验改进，GitHub 上总共有超过 2500 个点赞！ 这篇文章包含大量内容，涵盖了我们在过去六个月中所做的大部分改进。 1. 重新思考反应性作为 v16 版本的一部分，我们很高兴与大家分享 Angular 全新反应性模型的开发者预览版，该模型显着改进了性能和开发者体验。 它完全向后兼容并与当前系统互操作，并支持： 通过减少变更检测期间的计算数量来提高运行时性能。一旦 Angular Signals 完全推出，我们预计使用信号构建的应用程序的INP Core Web Vital 指标将得到显着改进 为反应性带来更简单的心智模型，明确视图的依赖关系是什么以及应用程序中的数据流是什么 启用细粒度的反应性，在未来的版本中，我们将仅检查受影响组件中的更改 通过在模型更改时使用信号通知框架，使 Zone.js 在未来版本中成为可选项 提供计算属性，而无需在每个更改检测周期中重新计算 通过概述引入反应性输入的计划，实现与 RxJS 更好的互操作性 最初的 GitHub 讨论收到了 682 条评论，此后我们分享了一系列 RFC，又收到了 1000 多条评论！ 在 v16 中，您可以找到一个新的信号库，它是@angular/coreRxJS 互操作包的一部分 @angular/core/rxjs-interop 框架中的完整信号集成将于今年晚些时候推出。 2. Angular SignalsAngular Signals 库允许您定义反应值并表达它们之间的依赖关系。您可以在相应的 RFC中了解有关该库属性的更多信息。以下是一个如何将它与 Angular 一起使用的简单示例： 1234567891011121314151617181920@Component({ selector: &quot;my-app&quot;, standalone: true, template: ` {{ fullName() }} &lt;button (click)=&quot;setName('John')&quot;&gt;Click&lt;/button&gt; `,})export class App { firstName = signal(&quot;Jane&quot;); lastName = signal(&quot;Doe&quot;); fullName = computed(() =&gt; `${this.firstName()} ${this.lastName()}`); constructor() { effect(() =&gt; console.log(&quot;Name changed:&quot;, this.fullName())); } setName(newName: string) { this.firstName.set(newName); }} 上面的代码片段创建了一个计算值 fullName，该值取决于信号 firstName 和 lastName。我们还声明了一个效果，每次我们更改它读取的任何信号的值时都会执行该回调 - 在本例中 fullName，这意味着它也传递地依赖于 firstName 和 lastName。 当我们将 的值设置 firstName 为“John”时，浏览器将登录到控制台： 123&quot;Name changed: John Doe&quot; 2.1. RxJS 互操作性@angular/core/rxjs-interop 作为 v16 版本的一部分，您将能够通过开发者预览版中的函数轻松地将信号“提升”到可观察量！ 以下是将信号转换为可观察信号的方法： 12345678910111213import { toObservable } from '@angular/core/rxjs-interop';@Component({...})export class App { count = signal(0); count$ = toObservable(this.count); ngOnInit() { this.count$.subscribe(() =&gt; ...); }} 这是一个如何将可观察量转换为信号以避免使用异步管道的示例： 123456789import { toSignal } from &quot;@angular/core/rxjs-interop&quot;;@Component({ template: ` &lt;li *ngFor=&quot;let row of data()&quot;&gt;{{ row }}&lt;/li&gt; `,})export class App { dataService = inject(DataService); data = toSignal(this.dataService.data$, []);} Angular 用户通常希望在相关主题完成时完成流。以下说明性模式非常常见： 123456789destroyed$ = new ReplaySubject&lt;void&gt;(1);data$ = http.get('...').pipe(takeUntil(this.destroyed$));ngOnDestroy() { this.destroyed$.next();} 我们引入了一个名为 takeUntilDestroyed 的新 RxJS 运算符，它将此示例简化为以下内容： 1data$ = http.get(&quot;…&quot;).pipe(takeUntilDestroyed()); 默认情况下，此操作符将注入当前清理上下文。例如，在组件中使用时，它将使用组件的生命周期。当您想将 Observable 的生命周期与特定组件的生命周期联系起来时，takeUntilDestroyed 特别有用。 2.2. 下一步我们将会针对信号做些什么?接下来，我们将研究基于信号的组件，这些组件具有一组简化的生命周期钩子，以及一种更简单的声明式输入和输出的替代方法。我们还将编写一套更完整的示例和文档。Angular 存储库中最受欢迎的问题之一是“Proposal:Input as Observable”。几个月前，我们回应说，我们希望支持这个用例，作为框架中更大努力的一部分。我们很高兴与大家分享，今年晚些时候，我们将推出一项功能，该功能将启用基于信号的输入——您将能够通过 interop 包将输入转换为可观测值！ 3. 服务器端渲染和水合根据我们的年度开发者调查，服务器端渲染是 Angular 改进的首要机会。在过去的几个月里，我们与 Chrome Aurora 团队合作，提高了水合 DX 和服务器端渲染的性能。今天我们很高兴分享全应用无损水合的开发者预览！ 在新的完整应用程序无损水合作用中，Angular 不再从头开始重新渲染应用程序。相反，该框架在构建内部数据结构时查找现有的 DOM 节点，并将事件侦听器附加到这些节点。 好处是： 对于最终用户来说，页面上没有内容闪烁 在某些情况下更好的 Web Core Vitals 面向未来的架构，支持使用我们将于今年晚些时候发布的原语进行细粒度代码加载。目前，这在渐进式懒惰路线补水中表现出来 只需几行代码即可轻松与现有应用程序集成（请参阅下面的代码片段） ngSkipHydration 对于执行手动 DOM 操作的组件，逐步采用模板中的属性来实现水合 在早期测试中，我们发现在应用程序完全水合作用的情况下， Largest Contentful Paint 的性能提升高达 45% ！ 一些应用程序已经在生产中启用了水合作用，并报告了 CWV 的改进. 要开始它就像在您的中添加几行一样简单 main.ts： 123456789101112import { bootstrapApplication, provideClientHydration,} from '@angular/platform-browser';...bootstrapApplication(RootCmp, { providers: [provideClientHydration()]}); 您可以在文档中找到有关其工作原理的更多详细信息。 3.1. 新的服务器端渲染功能作为 v16 版本的一部分，我们还更新了 Angular Universal 的 ng add schematics，使您能够使用 standalone API 将服务器端渲染添加到项目中。我们还引入了对内联样式更严格的内容安全策略的支持。 3.2. 水合和服务器端渲染的后续步骤我们计划在这里做更多的事情，v16 中的工作只是一个垫脚石。在某些情况下，有机会延迟加载对于页面来说并不重要的 JavaScript，并在稍后水合相关组件。这种技术称为部分水合，我们接下来将对其进行探讨。 自从 Qwik 从 Google 的闭源框架 Wiz 中推广了可恢复性的想法以来，我们收到了许多对 Angular 中的此功能的请求。可恢复性肯定是我们关注的焦点，我们正在与 Wiz 团队密切合作来探索这一领域。我们对它所带来的开发人员体验限制持谨慎态度，评估不同的权衡，并在我们取得进展时随时向您通报。 您可以在“ Angular 中服务器端渲染的下一步是什么”中了解有关我们未来计划的更多信息。 4. 改进了独立组件、指令和管道的工具Angular 是数百万开发人员用于许多关键任务应用程序的框架，我们认真对待重大更改。我们几年前就开始探索 standalone API，2022 年我们在开发者预览下发布了它们。现在，经过一年多的收集反馈和对 API 的迭代，我们希望鼓励更广泛的采用！ 为了支持开发人员将其应用程序转换为独立 API，我们开发了迁移 schematics 和 standalone 迁移指南。一旦进入项目目录，请运行： 1ng generate@angular/core:standalone 这个 schematic 将转换您的代码，删除不必要的 NgModules 类，并最终将项目的引导程序更改为使用独立的 API。 5. 可以使用 standalone 选项创建项目作为 Angular v16 的一部分，您可以从一开始使用 standalone 选项创建新项目！要尝试 standalone schematics 的开发者预览版，请确保您使用的是 Angular CLI v16 并运行： 1ng new --standalone 您将获得更简单的项目结构，无需任何 NgModules. 此外，项目中的所有生成器都将生成独立的指令、组件和管道！ 6. 配置 Zone.js在 standalone API 首次发布后，我们从开发人员那里得知, 您希望能够使用新 bootstrapApplication API 配置 Zone.js。 我们为此添加了一个选项 provideZoneChangeDetection： 123bootstrapApplication(App, { providers: [provideZoneChangeDetection({ eventCoalescing: true })],}); 7. 加强开发人员工具现在，让我们分享 Angular CLI 和语言服务(language service)的一些功能亮点。 7.1. 基于 esbuild 构建系统的开发者预览版一年前，我们宣布我们正在 Angular CLI 中对 esbuild 进行实验性支持，以使您的构建速度更快。今天，我们很高兴与大家分享，我们基于 esbuild 的构建系统在 v16 中进入了开发者预览版！早期测试显示 cold production 构建提高了 72% 以上。 我们 ng serve 现在使用 Vite 作为开发服务器，esbuild 既为开发环境也为生产环境构建提供支持！ 我们想强调的是，Angular CLI 完全依赖 Vite 作为开发服务器。为了支持选择器匹配，Angular 编译器需要维护组件之间的依赖关系图，这需要与 Vite 不同的编译模型。 您可以通过更新 angular.json 以下内容来尝试 Vite + esbuild 123456...&quot;architect&quot; : { &quot;build&quot; : { /* 添加 esbuild 后缀 */ &quot;builder&quot; : &quot;@angular-devkit/build-angular:browser-esbuild&quot; , ... 接下来，我们将在该项目退出开发者预览版之前解决对 i18n 的支持问题。 8. 使用 Jest 和 Web Test Runner 更好地进行单元测试根据 Angular 和更广泛的 JavaScript 社区的开发人员调查，Jest 是最受欢迎的测试框架和测试运行程序之一。我们收到了大量支持 Jest 的请求，由于不需要真正的浏览器，因此降低了复杂性。 今天，我们很高兴地宣布我们将推出实验性 Jest 支持。在未来的版本中，我们还将把现有的 Karma 项目移至 Web Test Runner，以继续支持基于浏览器的单元测试。这对于大多数开发人员来说不需要做什么事情。 npm install jest --save-dev您可以通过安装 Jest 并更新 angular.json 文件来在新项目中试验 Jest： 123456789101112131415{ &quot;projects&quot;: { &quot;my-app&quot;: { &quot;architect&quot;: { &quot;test&quot;: { &quot;builder&quot;: &quot;@angular-devkit/build-angular:jest&quot;, &quot;options&quot;: { &quot;tsConfig&quot;: &quot;tsconfig.spec.json&quot;, &quot;polyfills&quot;: [&quot;zone.js&quot;, &quot;zone.js/testing&quot;] } } } } }} 您可以在我们最近的博客文章中了解有关我们未来的单元测试策略的更多信息。 9. 模板中的自动完成导入您有多少次在模板中使用组件或管道从 CLI 或语言服务中收到错误，表明您实际上没有导入相应的实现？ Language service 插件现在允许自动导入组件和管道了。 10. 还有更多在 v16 中，我们还启用了对 TypeScript 5.0 的支持，支持 ECMAScript 装饰器，消除了 ngcc 的开销，在 standalone 应用程序中添加了对 Service Worker 和 app shell 的支持，扩展了 CLI 中的 CSP 支持等等！ 11. 改善开发者体验除了我们关注的大型计划之外，我们还致力于带来开发者强烈要求的功能。 11.1. Required inputs自从我们在 2016 年引入 Angular 以来，如果不为特定 input 指定值，就不可能出现编译时错误。由于 Angular 编译器在构建时执行检查，因此该更改在运行时增加了开销。多年来，开发人员一直 要求 此功能，我们得到了强烈的迹象表明 这个需求的实现将为开发者带来非常大的方便！ 在 v16 中，现在您可以根据需要标记 Required inputs： 1234@Component(...)export class App { @Input({ required: true }) title: string = '';} 11.2. 将路由数据作为组件输入传递路由的开发者体验一直在快速进步。GitHub 上的一个流行功能请求是要求能够将路由参数绑定到相应组件的输入。我们很高兴与大家分享，此功能现已作为 v16 版本的一部分提供！ 现在您可以将以下数据传递到路由组件的 input 属性： 路由数据 —— 解析器和数据属性 路径参数 查询参数 以下是如何从路由解析访问数据的示例： 123456789101112131415const routes = [ { path: 'about', loadComponent: import('./about'), resolve: { contact: () =&gt; getContact() } }];@Component(...)export class About { // The value of &quot;contact&quot; is passed to the contact input @Input() contact?: string;} 您可以通过使用 withComponentInputBinding 作为 provideRouter 的一部分来启用此功能。 12. CSP 对内联样式的支持Angular 在组件样式的 DOM 中包含的内联样式元素违反了默认的 style-src 内容安全策略 (CSP)。要解决此问题，它们应该包含一个 nonce 属性，或者服务器应该在 CSP 标头中包含样式内容的哈希值。尽管在 Google 我们没有找到针对此漏洞的有意义的攻击向量，但许多公司都执行严格的 CSP，导致 Angular 存储库上的功能请求流行起来。 nonce 在 Angular v16 中，我们实现了一项涵盖框架、Universal、CDK、Material 和 CLI 的新功能，它允许您为 Angular 内联的组件的样式指定属性。有两种方法可以指定随机数：使用属性 ngCspNonce 或通过 CSP_NONCE 注入令牌。 ngCspNonce 如果您有权访问服务器端模板，该模板可以将两者添加 nonce 到标头并 index.html 在构造响应时添加，则该属性非常有用。 12345&lt;html&gt; &lt;body&gt; &lt;app ngCspNonce=&quot;{% nonce %}&quot;&gt;&lt;/app&gt; &lt;/body&gt;&lt;/html&gt; 指定随机数的另一种方法是通过 CSP_NONCE 注入令牌。如果您有权在运行时访问 nonce 并且希望能够缓存以下内容，请使用此方法 index.html： 1234567891011import { bootstrapApplication, CSP_NONCE } from &quot;@angular/core&quot;;import { AppComponent } from &quot;./app/app.component&quot;;bootstrapApplication(AppComponent, { providers: [ { provide: CSP_NONCE, useValue: globalThis.myRandomNonceValue, }, ],}); 13. 灵活的 ngOnDestroyAngular 的生命周期钩子提供了强大的功能来插入应用程序执行的不同时刻。多年来的一个机会是实现更高的灵活性，例如，提供对 OnDestroy 作为 observable 的访问。 在 v16 中，我们使 OnDestroy 可注入，从而实现了开发人员一直要求的灵活性。这个新功能允许您注入 DestroyRef 对应的组件、指令、服务或管道 - 并注册 onDestroy 生命周期挂钩。可以 DestroyRef 在注入上下文中的任何位置注入，包括组件外部——在这种情况下，onDestroy 当相应的注入器被销毁时，钩子就会被执行： 123456789101112import { Injectable, DestroyRef } from '@angular/core';@Injectable(...)export class AppService { destroyRef = inject(DestroyRef); destroy() { this.destroyRef.onDestroy(() =&gt; /* cleanup */ ); }} 14. 自闭合标签我们最近实现的一项备受期待的功能允许您在 Angular 模板中的组件中使用自闭合标签。这是一个小的开发人员体验改进，可以帮助您节省一些打字时间！ 现在您可以替换： 12&lt;super-duper-long-component-name [ prop ]=&quot;someVar&quot;&gt;&lt;/super-duper-long-component-name&gt; 有了这个： 1&lt;super-duper-long-component-name [ prop ]=&quot;someVar&quot; /&gt; 15. 更好、更灵活的组件在过去的几个季度中，我们与 Google 的 Material Design 团队密切合作，为使用 Angular Material 的 Web 提供参考 Material 3 实现。我们于 2022 年发布的基于 Web 的 MDC 组件为这项工作奠定了基础。 下一步，我们正努力在今年晚些时候推出一个富有表现力的基于 Token 的主题 API，以实现 Angular 材质组件的更高程度的定制。 提醒您，我们将在 v17 中删除旧的、基于非 MDC 的组件。请务必遵循我们的迁移指南以迁移到最新版本。 16. 继续我们的无障碍倡议遵循 Google 的使命，Angular 让您可以为每个人构建 Web 应用程序！这就是为什么我们不断投资以提高 Angular CDK 和 Material 组件的可访问性。 17. 社区贡献亮点我们想要强调的社区引入的两个功能是： Matthieu Riegler 正确使用 ngSkipHydration 的扩展诊断 Julien Saguet 引入 provideServiceWorker, 使得使用 Service Worker 无需使用 NgModules. 超过 175 人在 GitHub 上为 v16 做出了贡献，还有数千人通过博客文章、演讲、播客、视频、对反应性 RFC 的评论等做出了贡献。 我们要向所有帮助我们使这个版本变得特别的人表示衷心的感谢。 18. 让我们一起保持前进的动力Angular 16 是明年 Angular 反应性和服务器端渲染未来改进的垫脚石。我们将通过开发人员体验和性能方面的创新来推动 Web 向前发展，同时使您能够为每个人进行构建！ 您可以成为 Angular Momentum 的一部分，并通过在即将发布的 RFC、调查或社交媒体中分享您的想法来帮助我们塑造框架的未来。 感谢您成为 Angular 社区的一员。我们迫不及待地想让您尝试这些功能！❤️ 19. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular 专题 | 鹏叔的技术博客 20. 参考文档Angular v16 is here!","link":"/angular/angular_16_update.html"},{"title":"Angular 17 有哪些更新?","text":"上个月是 Angular 红盾诞生 13 周年。AngularJS 是新一波 JavaScript 框架的起点，旨在支持对丰富 Web 体验日益增长的需求。今天，我们凭借新的外观和一系列前瞻性功能，通过版本 17 带领大家走向未来，为性能和开发人员体验设定了新标准。 在 v17 中，我们很高兴地介绍： 可延迟视图(Deferrable views)将性能和开发人员体验提升到一个新的水平 在公共基准测试中，通过内置控制流循环，运行时间提高了 90% 混合渲染的构建速度提高了 87%，客户端渲染的构建速度提高了 67% 全新的外观反映了 Angular 的未来特征 全新的互动学习之旅 以及许多其他功能和改进！ 1. 面向未来的品牌形象在过去的几个版本中，Angular 的复兴一直在全力推进中。我们一直在通过 signal-based 反应性、水合(hydration)、独立组件(standalone components)、指令组合和许多其他功能等改进来加快势头。尽管 Angular 发展迅速，但它的品牌却未能跟上—从 AngularJS 早期以来，它几乎一模一样。 今天，您喜爱的、经过数百万开发者考验的框架焕然一新，反映了其面向未来的开发者体验和性能！ 2. 面向未来的文档与新品牌一起，我们还为 Angular 文档开发了一个新网站 — angular.dev。对于新的文档网站，我们采用了新的结构、新的指南、改进的内容，并构建了一个交互式学习之旅平台，让您可以直接在浏览器中按照自己的节奏学习 Angular 和 Angular CLI。 新的交互式学习体验由 WebContainers 提供支持，让您可以在任何现代 Web 浏览器中使用 Angular CLI 的强大功能！ 今天，我们将推出 angular.dev 的 Beta 预览版，并计划将其设为 v18 中 Angular 的默认网站。您可以在“宣布 angular.dev”中了解有关 Angular 新外观和angular.dev 的更多信息。” 现在让我深入了解 v17 的功能，我们迫不及待地想告诉您！ 3. 内置控制流程为了改善开发人员体验，我们发布了新的块模板语法，通过简单的声明性 API 为您提供强大的功能。在底层，Angular 编译器将语法转换为高效的 JavaScript 指令，可以执行控制流、延迟加载等。 我们使用新的块语法来实现优化的内置控制流。在进行用户研究后，我们发现许多开发人员都在为*ngIf、*ngSwitch 和 *ngFor 而苦苦挣扎。自 2016 年开始使用 Angular 并在过去 5 年里成为 Angular 团队的一员，我个人仍然需要查找*ngFor 和的语法 trackBy。在收集了社区、合作伙伴的反馈并进行了用户体验研究之后，我们为 Angular 开发了一个新的内置控制流程！ 内置控制流程可以： 更符合人体工程学的语法，更接近 JavaScript，因此更直观，减少帮助文档的查找 得益于更优化的类型收敛（type narrowing），类型检查得到了很好的改善 内置控制流是构建阶段核心处理的部分，除了大大减少运行时的消耗（甚至直接消失）之外，还将使你的应用程序包大小整体减少 30KB 之多，从而进一步提高应用的核心网络指标（Core Web Vital）的得分 无需额外导入，即可在模版中通过变量来使用 我们稍后会介绍显着的性能改进 3.1. 条件语句让我们看一下内置控制流中的 if 与 *ngIf 的 side by side 比较 12&lt;div *ngIf=&quot;loggedIn; else anonymousUser&quot;&gt;The user is logged in&lt;/div&gt;&lt;ng-template #anonymousUser&gt; The user is not logged in &lt;/ng-template&gt; 使用内置控制流 if 语句，此条件将如下所示： 1234567@if (loggedIn) { The user is logged in} @else { The user is not logged in} @else 与传统的 else 子句相比，能够直接提供内容是对 ngIf 一个重大的简化。当前的控制流也使得拥有@else if 条件语句变得轻而易举，这在历史版本中几乎是是不可能的。 ngSwitch 人体工学改进的更加明显： 12345&lt;div [ngSwitch]=&quot;accessLevel&quot;&gt; &lt;admin-dashboard *ngSwitchCase=&quot;admin&quot; /&gt; &lt;moderator-dashboard *ngSwitchCase=&quot;moderator&quot; /&gt; &lt;user-dashboard *ngSwitchDefault /&gt;&lt;/div&gt; 通过内置控制流程，它变成： 123@switch (accessLevel) { @case ( 'admin' ) { &lt;admin-dashboard/&gt; } @case ( ' moderator ' ) { &lt;moderator-dashboard/&gt; } @default { &lt; user -dashboard/&gt; } } 新的控制流可以在各个流程分支中更好地缩小类型，使用 ngSwitch 是做不到这一点的. 3.2. for 循环我最喜欢的更新之一是我们引入的内置 for 循环，它除了开发人员体验改进之外，还将 Angular 的渲染速度推向了另一个水平！ 其基本语法是： 12345@for (user of users; track user.id) { {{ user.name }}} @empty { Empty list of users} 当使用 ngFor 时我们经常看到应用程序由于缺乏 trackBy 功能而出现性能问题。一些区别是@for，track 是强制性的，以确保快速比较性能。此外，它更容易使用，因为它只是一个表达式而不是组件类中的方法。内置@for 循环还具有通过 optional @empty 快捷处理空集合。 @for 语句使用了新的 diffing 算法，并且与 ngFor 相比具有更优化的实现，这使得社区框架基准测试的运行时间提高了 90% ！ 3.3. 尝试内置控制流内置控制流现已在 v17 的开发者预览版中提供！ 内置控制流的设计目标之一是实现完全自动化的迁移。要在现有项目中尝试它，请使用以下迁移： 1ng generate @angular/core:control-flow 3.4. 接下来我们将会做些什么您已经可以使用带有最新语言服务的内置控制流，我们与 JetBrains 密切合作，以便在他们的产品中提供更好的支持。我们还与 Prettier 的 Sosuke Suzuki 联系，以确保 Angular 模板的格式正确。 ngIf 与、ngFor、ngSwitch 和相比内置控制流处理 content projection 的方式仍然存在一些差异，我们将在接下来的几个月内解决这些问题。除此之外，我们对内置控制流的实现和稳定性充满信心，所以您今天就可以尝试一下！我们希望将其保留在开发者预览版中，直到下一个主要版本，以便我们可以为潜在的向后不兼容修复打开大门，以便我们找到更多进一步增强开发者体验的机会. 4. 可延迟视图(Deferrable views)现在让我们谈谈延迟加载的未来！利用新的块语法，我们开发了一种新的强大机制，您可以使用它来使您的应用程序更快。在博客文章的开头，我说过可延迟视图将性能和开发人员体验提升到了一个新的水平，因为它们通过前所未有的人体工程学实现了声明性和强大的延迟加载(deferred loading)。 假设您有一个博客，并且您想延迟加载用户评论列表。目前，您必须在使用的 ViewContainerRef 同时管理清理的所有复杂性、管理加载错误、显示占位符等。处理各种极端情况可能会导致一些复杂度高极高的代码，这将难以测试和调试。 新的可延迟视图允许您使用一行声明性代码延迟加载注释列表及其所有传递依赖项： 123@defer { &lt;comment-list /&gt;} 当某个 DOM 元素进入视口时开始延迟加载组件涉及许多更重要的逻辑和 IntersectionObserver API。Angular 使 IntersectionObservers 的使用变得简单到只需要添加可延迟视图触发器即可！ 123456@defer (on viewport) { &lt;comment-list /&gt;} @placeholder { &lt;!-- A placeholder content to show until the comments load --&gt; &lt;img src=&quot;comments-placeholder.png&quot;&gt;} 在上面的示例中，Angular 首先渲染占位符块的内容。当它在视口中可见时，组件就会开始加载。加载完成后，Angular 会删除占位符并渲染组件。 还有用于加载和错误状态的块： 1234567891011@defer (on viewport) { &lt;comment-list/&gt;} @loading { Loading…} @error { Loading failed :(} @placeholder { &lt;img src=&quot;comments-placeholder.png&quot;&gt;} 就是这样！Angular 为您管理了大量的复杂性。 可延迟视图提供了更多触发器： on idle- 当浏览器不做任何繁重的工作时延迟加载块 on immediate— 自动开始延迟加载，不阻塞浏览器 on timer()— 使用计时器延迟加载 on viewport 并且 on viewport()- 视口还允许指定锚元素的引用。当锚元素可见时，Angular 将延迟加载组件并渲染它 on interaction 并且 on interaction()- 使您能够在用户与特定元素交互时启动延迟加载 on hoverand on hover()- 当用户悬停元素时触发延迟加载 when — 使您能够通过布尔表达式指定您自己的条件 可延迟视图还提供了在渲染依赖项之前预取依赖项的能力。添加预取就像 prefetch 向 defer 块添加语句一样简单，并且支持所有相同的触发器。 123@defer (on viewport; prefetch on idle) { &lt;comment-list /&gt;} 今天，可延迟视图在 v17 的开发者预览版中可用！[了解有关本指南中该功能的更多信息。 4.1. 下一步可延迟视图将会如何发展？可延迟视图已准备好使用，我们强烈鼓励您尝试一下！我们将它们保留在开发人员预览中的原因是这样我们可以收集更多反馈并在 API 表面中引入更改，直到我们将它们锁定为像框架的其余部分一样遵循语义版本控制。 目前，服务器端渲染将渲染指定的占位符。一旦框架加载应用程序并对其进行水合，可延迟视图将按照我们上面描述的方式工作。 下一步，我们将探索在服务器上渲染延迟块内的内容，并在客户端上启用部分水合作用。在这种情况下，客户端不会下载延迟视图的代码，直到触发器请求它。此时，Angular 将下载相关的 JavaScript 并仅对视图的这一部分进行水合。 还将有许多令人兴奋的信号互操作性，敬请期待！ 5. 改进的混合渲染体验今天，我们通过以下一行提示让开发人员开启服务器端渲染 (SSR) 和静态站点生成（SSG 或预渲染） 123ng new 这是我们长期以来一直想要做出的改变，但首先我们希望对 Angular 的 SSR 开发人员体验充满信心。 或者，您可以通过以下方式在新项目中启用 SSR： 1ng new my-app --ssr 6. Hydration 从开发者预览版毕业在过去的 6 个月里，我们看到数千个应用程序采用了水合作用。今天，我们很高兴地宣布，水合作用已不再是开发者预览版，并且在所有使用服务器端渲染的新应用程序中默认启用！ 新的 @angular/ssr 包我们将 Angular 通用存储库移至 Angular CLI 存储库，并使服务器端渲染成为我们工具产品中更不可或缺的一部分！ 从今天开始，要向现有应用程序添加混合渲染支持，请运行： 123ng add @angular/ssr 此命令将生成服务器入口点，添加 SSR 和 SSG 构建功能，并默认启用水合。@angular/ssr 提供与@nguniversal/express-engine 当前处于维护模式的功能等效的功能。如果您使用的是 express-engine，Angular CLI 会自动将您的代码更新为@angular/ssr. 从旧平台迁移到最新的 Angular 混合渲染解决方案后，Virgin Media O2 的销售额增长了 112%。NgOptimizedImage 通过与 Angular SSR 和 DOM Hydration 结合使用，累积布局偏移平均减少了 99.4% 。 7. 使用 SSR 部署您的应用程序为了进一步增强开发人员体验，我们与云提供商密切合作，以实现顺利部署到他们的平台。 Firebase 现在将通过其新的框架感知 CLI 的早期预览版，以接近零的配置自动识别和部署您的 Angular 应用程序。 12345firebase experiments:enable webframeworksfirebase init hostingfirebase deploy 框架感知(framework-aware)的 CLI 可识别 SSR、i18n、图像优化等的使用，使您能够在经济高效的无服务器基础设施上提供高性能的 Web 应用程序。 对于那些拥有复杂 Angular monorepos 或只是喜欢本机工具的人，AngularFire 允许使用以下方式部署到 Firebase ng deploy： 1234ng add @angular/fireng deploy 为了能够部署到边缘工作人员，我们在 Angular 的服务器端渲染中启用了 ECMAScript 模块支持，引入了 fetch 后端 HttpClient，并与 CloudFlare 合作来简化流程。 8. 新的生命周期钩子为了提高 Angular 的 SSR 和 SSG 的性能，从长远来看，我们希望摆脱 DOM 模拟和直接 DOM 操作。同时，在大多数应用程序的生命周期中，它们需要与元素交互以实例化第三方库、测量元素大小等。 为了实现这一点，我们开发了一组新的生命周期挂钩： afterRender— 注册每次应用程序完成渲染时调用的回调 afterNextRender— 注册一个回调，以便在下次应用程序完成渲染时调用 只有浏览器才会调用这些钩子，这使您能够将自定义 DOM 逻辑安全地直接插入组件中。例如，如果您想实例化一个图表库，您可以使用 1234567891011121314151617@Component({ selector: &quot;my-chart-cmp&quot;, template: `&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`,})export class MyChartCmp { @ViewChild(&quot;chart&quot;) chartRef: ElementRef; chart: MyChart | null; constructor() { afterNextRender( () =&gt; { this.chart = new MyChart(this.chartRef.nativeElement); }, { phase: AfterRenderPhase.Write } ); }} 每个钩子都支持一个阶段值（例如读、写），Angular 将使用该阶段值来安排回调以减少布局抖动并提高性能。 9. 新项目默认使用 Vite 和 esbuild 如果没有对 Angular CLI 的构建管道进行根本性的改变，我们从一开始就无法在 Angular 中启用 SSR！ 在 v16 中，我们引入了 esbuild 和 Vite 支持的构建体验的开发者预览版。从那时起，许多开发人员和一些企业合作伙伴都尝试了它，报告称他们的一些应用程序的构建时间缩短了 67% ！今天，我们很高兴地宣布，新的应用程序构建器已从开发者预览版中毕业，并且默认为所有新应用程序启用！ 此外，我们还更新了使用混合渲染时的构建管道。借助 SSR 和 SSG，您可以观察到 ng build 的速度提高了 87%，ng serve 时修改刷新 loop 速度提高了 80%。 在未来的次要版本中，我们将提供 schematics，以使用混合渲染（​​ 使用 SSG 或 SSR 进行客户端渲染）自动迁移现有项目。如果您今天想测试新的应用程序构建器，请查看我们文档中的指南。 10. DevTools 中的依赖注入调试去年，我们展示了 Angular DevTools 中依赖注入调试功能的预览。在过去的几个月里，我们实现了全新的调试 API，使我们能够插入框架的运行时并检查注入器树。 基于这些 API，我们构建了一个检查用户界面，允许您预览： 组件检查器中组件的依赖关系 注入器树和依赖解析路径 在各个注入器中声明的 Providers 您可以在下面的动画中快速预览这些功能。在 angular.io 上了解有关Angular DevTools 的更多信息。 下一步，我们将完善 UI 并致力于更好地可视化注入器层次结构、providers 及其分辨率。 11. 从项目创建时就使用 Standalone API在过去一年半的时间里收集了独立组件、指令和管道的反馈并完善了它们的 DevEx 后，我们有信心从一开始就在所有新应用程序中启用它们。所有 ng generate 命令现在都将构建独立组件、指令和管道。 与此同时，我们还重新审视了 Angular.io 和 Angular.dev 的整个文档，以确保一致的学习体验、开发实践和建议。 在可预见的将来，我们将保留 NgModules，但看到新的独立 API 的好处，我们强烈建议您逐步将项目迁移到它们。我们还提供了一个示意图，可以为您自动完成大部分工作： 1ng generate @angular/core:standalone 有关更多信息，请查看我们的迁移指南。 12. reactivity 的后续计划Angular 新的基于信号的reactive系统是我们在该框架中所做的最大转变之一。为了确保与基于 Zone.js 的变更检测的向后兼容性和互操作性，我们一直在努力制作原型并设计前进的道路。 今天，我们很高兴地宣布 Angular Signals 实现已通过开发者预览版。目前，我们将将该 effect 函数保留在开发人员预览状态下，以便我们可以进一步迭代其语义。 在接下来的几个月中，我们将开始推出基于信号的输入、视图查询等功能。到明年 5 月，在 Angular v18 中，我们将提供许多功能来进一步改善开发人员使用 Signals 的体验。 13. testing 的后续计划我们将继续试验 Jest，并确保我们构建一个高性能、灵活且直观的解决方案，足以满足开发人员的需求。我们还开始尝试 Web Test Runner，并为初始实施提供了一个开放的 PR 。在不久的将来，我们可能会首先关注 Web Test Runner，以解锁那些渴望摆脱 Karma 的项目。 14. Material 3 的后续计划我们一直在与 Google 的 Material Design 团队努力合作，重构 Angular Material 的内部结构，以纳入Design token，该系统将为组件提供更多的自定义选项并启用Material 3支持。虽然我们还没有准备好为 v17 提供设计令牌和 M3 支持，但我们预计很快会在 v17 小版本中提供这些功能。 在 2022 年第四季度，我们宣布推出基于 MDC 的新 Angular Material 组件，并弃用具有相同功能但 DOM 结构和样式不同的旧组件。我们在 v15 中弃用了旧组件，并将在 v17 中删除。即使它们不属于 Angular Material v17 包的一部分，您仍然可以将应用程序更新到 Angular v17 并使用 v16 Angular Material 包。在 v18 之前，这将是一个选项，之后 Angular Material v16 将不再与较新版本的 Angular 兼容。我们还与HeroDevs的合作伙伴合作，他们将提供无休止的付费支持，以防您暂时无法执行迁移。 15. 开发体验改善除了所有这些面向未来的功能之外，我们还从待办事项中提供了一系列较小的开发人员体验增强功能！ 16. 实验性视图转换支持视图转换 API可在更改 DOM 时实现平滑转换。在 Angular 路由器中，我们现在通过该withViewTransitions功能提供对此 API 的直接支持。使用此功能，您可以使用浏览器的本机功能在路线之间创建动画过渡。 您现在可以通过在引导期间在路由器的提供程序声明中配置此功能来将此功能添加到您的应用程序中： 1234567bootstrapApplication(App, { providers: [ provideRouter(routes, withViewTransitions()), ]}); withViewTransitions接受带有 property 的可选配置对象onViewTransitionCreated，这是一个为您提供一些额外控制的回调： 决定是否要跳过特定动画 向文档添加类以自定义动画并在动画完成时删除这些类 等等。 17. 图像指令中的自动预连接Angular 图像指令现在会自动为您作为参数提供给图像加载器的域生成预连接链接。如果图像指令无法自动识别源并且未检测到 LCP 图像的预连接链接，它将在开发过程中发出警告。 在图像指令指南中了解有关此功能的更多信息。 18. 延迟加载动画模块此功能可以使您的初始捆绑包（压缩后的 16KB）减少 60KB。社区贡献者Matthieu Riegler提出并实现了一项功能，允许您通过异步提供程序函数延迟加载动画模块： 1234567import { provideAnimationsAsync } from '@angular/platform-browser/animations-async';bootstrapApplication(RootCmp, { providers: [provideAnimationsAsync()]}); 19. 输入值转换常见的模式是具有接收布尔输入的组件。然而，这对如何将值传递给此类组件设置了限制。例如，如果我们对 Expander 组件有以下定义： 12345678910@Component({ standalone: true, selector: 'my-expander', template: `…`})export class Expander { @Input() expanded: boolean = false;} …我们尝试将其用作： 123&lt;my-expander expanded/&gt; 您将收到“字符串不可分配给布尔值”的错误。输入值转换允许您通过配置输入装饰器来解决此问题： 12345678910@Component({ standalone: true, selector: 'my-expander', template: `…`})export class Expander { @Input({ transform: booleanAttribute }) expanded: boolean = false;} 您可以在 GitHub 上找到原始功能请求 -布尔属性作为 HTML 二进制属性。 20. 作为字符串的 Style 和 styleUrlsAngular 组件支持每个组件多个样式表。然而，绝大多数情况下，当我想要设置组件的样式时，我会创建一个数组，其中包含指向内联样式或引用外部样式表的单个元素。一项新功能使您可以切换： 1234567@Component({ styles: [` ... `]}) 12345@Component({ styleUrls: ['styles.css']}) 切换到更简单、更符合逻辑的形式： 1234567@Component({ styles: ` ... `}) 12345@Component({ styleUrl: 'styles.css'}) 当您使用数组时，我们仍然支持多个样式表。这更符合人体工程学，更直观，并且与自动格式化工具配合使用效果更好。 21. 社区schematics为了支持社区schematics的开发，我们提供了一些实用方法作为@schematics/angular/utility. 现在，您可以将表达式直接导入到 Angular 应用程序的根目录中，并将providers添加到 Angular 应用程序的package.json文件. 您可以在文档中的schematics指南中了解更多信息。 22. Angular 开发人员培训我们与EdTech交互式平台 SoloLearn 合作，基于我们最近开发的“ Angular 简介”课程开发了新的 Angular 培训。他们创建了一个互动学习之旅，在过去两个月内覆盖了超过 7 万人！ 请参阅我们最近的公告了解更多信息 23. 社区亮点我们要感谢 346 位贡献者，是他们让 Angular v17 变得如此特别！我们想列出一些亮点： HttpClient现在可以使用 fetch 作为后端，这是使 Angular 能够在边缘工作线程中运行的功能之一。我们要感谢Matthieu Riegler的帮助 Matthieu 还启用了自定义功能，HttpTransferCache允许对发布请求指定标头、过滤器和缓存 Cédric Exbrayat 在新的应用程序构建器中引入了支持namedChunks Thomas Laforge的Angular Challenges是一个优秀的资源网站，它一直在帮助 Angular 开发人员达到新的水平 AnalogJS一直在稳步发展并接近 1.0。祝贺布兰登·罗伯茨所做的出色工作！ 祝贺Santosh Yadav的Angular 初学者课程浏览量达到 100 万次 24. 用 Angular 构建未来在过去的六个月里，我们一直在继续 Angular 的复兴，发布了一些功能，以提供更好的开发人员体验和性能。今天，我们很高兴在 Angular 更新的品牌和angular.dev 的学习体验中体现出这种势头。 在下一个发布周期中，预计 Angular 基于信号的反应性、混合渲染和学习之旅将发生大量演变。 我们很荣幸能够成为您使用 Angular 构建未来的旅程的一部分！谢谢你！ 25. 参考文档Introducing Angular v17","link":"/angular/angular_17_update.html"},{"title":"Angular中的JIT与AOT","text":"1. 前言本文会聊聊 JIT 与 AOT 之间的区别，及前端框架中 AOT 的应用。Angular 同时提供这两种编译方案，下面我们用 Angular 举例说明两者的区别。 2. 前端框架的编译现代前端框架都需要“编译”这一步骤，用于： 将框架中描述的 UI 转换为宿主环境可识别的代码 代码转化，比如将 ts 编译为 js、实现 polyfill 等 执行一些编译时优化 代码打包、压缩、混淆 编译可以选择放在两个时机执行： 代码构建时，被称为 AOT(Ahead Of Time，提前编译或预编译)，宿主环境获得的是编译后的代码 代码在宿主环境执行时，被称为 JIT(Just In Time，即时编译)，代码在宿主环境编译并执行 3. AOT 和 JIT 的区别本文会聊聊两者的区别，及前端框架中 AOT 的应用。Angular 同时提供这两种编译方案，下面我们用 Angular 举例说明两者的区别。 考虑如下 Angular 代码： 1234567891011import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;app-root&quot;, template: &quot;&lt;h3&gt;{{getTitle()}}&lt;/h3&gt;&quot;,})export class AppComponent { public getTitle() { return &quot;Hello World&quot;; }} 定义 AppComponent，最终浏览器(作为宿主环境)渲染的结果为： 12345&lt;body&gt; &lt;app-root ng-version=&quot;13.3.1&quot;&gt; &lt;h3&gt;Hello World&lt;/h3&gt; &lt;/app-root&gt;&lt;/body&gt; 现在将模版中使用的 getTitle 方法修改为未定义的 getTitleXXX： 1234// 从template: &quot;&lt;h3&gt;{{getTitle()}}&lt;/h3&gt;&quot;;// 修改为template: &quot;&lt;h3&gt;{{getTitleXXX()}}&lt;/h3&gt;&quot;; 如果使用 AOT，编译后会立刻报错： 1Error occurs in template of component AppComponent 如果使用 JIT，编译后不会报错，代码在浏览器中执行时会报错：： 1Error TypeError: _co.get getTitleXXX is not a function 造成以上区别的原因是：当使用 JIT 时，构建阶段仅仅使用 tsc 将 ts 编译为 js 并将代码打包。 打包后的代码在浏览器运行后，执行到 Decorator(上例中的@Component 语句)时，Angular 的模版编译器才开始编译 template 字段包含的模版语法，并报错。 当使用 AOT 时，tsc、Angular 的模版编译器都会在构建阶段进行编译，所以会立刻发现 template 字段包含的错误。 除了以上区别外，JIT 与 AOT 的区别还包括： 使用 JIT 的应用在首次加载时慢于 AOT，因为其需要先编译代码，而使用 AOT 的应用已经在构建时完成编译，可以直接执行代码 使用 JIT 的应用代码体积普遍大于使用 AOT 的应用，因为在运行时会多出编译器代码 基于以上原因，在 Angular 中一般在开发环境使用 JIT，在生产环境使用 AOT。 从前端框架的角度看 AOT 可以用两个步骤描述前端框架的工作原理： 根据组件状态变化找到变化的 UI 将 UI 变化渲染为宿主环境的真实 UI 借助 AOT 对模版语法编译时的优化，就能减少步骤 1 的开销。 这是大部分采用模版语法描述 UI 的前端框架都会进行的优化，比如 Vue3、Angular、Svelte。 其本质原因在于模版语法的写法是固定的，固定意味着「可分析」。 「可分析」意味着在编译时可以标记模版语法中的静态部分(不变的部分)与动态部分(包含自变量，可变的部分)，使步骤 1 在寻找变化的 UI 时可以跳过静态部分。 甚至 Svelte、Solid.js 直接利用 AOT 在编译时建立了「组件状态与 UI 中动态部分的关系」，在运行时，组件状态变化后，可以直接执行步骤 2。 选择编译器Angular 提供了两种方式来编译你的应用： ANGULAR 编译方式 详情 即时（JIT） 当运行时在浏览器中编译你的应用程序。在 Angular 8 之前，这是默认值。 预先（AOT） 在构建时编译你的应用程序和库。这是从 Angular 9 开始的默认值。 angular.json 配置：在你的 angular.json 文件中，可以找到 build 配置中的 aot 属性。默认情况下，新建的 CLI 应用程序的 aot 属性值为 true。当你运行 ng build（仅构建）或 ng serve（构建并本地运行）命令时，编译模式（JIT 或 AOT）取决于该属性的值。如果 aot 设置为 true，则构建过程将使用 AOT 编译, 如果如果 aot 设置为 false,则构建过程将使用 JIT 编译. 12345&quot;build&quot;: { &quot;options&quot;: { &quot;aot&quot;: true }} 也可以使用命令行选项开启 AOT 编译 1ng serve --aot 4. AOT 与 JSX而采用 JSX 描述 UI 的前端框架则很难从 AOT 中受益。 原因在于 JSX 是 ES 的语法糖，作为 JS 语句只有执行后才能知道结果，所以很难被静态分析。 为了让使用 JSX 描述 UI 的前端框架在 AOT 中受益，有两个思路： 使用新的 AOT 思路 约束 JSX 的灵活性 React 尝试过第一种思路。prepack 是 meta(原 Facebook)推出的一款 React 编译器，用来实现 AOT 优化。他的思路是：在保持运行结果一致的情况下，改变源代码的运行逻辑，输出性能更高的代码。 即：代码在编译时将计算结果保留在编译后代码中，而不是在运行时才去求值。比如，如下代码： 123456789(function () { function hello() { return &quot;hello&quot;; } function world() { return &quot;world&quot;; } global.s = hello() + &quot; &quot; + world();})(); 经由 prepack 编译后输出： 1s = &quot;hello world&quot;; 遗憾的是，由于复杂度以及人力成本考虑，prepack 项目已于三年前暂停了。 Solid.js 同样使用 JSX 描述视图，他实现了几个内置组件用于描述 UI 的逻辑，从而减少 JSX 的灵活性，使 AOT 成为可能。比如： For 替代数组的 map 方法： 123&lt;For each={state.list} fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; {(item) =&gt; &lt;div&gt;{item}&lt;/div&gt;}&lt;/For&gt; Show 替代 if 条件语句： 123&lt;Show when={state.count &gt; 0} fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;div&gt;My Content&lt;/div&gt;&lt;/Show&gt; 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 总结总结一下，前端框架可以从 AOT 中收获很多益处，其中最主要的一条是： 减少“根据组件状态变化找到变化的 UI”这一步骤的工作量 要实现 AOT 的前提是：组件代码易于分析。 7. 参考文档前端框架的 JIT 与 AOT angular-cli: AoT compilation with ng serve by default","link":"/angular/angular_JIT_AOT.html"},{"title":"Angular应用如何使用百度统计","text":"Angulartics2 是一个用于 Angular 应用程序的分析工具。它可以自动跟踪导航事件并将其发送到您的分析服务提供程序，例如百度统计, Google Analytics 等。您可以通过运行npm i angulartics2在项目中开始使用 angulartics。 1. 获取百度统计账号关于如何获取百度统计账号, 可以访问我以前的博客百度统计的使用 2. 安装与配置 angulartics2在命令行中运行npm i angulartics2以安装 angulartics2. 2.1. 配置 angulartics2 将 angulartics2 添加到项目的根模块(root module) 12345678910111213141516171819202122232425import { NgModule } from '@angular/core';import { BrowserModule } from '@angular/platform-browser';import { RouterModule, Routes } from '@angular/router';import { Angulartics2Module } from 'angulartics2';import { Angulartics2GoogleAnalytics } from 'angulartics2';const ROUTES: Routes = [ { path: '', component: HomeComponent }, { path: 'about', component: AboutComponent },];@NgModule({ imports: [ BrowserModule, RouterModule.forRoot(ROUTES), // added to imports Angulartics2Module.forRoot(), // 添加Angulartics2Module 模块 ], declarations: [AppComponent], bootstrap: [AppComponent],}) 注意: 如果是使用Standalone component引导启动的 Angular 应用, 需要在ApplicationConfig 配置中引入 Angulartics2Module 1importProvidersFrom(Angulartics2Module.forRoot()), 在项目的根组件(root component)中引入相应的分析服务 provider, 例如 Angulartics2BaiduAnalytics并调用tracking 123456789// in root componentimport { Angulartics2BaiduAnalytics } from 'angulartics2';@Component({ ... })export class AppComponent { constructor(angulartics2BaiduAnalytics: Angulartics2BaiduAnalytics) { angulartics2BaiduAnalytics.startTracking(); }} 3. 使用 angulartics2前面两部导入Angulartics2Module 和 startTracking 是必要的两步. 完成以上操作后, 我们就可以开始使用angulartics2BaiduAnalytics. 3.1. 跟踪模板/HTML中的事件要跟踪事件，您可以将指令angulartics2On注入任何组件，并使用属性angulartics3On、angularticsAction和angularticsCategory： 12345678910111213141516171819202122232425262728// componentimport { Component } from '@angular/core';@Component({ selector: 'song-download-box', template: ` &lt;div angulartics2On=&quot;click&quot; angularticsAction=&quot;DownloadClick&quot; [angularticsCategory]=&quot;song.name&quot;&gt; Click Me &lt;/div&gt; `,})export class SongDownloadBox {}import { NgModule } from '@angular/core';import { Angulartics2Module } from 'angulartics2';@NgModule({ imports: [ Angulartics2Module, ], declarations: [ SongDownloadBox, ]}) 如果需要事件标签，可以使用 1234567891011&lt;div angulartics2On=&quot;click&quot; angularticsAction=&quot;DownloadClick&quot; angularticsLabel=&quot;label-name&quot; angularticsValue=&quot;value&quot; [angularticsCategory]=&quot;song.name&quot; [angularticsProperties]=&quot;{'custom-property': 'Fall Campaign'}&quot;&gt; Click Me&lt;/div&gt; 3.2. 使用代码跟踪事件123456789import { Angulartics2 } from 'angulartics2';constructor(private angulartics2: Angulartics2) { this.angulartics2.eventTrack.next({ action: 'myAction', properties: { category: 'myCategory' }, });} 如果需要事件标签，可以使用 123456789this.angulartics2.eventTrack.next({ action: 'myAction', properties: { category: 'myCategory', label: 'myLabel', },}); 4. Angulartics2 高级配置4.1. 排除跟踪一些页面传递字符串文字或正则表达式以从自动页面跟踪中排除一些页面。 12345678910Angulartics2Module.forRoot({ pageTracking: { excludedRoutes: [ /\\/[0-9]{4}\\/[0-9]{2}\\/[a-zA-Z0-9|\\-]*/, '2017/03/article-title' ], }}), 4.2. 从url路径中删除ID有时如果统计完整的url路径, 在统计报告中看起来非常琐碎, 所以需要去除一些信息, 例如id, 我们可以像下面这样去配置. 12345Angulartics2Module.forRoot({ pageTracking: { clearIds: true, }}), 默认情况下，它会删除与此模式匹配的ID（即，所有数字或UUID）：^\\d+$|^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$. 如果需要，您可以设置自己的regexp： 例如使得/project/a01/feature变成/project/feature 1234567Angulartics2Module.forRoot({ pageTracking: { clearIds: true, idsRegExp: new RegExp('^[a-z]\\\\d+$') /* Workaround: No NgModule metadata found for 'AppModule' */ }}), 4.3. 从url路径中删除查询参数这可以与clearId和idsRegExp组合使用 /project/12981/feature?param=12变为/project/12981/feature 1234567Angulartics2Module.forRoot({ pageTracking: { clearQueryParams: true, }}), 4.4. 从url路径中删除hash/callback#authcode=123&amp;idToken=456 变成 /callback 12345Angulartics2Module.forRoot({ pageTracking: { clearHash: true, }}), 4.5. 在没有路由器的情况下使用警告：此支持仍然是实验性的 @仍必须安装angular/router！但是，它不会被使用。 12345678910import { Angulartics2RouterlessModule } from 'angulartics2';@NgModule({ // ... imports: [ BrowserModule, Angulartics2RouterlessModule.forRoot(), ],}) 4.6. 与UI路由器一起使用警告：此支持仍然是实验性的 @仍必须安装angular/router！但是，它不会被使用。 12345678import { Angulartics2UirouterModule } from 'angulartics2';@NgModule({ // ... imports: [ BrowserModule, Angulartics2UirouterModule.forRoot(), ],}) 5. trouble shooting 问题一, 当运行server sider rendering 时, 报错ReferenceError: _hmt is not defined 12345678910111213141516 Build at: 2023-11-16T08:00:28.460Z - Hash: b945708904bd624f - Time: 78602ms⠙ Prerendering 13 route(s) to D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\browser...ReferenceError: _hmt is not defined at new Angulartics2BaiduAnalytics (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:199481:12) at Object.Angulartics2BaiduAnalytics_Factory [as factory] (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:199536:10) at D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:134269:33 at runInInjectorProfilerContext (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:125777:5) at R3Injector.hydrate (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:134268:9) at R3Injector.get (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:134148:23) at R3Injector.get (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:134157:27) at ChainedInjector.get (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:138783:32) at lookupTokenUsingModuleInjector (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:129505:31) at getOrCreateInjectable (D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\server\\main.js:129551:10)✖ Prerendering routes to D:\\dev\\proj\\demo-angular-project\\dist\\demo-angular-web\\browser failed._hmt is not defined 问题原因: 因为时server side 而不是浏览器中运行angulartics2, 所以找不到_hmt 解决办法: 我已经提交issue给angulartics2, 正在等待它们回复. 这里有一个类似的问题, 里面提到了一种workaround, 即通过服务去访问angulartics2, 定义一个专门针对server side的service, 在服务中避免调用angulartics2 6. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular 专题 | 鹏叔的技术博客 7. 参考文档angulartics2","link":"/angular/angular_analytics_baidu.html"},{"title":"在Angular中使用async-await特性","text":"Promise 和回调函数是在 JavaScript 中编写异步代码的构建块。 在 Angular 应用程序中，我们可以使用 Rx.js 来利用 Observables、Subject、BehaviorSubject 等的强大功能，以优雅的方式编写异步代码。 随着最新版本的 ECMA Script 草案，JavaScript 开始支持“异步等待”功能。 ECMAScript 最新草案 (ECMA-262) 1. 什么是 Async-await当 async 函数被调用，它返回一个 Promise。当 async 函数返回一个值，Promise 将 resolve 返回值。当 async 函数抛出异常或某个值的时候，Promise 将 reject 抛出的值。 async 函数可以包含一个 await 表达式，该表达式将等待异步函数的执行完成才处理下一条语句, 并将 Promise 的 resolve 的结果作为表达式的结果返回，然后恢复 async 函数的执行并返回 resolve 的值。 async 函数可以包含一个 await 表达式，该表达式暂停执行下一条语句, 并等待异步函数的执行完成并将 Promise 执行结果进行解析作为返回值，然后恢复 async 函数的执行并返回解析的值。 简而言之，您将有机会以同步方式编写异步代码。 这样讲有些抽象, 下面我们来看两个实例就清晰了. 2. 实例 1让我们考虑一个简单的例子。一个函数，它返回一个 Promise，在两秒后解析并返回作为参数传递的值。 123456789resolveAfter2Seconds(x) { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(x); }, 2000); }); } 使用 Promise，我们可以使用“then”回调函数获取值。 123456getValueWithPromise() { this.resolveAfter2Seconds(20).then(value =&gt; { console.log(`promise result: ${value}`); }); console.log('I will not wait until promise is resolved'); } 在上面的情况下，第 5 行的 console.log() 应在第 3 行的 console.log() 之前执行。这是 Promise 的基本性质。 现在让我们看看 async-await 的用法。 12345async getValueWithAsync() { const value = &lt;number&gt;await this.resolveAfter2Seconds(20); console.log(`async result: ${value}`); } 这里有几点需要注意： 第 1 行 — 函数以“async”关键字为前缀。如果您的函数具有“await”关键字，则必须使用此前缀。这意味着整个函数还是异步执行, 不会阻塞调用它的主进程. 但是函数内部会有阻塞等待. 这样也非常合理, 毕竟远程调用, 文件读取之类的操作是受到硬件以及网络性能影响, 这部分等待时间是很难从软件层面避免的. 第 2 行 — 我们没有在 Promise 函数之后调用“.then()”回调函数。相反，我们在函数调用前加上“await”关键字。该关键字不允许在 resolveAfter2Seconds 结束前执行下一个代码块。这意味着，只有当第 2 行的 Promise 得到解析后，第 3 行的 console.log() 才会被打印，就像同步函数调用一样。 由于我们使用的是 Typescript，因此我们需要将 Promise 返回值类型转换为特定类型，因此第 2 行的 &lt;number&gt; 。 3. 实例 2让我们尝试使用基于承诺的方法将两个数字相加。 123456789101112addWithPromise() { this.resolveAfter2Seconds(20).then(data1 =&gt; { let result1 = &lt;number&gt;data1; this.resolveAfter2Seconds(30).then(data2 =&gt; { let result2 = &lt;number&gt;data2; this.additionPromiseResult = result1 + result2; console.log(`promise result: ${this.additionPromiseResult}`); }); }); } 在现实世界的应用程序中，最终陷入嵌套的 Promise-then 代码结构（回调地狱）是很常见的。通过 2 层嵌套，我们得到了上面的代码。想象一下 7-8 层嵌套，其中包含捕获的变量和异常（如果有）。这很可怕不是吗？ 现在采用基于异步的方法。 12345678async addWithAsync() { const result1 = &lt;number&gt;await this.resolveAfter2Seconds(20); const result2 = &lt;number&gt;await this.resolveAfter2Seconds(30); this.additionAsyncResult = result1 + result2; console.log(`async result: ${this.additionAsyncResult}`); } 两种方法都会给我们相同的结果，但就代码可读性而言, 代码的简单程度，维护“async-await”优于经典的 Promise-then 方法。 4. 使用 Http REST APIs到目前为止我们讨论了简单的例子。在 Angular 应用程序中，我们可以使用 Http（即将废弃）或 HttpClient 服务来获取 REST 数据。默认情况下，HttpClient 类的“get()”、“put()”、“delete()”和“post()”方法返回Observable&lt;T&gt;。该结果集可以通过“subscribe”方法或使用 RxJs 中的“toPromise()”运算符来使用。 4.1. 使用 Observable 获取 HttpClient 结果我见过许多 Angular 开发者使用“subscribe”来获取 Http REST 数据，但不知道它与“promise”的区别。“subscribe”方法来自“Observable”对象。订阅后，只要“Observer”产生新数据，就会执行“subscribe”回调。而 Promise 的“then()”回调处理程序应最多执行一次。因此，除非您需要使用重复数据，否则不要使用“订阅”。请改用“toPromise()”。如果你注意到 Angular 官方文档中给出的示例；大量使用“toPromise”。 123456789getDataUsingSubscribe() { this.httpClient.get&lt;Employee&gt;(this.url).subscribe(data =&gt; { this.subscribeResult = data; console.log('Subscribe executed.') }); console.log('I will not wait until subscribe is executed..'); } 4.2. 使用 toPromise 获取 HttpClient 结果Rx.js 提供了一个名为“toPromise()”的运算符，可用于将Observeble&lt;T&gt;转换为 Promise。一旦转换，只要有数据，它的“then”块就会被执行。 123456789getDataUsingPromise() { this.httpClient.get&lt;Employee&gt;(this.url).toPromise().then(data =&gt; { this.promiseResult = data; console.log('Promise resolved.') }); console.log('I will not wait until promise is resolved..'); } 4.3. 使用 async-await 获取 HttpClient 结果使用 async-await 模式，我们既不需要“订阅”也不需要“then”。代码看起来非常简单明了。从“url”获取数据后，将执行第 3 行，Observerable&lt;T&gt; 转换为 Promise，Promise 被解析，数据存储在“asyncResult”成员变量中。 1234async getAsyncData() { this.asyncResult = await this.httpClient.get&lt;Employee&gt;(this.url).toPromise(); console.log('No issues, I will wait until promise is resolved..'); } 4.4. Conditional programming很多时候应用程序需要从一个 url 获取数据并使用条件来获取下一个数据。使用 Promise 代码应如下所示： 123456789101112getConditionalDataUsingPromise() { this.httpClient.get&lt;Employee&gt;(this.url).toPromise().then(data =&gt; { console.log('First Promise resolved.') if (data.id &gt; 5) { let anotherUrl = 'http://dummy.restapiexample.com/api/v1/employee/23'; this.httpClient.get&lt;Employee&gt;(anotherUrl).toPromise().then(data =&gt; { this.conditionalPromiseResult = data; console.log('Second Promise resolved.') }); } }); } 使用 async-await 代码应如下所示： 12345678910async getConditionalDataUsingAsync() { let data = await this.httpClient.get&lt;Employee&gt;(this.url).toPromise(); if (data.id &gt; 5) { let anotherUrl = 'http://dummy.restapiexample.com/api/v1/employee/23'; this.conditionalAsyncResult = await this.httpClient.get&lt;Employee&gt;(anotherUrl).toPromise(); } console.log('No issues, I will wait until promise is resolved..'); } 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 总结总而言之，async-await 等待功能为我们提供了一种在 Angular 应用程序中编写异步代码的更好方法。","link":"/angular/angular_async-await.html"},{"title":"异步初始化MatPaginator","text":"1. 问题描述我们在组件中初始化MatPaginator，如 @ViewChild(MatPaginator) paginator: MatPaginator; 并将其分配给在我们的组件中定义的MatTable DataSource matTableDataSource.paginator=this.ginator； 当使用带有*ngIf组合的async管道异步初始化数据源时，这在用例中不起作用。 像这样: 12345678&lt;div *ngIf=&quot;someDataObs | async as yourData else loading&quot;&gt; &lt;mat-table #table [dataSource]=&quot;yourData&quot;&gt; ... your headers and columns &lt;/mat-table&gt; &lt;mat-paginator [pageSize]=&quot;10&quot; showFirstLastButtons&gt;&lt;/mat-paginator&gt;&lt;/div&gt; 注意：您可以使用*ngIf将mat-paginator放在div下面，但这不是一个理想的解决方案，如果您需要在同一组件中显示多个表，并使用单个后端异步调用，则更是如此。 由于mat-paginator被包裹在ngIf之类, 所以未从数据源获取到数据之前mat-paginator没有被初始化, 因此当我们创建matTableDataSource时paginator仍然为null。 12345678ngAfterViewInit() { this.someDataObs = this.backendService.get() .map(value =&gt; { const matTableDataSource = new MatTableDataSource&lt;SomeType&gt;(value); matTableDataSource.paginator = this.paginator; // will be null here return matTableDataSource; });} 2. 解决方案所以要解决这个问题, 我们需要改变一下思路, 在创建matTableDataSource时我们不要急于为其设置paginator, 等mat-paginator初始化后再将mat-paginator关联至matTableDataSource. 在创建matTableDataSource时我们将为其关联paginator的代码移除 123456789101112private _datasource: MatTableDataSource&lt;SomeType&gt;ngAfterViewInit() { this.someDataObs = this.backendService.get() .map(value =&gt; { const matTableDataSource = new MatTableDataSource&lt;SomeType&gt;(value); // matTableDataSource.paginator = this.paginator; // 将matTableDataSource与paginator的代码注释掉 this._datasource = matTableDataSource // 这里需要创建一个_datasource用来持有matTableDataSource对象, 当paginator初始化完成后我们需要将paginator赋值给matTableDataSource return matTableDataSource; });} 现在我们要找到paginator初始化后赋值的位置, 将paginator赋值给datasource对象。我们可以使用angular setter拦截赋值过程, 关于angular setter和getter可以参考我的博客在TypeScript和Angular中使用Getter和Setter, 这里不展开论述. 我们需要将paginator修改为使用setter赋值, 这样我们就有机会在paginator初始化以后将其关联到matTableDataSource 12345@ViewChild(MatPaginator, { static: false }) set paginator(mp: MatPaginator) { this._datasource.paginator = mp} 注意: 这里需要使用参数static: falsestatic若为 true，在变更检测运行之前解析查询结果；若为 false，在变更检测之后解析。默认为 false。 至此MatPaginator就能正常的运行了. 该解决方案也适用于sort不能异步初始化的情况. 加上如下一行代码就能解决了 12345@ViewChild(MatSort, { static: false }) set sort(ms: MatSort) { this._datasource.sort = ms} 3. 相关文章最新更新以及更多Angular相关文章请访问 Angular合集 | 鹏叔的技术博客 4. 参考文档MatPaginator in Angular fails to initialize Initialising MatPaginator asynchronously Mat Paginator is not working properly along when used conditional rendering (*ngIf) on the outer div.","link":"/angular/angular_async_MatPaginator.html"},{"title":"Angular Async Pipe详解","text":"Async Pipe可以对 Angular 应用程序的更改检测策略产生巨大影响。如果到目前为止您还感到困惑，请详解读完全文。我们一起来了解一下吧！ 在 Angular 中，Async Pipe本质上是执行以下三个任务的管道: 它订阅一个observable或一个Promise并返回最后发出的值。 每当发出新值时，它都会标记组件为需要要检查的。这意味着Angular将在下一个周期中为该组件运行Change Detector。 当组件被销毁时，它会取消订阅可观察的内容。 此外，作为最佳实践，建议尝试使用 onPush 更改检测策略上的组件和异步管道来订阅可观察对象。 如果您是Angular的初学者，也许上面对异步管道的解释让人不知所措。因此，在本文中，我们将尝试使用代码示例逐步理解异步管道。只需创建一个新的Angular 项目并继续操作即可；在文章的最后，您应该对异步管道有一些深刻的了解。 1. 创建服务让我们从创建产品接口和服务开始。 12345678910export interface IProduct { Id : string; Title : string; Price : number; inStock : boolean;} 创建IProduct接口后，接下来在 Angular 服务内部创建一个IProduct数组来执行读写操作。 12345678910111213141516171819202122232425262728293031import { Injectable } from '@angular/core';import { IProduct } from './product.entity';@Injectable({ providedIn: 'root'})export class AppService { Products : IProduct[] = [ { Id:&quot;1&quot;, Title:&quot;Pen&quot;, Price: 100, inStock: true }, { Id:&quot;2&quot;, Title:&quot;Pencil&quot;, Price: 200, inStock: false }, { Id:&quot;3&quot;, Title:&quot;Book&quot;, Price: 500, inStock: true } ] constructor() { }} 请记住，在实际应用程序中，我们从远程API获取数据；然而，在这里我们模仿本地数组中的读取和写入操作，以重点关注异步管道。 为了执行读写操作，我们将 Products 数组包装在 a 中BehaviorSubject，并在每次将新项目推送到数组时发出一个新数组Products。 为此，请在服务中添加代码，如下所示： 1234567891011Products$ : BehaviorSubject&lt;IProduct[]&gt;; constructor() { this.Products$ = new BehaviorSubject&lt;IProduct[]&gt;(this.Products); } AddProduct(p: IProduct): void{ this.Products.push(p); this.Products$.next(this.Products); } 让我们看一下代码： BehaviourSubject是一种发出默认值或最后发出值的Subject。我们使用的BehaviorSubject最初发送的默认值是Products数组。 在该AddProduct方法中，我们接收一个Product并将其推送到数组中。 在该AddProduct方法中，将接收到的Product推送到Products数组后，我们将发出更新后的Products数组。 目前，该服务已准备就绪。接下来，我们将创建两个组件: 一个用于添加产品，另一个用于在表格上显示所有产品。 2. 添加产品创建一个名为AddProduct的组件，并添加一个响应式式表单来接受产品信息。 1234567891011productForm: FormGroup; constructor(private fb: FormBuilder, private appService: AppService) { this.productForm = this.fb.group({ Id: [&quot;&quot;, Validators.required], Title: [&quot;&quot;, Validators.required], Price: [], inStock: [] }) } 我们使用FormBuilder来创建FormGroup组件，并在template中使用HTML表单结合productForm来接受用户输入，如下所示： 1234567&lt;form (ngSubmit)='addProduct()' [formGroup]='productForm'&gt; &lt;input formControlName='Id' type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter ID&quot; /&gt; &lt;input formControlName='Title' type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter Title&quot; /&gt; &lt;input formControlName='Price' type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter Price&quot; /&gt; &lt;input formControlName='inStock' type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Enter Stock &quot; /&gt; &lt;button [disabled]='productForm.invalid' class=&quot;btn btn-default&quot;&gt;Add Product&lt;/button&gt;&lt;/form&gt; 在函数AddProduct中，我们将检查表单是否有效。如果有效，我们调用该服务将一种产品推送到Products数组。该AddProduct函数应如下所示： 12345addProduct() { if (this.productForm.valid) { this.appService.AddProduct(this.productForm.value); } } 到目前为止，我们已经创建了一个包含reactive form的组件，用于输入产品信息并调用服务在 Products 数组中插入新产品。如果您使用过 Angular，上面的代码应该很简单。 3. 显示产品列表为了显示产品列表, 我需要这样做: 将组件的更改检测策略设置为 Default。 在组件中注入AppService。 使用 subscribe 方法从 observable 中获取数据。 123456789101112131415161718192021222324252627282930@Component({ selector: 'app-list-products', templateUrl: './list-products.component.html', styleUrls: ['./list-products.component.css'], changeDetection: ChangeDetectionStrategy.Default})export class ListProductsComponent implements OnInit, OnDestroy { products: IProduct[] = [] productSubscription?: Subscription constructor(private appService: AppService) { } productObserver = { next: (data: IProduct[]) =&gt; { this.products = data; }, error: (error: any) =&gt; { console.log(error) }, complete: () =&gt; { console.log('product stream completed ') } } ngOnInit(): void { this.productSubscription = this.appService.Products$.subscribe(this.productObserver) } ngOnDestroy(): void { if (this.productSubscription) { this.productSubscription.unsubscribe(); } }} 让我们看一下代码： products变量保存从服务返回的数组。 是productSubscription 是RxJS Subscription类型的变量，用于保存从可观察对象的订阅方法返回的订阅。 这productObserver是一个具有 next、error 和complete 回调函数的对象。 观察者productObserver被传递给 subscribe 方法。 在ngOnDestrory()生命周期钩子中，我们取消订阅可观察的内容。 在html模板上，您可以在表格中显示产品，如下所示： 1234567891011121314151617181920&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;inStock&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=&quot;let p of products&quot;&gt; &lt;td&gt;{{p.Id}}&lt;/td&gt; &lt;td&gt;{{p.Title}}&lt;/td&gt; &lt;td&gt;{{p.Price}}&lt;/td&gt; &lt;td&gt;{{p.inStock}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 4. 使用组件我们将使用这两个组件作为同级组件，如下所示。 12345678&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;app-add-product&gt;&lt;/app-add-product&gt;&lt;hr/&gt;&lt;app-list-products&gt;&lt;/app-list-products&gt; 这里您应该注意的一个关键点是组件AddProduct和ListProducts组件是不相关的。它们之间只有两种方式传递数据： 通过父组件进行通信 通过使用服务进行通信 我们已经创建了一项服务，并将使用该服务在这两个组件之间传递产品信息。 5. 运行应用程序您可以通过单击“添加产品”按钮来添加产品。这会调用服务中的一个函数，该函数会更新数组并从可观察对象中发出更新后的数组。 列出产品的组件会订阅可观察的内容，因此每当我们添加另一个项目时，表就会更新。到目前为止，一切都很好。 6. 使用 onPush 变化检测策略如果您还记得ListProducts组件更改检测策略设置为默认值。现在让我们继续将策略更改为onPush： 123456789@Component({ selector: 'app-list-products', templateUrl: './list-products.component.html', styleUrls: ['./list-products.component.css'], changeDetection: ChangeDetectionStrategy.OnPush})export class ListProductsComponent implements OnInit, OnDestroy { 再次，继续运行该应用程序。你发现了什么？正如您注意到的那样，当您用AddProduct组件添加产品时，它会被添加到数组中，甚至更新的数组也会从服务中发出。尽管如此，该 ListProducts组件仍未更新。发生这种情况是因为ListProducts组件的更改检测策略设置为onPush。 将更改检测策略更改为 onPush 可防止表被新产品刷新。 对于具有onPush更改检测策略的组件，Angular仅在新引用传递给组件时才运行更改检测器。但是，当observable发出新元素时，它仍然是原来的引用。因此，Angular没有运行变更检测器，并且更新的 Products 数组也没有显示在组件中。 您可以在此处了解有关Angular变化检测器的更多信息。 7. 我们该如何解决这个问题？我们可以通过手动调用更改检测器来解决此问题。为此，请注入ChangeDetectorRef组件并调用该markForCheck()方法。 123456789101112131415161718192021222324252627export class ListProductsComponent implements OnInit, OnDestroy { products: IProduct[] = [] productSubscription?: Subscription constructor(private appService: AppService, private cd: ChangeDetectorRef) { } productObserver = { next: (data: IProduct[]) =&gt; { this.products = data; this.cd.markForCheck(); }, error: (error: any) =&gt; { console.log(error) }, complete: () =&gt; { console.log('product stream completed ') } } ngOnInit(): void { this.productSubscription = this.appService.Products$.subscribe(this.productObserver) } ngOnDestroy(): void { if (this.productSubscription) { this.productSubscription.unsubscribe(); } }} 至此，我们完成了以下任务： 我们将 Angular ChangeDetectorRef 注入到组件中。 该markForCheck()方法将该组件及其所有父组件标记为dirty组件，以便 Angular 在下一个更改检测周期中检查更改。 现在运行应用程序，您应该能够看到更新的产品数组。 8. Subscribe方式分析正如您所看到的，在设置为 的组件中onPush，要使用可观察量，请按照以下步骤操作。 订阅可观察的内容。 手动运行更改检测。 取消订阅可观察的内容。 该方法的优点subscribe()是： 属性可以在模板中的多个位置使用。 属性可以用在组件类的不同位置。 您可以在订阅可观察对象时运行自定义业务逻辑。 一些缺点是： 对于onPush变更检测策略，您必须手动标记组件以使用该markForCheck方法运行变更检测器。 您必须明确取消订阅可观察量。 当组件中使用许多可观察量时，这种方法可能会失控。如果我们错过取消订阅任何可观察的内容，则可能存在潜在的内存泄漏等。 使用Async Pipe可以解决上述问题。 9. Async管道异步管道是在组件中处理可观察对象的更好且更推荐的方式。在底层，异步管道执行以下三项任务： 它订阅可观察对象发出的最后值。 当发出新值时，它标记要检查更改的组件。 当组件被销毁时，异步管道会自动取消订阅，以避免潜在的内存泄漏。 所以基本上，异步管道会完成您为订阅方法手动执行的所有三项任务。 让我们修改ListProducts组件以使用异步管道。 1234567891011121314@Component({ selector: 'app-list-products', templateUrl: './list-products.component.html', styleUrls: ['./list-products.component.css'], changeDetection: ChangeDetectionStrategy.OnPush})export class ListProductsComponent implements OnInit { products?: Observable&lt;IProduct[]&gt;; constructor(private appService: AppService) {} ngOnInit(): void { this.products = this.appService.Products$; }} 我们删除了ListProductsComponent之前的所有代码，并将服务返回的可观察赋给产品变量。在现在HTML模板上，使用异步管道。 123456789101112131415161718&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;inStock&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=&quot;let p of products | async&quot;&gt; &lt;td&gt;{{p.Id}}&lt;/td&gt; &lt;td&gt;{{p.Title}}&lt;/td&gt; &lt;td&gt;{{p.Price}}&lt;/td&gt; &lt;td&gt;{{p.inStock}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 使用异步管道可以使代码更清晰，并且您不需要为onPush更改检测策略手动运行更改检测器。在应用程序上，您会看到ListProducts每当添加新产品时组件都会重新。 始终建议的最佳做法是： 将组件变化检测策略设置为onPush 使用异步管道来处理可观察量 我希望您觉得这篇文章很有用，并且现在已经准备好在您的 Angular 项目中使用异步管道。 10. 如何处理异常如果程序在抓取数据时出现异常, 此时我们可以在 tap算子中捕捉异常, 在catchError算子中将error转换成空数组. 在页面向用户显示异常信息. 123456789101112131415161718192021@Component({ selector: 'app-list-products', templateUrl: './list-products.component.html', styleUrls: ['./list-products.component.css'], changeDetection: ChangeDetectionStrategy.OnPush})export class ListProductsComponent implements OnInit { products?: Observable&lt;IProduct[]&gt;; error: Error | null = null; constructor(private appService: AppService) {} ngOnInit(): void { this.products = this.appService.Products$.pipe( tap({ error: (error) =&gt; this.error = error }) catchError((err) =&gt; of([])) ); }} 在页面检测是否有错误发生, 将错误信息显示给用户. 12345678910111213141516171819 &lt;div *ngIf=&quot;error&quot; class=&quot;error&quot;&gt;{{error}}&lt;/div&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;inStock&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr *ngFor=&quot;let p of products | async&quot;&gt; &lt;td&gt;{{p.Id}}&lt;/td&gt; &lt;td&gt;{{p.Title}}&lt;/td&gt; &lt;td&gt;{{p.Price}}&lt;/td&gt; &lt;td&gt;{{p.inStock}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 11. Angular 系列文章最新更新以及更多Angular相关文章请访问 Angular合集 | 鹏叔的技术博客 12. 参考文档Angular Basics: Step-by-Step Understanding the Async Pipe How to Handle Errors Reactively when Using the Async Pipe","link":"/angular/angular_async_pipe.html"},{"title":"Angular async pipe中的异常处理","text":"处理 web 应用程序中的错误对于获得良好的用户体验非常重要。有时会发生异常，每个应用程序都应该涵盖这些情况，以帮助用户了解发生了不好的事情。 许多教程没有显示如何在使用异步管道时处理错误/异常情况。因此，在这篇文章中，我们将研究如何处理这些错误案例的一些技术。 一个简单的异步管道示例让我们看看您可能在许多教程中看到的一个示例： 12345678910111213141516171819202122@Component({ selector: &quot;app-mycomponent&quot;, changeDetection: ChangeDetectionStrategy.OnPush, template: ` &lt;div *ngIf=&quot;users$ | async as users; else loading&quot;&gt; &lt;div *ngFor=&quot;let user of users&quot;&gt; {{ user.name }} &lt;/div&gt; &lt;/div&gt; &lt;ng-template #loading&gt; Loading users... &lt;/ng-template&gt; `,})class MyComponent { users$: Observable&lt;User[]&gt;; constructor(httpClient: HttpClient) { this.users$ : httpClient.get&lt;User[]&gt;(&quot;/api/users&quot;); }} 异步管道订阅$users observable。第一种状态是“加载”状态，因为 Observable 还没有发出值，所以*ngIf 中的 else 情况是 active 的。当 HTTP 请求以 2xx 状态代码响应时，一切都很好：用户将看到用户列表。 这个例子只是一个 happy case, 并没有考虑 observable 出现异常的情况。当 HTTP 请求以错误结束时，用户在页面上看不到任何错误消息。他仍然会看到加载状态，这与用户在这种情况下的预期相去甚远。那么，我们如何更好地处理这一问题，并向用户表明发生了不好的事情？ 1. 一个简单的解决方案让我们从上面扩展我们的示例，以便能够处理所有三种状态（加载、成功、错误）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import { ChangeDetectionStrategy, Component } from &quot;@angular/core&quot;;import { Observable, Subject, of } from &quot;rxjs&quot;;import { catchError } from &quot;rxjs/operators&quot;;import { HttpClient, HttpClientModule } from &quot;@angular/common/http&quot;;import { CommonModule } from &quot;@angular/common&quot;;@Component({ standalone: true, selector: &quot;app-mycomponent&quot;, changeDetection: ChangeDetectionStrategy.OnPush, template: ` &lt;p&gt;hi&lt;/p&gt; &lt;div *ngIf=&quot;users$ | async as users; else loadingOrError&quot;&gt; &lt;div *ngFor=&quot;let user of users&quot;&gt; {{ user.name }} &lt;/div&gt; &lt;/div&gt; &lt;ng-template #loadingOrError&gt; &lt;div *ngIf=&quot;loadingError$ | async; else loading&quot;&gt; Error loading the list of users. Please try again later. &lt;/div&gt; &lt;ng-template #loading&gt;Loading users...&lt;/ng-template&gt; &lt;/ng-template&gt; `, imports: [CommonModule, HttpClientModule],})export class MyComponent { users$: Observable&lt;User[]&gt;; loadingError$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;(); constructor(httpClient: HttpClient) { this.users$ = httpClient.get&lt;User[]&gt;(&quot;/api/users&quot;).pipe( catchError((error) =&gt; { // it's important that we log an error here. // Otherwise you won't see an error in the console. console.error(&quot;error loading the list of users&quot;, error); this.loadingError$.next(true); return of(); }) ); }}export interface User { name: string;} 当创建组件时，我们会为 users$ observable 创建一个处理错误状态的 ng template #loadingOrError 和一个接受信息的 observableerrorLoading$。 如果发生错误，我们将使用 catchError 运算符捕获错误。catchError 的作用是，您将不再在 devtools 控制台中看到错误，这对调试错误情况没有太大用处。接下来，我们为 loadingError$主题发出一个新值。最后一个重要步骤是用 of 算子恢复可观测值，并给它一个 false 值。您也可以使用 null。 2. 分离异常数据上面显示的解决方案基本能解决问题，但是还有很大的改善空间。所以，让我们看看如何做得更好一点。 记住我们的目标，我们的目标是将加载过程显示和错误处理抽取到一个独立的组件中，提高代码的可重用性，并且尽量减少对现有 async pipe 结构的侵入性。 回顾以上解决方案，我们发现有两个问题，首先第一点，正常数据流与异常数据流，紧密耦合在一起，这不利于我们朝目标方向进行重构。 第二点，我们完全创建了一个全新的 loadingError$ subject,这个有点多余，而且它只接受 boolean 对象，这不利于我们向用户展示详细错误信息， 我们可以在 users$ observable 的基础上分岔出一个加载异常流。 下面我们就以上两点进行改进。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import { CommonModule } from &quot;@angular/common&quot;;import { HttpClient, HttpClientModule } from &quot;@angular/common/http&quot;;import { ChangeDetectionStrategy, Component } from &quot;@angular/core&quot;;import { Observable, of } from &quot;rxjs&quot;;import { catchError, ignoreElements, shareReplay } from &quot;rxjs/operators&quot;;@Component({ standalone: true, selector: &quot;app-mycomponent&quot;, changeDetection: ChangeDetectionStrategy.OnPush, template: ` &lt;div *ngIf=&quot;users$ | async as users; else loadingOrError&quot;&gt; &lt;div *ngFor=&quot;let user of users&quot;&gt; {{ user.name }} &lt;/div&gt; &lt;/div&gt; &lt;ng-template #loadingOrError&gt; &lt;div *ngIf=&quot;loadingError$ | async as originalErrorMsg; else loading&quot;&gt; &lt;p&gt;Error loading the list of users.&lt;/p&gt; &lt;p&gt;{{ originalErrorMsg }}&lt;/p&gt; &lt;p&gt;Please try again later.&lt;/p&gt; &lt;/div&gt; &lt;ng-template #loading&gt;Loading users...&lt;/ng-template&gt; &lt;/ng-template&gt; `, imports: [CommonModule, HttpClientModule],})export class MyComponent { users$: Observable&lt;User[]&gt;; loadingError$: Observable&lt;string&gt;; constructor(httpClient: HttpClient) { this.users$ = httpClient.get&lt;User[]&gt;(&quot;/api/users&quot;); this.loadingError$ = this.users$.pipe( shareReplay(1), ignoreElements(), // 忽略数据元素，避免数据元素对异常数据流的影响 catchError((error: any) =&gt; { // it's important that we log an error here. // Otherwise you won't see an error in the console. console.error(&quot;error loading the list of users&quot;, error); //this.loadingError$.next(true) return of(error.message); }) ); }}export interface User { name: string;} 通过努力，我们将正常数据流和异常数据流行进行了分离，正常数据流通过 users$ Observable 获取，如果数据正在加载过程中或者加载过程中出现异常，将会显示 loadingOrError template 所定义的内容。 如果出现异常，loadingOrError template 将会向用户展示异常的详细信息。接下来我们将 loadingOrError 抽取为一个组件，以便在其他页面中重用。 3. 重构，抽取成可重用组件我们将处理加载过程和展示错误信息的部分抽取成组件，暂且命名为 loadingOrError LoadingOrError.component.ts 123456789101112131415161718192021222324252627282930313233import { CommonModule, NgIfContext } from &quot;@angular/common&quot;;import { Component, Input, TemplateRef, ViewChild } from &quot;@angular/core&quot;;import { Observable, of } from &quot;rxjs&quot;;import { catchError, ignoreElements, shareReplay, tap } from &quot;rxjs/operators&quot;;@Component({ standalone: true, selector: &quot;loading-or-error&quot;, templateUrl: &quot;./LoadingOrError.component.html&quot;, imports: [CommonModule],})export class LoadingOrErrorComponent { loadingError$: Observable&lt;string&gt;; /** * The loading wrapper that should be used to show the loading/error state */ @Input() set loadingWrapper(data: Observable&lt;any&gt;) { this.loadingError$ = data.pipe( shareReplay(1), ignoreElements(), catchError((error: any) =&gt; { console.log(error.message); return of(error.message); }) ); } /** * A configurable error message for error cases. */ @Input() userDefinedMessage: string = &quot;&quot;;} 注意，这里我们添加了 ignoreElements rxjs 算子, 这样正常数据流就被过滤掉了，从而形成一个纯粹的异常数据流。 LoadingOrError.component.html 1234&lt;div *ngIf=&quot;loadingError$ | async as originalErrorMsg; else loading&quot;&gt; {{ userDefinedMessage + ' | ' + originalErrorMsg }}&lt;/div&gt;&lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt; 这样我们就将 loading 和 error handling 抽取出成了一个独立组件。接下来我们在业务处理页面使用它。 4. 使用 LoadingOrError 组件src/app/app.component.html 1234567891011121314&lt;div *ngIf=&quot;users$ | async as users; else loading&quot;&gt; &lt;div *ngFor=&quot;let user of $any(users)&quot;&gt; &lt;p&gt;{{ user.name }}&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;ng-template #loading&gt; &lt;loading-or-error #loadingOrError [loadingWrapper]=&quot;users$&quot; [userDefinedMessage]=&quot;'Error loading the list of users'&quot; &gt;&lt;/loading-or-error&gt;&lt;/ng-template&gt; 从以上使用方法可以看出，我们依然保持了 async pipe 的写法，对 html template, 中 async pipe 部分没有任何侵入性，对数据流的创建过程也没有任何的侵入性。 src/app/app.component.ts 123456789101112131415161718import { ChangeDetectionStrategy, Component } from &quot;@angular/core&quot;;import { Observable } from &quot;rxjs&quot;;import { TestDataService, User } from &quot;./services/TestDataService&quot;;import { HttpClient } from &quot;@angular/common/http&quot;;@Component({ selector: &quot;app-root&quot;, changeDetection: ChangeDetectionStrategy.OnPush, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;],})export class AppComponent { users$: Observable&lt;User[]&gt;; constructor(httpClient: HttpClient) { this.users$ = httpClient.get&lt;User[]&gt;(&quot;/api/users&quot;); }} 5. 总结我们组件的代码现在简单多了：我们在一个通用的、可重用/可配置的组件中处理了错误和加载情况，在几乎不改变原有代码结构的基础上，添加了错误处理功能，它为我们节省了一些代码，否则我们必须在每个组件中编写这些代码。 我很好奇你在项目中是如何处理这些案例的！如果您使用下面的评论框谈论您的解决方案和上面的解决方案，我将非常高兴。 6. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular 专题 | 鹏叔的技术博客 7. 参考文档How to Handle Errors Reactively when Using the Async Pipe [Error Handling with Angular`s async Pipe](https://sebastian-holstein.de/post/2018-02-26-error-handling-angular/)","link":"/angular/angular_async_pipe_error_handling.html"},{"title":"深入了解 Angular 异步管道","text":"Angular 异步管道(Async pipe)是 Angular 框架中在 HTML 模板中使用 Observables 或 Promises 的方法之一。而且在大多数情况下，我认为这是在 Angular 中处理 Observables 和 Promise 的首选方式。 当您使用异步管道订阅 Observable 或 Promise 时，您将收到 Observable 或 Promise 最后发出的值。 请注意，在 Observable 或 Promise 发出值之前，需要在 HTML 模板中初始化异步管道，否则管道不会接收任何值。 因此，如果异步管道位于 *ngIf 内，并且 Observable 在 ngIf 计算为 true 之前发出一个值，则不会显示任何内容，并且异步管道在发出新值之前不会接收任何值。 使用 Angular 异步管道很简单，并且比订阅 Observables 和 Promise 的一些更标准的方法提供了一些好处。 1. 为什么使用 Angular 异步管道？在 Angular 中，当您订阅 Observable 或 Promis 时，您需要在组件被销毁（或 Observable 不再使用）时取消订阅。如果您忘记取消订阅，则会出现内存泄漏，从而给您的应用程序带来各种麻烦。使用 Angular 异步管道，当组件被销毁时，订阅会自动取消订阅。此外，如果您使用新的 observable 重新分配与异步管道一起使用的属性，它会自动取消订阅旧的并订阅新分配的 Observable 或 Promise。这大大降低了 Angular 应用程序中内存泄漏的风险。 另一个好处是，异步管道在收到新值时会将模板标记为要检查更改。当您将更改检测策略设置为 OnPush 时，这会简化很多手工检查操作。 对于常规订阅(非异步管道订阅)，如果您使用 OnPush 策略，则 HTML 模板不会用于检查更改，这意味着您必须在订阅收到新值后自行触发更改检测。因此，通过将异步管道与 OnPush 策略结合使用，您可以获得两方面的好处，自动更新 HTML 模板，而无需自己触发它，也无需 Angular 定期检查它。结合使用异步管道和 OnPush 更改检测策略是提高 Angular 应用程序性能的好方法。 2. 如何使用 Angular 异步管道？要开始使用 Angular 异步管道，您需要在 TypeScript 文件中创建一个 Observable 属性，并为其分配一个 Observable 对象。现在，您可以在 HTML 模板中使用此属性，并在模板中使用 async 管道订阅 Observable 对象。异步管道将为您订阅可观察对象并解析 HTML 模板内的值。当组件被销毁时，异步管道将自动取消订阅可观察对象。在以下示例中，我创建了一个示例服务，其中包含我们订阅的 RxJs 主题，以及一个简单的方法来通过超时来更新其值，该超时会模拟我们真实场景中 Observable 的处理时间。 123456789101112131415161718import { Injectable } from &quot;@angular/core&quot;;import { Observable, Subject } from &quot;rxjs&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class TestServiceService { private readonly _testSubject: Subject&lt;any&gt; = new Subject&lt;any&gt;(); public testSubject: Observable&lt;any&gt; = this._testSubject.asObservable(); constructor() {} updateTestBehaviorSubject(value: any, timeout: number = 500) { setTimeout(() =&gt; { this._testSubject.next(value); }, timeout); }} 在 TypeScript 文件中，您可以看到我们分配可观察值的属性。属性名称以 $ 为前缀，这是可观察量的常见做法。Typescript 文件中还有一个函数调用来更新服务中的 Observable 值。 1234567891011121314151617import { Component } from &quot;@angular/core&quot;;import { TestServiceService } from &quot;./services/TestServiceService&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;],})export class AppComponent { $testObservable = this.testService.testSubject; constructor(private testService: TestServiceService) {} ngOnInit(): void { this.testService.updateTestBehaviorSubject(&quot;Some observable test value&quot;); }} 现在我们可以在 HTML 模板中使用$testObservable 属性以及异步管道来接收其值并将其显示在我们的视图中，如下所示： 1&lt;div&gt;{{$testObservable | async}}&lt;/div&gt; 通过使用异步管道，我们可以编写更少的代码，并且我们编写的代码不太容易出现内存泄漏。如果我们在没有异步管道的情况下执行相同的操作，我们的代码将如下所示： 123456789101112131415161718192021222324252627import { TestServiceService } from &quot;./test-service.service&quot;;import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;],})export class AppComponent { $testSubscription: any; testObservableValue: any; constructor(private testService: TestServiceService) {} ngOnInit(): void { this.testService.updateTestBehaviorSubject(&quot;Some observable test value&quot;); this.$testSubscription = this.testService.testSubject.subscribe( (value) =&gt; (this.testObservableValue = value) ); } ngOnDestroy(): void { //Called once, before the instance is destroyed. //Add 'implements OnDestroy' to the class. this.$testSubscription.unsubscribe(); }} 正如您所看到的，当我们不使用异步管道时，TypeScript 文件中需要更多代码。当订阅数量增加时，您忘记取消订阅的机会也会增加，从而导致很多麻烦。当您处理多个订阅时，样板代码也会开始堆积，使您的文件变得更加臃肿，并且更难以阅读和维护。 但现在您可能会问自己，当我想在订阅的括号内执行某些逻辑时会发生什么，如何使用异步管道处理？对于这个 Rxjs 使用 Pipe 和 Map 来救援！在将值发送到 HTML 模板之前，我们可以对可观察对象进行管道和映射以添加我们想要的任何逻辑。作为示例，我将在将可观察值发送回 HTML 之前向其添加一些文本： 12345678910111213141516171819202122import { Component } from &quot;@angular/core&quot;;import { TestServiceService } from &quot;./services/TestServiceService&quot;;import { map } from &quot;rxjs&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;],})export class AppComponent { $testObservable = this.testService.testSubject.pipe( map((val) =&gt; { return val + &quot; + Added value&quot;; }) ); constructor(private testService: TestServiceService) {} ngOnInit(): void { this.testService.updateTestBehaviorSubject(&quot;Some observable test value&quot;); }} 3. 以多种方式使用异步管道您可以在 HTML 模板中以多种方式使用异步管道及其生成的值。例如，您可能想要检查 *ngIf 或 *ngFor 内的值，或者在 HTML 模板中的多个位置使用该值。让我们看一下多种场景以及处理此问题的方法。 3.1. 在模板变量中使用异步管道在某些情况下，您可能需要 HTML 模板中多个位置的异步管道的解析值。实现此目的的一种方法是在模板中多次使用异步管道，但这会创建多个订阅，从而影响性能。 123456789101112131415161718192021import { TestServiceService } from &quot;./test-service.service&quot;;import { ChangeDetectionStrategy, Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.scss&quot;], changeDetection: ChangeDetectionStrategy.OnPush,})export class AppComponent { $testObservable = this.testService.testSubject; constructor(private testService: TestServiceService) {} ngOnInit(): void { this.testService.updateTestBehaviorSubject({ title: &quot;Some title&quot;, description: &quot;Test description&quot;, }); }} 1234&lt;div&gt; &lt;p&gt;{{( $testObservable | async)?.title }}&lt;/p&gt; &lt;p&gt;{{( $testObservable | async)?.description }}&lt;/p&gt;&lt;/div&gt; 这确实有效，但我们肯定可以做得更好，现在让我们为异步管道分配一个变量名称，这样我们就可以在多个地方使用该值，而无需多次使用异步管道。最常见的方法之一是在父元素上使用 *ngIf，并在 *ngIf 内使用异步管道， 这样您就可以安全地使用子元素中的值。只需用分号结束异步管道，并在其后创建一个 let 变量即可将异步值分配给该变量。 1234&lt;div *ngIf=&quot;$testObservable | async; let testValue&quot;&gt; &lt;p&gt;{{testValue.title }}&lt;/p&gt; &lt;p&gt;{{testValue.description }}&lt;/p&gt;&lt;/div&gt; 如果并非所有子元素都需要等待异步管道来解析值，并且没有明确的 HTML 标记来放置异步管道，您可以使用 ng-container 并将带有变量名称的异步管道放置在其上。 12345678&lt;div&gt; &lt;p&gt;Some other value that does not need to wait on the observable&lt;/p&gt; &lt;ng-container *ngIf=&quot;$testObservable | async; let testValue&quot;&gt; &lt;p&gt;{{testValue.title }}&lt;/p&gt; &lt;p&gt;{{testValue.description }}&lt;/p&gt; &lt;/ng-container&gt;&lt;/div&gt; 现在让我们修改代码通过将数组传递给 Observable： 1234this.testService.updateTestBehaviorSubject([ { title: &quot;Some title&quot;, description: &quot;Test description&quot; }, { title: &quot;Some title&quot;, description: &quot;Test description&quot; },]); 您还可以在 HTML 模板中将异步管道与 *ngFor 循环结合使用，如下所示： 1234&lt;div *ngFor=&quot;let item of $testObservable | async;&quot;&gt; &lt;p&gt;{{item.title }}&lt;/p&gt; &lt;p&gt;{{item.description }}&lt;/p&gt;&lt;/div&gt; 3.2. 处理多个异步管道最后一件事是如何在一个 HTML 模板中处理多个异步管道。假设我们的 HTML 模板中有 3 个不同的可观察量，并且所有这些都在 ngIf 中使用，如下所示： 12345678910111213&lt;div *ngIf=&quot;$testObservable | async; let testValue&quot;&gt; &lt;p&gt;{{testValue[0].title }}&lt;/p&gt; &lt;p&gt;{{testValue[0].description }}&lt;/p&gt;&lt;/div&gt;&lt;div *ngIf=&quot;$testObservable | async; let testValue2&quot;&gt; &lt;p&gt;{{testValue2[0].title }}&lt;/p&gt; &lt;p&gt;{{testValue2[0].description }}&lt;/p&gt;&lt;/div&gt;&lt;div *ngIf=&quot;$testObservable3 | async; let testValu3&quot;&gt; &lt;p&gt;{{testValu3[0].title }}&lt;/p&gt; &lt;p&gt;{{testValu3[0].description }}&lt;/p&gt;&lt;/div&gt; 当可观察量的数量增加时，HTML 模板的复杂性也会增加。这可能会导致 UI 错误，其中某些元素先于其他元素显示，或者无法获取其异步值，因为它位于另一个解析太晚的元素内部，等等。有一种更简洁的方法来处理这个问题，即创建一个 ng-container 元素，在其中一次性解析所有异步管道并将其分配给一个变量。 123456789101112131415161718192021&lt;ng-container *ngIf=&quot;{ obser1: $testObservable | async, obser2: $testObservable2 | async, obser3: $testObservable3 | async} as data&quot;&gt; &lt;div&gt; &lt;p&gt;{{data.obser1[0].title }}&lt;/p&gt; &lt;p&gt;{{data.obser1[0].description }}&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;{{data.obser2[0].title }}&lt;/p&gt; &lt;p&gt;{{data.obser2[0].description }}&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;{{data.obser2[0].title }}&lt;/p&gt; &lt;p&gt;{{data.obser2[0].description }}&lt;/p&gt; &lt;/div&gt;&lt;/ng-container&gt; 4. 异步加载动画当我们从服务器端获取数据时，通常有一个漫长的等等过程，数据在加载过程中，会出现白屏的情况，此时用户会不知所措，从而导致用户体验较差。此时我们可以在数据加载时显示加载动画，让用户直到数据正在加载，从而耐心等待数据加载完成。 123456789101112&lt;div *ngFor=&quot;let item of $testObservable | async; else loading&quot;&gt; &lt;p&gt;{{item.title }}&lt;/p&gt; &lt;p&gt;{{item.description }}&lt;/p&gt;&lt;/div&gt;&lt;ng-template #loading&gt; &lt;ion-card&gt; &lt;ion-card-content&gt; &lt;ion-skeleton-text animated&gt;&lt;/ion-skeleton-text&gt; &lt;/ion-card-content&gt; &lt;/ion-card&gt;&lt;/ng-template&gt; 5. 异步管道异常处理以下是一个异常处理的示例，其能够处理所有三种状态（加载、成功、错误）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import { Observable } from &quot;rxjs/Observable&quot;;import { of } from &quot;rxjs/observable/of&quot;;import { catchError } from &quot;rxjs/operators&quot;;import { Subject } from &quot;rxjs/Subject&quot;;@Component({ selector: &quot;app-mycomponent&quot;, changeDetection: ChangeDetectionStrategy.OnPush, template: ` &lt;div *ngIf=&quot;users$ | async as users; else loadingOrError&quot;&gt; &lt;div *ngFor=&quot;let user of users&quot;&gt; {{ user.name }} &lt;/div&gt; &lt;/div&gt; &lt;ng-template #loadingOrError&gt; &lt;div *ngIf=&quot;errorLoading$ | async; else loading&quot;&gt; Error loading the list of users. Please try again later. &lt;/div&gt; &lt;ng-template #loading&gt; Loading users... &lt;/ng-template&gt; &lt;/ng-template&gt; `,})export class LoadingWrapper&lt;T&gt; { private readonly _errorLoading$ : new Subject&lt;boolean&gt;(); readonly errorLoading$: Observable&lt;boolean&gt; : this._errorLoading$.pipe( shareReplay(1) ); readonly data$: Observable&lt;T&gt;; constructor(data: Observable&lt;T&gt;) { this.data$ : data.pipe( shareReplay(1), catchError((error) =&gt; { console.log(error); this._errorLoading$.next(true); return of(); }) ); }} 当组件被创建时，我们有一个 users$ 可观察的状态，因此 loadOrError ng-template 被创建。接下来，我们还有一个errorLoading$可观察的“假”状态，因此“正在加载用户…”文本是可见的。 如果发生错误，我们将使用 catchError 运算符捕获错误。其 effect 作用 catchError 是您将不再在 devtools 控制台中看到错误，这对于调试错误情况并不是非常有用。所以我们添加一个 console.error 并记录给定的错误。接下来，我们为该 loadingError$主题发出一个新值。最后一个重要的步骤是使用运算符恢复可观察值 of 并赋予它一个假值。您也可以使用 null. 更多 async pipe 异常相关内容，请参考Angular async pipe 中的异常处理 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 结论使用 Angular 异步管道是减少样板代码、在处理可观察量的方式上创建一定一致性的好方法，并且可以最大限度地减少数据泄漏的变化。我建议尽可能使用异步管道，它将提高应用程序的性能和可维护性。将异步管道与 OnPush 更改检测结合使用甚至可以通过在收到新值时自动标记要检查更改的 HTML 模板来使事情变得更好。 8. 参考文档Angular async pipe in depth How to Handle Errors Reactively when Using the Async Pipe [Error Handling with Angular`s async Pipe](https://sebastian-holstein.de/post/2018-02-26-error-handling-angular/)","link":"/angular/angular_async_pipe_in_depth.html"},{"title":"使用Angular实现面包屑导航","text":"面包屑导航(Breadcrumb Navigation)这个概念来自童话故事“汉赛尔和格莱特”，当汉赛尔和格莱特穿过森林时，不小心迷路了，但是他们发现沿途走过的地方都撒下了面包屑，让这些面包屑来帮助他们找到回家的路。 面包屑导航的作用面包屑导航最大的两个主要作用，一是让用户清晰地知道自己在那里，不会在网站中迷失方向，对网站的逻辑结构逐渐形成清晰地认识。尤其是初次通过外链接或者搜索引擎导流行进来的用户。 其二，用户能够快速的在页面之间切换，有人将面包屑导航比喻为电梯，可以在楼层之间自由地切换，相较于一级一级返回“楼梯”式的导航或者从主菜单引导式的导航，面包屑导航根据快捷方便，用户有更强的操控感。 但是面包屑导航不能作为主导航，它仍然只能主导航的辅助手段。就像我们日常饮食还是要以大米面食为主，但是如果有一些餐后甜点和水果，用户的满意度会更高。 对于搜索引擎来讲，面包屑导航会让蜘蛛了解你的网站结构，方便爬取索引。 面包屑导航的优点 减少不必要的步骤 面包屑导航最实用的一点便是可以帮助用户更快地访问上级网页，无需借助浏览器的“返回”按钮和顶级导航栏。 占用空间少 面包屑导航仅由文本和链接组成的一行内容构成，因此占用的页面空间非常小。这样的好处是当内容过载时它的功能也不会受到影响。 用户体验很好 用户可能会忽略这个小控件，但是他们从来不会误解或在使用上遇到问题。 面包屑导航的分类面包屑导航大致可以分为三类： 一是基于层次结构的导航。 这也是用户最经常用到的，它可以显示出当前页面在整个网站中所占据的层次，类似主页&gt;博客＞分类&gt;文章名称。对于结构层次深的网站来说很有帮助，不至于让用户在网站中迷路，对于用户体验的提升很有帮助； 二是基于属性的面包屑导航。 这种导航常见于电商类网站，显示为商品的属性类别，例如进行购买手机的时候可以对手机的品牌、系统、内存及尺寸等方面进行筛选组合，是用户方便了解当前查看的商品的属性； 三是基于路径的导航。 与童话中描述的方式相似，记录显示用户所访问过的网页，这种导航井不常见。 面包屑导航可用性设计指南面包屑显示为页面顶部的链接，通常位于全局导航下方；主页（或层次结构的根节点）是第一个链接。 链接通常用符号“&gt;”或“/”分隔，我们推荐使用“&gt;”字符，尽管两者在功能上没有区别。 当用户跳过一些网站层级，比如点击外部链接（如搜索引擎结果到达网站），面包屑会引导并帮助他们找到通往其他更相关页面的路径。 （一）在桌面上（PC端）使用面包屑导航的指南1.面包屑不应取代全局导航栏或部分本地导航。 面包屑可以作为导航的有效补充，但是不能取代主要导航。可以采用下拉式菜单。更好的设计是为本地导航提供单独的Ul，以使用户能够访问站点当前部分的横向层级页面。 2.面包屑应该显示站点层次结构中的当前位置，而不是浏览历史记录。 面包屑并不用于显示用户在网站的页面浏览历史记录（例如浏览器的本机后退按钮）；它们旨在显示站点的层次结构。 3.对于多层次站点，面包屑应显示站点多层次结构中的单一路径。 面包屑与多层次站点（其中一个页面有享个父级） 之间存在固有的紧张关系。在这种情况下，我们不建议两个或更多反映多层次结构中不同路径的面包屑路径，因为它们会混淆用户并在页面顶部占用大量空间。 如果一个页面有多个不同的父级，请在站点层次结构中标识到它的规范路径，并在面包屑路径中显示该路径。 4.包括当首页面作为面包屑路径中的最后一顶。 5.在面包屑路径中，当前页面对应的面包屑不应该是链接。 最后一个面包屑（表示当前页面） 不应该是链接。 为避免混淆用户，请在视觉上区分当前页面和前面键接的面包屑，最好使用下划线或蓝色文本。 6.面包屑应送只包含网站页面，而不是IA中的逻辑类别。 面包屑路径中的每个节点都应该是一个指向主页的链接。如果全局导航中的某些子类别标签没有专门的单独页面，请不要在面包屑路径中包含这些子类别。 “点击即走”能力是用户理解面包屑的关键部分，因此所有项目(当前页面除外)都应该代表用户可以去的地方。 7.对于具有仅 1-2层深的扁平结构站点或结构呈线性的站点，面包屑导航是非必需的。 8.面包屑路径应该以指向主页的链接开头。 （二）在移动设备上使用面包屑的指南需要提出的是，在移动设备上，使用面包屑的成本很快就会超过收益。 9.不要使用包含多行的面包屑。 在移动网站上，面包屑可以快速换成多行，并在已经拥挤的移动显示器上占用宝贵的空间。多行面包屑路径不能很好地说明链的结构。 10.不要使用太小或太拥挤的面包屑。 一些网站试图通过使链接更小或更靠近来减少面包屑占用的屏幕空间。不幸的是，此解决方案不适用手触摸屏：点击目标至少需要 1cm x 1cm。 11.考虑缩短面包屑路径以仅包含最后一个级别。 在某些页面上，指向一个级别的单个面包屑可能是支持主要用户目标所必需的。此解决方案避免了占用宝贵的移动空间的冗长、拥挤的面包屑路径。 请注意，此建议与准则 #8 冲突，井且只能在移动设备上完成。在桌面上一一有更多空间——总是显示完整的轨迹。 Angular面包屑导航选型在Angular项目中添加面包屑导航有很多选择。以下是一些Angular 面包屑导航组件库。 ngx-breadcrumbs xng-breadcrumb ng-dynamic-breadcrumb ng2-breadcrumb 82 forks, 102 stars ngx-breadcrumbs是基于ng2-breadcrumb的组件库, 并在其基础上增加了对高版本Angular的支持，两者都没有到1.0版本。 ng7-dynamic-breadcrumb是Angular的一个模块，它为应用程序的任何页面生成面包屑。它基于内置的Angular router。但是相比较与xng-breadcrumb更能没有那么丰富。 从npm趋势图来看，xng-breadcrumb下载量更高，项目更新更加活跃，更受欢迎。 所以最终还是选择了xng-breadcrumb。 xng-breadcrumb 特点✅ 零配置：只需在应用程序的任何位置添加&lt;xng-breadcrumb&gt;&lt;/xng-breadscrumb&gt;。面包屑标签是通过分析应用程序中的角度路线配置自动生成的。✅ 自定义标签：每条路线都可以通过Angular route Config定义一个自定义标签。生成面包屑时会自动使用这些标签。✅ 动态更新标签：使用BreadcrummService.set（）动态更改面包屑标签。您可以使用路由路径或路由路径别名来更新标签。✅ 跳过面包屑：有条件地跳过在面包屑中显示的特定路线。✅ 禁用breadcrumb：禁用特定路线，以便取消导航到中间路线。✅ 自定义：自定义面包屑模板以显示带有标签的图标，在文本上使用管道，添加带有ngx-translate的i18n等。✅ 样式：分隔符和样式可以轻松自定义。✅ QueryParams和Fragment：通过面包屑导航时保留QueryParams与Fragemnet✅ SSR：支持nguniversal的服务器端渲染 使用xng-breadcrumb快速添加面包屑导航在项目中引入xng-breadcrumb依赖12345npm install --save xng-breadcrumb//------------- 或者 -------------yarn add xng-breadcrumb 在主模块中引入BreadcrumbModule12345678910import {BreadcrumbModule} from 'xng-breadcrumb';@NgModule({ ... imports: [BreadcrumbModule], ...})export class AppModule { } 在页面中添加xng-breadcrumb组件123&lt;xng-breadcrumb&gt;&lt;/xng-breadcrumb&gt; 完成这些工作。你应该会看到自动生成的面包屑出现在每条路线上。 注意：xng-breadcrumb对@angular/router有依赖。在app.module.ts导入中需要包括RouterModule（如果您还没有）。 定制样式&lt;xng-breadcrumb&gt;为选择器定义了尽可能少的特殊性，以便轻松覆盖它们。 通过更改相应类的CSS来覆盖样式。（如果您不想使用：：ng-deep，请将此样式保存在应用程序根样式文件中） 下面是xng-breadcrumb中涉及的各种类的可视化，以帮助您轻松识别。 xng-breadcrumb将“class”作为输入。该类将应用于breadcrumb的根。当风格冲突时，这可以用来增加特异性。 123456789101112.xng-breadcrumb-root { padding: 8px 16px; display: inline-block; border-radius: 4px; background-color: #e7f1f1;}.xng-breadcrumb-separator { padding: 0 4px;} 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 参考文档Add Breadcrumbs to Your Angular App in Just 5 Minutes Breadcrumbs for Websites: Best Practices &amp; Examples Building Clickable Breadcrumbs Component for Angular Application 什么是面包屑导航？ 直达电梯－导航的交互设计 你真的会用面包屑导航吗？ Angular and Material Multi-level Menu with Breadcrumb not working properly xng-breadcrumb","link":"/angular/angular_breadcrumbs.html"},{"title":"Angular图表库介绍","text":"1. 前言如今，数据分析是任何业务应用程序的重要组成部分。这有助于企业做出重要决策。以易于理解和交互的方式表示大量数据非常重要。图表对于美观、易于理解和交互式的数据可视化非常有用。 JavaScript 中有不同的开源和付费图表库，可以实现漂亮的数据表示。 在本文中，我们将研究几款美观的, 易于交互的 Angular 图表库。 首先，我们将看到开源 Angular 图表库，稍后我们将研究其他付费 Angular 图表库. 2. npm 趋势图以下是近五年(as of 2023-09-04)的 npm 趋势图 以及状态图 从图中我们可以看出, ng2-charts 是比较老牌的 angular 图表库, 而且一直保持着较好的增长. 后起之秀 highcharts-angular 发展也比较迅猛. ngx-echarts 一直保持着稳步增长. 从活跃度来看 ng2-charts 更新一直比较活跃. 注意以上图中, 没有将 PrimeNG/Charts 加入到比较, 因为 PrimeNG/Charts 是 PrimeNG 这个大包里面的一个模块, npmtrends 不支持将模块添加到比较行列.而将整个 PrimeNG 添加到比较行列对其它 charts 库又不太公平, 所以请自行判断 PrimeNG/Charts 在整个 Angular chart libs 中的地位和发展. 3. 最佳开源 Angular 图表库以下是使用 Angular 技术封装的最佳开源图表库 ng2-charts ngx-echarts PrimeNG Charts ngx-charts angular-plotly.js 4. ng2-chartsng2-charts是经过 Angular 包装的基于Chart.js的 Angular 指令(directive) Chart.js 是一个流行的开源 JavaScript 图表库, Chart.js 使用 HTML5 画布，可在所有现代浏览器（IE11+）上提供出色的渲染性能。 ng2-charts 它提供了便于集成到 Angular 应用程序中的原理图。 4.1. Ng2-Charts 功能图表类型: ng2-charts 支持 8 种图表类型： 折线图 条形图 雷达图 饼图 面积图 圆环图 气泡图 散点图 定制化: 图例(Legends) 标签 颜色 提示条(Tooltip) 主题(Theming) 组合图表(Combine Charts) 选项(Options) 在这里查看Angular 13 中带有 ng2-charts 的很棒的图表 5. ngx-chartsngx-charts是 Angular2+ 的声明式图表框架。 它使用 Angular 来渲染和动画 SVG 元素，并利用 Angular 所有的绑定和速度优势，并使用 d3 来实现出色的数学函数、比例、轴和形状生成器等。 通过让 Angular 完成所有渲染，它为我们带来了 Angular 平台提供的无限可能性，例如 AoT、Universal 等。 ngx-charts 允许我们使用 CSS 自定义样式。我们还可以使用 ngx-charts 组件创建自定义图表。 以下是一篇很好的关于如何在 Angular 项目中使用 Ngx-Charts 的文章How To Use Ngx-Charts In Angular Application ? 5.1. ngx-charts 功能 图表类型 水平和垂直条形图(bar charts) 线型图(line) 面积图(Area)（标准、堆叠、归一化） 饼图(Pie)（可爆炸、网格、自定义图例） 气泡图(bubble) 油炸圈饼(Doughnut) 仪表盘(Gauge)（线性和径向） 热图(Heatmap) 树形图(Treemap) 数字卡片图(Number Cards) 定制化 自动缩放 时间线过滤(Timeline Filtering) Line Interpolation 可配置的轴标签 图例(Legends)（标签和渐变） 可定制的标签位置 实时数据支持 可定制的工具提示 数据点事件处理程序(Data point Event Handlers) 应用主题(Theming) 可以配合 ngUpgrade 一起升级 6. Ngx-Echartsngx-echarts是经过 Angular 包装的基于ECharts (3.x+) 的 Angular 指令(directive) ECharts 是一个开源的、基于 Web 的、跨平台的框架，支持交互式可视化的快速构建。 ECharts 在 github 上拥有 39.6k star 和 13.2k fork，被视为全球领先的可视化开发工具，在 GitHub 可视化类别中排名第三。 它可以在 PC 和移动设备上流畅运行。它与大多数现代网络浏览器兼容，例如 IE8/9/10/11、Chrome、Firefox、Safari 等。ECharts 依赖图形渲染引擎 ZRender 来创建直观、交互式和高度可定制的图表。 6.1. Ngx-Echarts 功能 图表类型 线型图系列 条形图系列 散点图系列 饼图 烛台图系列 统计箱线图系列 Map 系列 热图系列 方向信息线系列 关系图系列 树状图系列 旭日图系列 多平行系列尺寸数据 漏斗系列 量具系列 定制化 加载处理(Loading Handling) 事件处理(Event Handling) 数据实时更新 初始选项(Initial Options) 自动调整大小(Auto Resize) 应用主题 图表连接(Connect Charts) 可拖拽图表 3D 图表 请参阅ECharts 文档以获取更多自定义信息。 在此处查看使用 NGX-ECHARTS 在 Angular 中使用 ECharts 进行数据可视化 （带有 COVID Tracker 示例应用程序）。 7. Angular-PlotlyAngular-plotly是来自 plotly 的 plotly.js Angular 组件。 它支持 Angular 9.x，如果您想与 Angular 8.x 一起使用，请使用版本angular-plotly.js@1.x plotly.js 构建于 d3.js 和 stack.gl 之上，是一个高级声明性图表库。plotly.js 附带 40 多种图表类型，包括科学图表、3D 图表、统计图表、SVG 地图、金融图表等。Plotly.js 在 github 上有 1.12 万颗星和 1.3 万个分支。 7.1. Angular-Plotly.Js 的功能 基本图表：散点图、条形图、折线图、饼图、气泡图、点图、填充面积图、水平条形图、旭日图、桑基图、点云、多图表类型 统计图表：误差线、箱线图、直方图、二维密度图、平行类别图。 金融图表：瀑布图、指标、烛台图、漏斗图和漏斗面积图。 地图：Mapbox 地图图层、Mapbox 密度热图、Choropleth Mapbox、地图上的线条等。 3D 图表：3D 散点图、带状图、3D 曲面图、3D 网格图等 定制化: 下载为 SVG / PNG 数据导出 事件处理 自动调整大小(Auto Resize) 滚动(Scroll) 缩放(Zoom) 筛选(Filter) 动效(Animation) 分组(Group by) 8. primeng/chartPrimeNg/Charts组件基于 Charts.js 2.7.x，这是一个基于开源 HTML5 的图表库。 PrimeNG 是 Angular 的丰富 UI 组件的集合。所有小部件都是开源的，可以在 MIT 许可下免费使用。 8.1. PrimeNG/Charts 功能图表类型: 目前有 6 个选项可供选择；饼图、圆环图、折线图（折线图或水平条形图）、条形图、雷达图和极面积图。 定制化: 响应式(Responsive) 事件处理 标签 图例(Legends) 提示条(Tooltip) 宽度和高度 选项（参考 Chart.js 文档） 9. Angular Google Chartsangular-google-charts 是为 Angular 6 和 7 编写的 Google Charts 库的包装器(wrapper)。 Google 图表工具功能强大、易于使用且免费。 注意：Google Charts 是免费的，但不是开源的。Google 的许可不允许您在您的服务器上托管他们的 JS 文件。因此，如果您是企业并拥有一些敏感数据，Google Charts 可能不是最佳选择。 10. Highcharts AngularHighcharts Angular 是 Angular 的官方 Highcharts 包装器(wrapper)。 Highcharts 是一个基于 SVG 的现代多平台图表库。它拥有丰富的图表集合。 Highcharts 对于非商业用途是免费的，对于商业用途是付费的。 11. Angular Fusion Chartsangular-fusioncharts 是 FusionCharts JavaScript 图表库的简单且轻量级的官方 Angular 组件。angular-fusioncharts 使您能够轻松地在 Angular 应用程序中添加 JavaScript 图表。 FusionCharts 是一个 JavaScript 图表库，拥有饼图、柱形图、面积图、折线图、雷达图等图表以及 150 多种其他用于 Web 应用程序的图表。 Fusion Charts 提供商业用途的付费许可。 12. 相关文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 13. 总结在本文中，我们看到了五个最好的开源 Angular 图表库和其他付费 Angular 图表库。本文原文位于Angular 图表库介绍 | 鹏叔的技术博客, 若要获取最近更新请访问原文. 14. 参考文档Best Angular Chart Libraries","link":"/angular/angular_chart_solutions.html"},{"title":"Angular结合ckeditor5实现富文本以及markdown编辑器","text":"1. 背景介绍自己编写了一个博客系统，想要支持 html 和 markdown 两种格式，但是又不希望向其他博客系统一样，数据库存两种完全格式的内容，前端用多套编辑器这么麻烦和繁琐。于是做了一下 research 还真让我找到了。 这套方案的核心就是ckeditor5，它原本是一套富文本编辑器，但是当给它添加上 markdown plugin 以后，它就可以变成了一个富文本编辑器+markdown 编辑器类似 typro 编辑器，编辑器的输出统一为了 markdown 格式。 这样做的好处，大致有以下三点： 无论是偏爱富文本编辑器的用户还是 markdown 文本编辑器的用户都能被满足。非常类似于 typora 的使用体验。 文档格式统一，当有富文本编辑器偏好的用户习惯了 markdown 的简便性后可以顺利切换到 markdown 编辑器，以前的文档格式不用做转换。 用户可以采用富文本编辑器书写 markdown 文档，这样在用户不熟悉 markdown 文法的时候，可以使用富文本编辑器中的经验编写 markdown 就目前开源编辑器项目的现状来看，只有 ckeditor5 + markdown 插件支持得最好。以下是国外的一个网友针对 WYSIWYG 系列编辑器做的比较表格。 CKEditor5 TinyMCE QuillJS SlateJS Add Images Yes Yes Yes Yes Move Images Yes Yes No, is too buggy Yes, but clunky Resize Images Yes Yes Yes, with plugin “quill-image-resize” No. Paste Images Yes “Yes but buggy without paid PowerPaste plugin No, plugin “quill-image-drop-module” does not work when I try it. Yes with plugin “slate-drop-or-paste-images” Collaborative Editing Yes natively Yes using Wave. Yes using Wave. Yes using Wave. Tables Yes Yes Yes, with plugin “quill-better-table” Yes Paste from Office Yes Yes but buggy without paid PowerPaste plugin No No Lists Yes Yes Yes Yes Markdown Yes No Partially No 从最后一行可以看出，也只有 ckeditor5 这个富文本编辑器及其插件对 markdown 格式支持最好。我也实际体验了ckeditor-5 Markdown editor demo 和 quilljs-markdown demo.前者的用户体验要好太多。 所以在这个博客系统中，我果断的放弃了之前的 quill 方案，选用了 ckeditor-5 + markdown 插件（ckeditor5-markdown-gfm）的方案。quill 方案的实例在我的技术博客中也有详细讲解。 2. 创建 Angular 工程2.1. 创建工程首先创建一个 angular 工程. 工程的名字就叫 angular-richtext-markdown. 123ng new angular-richtext-markdown 2.2. 添加依赖这里需要添加 @ckeditor/ckeditor5-angular 依赖包, 以下是 ckeditor5-angular 与 Angular 之间的兼容关系. ckeditor5-angular， angular 以及 ckeditor5 的版本兼容性描述可以在ckeditor5-angular官网找到。 由于我目前使用的 angular 版本 17.3.2, 我选择的 ckeditor5-angular 为 7.x 版本，ckeditor5 版本为 42.x.x, ckeditor5-markdown-gfm 版本为 41.2.1。 123npm install --save @ckeditor/ckeditor5-angular@7.0.1npm install --save @ckeditor/ckeditor5-core @ckeditor/ckeditor5-engine @ckeditor/ckeditor5-utils @ckeditor/ckeditor5-watchdog 安装一个 CKEditor 5 predefined build 或者创建 create a custom predefined build. 1npm install --save @ckeditor/ckeditor5-build-classic 3. 创建编辑器3.1. 引入 ckeditor5 模块添加依赖包之后还不能直接使用 ckeditor, 还需要再使用 ckeditor 的 Module 声明文件引入它. 以下以根模块为例讲解如何引入模块，引入 @ckeditor/ckeditor5-angular 的 CKEditorModule src/app/app.component.ts 12345678910111213141516import { Component } from &quot;@angular/core&quot;;import { RouterOutlet } from &quot;@angular/router&quot;;import { CKEditorModule } from &quot;@ckeditor/ckeditor5-angular&quot;;import ClassicEditor from &quot;@ckeditor/ckeditor5-build-classic&quot;;@Component({ selector: &quot;app-root&quot;, standalone: true, imports: [RouterOutlet, CKEditorModule], templateUrl: &quot;./app.component.html&quot;, styleUrl: &quot;./app.component.scss&quot;,})export class AppComponent { title = &quot;angular&quot;; public Editor = ClassicEditor;} 123&lt;!-- app.component.html --&gt;&lt;ckeditor [editor]=&quot;Editor&quot; data=&quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;&gt;&lt;/ckeditor&gt; 4. 如何定制编辑器定制编辑器的方式有很多。 从源代码构建编辑器 如果您想向现有构建添加更多插件，或者自定义编辑器配置无法控制的内容，则需要首先创建自定义构建，如从源代码构建编辑器指南中所述。 完成以上教程后，您应该会得到一个生成的 ckeditor.js 文件（以及相应的 type 文件）。在下一步中，您应该将其复制到 src 目录中，并将其导入到组件文件中。 使用 CKEditor 5 online builder 定制 本指南假设您已经使用CKEditor5 在线构建器构建的编辑器创建了一个 zip 档案。 将其解压缩到应用程序的主目录中, 作为源代码的一部分进行使用。 基于一个已经存在的 predefined build 进行修改 利用 ckeditor 的核心组件以及一些打包工具从头构建 本文主要讲述如何通过 CKEditor 5 online builder 定制一个支持 markdown 功能的 ckeditor 4.1. 定制编辑器导航到CKEditor 5 online builder 第一步： 选择编辑器类型： classic, Inline, Ballon, Ballon block, Decoupled document. 第二步： 配置插件 第三步： 配置工具栏 第四步： 选择语言 第五步： 生成 builder 并下载。 对于 markdown editor, 需要选择 source editing 和 markdown 两个插件，后者提供了将输出转化为 markdown 文本，前者是提供了查看和编辑 markdown 的功能。另外需要将一些额外商业 license 的插件删除掉，例如 ckbox。 4.2. 如何使用定制编辑器经过前面的步骤我们会获得一个，包含源代码，已经编译后的文件的文件的 zip 文档。 首先将其解压，放置到项目同级的目录下，可以作为独立的代码库，也可可以作为 mono repo 的一个模块进行保存。 然后在 angular 项目安装该依赖。 123npm install --save path_to_customized_editor 经过以上操作，我们应该可以在 package.json 中看到如下更改 12345&quot;dependencies&quot;: { ... &quot;custom-ckeditor5&quot;: &quot;path_to_customized_editor&quot;, ...) 修改 app.component.ts， 将之前的 ckeditor5-build-classic 替换为定制的 src/app/app.component.ts 12345678910111213141516171819import { Component } from &quot;@angular/core&quot;;import { FormsModule } from &quot;@angular/forms&quot;;import { RouterOutlet } from &quot;@angular/router&quot;;import { CKEditorModule } from &quot;@ckeditor/ckeditor5-angular&quot;;//import ClassicEditor from '@ckeditor/ckeditor5-build-classic';import Editor from &quot;custom-ckeditor5&quot;;@Component({ selector: &quot;app-root&quot;, standalone: true, imports: [RouterOutlet, CKEditorModule, FormsModule], templateUrl: &quot;./app.component.html&quot;, styleUrl: &quot;./app.component.scss&quot;,})export class AppComponent { title = &quot;angular&quot;; public Editor = Editor; htmlData: string = &quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;;} 重新启动程序，我们应该能看到带有 markdown 功能的编辑器。 5. 如何添加更多插件如何需要添加更多插件，以及定制的功能，我们只需要维护 online buid 生成的源代码，然后重新编译即可。 例如我们需要添加一个 image upload 的功能。 12345cd path_to_customized_editornpm install --save @ckeditor/ckeditor5-upload 将 SimpleUploadAdapter 添加到插件列表并配置插件 编辑 ckeditor.ts 12345678910111213141516public static override builtinPlugins = [ SimpleUploadAdapter, //将 SimpleUploadAdapter 添加到插件列表 ....];public static override defaultConfig: EditorConfig = { toolbar: [ /* ... */ ], language: 'zh-cn', simpleUpload: { // 一些默认配置可以放在这里 // Feature configuration. }} 重新编译 cutomized ckeditor 123npm run build 在客户端，重新安装cutomized ckeditor 123npm install path_to_customized_editor 6. 在客户端配置插件customized ckeditor 可以作为一个可重用的逐渐，在前端或者客户端不同页面可能需要使用不同的参数。 例如对于对于uploadUrl，不同的项目，不同版本，不同的页面可能需要使用url, 这些都可以在具体使用是进行配置。 123simpleUpload: { uploadUrl: 'http://example/project/version/page/upload' }, 在创建ckeditor时我们可以给它传入特定的参数。 123&lt;ckeditor [editor]=&quot;Editor&quot; [config]=&quot;customEditorConfig&quot; data=&quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;&gt;&lt;/ckeditor&gt; 例如在使用过程中可以给它指定uploadUrl customEditorConfig: EditorConfig = { licenseKey: this.PRODUCTIVITY_PACK_LICENSE_KEY, language: 'zh-cn', toolbar: [ ..... ], ], }, simpleUpload: { uploadUrl: 'http://example/project/version/page/upload' }, image: { toolbar: [ 'imageTextAlternative', ] }, } ## 7. 参考文档 [Markdown output](https://ckeditor.com/docs/ckeditor5/latest/features/markdown.html) [WYSIWYG Comparison](https://docs.google.com/spreadsheets/d/15fVNQKZbO9BstMaiGzlqkCI9-WiKPlo9rWUX-NzNMxU/edit?pli=1&amp;gid=0#gid=0) [ckeditor-5 Markdown editor demo](https://ckeditor.com/ckeditor-5/demo/markdown/) [ckeditor5-demos source repository](https://github.com/ckeditor/ckeditor5-demos/tree/master/markdown) [Angular integration](https://ckeditor.com/docs/ckeditor5/latest/installation/integrations/angular.html) [Import from Markdown / Export as Markdown / Paste Markdown](https://github.com/ckeditor/ckeditor5/issues/14003)","link":"/angular/angular_ckEditor5.html"},{"title":"如何调试Angular应用程序","text":"本文演示如何调试 Angular 应用程序。在本文中，我们将讨论。 如何在 VS Code 中调试 Angular 应用程序 如何在 Chrome Dev Tool 中调试 Angular 应用程序 先决条件 我们已经创建并打开了一个 Angular 应用程序 1. 在 VS Code 中调试 Angular 应用程序以下是在 Visual Studio Code 中调试 Angular 应用程序的步骤。 1.1. 配置调试环境通过单击 VS 代码编辑器左侧的调试图标或使用快捷键[Ctrl] + [Shift] + [D] 转到调试视图。VS Code 将本地调试配置存储在 launch.json 文件中。 如果尚未配置 launch.json，VS Code 会要求创建一个。单击 运行和调试选项。 单击“运行和调试”后，系统会打开并要求您选择环境对话框。只需在其中输入“Chrome”并选择即可。 VS Code 将创建 launch.json 文件，其中包含启动应用程序的配置。以下是示例。 我们需要将 URL 中的端口号更改为 4200，因为 Angular 应用程序在此端口上运行。我们可以修改配置名称，但这是可选的。 如果 VS Code 中已经存在 launch.json，我们可以直接编辑launch.json。 1234567891011121314151617{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Launch Chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;chrome&quot;, &quot;url&quot;: &quot;http://localhost:4200&quot;, &quot;webRoot&quot;: &quot;${workspaceFolder}&quot; } ]} 1.2. 步骤2. 运行应用程序并开始调试在调试之前，请先使用以下命令运行 Angular 应用程序 1ng server -o 注意。首先需要在端口 4200 上运行应用程序，然后启动调试，因为调试器需要连接到应用程序的正在运行的实例才能与其交互。默认情况下，Angular 在端口 4200 上为应用程序提供服务。这意味着当我们使用命令 ng serve -o 或 ng serve –port 4200 运行应用程序时，它将启动本地开发服务器并使应用程序在 http://localhost:4200/ 上可用。 应用程序运行后，我们可以通过使用 Debug 面板并选择配置（例如“针对 localhost 启动 Chrome”）在 VS Code 中启动调试器。然后，调试器将连接到端口 4200 上正在运行的应用程序实例，并允许我们执行设置断点、检查变量和单步执行代码等任务。 让我们通过单击行号左侧来在代码中设置一个断点。单击绿色播放按钮或使用快捷键 F5 来启动调试会话。该应用程序将在 Google Chrome 中启动并在断点处停止。 我们现在可以从 Visual Studio Code 中检查变量、调用堆栈并执行其他调试操作。 2. 在 Chrome Dev Tool 中调试 Angular 应用程序2.1. Angular DevTools：强大的调试扩展Angular DevTools 是 Chrome 和 Firefox 的浏览器扩展程序，旨在增强 Angular 应用程序的调试和分析功能。只要在编译应用程序时关闭优化配置选项 ( {optimization:false})，它就可以与 Angular v12 或更高版本配合使用。 安装Angular DevTools扩展程序需要魔法，如果您没有魔法，you can access to my home page to get。 魔法可以从这里获得 Windows 上安装与配置 v2rayA。 2024 最新 v2rayA 安装与配置教程 for Windows、Macos、Linux、Android。 DevTools 扩展位于浏览器 DevTools 中的 Angular 选项卡下，打开后会出现两个附加选项卡： 组件：此选项卡可让您深入了解应用程序的组件和指令，从而让您预览或调整它们的状态。 Profiler：此选项卡使您能够分析您的应用程序，帮助您在执行变更检测期间检测性能瓶颈。 此外，它还显示 Angular 版本和扩展的最新提交哈希。 2.2. 使用 Angular DevTools 进行调试Angular DevTools 可帮助您快速查看应用的布局，显示组件和指令树。您可以使用鼠标或键盘快捷键检查每个部分及其详细信息和信息。 您可以直接从属性视图更新属性值并访问选定的组件或指令。 2.3. 分析您的应用程序Angular DevTools 中的 Profiler 选项卡记录了 Angular 如何检测更改并提供有用的事件信息。您可以在清晰的条形图中查看这些数据，其中显示了每个部分及其在每个步骤中的活动。 Profiler 选项卡可帮助您查看 Angular 如何查找更改并提供有用的事件详细信息。它显示了一个简单的条形图，其中显示了每个部分在每个步骤中的活动。它还有一个类似火焰图的视图，显示每个项目在显示树中的位置以及查找更改所用的时间。 如果您想了解更多信息，请查看Google团队的官方视频。 Angular DevTool Chrome 扩展程序 3. 参考文档How To Debug An Angular ApplicationHow To Debug Angular Applications Easy","link":"/angular/angular_debug.html"},{"title":"Angular结合quill实现富文本编辑器","text":"1. 前言由于需要一个富文本编辑器来编辑一些网页内容, 手动编辑后存储到数据库比较麻烦, 所以着手实现一个自己的富文本编辑器, 来编辑和存储一些 html 文件.这里使用 Angular 框架, 加 Quill 库实现. ngx-quill: https://github.com/KillerCodeMonkey/ngx-quillquill 官网: https://quilljs.com/ 2. 创建 Angular 工程2.1. 创建工程首先创建一个 angular 工程. 工程的名字就叫 angular-editor. 123ng new angular-editor 2.2. 添加依赖这里需要添加 ngx-quill 依赖包, 以下是 ngx-quill 与 Angular 之间的兼容关系. Angular ngx-quill supported v15 &gt;= 20.0.0 until May, 2024 v14 &gt;= 17.0.0 until Dec 02, 2023 v13 &gt;= 15.0.0, &lt; 17.0.0 until May 04, 2023 由于我目前使用的 angular 版本 13.3.11, 我选择了一个稳定版本ngx-quill@16.2.1查看ngx-quill@16.2.1的配置文件package.json, 其对应的 quill 版本为quill@1.3.7, 所以这里 quill 使用quill@1.3.7. 为了让 typescript 能识别类型信息, 这里还需要导入一个开发依赖包@types/quill@1.3.10, 版本也可以从 ngx-quill 的 package.json 中找到. 12345npm install ngx-quill@16.2.1 --savenpm install quill@1.3.7 --savenpm install @types/quill@1.3.10 --save-dev 当前最新版本为 ngx-quill@20.0.1 quill@1.3.7 3. 创建编辑器3.1. 引入 Quill 模块添加依赖包之后还不能直接使用 Quill, 还需要再使用 Quill 的 Module 声明文件引入它. 以下以根模块为例讲解如何引入模块，引入 ngx-quill 的 QuillModule app.module.ts 1234567891011121314151617import { NgModule } from &quot;@angular/core&quot;;import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { QuillModule } from &quot;ngx-quill&quot;; // 引入富文本编辑器模块import { AppRoutingModule } from &quot;./app-routing.module&quot;;import { AppComponent } from &quot;./app.component&quot;;@NgModule({ declarations: [AppComponent], imports: [ BrowserModule, AppRoutingModule, QuillModule.forRoot(), // 富文本编辑器模块 ], providers: [], bootstrap: [AppComponent],})export class AppModule {} 3.2. 引入 quill css 样式由于我使用的 scss, 所以可以很方便的引入 quill css. 可以在预编译的时候将 quill 的样式编译进来. 找到 styles.scss, 添加如下代码引入 quill 样式 quill 提供两种主题, 一种是 bubble, 另一种是 snow, 默认是 snow, 可以任选一种导入, 也可以同时导入两种主题, 方便动态切换样式. styles.scss 12@import url(&quot;https://cdn.quilljs.com/1.3.7/quill.snow.css&quot;);@import url(&quot;https://cdn.quilljs.com/1.3.7/quill.bubble.css&quot;); 3.3. 将 quill 富文本编辑器添加到页面做好以上准备工作, 我们就可以将 quill 富文本编辑器. 以 app.component.html 为例, 只要在页面添加这样一行, 然后启动 angular 应用, 就可以看到编辑器了. 1&lt;quill-editor&gt;&lt;/quill-editor&gt; 启动应用看效果 1ng serve --open 4. 加载与获取富文本内容当我们使用 quill 编辑文档的时候, 往往不是从空白文档开始, 大多数情况下我们是在已有文档的基础上进行修改. 当我们拿到一个文档时, 如何将其内容加载到 quill 编辑器中呢? 网上很多的教程或博客讲解得不够深入. 首先要将 quill-editor 与一个 control 控件连接起来, 如下: 123&lt;form [formGroup]=&quot;form&quot;&gt; &lt;quill-editor format=&quot;html&quot; formControlName=&quot;html&quot;&gt;&lt;/quill-editor&gt;&lt;/form&gt; 当然连接之前, 我们需要创建该控件. 12345form: FormGroup = this.fb.group({ html: new FormControl( '&lt;div&gt;test&lt;/div&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li class=&quot;ql-indent-1&quot;&gt;1-1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;ol&gt;&lt;li&gt;numbered&lt;/li&gt;&lt;li class=&quot;ql-indent-1&quot;&gt;numbered-1&lt;/li&gt;&lt;/ol&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;' ),}); 这样我们通过控制该控件, 可以在构建 FormControl 时传入, 也可以在创建完 FormControl 后通过 setValue 方法加载 html 内容, 就能加载 html 内容到 quill 编辑器中. 而在 quill 中编辑文档内容时, control 控件中的内容会自动更新. 当我们准备存盘时, 获取到该控件, 通过 value 熟悉即可获取到修改后的 html 内容 form.get(‘html’).value, 而不必去操作 quill-editor 组件. 更多用法可以参考ngx-quill 示例 5. 如何处理插入图片当插入图片时, quill 默认会将图片转换成 base64 编码嵌入到文本中, 因为我需要将富文本存储到数据库中, 这种默认方式会导致数据库字段内容庞大.影响查询性能. 所以我想将这种默认行为改为, 将图片保存到图片服务器, 在富文本中仅仅插入图片链接. 首先需要捕获 onEditorCreated 事件, 捕获该事件后我们才有机会替换 quill 编辑器的默认行为. 获取该事件的方法十分简单.只需要给 qull-editor 绑定一个定制的方法editorCreated($event), 通过$event 即可获取到创建好的 editor 本身. 12345&lt;quill-editor format=&quot;html&quot; formControlName=&quot;body&quot; (onEditorCreated)=&quot;editorCreated($event)&quot;&gt;&lt;/quill-editor&gt; 捕获到 onEditorCreated 事件以及获取到 editor 后我们就可以客制化插入图片的行为了. 123456789/** * ngx-quill上传图片需要的方法 */ editorCreated(quill:any) { const toolbar = quill.getModule('toolbar'); toolbar.addHandler('image', this.imageHandler); // 将image handler替换为自己的imageHander this.editor = quill;} 将 image handler 替换为自己的 imageHander. 例如, 一下是我实现的一个 imageHandler.实现方式比较容易理解, 即将图片上传到文件服务器, 然后获取到图片的 url, 将 url 嵌入到图片插入位置. 这里 imageHandler 做的事情很简单, 只是出发一个 open dialog 事件.为什么这样设计? 因为在 imageHandler 内部调用 this.dialog.open 创建的 DialogOverviewExampleDialog 脱离了 NgZone, 后续无论是渲染, 还是关闭对话框都会出现很奇怪的行为.所以在 imageHandler 内部只是触发一个事件.外部的 component 接收到这个事件再打开对话框. 12345678910111213 /** * Note: why not dirrectly call open dialog that's because * the mothod need to bind this which will cause * the problem that the component created by this.dialog.open * will be out of box (ngzone) * please refer to the page for the details * https://github.com/angular/components/issues/9676 */imageHandler(){ const event = new Event(&quot;open dialog&quot;); window.dispatchEvent(event);} 外部的组件也就是 AppComponent 接收到事件再弹出对话框 123456789101112131415@HostListener(&quot;window:open dialog&quot;)openDialog() { let dialogRef = this.dialog.open(DialogOverviewExampleDialog, {width:'400px'}); dialogRef.afterClosed().subscribe(result =&gt; { console.log(result); if(result) { const range = this.editor.getSelection(true); const index = range.index + range.length; this.editor.insertEmbed(index, 'image', result, 'user'); this.editor.setSelection(1+index) } });} 这里要自己设计对话框组件 DialogOverviewExampleDialog, 关闭时传出图片的 URL; 可以参照如下代码 example-dialog.component.ts 12345678910111213141516171819202122import { Component, NgZone, OnInit } from &quot;@angular/core&quot;;import { MatDialogRef } from &quot;@angular/material/dialog&quot;;@Component({ selector: &quot;dialog-overview-example-dialog&quot;, templateUrl: &quot;example-dialog.component.html&quot;, styleUrls: [&quot;./example-dialog.component.scss&quot;],})export class DialogOverviewExampleDialog implements OnInit { value = &quot;&quot;; constructor( public dialogRef: MatDialogRef&lt;DialogOverviewExampleDialog&gt;, public ngZone: NgZone ) {} ngOnInit(): void {} close(): void { console.log(&quot;close clicked&quot;); this.dialogRef.close(); }} example-dialog.component.html 123456789101112131415161718&lt;div cdkDrag cdkDragRootElement=&quot;.cdk-overlay-pane&quot; class=&quot;w-100&quot;&gt; &lt;h1 mat-dialog-title&gt;Insert image&lt;/h1&gt; &lt;div mat-dialog-content&gt; &lt;mat-form-field class=&quot;w-100&quot;&gt; &lt;mat-label&gt;url&lt;/mat-label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;input image url&quot; matInput [(ngModel)]=&quot;value&quot; /&gt; &lt;/mat-form-field&gt; &lt;/div&gt; &lt;div mat-dialog-actions&gt; &lt;button mat-button (click)=&quot;close()&quot;&gt;Cancel&lt;/button&gt; &lt;button mat-button [mat-dialog-close]=&quot;value&quot; cdkFocusInitial&gt;Ok&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 6. 实现后的效果实现后的效果如下: 7. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 8. 参考文档Angular：ngx-quill 富文本编辑器的使用 如何在 Angular 11/12 版本中整合 ngx-quill 教程 element ui 富文本编辑器的使用 Dialog Handler for image upload angular-demo","link":"/angular/angular_editor.html"},{"title":"Angular Flex Layout使用详解","text":"1. 前言1.1. update on 5th/Apr/2023根据 flex-layout 官方宣告, @angular/flex-layout 当前处于 deprecated 状态. 替代方案为 Tailwindcss 或者 Angular CDK. 具体原因参考官方的 anoucement - Medium post和 github 上的讨论 建议新项目使用其他 css library, 旧项目考虑移植到其他 css library. 迁移工具: migrate-angular-flex-to-tailwind [flex-layout-migrator](https ://github.com/NIPE-Solutions/flex-layout-migrator) 1.2. update on 25th/June/2023目前 DuncanFaulkner 克隆了@angular/flex-layout 并提供社区支持, 目前以及能支持 Angular 16 了. 所以使用社区版本的 flex-layout 也是一直选择, 如果重度依赖 flex-layout 新家现在位于 @ngbracket/ngx-layout。 2. 安装要在 Angular CLI 项目中使用@angular/flex-layout 相当简单，只需要两个步骤： 安装组件指令 1npm install @angular/flex-layout --save 将 Angular Flex Layout 导入到 app.module 中 123456789// src/app/app.module.tsimport {NgModule} from '@angular/core';import {FlexLayoutModule} from '@angular/flex-layout';@NgModule({imports: [FlexLayoutModule],...})export class AppModule {} 3. Angular Flex Layout 简介Flex Layout 布局 cheatsheet Angular Flex Layout 底层使用 FlexBox CSS + mediaQuery 来实现页面布局的设计. FlexBox 的基本模型请参考下图： FlexBox 主要角色为主容器(flex-container)和子元素(flex-item)，主容器来包各项子元素并控制子元素的排列方式。 4. 使用方式Angular Flex Layout 中，HTML API 可以分为以下三类： 容器类 Containers 子容器类 Child Elements within Containers 特殊响应功能 Special Response Features 4.1. 容器类建立一个 FLexBox 容器，其中可以包含一个以上的 Flex 子元素。fxLayout 控制容器内子元素的排版方向 范例： &lt;div fxLaout=&quot;row&quot; fxLayout.xs=&quot;column&quot;&gt;&lt;/div&gt;设定值: row: 预设值，由左到右，从上到下 column: 从上到下，再由左到右 row-reverse: 与 row 相反 column-reverse: 与 column 相反 wrap: 多行 fxLayoutWrap 控制容器内子元素的排版方式采用多行方式排列 范例： &lt;div fxLayoutWrap&gt;&lt;/div&gt; fxLayoutGap 控制容器内子元素的间隔 范例：&lt;div fxLayoutGap=&quot;10px&quot;&gt; &lt;/div&gt; 设定值： 可以接受这些单位%、px、vw、vh fxLayoutAlign 控制容器内子元素的对齐方式 范例：&lt;div fxLayoutAlign=&quot;start stretch&quot;&gt; &lt;/div&gt; 设定值： main-aixs: start、center、end、space-around、space-between cross-axis: start、center、end、stretch 4.2. 子元素类 fxFlex 控制子元素大小，以及如何自动增长或收缩大小 范例：&lt;div fxFlex=&quot;1 2 calc(15em + 20px)&quot;&gt;&lt;/div&gt; 设定值: 可接受这些单位 %、px、vw、vh 设定值顺序：&lt;grow&gt; &lt;shrink&gt; &lt;basis&gt; fxFlex 详细介绍可以参考https://www.angularjswiki.com/flexlayout/fxflex 当中 fxFlex 有很大的变化单行可以设定，它由三个属性组合而成，依照先后顺序分别是 flex-grow、flex-shrink 和 flex-basis，三个属性的解释如下： flex-grow 当子元素的 flex-basis 长度小于它父元素分配到的长度，按照数字做相对应的伸展比例分配数字，无单位，预设值为 1，设为 0 的话不会进行弹性变化，不可为负值 flex-shrink 当子元素 flex-basis 长度大于它从父元素分配到的长度，按照数字做对应的压缩比例分配数字，无单位，预设值为 1，设为 0 的话不会进行弹性变化，不可为负值 flex-basis 子元素的基本大小，作为父元素的大小比较基准预设值为 0， flex-basis 也可以设为 auto，表示子元素以自己的基本大小为单位 fxFlexOrder 定义排列顺序 范例： &lt;div fxFlexOrder=&quot;2&quot;&gt;&lt;/div&gt; 设定值： int fxFlexOffset 设定子元素的偏移 范例：&lt;div fxFlexOffset=&quot;20px&quot;&gt;&lt;/div&gt; 设定值：可接受这些单位 %、px、vw、vh fxFlexFill 最大化子元素，将子元素的 width 和 height 撑到最大 范例: &lt;div fxFlexFill&gt;&lt;/div&gt; 4.3. 特殊响应功能FlexBox CSS 本身无法控制 DOM 的显示与否，透过此特殊响应功能，方便我们控制容器或子元素的显示。 fxShow 设定显示条件范例: &lt;div fxShow [fxShow.xs]=&quot;isVisibleOnMobile()&quot;&gt;&lt;/div&gt; fxHide 设定隐藏条件范例：&lt;div fxHide [fxHide.gt-sm]=&quot;isVisibleOnDesktop()&quot;&gt;&lt;/div&gt; ngClass 强化 Angular 中 ngClass 的样式设定范例：&lt;div [ngClass.sm]=&quot;{'fxClass-sm': hasStyle}&quot;&gt;&lt;/div&gt; ngStyle 强化 Angular 中的 ngStyle 的样式设定范例：&lt;div [ngStyle.xs]=&quot;{'font-size.px': 10, color: 'blue'}&quot;&gt;&lt;/div&gt; 4.4. 响应断点屏幕断点是响应式设计的基础依据，它决定了我们要适配到什么样的设备或屏幕规格，并通过“媒体查询”这样的技术实现不同 “屏幕断点” 条件下的不同 UI 表现。一般情况屏幕断点都是手机、平板、PC 这三个维度设计。 响应式的关键在于控制断点，而在上面的范例中你可能会看到像 fxLayout.xs 这样的写法，这就是在控制主容器在 xs 断点下的布局方式，断点设定方式及适用范围请参考下表： 断点 适用范围 说明 (相当于正常设置满屏状态下) xs width &lt; 600px 手机_竖屏 sm 600px &lt;= width &lt; 960px 手机横屏, 平板竖屏, 平板横屏 md 960px &lt;= width &lt; 1279px 电脑_小屏 lg 1280px &lt;= width &lt; 1919px 电脑_大屏 xl 1920px &lt;= width &lt; 5000px 超大屏 lt-sm width &lt;= 599px 手机_竖屏 lt-md width &lt;= 959px 手机_竖屏, 手机横屏, 平板竖屏, 平板横屏 lt-lg width &lt;= 1279px 手机竖屏, 手机横屏, 平板竖屏, 平板横屏, 电脑小屏 lt-xl width &lt;= 1919px 手机竖屏, 手机横屏, 平板竖屏, 平板横屏, 电脑小屏,电脑_大屏 gt-xs width &gt;= 600px 手机横屏, 平板竖屏, 平板横屏, 电脑小屏,电脑大屏, 超大屏 gt-sm width &gt;= 960px 电脑小屏,电脑大屏, 超大屏 gt-md width &gt;= 1280px 电脑_大屏, 超大屏 gt-lg width &gt;= 1920px 超大屏 具体各机型手机屏幕尺寸可查看手机屏幕尺寸大全 5. 如何修改屏幕尺寸例如，要将 XL 断点从 1920px 更改为 1600px，请在 app.module.ts 中添加以下代码： 12345678910import { DEFAULT_BREAKPOINTS } from &quot;@angular/flex-layout&quot;;DEFAULT_BREAKPOINTS.find((item) =&gt; item.alias == &quot;lg&quot;).mediaQuery = &quot;screen and (min-width: 1280px) and (max-width: 1599.98px)&quot;;DEFAULT_BREAKPOINTS.find((item) =&gt; item.alias == &quot;xl&quot;).mediaQuery = &quot;screen and (min-width: 1600px) and (max-width: 4999.98px)&quot;;DEFAULT_BREAKPOINTS.find((item) =&gt; item.alias == &quot;lt-xl&quot;).mediaQuery = &quot;screen and (max-width: 1599.98px)&quot;;DEFAULT_BREAKPOINTS.find((item) =&gt; item.alias == &quot;gt-lg&quot;).mediaQuery = &quot;screen and (min-width: 1600px)&quot;; 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Angular 开发布局利器：Angular Flex Layout flex layout","link":"/angular/angular_flex_layout.html"},{"title":"Angular中使用forroot和forchild","text":"在本文中我们将深入探讨一些您可能已经见过的 Angular 模式和方法。我将讨论 Angular 管理依赖项辑器配置信息中经常会使用到的 forRoot 和 forChild 方法。 1. Angular 中的 forRoot 是什么？当我们使用 Angular6 及以上版本创建服务时，Angular 会在@Injectable 中创建一个对象，并将其 ProvideIn 属性为设置为’root’ 123456import { Injectable } from &quot;@Angular/core&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class UserService {} 当然，我们完全可以将其设置为我们想要的任何模块。这意味着除非我们导入在“provideIn”中指定的模块，否则 UserService 将不可用。 forRoot 用于提供初始化模块及其组件所需的配置数据。此配置数据可以是从环境变量到 API 密钥的任何数据，用于以特定方式设置应用程序。 大多数 Angular 开发人员都使用过 RouterModule 中的 forRoot 静态方法。这是为应用程序配置整个路由模块的方法，Angular 会全局创建它。 该方法本身返回一个 ModuleWithProviders 对象，其包括两个属性：ngModule 一般就是当前模块的引用，providers 一般是一组 provider。 RouterModule.forRoot() 1static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders&lt;RouterModule&gt;; ModuleWithProviders 1234export declare interface ModuleWithProviders&lt;T&gt; { ngModule: Type&lt;T&gt;; providers?: Provider[];} 2. 我们为什么需要 forRoot 和 forChild？引入模块我们一般有 3 个方法: 直接导入 1234567import { XXXModule } from 'xxx.module'@NgModule({ imports: [ XXXModule ]}) 如果 XXXModule 实现了 forRoot 方法，我们可以： 1234567import { XXXModule } from 'xxx.module'@NgModule({ imports: [ XXXModule.forRoot() ]}) 如果 XXXModule 实现了 forChild 方法，我们可以： 1234567import { XXXModule } from 'xxx.module'@NgModule({ imports: [ XXXModule.forChild() ]}) 在 angular 中，对于一些公共的组件，指令，管道，当我们需要在某个模块中使用时，我们就需要在该模块中导入一次。 但公共的服务是只需要引入一次的。对于一个服务，我们一般只需要在 root 模块中引入一次，然后就可以在其他模块中使用了。 当我们导入 XXXModule 时，angular 会为我们注册该模块上面的所有服务，如果我们在多个模块中导入了 XXXModule 模块，XXXModule 模块上面的服务是不会重复注册的，因为 angular 会确保服务都是单例的，也就是说一个应用里只会有一个该服务的实例。这能确保我们用服务共享数据时，不同模块取到的数据是一致的。 但有一种情况 angular 处理不了，当我们懒加载某一个模块时，该模块上面的服务会重新注册，如果该服务已经被注册过了，就会造成应用中一个服务有多个实例的情况。 怎么能确保完全的单例呢？这个时候我们就需要借助 forRoot 和 forChild 了。 3. 一个有关 forRoot 和 forChild 方法的示例我们来看一个有关 RouterModule forRoot 和 forChild 方法的示例。 1234567891011121314151617181920212223242526272829303132333435const routes: Routes = { path: '', component: LayoutComponent, children: [ { path: '', redirectTo: 'home', pathMatch: 'full', }, { path: 'home', loadChildren: ()=&gt; { import('features/home/home.module').then( (m)=&gt; m.HomeModule ) } }, { path: 'dashboard', loadChildren: ()=&gt; { import('features/dashboard/dashboard.module').then( (m)=&gt; m.DashboardModule ) } }, ],};@NgModule( { imports: [RouterModule.forRoot(routes)], exports: RouterModule })export class AppRoutingModule 正如您看到的, 在 Imports 数组中我们调用了 RouterModule 模块的 forRoot 方法, 并将事先定义好的参数 routes 传递给它, 该方法是静态的, 并需要接收一些必要参数. 1static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders&lt;RouterModule&gt;; 当 Angular 创建应用程序的同时它会创建创建路由系统，并且在整个应用程序的生命周期, 路由系统都是有效的.通常，forRoot 方法在应用程序中仅并调用一次，并且始终在根模块中存在。 123static forChild(routes: Routes): ModuleWithProviders&lt;RouterModule&gt;; 观察 ModuleWithProviders，我们可以看到 providers 属性是可选的，他们的区别也是在 providers 上。我们可以将需要确保完全单例的服务移动到 forRoot 中去。在主模块中导入模块时通过 forRoot 方法导入，在子模块中导入模块时直接导入。这样就能确保服务只会注册一次了。 4. 创建自己的 forRoot()您可以完全自由地创建自己的 forRoot 方法并将其放入您的模块中。毕竟，模块就是一个类。这是一个关于如何提供核心模块实例并确保仅调用一次的示例！ 1234567891011121314151617181920212223242526@NgModule({ declarations: [], imports: [],})export class CoreModule { constructor(@Optional() @SkipSelf() parentModule: CoreModule) { if (parentModule) { throw new Error( &quot;CoreModule is already loaded. Import it in the AppModule only&quot; ); } } static forRoot() { return { ngModule: CoreModule, providers: [], }; }}@NgModule({ declarations: [AppComponent], imports: [coreModule.forRoot()], providers: [], bootstrap: [AppComponent],})export class AppModule {} 正如我所说，这个方法可以被称为任何名称，但由于命名规范，我命名为 forRoot() 。它也可以接受参数。例如，我可以将初始配置数据传递给模块及其组件. 让我们试着给模块传递初始配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// interfaceexport interface UserModuleConfig { id: string;}// the Module we are implementing the configexport class UserModule { static forRoot(config: UserModuleConfig): ModuleWithProviders&lt;UserModule&gt; { return { ngModule: UserModule, providers: [ UserService, { provide: 'config', useValue: config } ] } }}// defining the Userodule with the forRoot config@NgModute({ declarations: [AppComponent], imports: [ CoreHodule.forRoot(), UserModule.forRoot ({ id: ‘abc’ })], providers: [], bootstrap: [AppConponent],})export class Apphodule {}// implement the service@Injectable()export class UserService { user_id: string; constructor(@Inject('config') private config: UserModuleConfig) { this.user_id = config.id }} 5. Angular 中的 forChild 是什么forChild 与 forRoot 非常相似。 在接下来的路由示例之中，需要指出的是此静态方法通常在功能模块中加载，这些功能模块通常加载到根模块中。它允许我们配置功能模块而不影响整个应用程序。 当加载模块本身时，惰性模块会创建服务和提供者的新实例。这是因为 Angular 使用另一个注入器来创建模块。一个单独的。 比如当我们调用 RoutingModule.forChild() 为子模块创建路由时, 不会再创建 RoutingService, 我们有多个路由模块时，在子模块中必须调用 forChild 方法。 让我们看一个例子。这是我们之前实现的惰性模块。 1234567891011121314151617181920212223const routes: Routes = { path: '', component: DashboardComponent, children: [ { path: '', redirectTo: 'overview', pathMatch: 'full', }, { path: 'overview', component: OverviewComponent, } ],};@NgModule( { imports: [RouterModule.forChild(routes)], exports: [RouterModule] })export class DashboardRoutingModule 您可以在模块中为自己创建一个类似的方法，并且只能传递特定于功能的服务和提供者. 6. forRoot 和 forChild 之间的区别让我们讨论并比较以下它们之间的差异。我将在这里重点关注 RouterModule，因为它是最常用的，并且对于理解它的工作原理也很有用。 让我们首先看看它们的相似之处: 声明路由器信息 管理路线 让我们再来看看它们的区别: 一个区别是 forRoot 通常用于整个应用程序，而 forChild 用于功能模块。 另一个关键区别是 forRoot 注册路由服务，而 forChild 则不注册！ 也可以说它们具有不同的范围、使用频率以及对服务和 Provider 的访问。 7. 总结总之，forRoot() 和 forChild() 是 Angular 中强大的方法，用于配置模块及其组件。虽然这两种方法的目的相似，但它们具有关键的差异，这使得它们在不同的环境中具有独特性和价值。通过有效地使用 forRoot 和 forChild，您可以确保 Angular 应用程序已正确配置并准备好处理其所有要求。 8. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 9. 参考文档using forroot and forchild in angular angular2 forRoot 和 forChild","link":"/angular/angular_forroot_forchild.html"},{"title":"在TypeScript和Angular中使用Getter和Setter","text":"getter 和 setter 是一种众所周知的模式，在不同的语言中使用。在本文中，我想通过 TypeScript 中的示例帮助您理解 getter 和 setter。看看它如何在 Angular 应用程序中发挥作用。 首先简单介绍一下 TypeScript。 1. TypeScript 中的 Getter 和 Setter假设我们有一个简单的产品类，其属性为：价格、名称、序列号。 12345export class Product { private price: number; public name: string; public serialNumber: string;} 这里我们有一个私有属性 price 和两个公共属性 name 和 serialNumber(序列号)。我们决定创建一个新的产品类实例——汽车。正如您在下图中看到的，我们可以访问 Product 类的任何公共属性，但不能访问私有属性。Price 属性只能从 Product 类访问，而不能从外部访问。 123456789export class Product { private price: number; public name: string; public serialNumber: string;}let car = new Product();car.name = &quot;volvo&quot;;car.price = 123; //这里会报编译错误 为了解决这个问题，我们可以使用 getter 和 setter。Getter 和 Setter 是几乎所有语言中常用的模式。它们可以帮助您向属性添加额外的逻辑，正如我们将在上面看到的那样。 因此，让我们将价格属性设为私有，并为其添加 getter 和 setter。 1234567891011121314151617export class Product { private _price: number; public name: string; public serialNumber: string; public get price() { return this._price; } public set price(value: number) { this._price = value; }}let car = new Product();car.name = &quot;volvo&quot;;car.price = 123; //编译错误消失 语法很简单，对吧？现在我们调用的不是私有属性，而是同名的 setter。并且我们可以通过 getter 获取私有属性的值。通过以上修改，我们可以汽车实例中访问价格属性了。 除此之外，现在我们可以向 set 方法添加额外的逻辑。例如，在给价格赋值之前, 检查检查价格是否合理以及许多更复杂的逻辑。 1234567891011121314151617181920export class Product { private _price: number; public name: string; public serialNumber: string; public get price() { return this._price; } public set price(value: number) { if (value == 0) { throw new Error(&quot;Price can not be zero&quot;); } this._price = value; }}let car = new Product();car.name = &quot;volvo&quot;;car.price = 123; //编译错误消失 2. Angular 中的 Getter 和 Setter在 Angular 中，getter 和 setter 经常被用作拦截输入属性更改的方法之一。例如，我们有两个组件。products 作为父组件，product 作为子组件，具有两个输入（价格、名称）。 12&lt;app-product name=&quot;Soda&quot; price=&quot;100&quot;&gt; &lt;/app-product&gt;&lt;app-product name=&quot;Bread&quot; price=&quot;10&quot;&gt; &lt;/app-product&gt; 12345678910111213141516171819202122export class ProductComponent { private _price: number; private _name: string; @Input() public get price() { return this._price; } public set price(value: number) { this._price = value; } @Input() public get name() { return this._name; } public set name(value: number) { this._name = value; }} 因此，每当我们有一个输入值时，setter 就会被触发，正如我们上面所做的那样，我们可以向我们的 setter 添加一些额外的逻辑。但是在 setter 使用额外逻辑有一些限制： 不要在 setter 中使用 side effects。 不要在 setter 中使用订阅。 不要使用_elementRef.detectChanges()。如果确实有必要，例如您在 setter 中调用一个方法来切换 ngStyle 属性中使用的某些属性或使用类似的 css 变量，那么最好选择_elementRef.markForCheck()。Angular 不接受输入属性 detectChanges，可能会导致控制台错误和性能问题 12345678910111213141516171819202122232425262728293031323334@Component( { selector: 'app-product-component', changeDetection: ChangeDetectionStrategy.OnPush })export class ProductComponent { private _borderSize: number; constructor(private _elementRef: ElementRef) { } @Input() public get borderSize(): number { return this._borderSize; } public set borderSize(value: number) { this._borderSize = value; this.setStyles(value) } private setStyles(borderSize: number) { this._elementRef.nativeElement.style.setProperty( '--offset', '${borderSize + 'px'}' ) this._elementRef.markForCheck(); }} 如果您将 non-primitive 对象向下传递给子组件时，并在子组件中更改该对象的某个属性，则通常也会出现变更不生效的情况。因为父组件保持的对该对象的引用而不是值本身, 虽然对象的属性改变了, 引用并没有变, 所有父组件侦察不到变化。如果您使用 OnPush 更改检测策略来配置组件，您可能会发现由于底层对象引用没有修改，因此不会触发值变更检测。您经常会遇到这种情况, 尤其使用硬编码时，这些值不是来自异步流（例如 Observable）。 如果您使用 Angular 的默认更改检测机制，则允许直接对象变更，因此将检测到在不提供新引用的情况下对对象进行的更改。 但是，如果您不应用默认的更改检测 - 只需使用 Observable 和异步管道就是您的方式！ 3. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 4. 总结在这里，我尝试描述 TypeScript 中 getter 和 setter 的常见原理，以及在 Angular 应用程序中使用它们的一些有用技巧。希望这篇文章对您有所帮助， 5. 参考文档Using Getters and Setters in TypeScript and Angular","link":"/angular/angular_getter_setter.html"},{"title":"Angular 中的全局错误处理","text":"错误处理是构建强大而可靠的 Angular 应用程序的关键方面。处理错误可以有效改善用户体验并帮助开发人员识别和修复问题。以下是 Angular 中的一些错误处理策略 全局错误处理设置全局错误处理程序来捕获应用程序中未处理的错误。这可以通过创建实现接口的服务来实现 ErrorHandler。 12345678import { Injectable, ErrorHandler } from &quot;@angular/core&quot;;@Injectable()export class GlobalErrorHandler implements ErrorHandler { handleError(error: any): void { console.error(&quot;Global Error Handler:&quot;, error); }} 在您的 app.config.ts 中，提供您自定义的 ErrorHandler 处理程序。 123456789101112export const appConfig: ApplicationConfig = { //..... providers: [ { provide: ErrorHandler, useClass: GlobalErrorHandler, deps: [], }, ] //...... 用于错误处理的 HTTP 拦截器使用 HTTP 拦截器全局处理 HTTP 错误。拦截 HTTP 请求和响应可让您集中错误处理逻辑。 123456789101112131415161718192021222324import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest,} from &quot;@angular/common/http&quot;;import { Injectable, inject } from &quot;@angular/core&quot;;import { Observable, throwError } from &quot;rxjs&quot;;import { catchError } from &quot;rxjs/operators&quot;;@Injectable()export class HttpErrorInterceptor implements HttpInterceptor { intercept( req: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;any&gt;&gt; { return next.handle(req).pipe( catchError((error: HttpErrorResponse) =&gt; { console.error(&quot;Http Error Interceptor: &quot;, error); return throwError(error); }) ); }} 不要忘记在你的 app.config.ts 中提供拦截器： 1234567{ provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true, } 组件级错误处理在组件级别实现错误处理，特别是对于关键操作或异步任务。 123456789101112131415161718192021222324252627import Component from '@angular/core';@Component({selector: 'app-example',template:`&lt;div *ngIf=&quot;errorMessage&quot;&gt;{{ errorMessage }}&lt;/div&gt; ])`export class ExampleComponent { errorMessage: string | null = null; fetchData(){ // Simulate an error in fetching data throw new Error('Failed to fetch data'); } handleError(error: Error){ / Handle component-specific errors this.errorMessage = error.message; }} 日志记录服务利用日志服务记录错误和其他相关信息。Angular 的 Console 服务或第三方日志库等服务可能会有所帮助。 12345678910111213141516171819import Injectable from '@angular/core';@Injectable({ providedIn: 'root'})export class LoggerService log(message: string): void { console. log(message); } error(message: string, error: any): void { console. error(message, error); // You can also send logs to a remote server or analytics service }} 在您的组件或服务中使用此服务来记录错误。 这些策略可以单独使用，也可以根据应用程序的要求组合使用。有效的错误处理包括记录错误、提供有意义的用户反馈以及在可能的情况下实施适当的恢复机制。 如果有其他可行的方法，请告诉我，并欢迎提出建议。 参考文档Global level Error Handling in Angular Angular HTTP Interceptors : Multiple Interceptors and 6 Code Examples of Interceptors","link":"/angular/angular_global_error_handling.html"},{"title":"使用Angular制作Github pages网站","text":"GitHub Pages 是 GitHub 提供的一项服务，人们可以免费托管网站。这有助于人们为他们的博客、作品集、业务等托管个人网站。我们可以毫不费力地在 GitHub 页面上托管一个只有 HTML、CSS 和 JavaScript 的简单网站，但复杂的应用程序需要一些努力。 Angular 应用程序本身有许多附加内容，如组件、node 模块、路由等等功能。有几种方法可以在 GitHub Pages 中托管 Angular 应用程序。在这篇博客文章中，我们将看到在 GitHub Pages 中托管 Angular 应用程序的最简单方法。 首先我们必须有一个 Angular 应用程序和一个 GitHub 存储库。 1. 创建 Angular 应用程序让我们使用 Angular CLI 创建一个示例 Angular 应用程序。 安装 Nodejs 可以参考博客 安装并配置 nodejs | 鹏叔的技术博客 安装 Angular CLI，使用以下命令： 1npm install -g @angular/cli 我们可以通过以下命令来验证安装是否成功： 1angular version 现在，我们可以使用 Angular CLI 来创建一个新项目。 123ng new sample 使用 ng new 命令创建 Angular 应用程序。 启动 Angular 应用，看一下初始的样子。 2. 设置 GitGit 是一种跟踪文件更改的软件。 Git 的主要目的是帮助开发人员在一个组织内或在单个项目上进行合作。 Git 也是免费和开源的。它将文件视为文件系统的快照。每次发生更改时，Git 都会获取一个快照并将其存储以供参考。如果 Git 已经安装，您可以跳过这一步。如果没有安装，可以参考这篇文章进行安装Windows 上安装 git2.x。 安装后，我们可以通过检查其版本来确保其准备就绪： 1git --version 这条命令将会打印安装的 Git 版本。 3. 托管 Angular 应用程序有很多方法可以在 GitHub Pages 中托管 Angular 应用程序。 本文主要讲述使用 Angular-cli-ghpages 在 Github 上 托管 Angular 应用程序： 安装 Angular-cli-ghpages 1ng add angular-cli-ghpages 编译 Angular 应用 1ng build --base-href /angular-app/ base-href 的值将替换 index.html base 的值 添加 git 仓库 在 github 上创建仓库 12git initgit remote add origin &lt;https://github.com/&gt;&lt;username&gt;/&lt;repository&gt;.git 将用户名和仓库名替换。 将编译后的 html, css, js 发布到 github 1npx angular-cli-ghpages --dir=dist/angular-app/browser 到 github repo 上查看内容是否发布成功， gh-pages 分支上是否有发布的内容， 内容是否部署成功。 等待内容 deploy 成功后， 打开连接查看网页内容 浏览器打开 https://&lt;username&gt;.github.io/&lt;repositoryname&gt; 将 username 以及 repositoryname 替换成相应内容 4. troubleshooting问题 1: .nojekyll 文件找不到 原因：angular-cli-ghpages 默认会在 dist 目录创建一个.nojekyll 下， 但是这往往不是所需要的。 解决办法： 在 dist/angular-app/browser 下面放一个空的.nojekyll 文件即可 问题 2： 发布到github时clone不下来，也push不上去。connection is closed by remote 在$HOME/.ssh目录下添加config文件 1$vi ~/.ssh/config 1234567# GitHubHost github.comPort 443User gitHostName ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 参考文档Easy Steps to Host an Angular App in GitHub Pages","link":"/angular/angular_host_github_pages.html"},{"title":"Angular injectable接口","text":"1. 前言本文将使用@Injectable 装饰器创建 Angular 服务。Angular 服务是可注入的，注入器可以将其注入到我们 Angular 应用程序中的任何组件或服务中。@Injectable 装饰器在类级别的服务中使用。@Injectable 装饰器帮助注入器考虑可注入的服务。在应用程序模块中的@NgModule 装饰器的提供者元数据中配置我们的服务后，该服务将在整个应用范围内可用。 要在组件中获取服务实例，我们需要为服务构造一个带参数的构造器, 并构造包含一系列可供组件或其他服务调用的方法。 假设我们想要创建一个购物车应用程序。在这种情况下，服务可以包含管理商店的方法、将商品添加到购物车的方法、从购物车中删除商品的方法以及查询商品的方法等。 2. 创建 Angular 服务我们可以参照以下步骤来创建服务. 第一步: 创建一个带@Injectable 装饰器的服务. 12@Injectable()export class ItemService {} @Injectable（）装饰器是一个在类级别使用的装饰器。它告诉注入器这个类可以由注入器(Injector)创建。我们在服务类中使用@Injectable，这样就可以自动创建服务实例对象，以便在任何组件或任何其他服务类中进行依赖注入. @Injectable 还可以用来负责实例化 Angular 组件、管道、指令等。这之所以成为可能，是因为@component、@pipe 和@directive 装饰器使用@Injectable 装饰器。如果我们用@Injectable 修饰的服务类与其他服务类有依赖关系，那么我们不必担心它的创建，依赖关系注入, 这些将将由 Injector 自动执行。 第二步, 在模块文件中的@NgModule 装饰器元数据中配置服务名称。 1234567891011@NgModule({ ---- ---- providers: [ ItemService ], ---- ----})export class AppModule { } 只有当我们在@NgModule 的 providers 元数据中配置服务时，组件才能使用服务。我们也可以在@Component 的提供者元数据中配置服务，但在这种情况下，该服务将仅对该组件可用。当我们在模块文件中的@NgModule 装饰器的提供者元数据中配置服务时，该服务将在应用程序中全局范围可用。 我们还可以在@Injectable 装饰器中使用 providedIn:’root’属性来使服务全局可用。 1234@Injectable({ providedIn: &quot;root&quot;,})export class ItemService {} 第三步: 注入服务 1234567@Component({ selector: &quot;store-app&quot;, templateUrl: &quot;./store.component.html&quot;,})export class StoreComponent { constructor(private itemService: ItemService) {}} 为了在我们的组件中获得可用的服务，我们需要在私有范围中创建一个具有我们的服务类型参数的构造函数。当加载部件时，注入器将注入服务。现在我们已经准备好调用组件中的服务方法了。在上面的代码片段中，我们的服务实例是 itemService，它将用于调用 itemService 服务的方法。 3. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 4. 参考文档Angular Services Example using)","link":"/angular/angular_injectable_decorator.html"},{"title":"自己动手写一个Angular 日志框架","text":"日志记录是软件行业中相当常见的话题。不幸的是，它在前端世界中并不常见，虽然在后端相关文章中经常提到。 然而，这个主题也适用于前端项目。 在本文中，我们将了解什么是日志记录以及在现代 Angular 应用程序中实现它的各种方法。 1. 记录日志有什么用？首先，为什么我们要在 Angular 应用程序中记录任何内容？ 这里我们可以区分两个方面： 环境 我们想要阅读的信息类型 1.1. 环境从开发人员的角度来看，我们可能希望从应用程序的各个地方发生的事情中获得尽可能多的日志。 然而，从用户的角度来看，我不希望在开发工具中看到一堆日志或对后端的许多 HTTP 调用。 从环境（无论是生产环境、UAT 还是其他环境）来看，日志记录可能会发生变化，并提供有关应用程序的用途或使用方式的不同见解。 1.2. 信息类型日志携带两类信息：它们的级别（是错误？常规操作？不寻常的东西？）和它们的有效负载，即实际内容。 通过使用这两个部分，我们可以提供对用户所做事情的洞察，功能日志（例如 New todo created by John）或技术日志（例如 Cache refreshed, 486 todo items synchronized）。 通过组合日志类型并根据环境区分它们，我们可以实现应用程序更好的可观察性，提高我们的故障排除能力和整体开发体验。 2. 内置方式在 JavaScript 中，最知名的日志记录方法是调用该 console.log 方法，该方法将日志显示到控制台中： 1234&gt;&gt; console.log(&quot;hi tom!&quot;)hi tom! 除了 log 方法之外，还可以使用其他方法来显示信息： 1234567&gt;&gt; console.warn(&quot;Uh oh!&quot;)Uh oh!&gt;&gt; console.error(&quot;Oh no!&quot;)Oh no! 还有许多其他您可能想阅读的内容 3. 添加日志目前，我们没有任何日志，只能通过浏览代码来了解发生了什么。 通过利用该 console.log 方法，我们现在可以将一些日志添加到 TodoService： 123456789101112131415161718@Injectable({ providedIn: &quot;root&quot; })export class TodoService { // ... delete(idToDelete: number): void { // ... console.log(&quot;Todo Item #%d deleted&quot;, idToDelete); } setComplete(idToSet: number, isDone: boolean): void { // ... console.log( &quot;Todo Item #%d status set to %s&quot;, idToSet, isDone ? &quot;done&quot; : &quot;pending&quot; ); }} 3.1. 局限性尽管拥有日志很棒，但这些日志将在部署站点时发送到生产环境。 更糟糕的是，console.xxx 它们不集中，使得在审查或提交代码时更难发现并且更容易忘记。 这些日志还缺少我们可能需要的一些功能，例如记录到不同的提供程序（HTTP、控制台，为什么不甚至是另一个 Angular 服务？）。 出于所有这些原因，最好将它们集中在专用组件中。 3.2. 利用 Angular 服务我们可以创建一个简单的抽象来包装 console 调用： 1234567891011121314@Injectable({ providedIn: &quot;root&quot; })export class LoggerService { info(template: string, ...optionalParams: any[]): void { console.log(template, ...optionalParams); } warning(template: string, ...optionalParams: any[]): void { console.warn(template, ...optionalParams); } error(template: string, ...optionalParams: any[]): void { console.error(template, ...optionalParams); }} 只需使用这个新层，我们现在就可以在一个地方修改日志的行为。 例如，如果我们在生产中，我们可能希望禁用所有信息日志： 12345678910export class LoggerService { info(template: string, ...optionalParams: any[]): void {+ if (!isDevMode()) return; console.log(template, ...optionalParams); } // ...} 我们还可以强制执行特定的格式，例如添加当前时间： 123456789101112131415export class LoggerService {+ #withDate(template: string): string {+ return `${new Date().toLocaleTimeString()} | ${template}`;+ } info(template: string, ...optionalParams: any[]): void { if (!isDevMode()) return;- console.log(template, ...optionalParams);+ console.log(this.#withDate(template), ...optionalParams); } // ...} 3.3. 使用 LoggerServiceLoggerService 在新文件中创建 logger.service.ts 并添加之前的代码以在消息中记录日期。 完成后，替换任何出现的 console.from TodoService，并将它们替换为对我们新的 LoggerService. 完成这些更改后，您现在应该可以看到日志及打印时间 3.4. 定义日志级别虽然基础已经通过我们的服务建立起来，但如果我们想加强我们的日志，现在我们可以做很多事情。 定义日志级别通常，有六个日志级别： Name Meaning Example TRACE Tracing of the execution flow Starting DoStuff() DEBUG Information helpful for debugging purposes Value of x: 42 INFO General information about program execution Application started WARNING Indication of potential issues or anomalies Id not found ERROR Describes an error that occurred Unable to connect to the database FATAL Indicates a critical failure in the program System crashed 我们可以用枚举来表示这些级别： 12345678910export enum LogLevel { NEVER = Number.MAX_SAFE_INTEGER, TRACE = 0, DEBUG = 1, INFO = 2, WARNING = 3, ERROR = 4, FATAL = 5,} 并 InjectionToken 为我们的应用程序公开一个默认日志级别： 12345678910export const MIN_LOG_LEVEL = new InjectionToken&lt;LogLevel&gt;(&quot;Minimum log level&quot;);bootstrapApplication(AppComponent, { providers: [ { provide: MIN_LOG_LEVEL, useValue: isDevMode() ? LogLevel.INFO : LogLevel.NEVER, }, ],}); 也可以直接从环境变量设置 LoggerService 通过使用这个令牌，我们可以限制基于它的行为： 1234567891011121314151617export class LoggerService {+ readonly #minLogLevel = inject(MIN_LOG_LEVEL) ?? LogLevel.NEVER;+ #canLog(logLevel: LogLevel): boolean {+ return logLevel &gt;= this.#minLogLevel;+ } info(template: string, ...optionalParams: any[]): void {- if (!isDevMode()) return;+ if (!this.#canLog(LogLevel.INFO)) return; console.log(this.#withDate(template), ...optionalParams); } // ...} 为了 LoggerService 使用日志级别而不是检查 isDevMode，请 LogLevel 定义在新的 loglevel.enum.ts 文件中. 然后，如前所述定义”MIN_LOG_LEVEL” token， 并在 main.ts 以 provider 的方式以依赖注入的方式提供 MIN_LOG_LEVEL. 最后，使用前面的 LoggerService 代码片段来使用 token，定义#canLog 方法并将对的调用替换 isDevMode 为对新定义的#canLog 方法的调用。 完成后，您应该会发现应用程序的行为没有任何差异，但请尝试将其更改 MIN_LOG_LEVEL 为 LogLevel.NEVER：不再记录任何内容。 3.5. 使用 provider 注入 logging serviceAngular 拥有非常强大的依赖注入系统，自从引入该 inject 功能后就更加强大了。 使用它，我们可以通过适当 privider 来无缝地组合服务。 在我们的 logger 上下文中，我们可以利用它根据环境轻松改变记录器的行为，而无需将逻辑传播到各处。 为此，我们可以定义一个接口，为我们的日志系统公开提供程序： 12345export interface LoggerProvider { info(template: string, ...optionalParams: any[]): void; warning(template: string, ...optionalParams: any[]): void; error(template: string, ...optionalParams: any[]): void;} 一种简单的实现可能是依赖于 console： 1234567891011121314@Injectable()export class ConsoleProvider implements LoggerProvider { info(template: string, ...optionalParams: any[]): void { console.log(template, ...optionalParams); } warning(template: string, ...optionalParams: any[]): void { console.warn(template, ...optionalParams); } error(template: string, ...optionalParams: any[]): void { console.error(template, ...optionalParams); }} 由于这是一个 Injectable，我们绝对可以使用 HttpClient 例如，将日志发送到专用后端 然后我们可以利用 DI 系统的灵活性来定义一个新的 InjectionToken，提供所有已注册的 LoggerProvider： export const LOGGER_PROVIDERS = new InjectionToken&lt;LoggerProvider[]&gt;(“Providers for the logger”); 并注册我们的实现： 12345678910111213141516171819+ function registerLoggerProviders(): EnvironmentProviders {+ return makeEnvironmentProviders(+ isDevMode()+ ? [{ provide: LOGGER_PROVIDERS, useClass: ConsoleProvider, multi: true }]+ : []+ );+}bootstrapApplication(AppComponent, { providers: [+ registerLoggerProviders(), { provide: MIN_LOG_LEVEL, useValue: isDevMode() ? LogLevel.INFO : LogLevel.NEVER, }, ],}); 请注意，注册是根据当前环境组成的：更改应用程序在运行时使用的提供程序只需要在这里进行更改！ 我们的 logger 现在可以使用 LOGGER_PROVIDERS 令牌注入 logger 并仅仅依赖于 LoggerProvider 接口，而不是实现 LoggerProvider 的类，并且只关心何时调用它们： 12345678910111213141516171819export class LoggerService { readonly #minLogLevel = inject(MIN_LOG_LEVEL) ?? LogLevel.NEVER;+ readonly #providers = inject(LOGGER_PROVIDERS) ?? []; #canLog(logLevel: LogLevel): boolean { return logLevel &gt;= this.#minLogLevel; } info(template: string, ...optionalParams: any[]): void { if (!this.#canLog(LogLevel.INFO)) return;+ this.#providers.forEach((provider) =&gt;+ provider.info(template, ...optionalParams)+ ); } // ...} 3.6. 添加自定义 LoggerProvider按照前面的部分操作，以便 LoggerService 依赖所提供的 LoggerProvider。 再一次，除了我们不再在日志中添加时间这一事实之外，应用程序中不应看到任何更改：让我们将其恢复！ LoggerProvider 创建命名的新实现 TimedConsoleProvider。这个实现应该使用前面的#withDate 方法来格式化模板。 实现后，在 main.ts 文件中以 root 级别提供它，以便它可以与 ConsoleProvider 一起注入. 不要忘记设置 multi: true 为同一个 token 注册多个类 如果您按照这些步骤操作，您现在应该会看到每个操作的两个日志：一个由 编写 ConsoleProvider，另一个由 编写 TimedConsoleProvider： 4. 总结在本文中，我们了解了日志记录对于前端应用程序的意义，并研究了一系列在 Angular 中集成日志记录的技术，从简单的方法到更复杂的方法。 在现实应用程序中，您可能更喜欢依赖标准化的第三方库，在配置方面提供更多选项，例如@ngworker/lumberjack 或 ngx-logger 日志记录可以帮助您更好地观察应用程序。然而，保持以用户为中心的方法至关重要。 在生产环境中过多记录技术细节或过多使用 HTTP 调用可能会降低整体用户体验。在信息记录和用户体验之间取得适当的平衡是确保应用程序无缝运行的关键。 5. 参考文档What is going on here? Getting Started With Logging in Angular","link":"/angular/angular_logging.html"},{"title":"Angular Material 3 自定义主题","text":"1. 什么是 Material 3Material 3 (M3)是 Google 开源设计系统 Material Design 的最新版本。它是 Angular Material 所遵循的设计系统 Material 2 (M2)的继承者。 从 v17.2.0 开始，Angular Material 除了 M2 之外还包括对 M3 样式的实验性支持。该团队计划在短暂的实验后稳定对 M3 的支持，以获得有关设计和 API 的反馈。 2. 如何在您的应用中使用 Material 3作为许多应用程序已使用的同一组 Angular Material 组件的备用 Sass 主题。要将 M3 与 Angular Material 结合使用，请使用函数@angular/material-experimental 包中的 define-theme 创建主题，而不是 使用 @angular/material 的 define-light-theme 或 define-dark-theme 用于创建 M2 主题。 2.1. 定义您的主题API 最简单的用法$theme: matx.define-theme()是定义具有默认值的主题。但是，与 M2 对应项一样，define-theme 允许您通过传递主题配置对象，沿着三个主题维度配置 Angular Material 应用程序的外观：颜色、排版和密度。配置对象可以具有以下属性。 属性 描述 color [可选] 颜色选项。有关详细信息，请参阅自定义颜色。 typography [可选] 颜色选项。有关详细信息，请参阅自定义排版。 density [可选] 密度选项。有关详细信息，请参阅自定义密度。 1234567891011121314151617@use &quot;@angular/material-experimental&quot; as matx;$theme: matx.define-theme( ( color: ( theme-type: dark, primary: matx.$m3-violet-palette, ), typography: ( brand-family: &quot;Comic Sans&quot;, bold-weight: 900, ), density: ( scale: -1, ), )); 2.2. 定制您的颜色您的应用程序颜色的以下方面可以通过 color 主题配置对象的属性进行自定义（请参阅M3 颜色规范以了解有关这些术语的更多信息）： 颜色属性 描述 theme-type [可选] 指定主题的类型，light 或 dark. primary [可选] 指定用于应用程序主要调色板的调色板。 （注意：M3 规范中描述的辅助调色板、中性调色板和中性变体调色板将根据您的主调色板自动选择，以确保和谐的颜色组合）。 tertiary [可选] 指定用于应用程序的第三调色板的调色板。 有许多可用的调色板@angular/material-experimental 可以与 primary 和 tertiary 选项一起使用： $m3-red-palette 红色 $m3-green-palette 绿色 $m3-blue-palette 蓝色 $m3-yellow-palette 黄色 $m3-cyan-palette 青色主题 $m3-magenta-palette 洋红色 $m3-orange-palette 橙色 $m3-chartreuse-palette 浅黄色/浅绿色 $m3-azure-palette 天蓝色的/蔚蓝色的 $m3-violet-palette 蓝紫色/紫罗兰色 $m3-rose-palette 玫红色 2.3. 定制 typography您的应用程序排版的以下方面可以通过 typography 主题配置对象的属性进行自定义（请参阅 M3 排版规范以了解有关这些术语的更多信息）： 版式属性 描述 plain-family [可选] 用于纯文本（例如正文）的字体系列。 brand-family [可选] 用于品牌文本（例如标题）的字体系列。 bold-weight [可选] 用于粗体文本的字体粗细。 medium-weight [可选] 用于中等文本的字体粗细。 regular-weight [可选] 用于常规文本的字体粗细。 2.4. 定制密度您的应用程序密度的以下方面可以通过 density 主题配置对象的属性进行自定义： 密度特性 描述 scale [可选] 应用程序中组件的紧凑程度，从 0（最多空间）到-5（最紧凑）。 3. 应用主题创建主题后，您可以使用与应用 M2 相同的-theme、-color、-typography、 density 以及 -base mixin 来应用主题（在主题通用指南中了解有关这些 mixins 的更多信息）。对于 M3 主题，这些 mixins 对生成的样式做出了一些保证。这些保证对 M2 主题时不适用。 mixins 在您指定的确切选择器下生成属性。它们不会被添加到选择器或增加规则的特殊性。mixin 只生成 CSS 自定义属性声明 （例如–some-prop: xyz）。它们不发出任何标准 CSS 属性，例如 color、 width 等。 3.1. 使用组件颜色变体许多组件都有一个 color 属性，允许开发人员应用组件的不同颜色变体。当使用 M3 主题时，此属性仍然向组件添加 CSS 类（例如.mat-accent）。但是，没有针对这些类的内置样式。您可以通过将$color-variant 选项传递给组件-theme 或 -color mixin 来应用颜色变体。 1234&lt;mat-checkbox class=&quot;tertiary-checkbox&quot; /&gt;&lt;section class=&quot;tertiary-checkbox&quot;&gt; &lt;mat-checkbox /&gt;&lt;/section&gt; 12345678@use &quot;@angular/material&quot; as mat;@use &quot;@angular/material-experimental&quot; as matx;$theme: matx.define-theme();.tertiary-checkbox { @include mat.checkbox-color($theme, $color-variant: tertiary);} 此 API 更灵活，并且生成的 CSS 更少。例如，.tertiary-checkbox 上面显示的类可以应用于任何复选框或包含复选框的任何元素，以更改该元素内所有复选框的颜色。 虽然您应该更喜欢显式应用具有颜色变体的 mixins，但您也可以使用 mixins 提供的向后兼容性 ，将样式直接应用于现有 CSS 类（mat-primary、mat-accent 和 mat-warn）。 下表显示了$color-variant 每个组件支持的值。 （未列出的组件不支持任何颜色变体。） 组件 支持的$color-variant 值 默认 Badge 徽章 primary, secondary, tertiary,error error Button 按钮 primary, secondary, tertiary,error primary Button-toggle primary, secondary, tertiary,error secondary Checkbox 复选框 primary, secondary, tertiary,error primary Chips primary, secondary, tertiary,error secondary Datepicker 日期选择器 primary, secondary, tertiary,error primary Fab primary, secondary,tertiary primary Form-field primary, secondary, tertiary,error primary Icon 图标 surface, primary, secondary, tertiary,error surface Option 选项 primary, secondary, tertiary,error secondary Progress-bar 进度条 primary, secondary, tertiary,error primary Progress-spinner primary, secondary, tertiary,error primary Pseudo-checkbox primary, secondary, tertiary,error primary Radio 单选框 primary, secondary, tertiary,error primary Select primary, secondary, tertiary,error primary Slide-toggle primary, secondary, tertiary,error primary Slide primary, secondary, tertiary,error primary Stepper primary, secondary, tertiary,error primary Tabs primary, secondary, tertiary,error primary 3.2. 使用 CSS 自定义属性进行精细自定义主题 mixin 生成的 CSS 自定义属性源自 M3 的设计令牌。要在 API 之外进一步自定义 UI define-theme，您可以在样式中手动设置这些自定义属性。 主题 mixin 做出的保证意味着您不需要以组件的内部选择器为目标，也不需要使用过多的特异性来覆盖任何这些标记化属性。始终将基本主题应用到应用程序的根元素（通常为 html 或 body），并将任何覆盖应用到适用的最高级别选择器上。 1234567&lt;mat-sidenav-container&gt; Some content... &lt;mat-sidenav&gt; Some sidenav content... &lt;mat-checkbox class=&quot;danger&quot;&gt;Enable admin mode&lt;/mat-checkbox&gt; &lt;/mat-sidenav&gt;&lt;/mat-sidenav-container&gt; 12345678910111213141516171819202122232425262728@use &quot;@angular/material&quot; as mat;@use &quot;@angular/material-experimental&quot; as matx;$light-theme: matx.define-theme();$dark-theme: matx.define-theme( ( color: ( theme-type: dark, ), ));html { // Apply the base theme at the root, so it will be inherited by the whole app. @include mat.all-component-themes($light-theme);}mat-sidenav { // Override the colors to create a dark sidenav. @include mat.all-component-colors($dark-theme);}.danger { // Override the checkbox hover state to indicate that this is a dangerous setting. No need to // target the internal selectors for the elements that use these variables. --mdc-checkbox-unselected-hover-state-layer-color: red; --mdc-checkbox-unselected-hover-icon-color: red;} 4. 使用 Material 3 主题为您自己的组件设置主题用于读取 M2 主题属性的相同实用程序函数（在 我们的组件主题化指南中描述）可用于从 M3 主题读取属性。然而，根据规范，M3 主题的可用命名调色板、排版级别等有所不同。 主题对象的结构被视为实现细节。代码不应依赖于直接读取其属性，例如使用 map.get.始终使用 Angular Material 提供的实用函数来访问主题的属性。 1234567891011121314151617181920@use &quot;@anuglar/material&quot; as mat;@use &quot;@anuglar/material-experimental&quot; as matx;@mixin my-comp-theme($theme) { .my-comp { font: mat.get-theme-typography($theme, body-large, font); letter-spacing: mat.get-theme-typography( $theme, body-large, letter-spacing ); background: mat.get-theme-color($theme, surface); @if mat.get-theme-type($theme) == dark { color: mat.get-theme-color($theme, primary, 20); } @else { color: mat.get-theme-color($theme, primary, 80); } padding: 48px + (2px * mat.get-theme-density($theme)); }} 4.1. 读取色调调色板颜色要从主题中读取 色调调色板颜色 get-theme-color，请使用带有三个参数的函数： 参数 描述 $theme 要读取的 M3 主题。 $palette 要读取的调色板的名称。这可以是任何标准 M3 调色板： primary secondary tertiary error neutral neutral-variant $hue 在调色板中读取的色相编号。这可以是任何标准色调： 0 10 20 30 40 50 60 70 80 90 95 99 100 4.2. 解读色彩角色要读取颜色角色，请 使用 get-theme-color 与两个参数一起使用： 参数 描述 $theme 要读取的 M3 主题。 $role 颜色角色的名称。这可以是任何 M3 颜色角色： primary on-primary primary-container on-primary-container primary-fixed primary-fixed-dim on-primary-fixed on-primary-fixed-variant secondary on-secondary secondary-container on-secondary-container secondary-fixed secondary-fixed-dim on-secondary-fixed on-secondary-fixed-variant tertiary on-tertiary tertiary-container on-tertiary-container tertiary-fixed tertiary-fixed-dim on-tertiary-fixed on-tertiary-fixed-variant error on-error error-container on-error-container surface-dim surface surface-bright surface-container-lowest surface-container-low surface-container surface-container-high surface-container-highest on-surface on-surface-variant outline outline-variant inverse-surface inverse-on-surface inverse-primary scrim shadow 4.3. 读取主题类型要读取主题类型（light 或 dark），请 使用 get-theme-type 并存入一个参数进行调用： 参数 描述 $theme 要读取的 M3 主题。 4.4. 读取类型比例属性要从主题读取 typescale 请使用 get-theme-typography 方法，并传入三个参数进行调用： 参数 描述 $theme 要读取的 M3 主题。 $level 字体级别。这可以是任何 M3 类型级别： display-large display-medium display-small headline-large headline-medium headline-small title-large title-medium title-small body-large body-medium body-small label-large label-medium label-small $property 要获取值的 CSS 字体属性。这可以是以下 CSS 属性之一： font（CSS 字体简写，包括除字母间距之外的所有字体属性） font-family font-size font-weight line-height letter-spacing 4.5. 读取密度标尺要从主题 读取密度标度（0、-1、-2、-3、-4 或 -5），请使用单个参数进行调用：get-theme-density | 参数 | 描述 || $theme | 要读取的 M3 主题。| 5. 如何将应用程序从 Material 2 迁移到 Material 3Angular Material 不提供从 M2 到 M3 的自动迁移，因为应用程序的设计是主观的。 Material Design 提供了一般原则和约束来指导您，但最终由您决定如何在您的应用程序中应用这些原则和约束。也就是说，Angular Material 的 M3 主题在设计时就考虑到了最大兼容性。 5.1. 更新使用 Angular Material 主题的组件以与 Material 3 兼容为了促进从 M2 到 M3 的平滑过渡，让您的组件同时支持 M2 和 M3 主题可能是有意义的。迁移整个应用程序后，可以删除对 M2 主题的支持。 实现此目的的最简单方法是检查主题版本并为 M2 和 M3 发出不同的样式。您可以使用 的 get-theme-version 功能 检查主题版本@angular/material。该函数将返回 0M2 主题或 1M3 主题（请参阅 使用 Material 3 主题主题您自己的组件， 了解如何从 M3 主题读取值）。 123456789@use &quot;@angular/material&quot; as mat;@mixin my-comp-theme($theme) { @if (mat.get-theme-version($theme) == 1) { // Add your new M3 styles here. } @else { // Keep your old M2 styles here. }} 5.2. 在您的全局主题样式中传递新的 M3 主题使用创建一个新的 M3 主题对象 define-theme 并将其传递到您之前传递 M2 主题的任何地方。所有采用 M2 主题的 Angular Material mixins 也与 M3 主题兼容。 5.3. 更新 Material 3 主题不支持的 API由于 Material 3 是作为 Material 2 所用相同组件的替代主题实现的，因此两者的 API 基本相同。但是，有一些差异需要注意： M3 期望任何@include、-theme、-color、-typography 或-densitymixin-base 都应包装在选择器中。如果您的应用程序@include 在根级别包含这样的内容，我们建议将其包装在 html { … } M3 有一个不同的 API 用于设置组件的颜色变体（有关更多信息，请参阅 使用组件颜色变体）。 不支持 backgroundColor 属性，并且不应与 M3 主题一起使用。 不支持 appearance=”legacy” 变量，并且不应与 M3 主题一起使用。 对于 M3 主题，调用 all-component-typographies 不会生成样式 typography-hierarchy ，因为这会违反 M3 不添加选择器的保证。相反， 如果您希望在应用程序中使用 typography-hierarchy 的这些样式，则必须显式调用 mixin。 mixintypography-hierarchy 输出对应于 M3 字体级别而不是 M2 字体级别名称的 CSS 类名称。如果您依赖 M2 类来设计应用程序的样式，则可能需要更新类名称。 5.4. 为颜色变体添加向后兼容样式（可选）我们建议不要依赖许多 Angular Material 组件提供的的 color=”primary”、color=”accent”或 color=”warn” M2 主题选项。但是，如果您想快速更新到 M3 并愿意接受为这些变体生成的额外 CSS，您可以启用向后兼容样式来恢复此 API 的行为。使用您想要为其生成颜色变体样式的 M3 主题调用 @angular/material-experimental的 color-variants-back-compat mixin 。 123456789@use &quot;@angular/material&quot; as mat;@use &quot;@angular/material-experimental&quot; as matx;$theme: matx.define-theme();html { @include mat.all-component-themes($theme); @include matx.color-variants-back-compat($theme);} 5.5. 为排版层次结构添加向后兼容样式（可选）使用 M3 主题调用 typography-hierarchy mixin 会生成与 M3 typescale 名称（例如.mat-headline-large）相匹配的 CSS 类样式，而不是与 M2 类型规模名称匹配的 CSS 类样式（.mat-headline-1）。如果您在应用程序中使用 M2 类名称，我们建议将所有用法更新为新类名称。然而，为了使迁移更容易， typography-hierarchy mixin 除了新的类名之外还支持生成旧的类名。我们已尽最大努力将 M2 类映射到 M3 中合理的等效项。要启用这些样式，请将附加参数$back-compat: true 传递 给 mixin。 123456@use &quot;@angular/material&quot; as mat;@use &quot;@angular/material-experimental&quot; as matx;$theme: matx.define-theme();@include mat.typography-hierarchy($theme, $back-compat: true); 5.6. 常问问题 我可以使用预定义的 Material 3 调色板以外的颜色吗？ 目前，我们仅提供预定义的调色板，但我们计划添加对使用自定义生成的调色板的支持. 我可以依赖稳定的 CSS 自定义属性名称吗？ 在将 Material 3 API 走出实验阶段之前，我们可能会对自定义属性名称进行更改，但伴随着这些更改我们将提供相应的 schematic，以便在您的应用程序中方便的替换旧名称为新名称。 Material 2 样式和 API 会消失吗？ Material 2 样式及其 API 将继续受到支持，并且我们没有立即计划弃用它们。我们知道应用程序切换到最新的 Material 3 样式需要一些时间，我们希望为迁移提供足够的时间。当我们决定删除这些 API 时，它们将被标记为已弃用，并在以下两个主要版本中继续受支持。截至目前，它们尚未被视为已弃用。 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Material 3 Theming","link":"/angular/angular_material3_theming.html"},{"title":"Angular Material 2 自定义主题","text":"1. 什么是 themingAngular Material 的主题系统可让您为应用程序中的组件自定义基础样式、颜色、排版和密度样式。主题系统基于 Google 的 Material Design 规范。 本文档介绍了自定义颜色的概念和 API。对于排版自定义，请参阅Angular Material Typography。有关构建可使用此系统进行自定义的组件的指南，请参阅主题化您自己的组件。 2. SassAngular Material 的主题 API 是使用 Sass 构建的。本文档假设您熟悉 CSS 和 Sass 基础知识，包括变量、函数和 mixin。 您可以通过使用预构建主题来使用不带 Sass 的 Angular Material，如 下面的使用预构建主题中所述。但是，直接使用库的 Sass API 可以让您最大程度地控制应用程序中的样式。 3. 调色板调色板是代表颜色空间一部分的颜色的集合。该集合中的每个值称为色调。在 Material Design 中，调色板中的每种色调都有一个标识符号。这些标识符数字包括 50，然后是 100 到 900 之间的每 100 个值。这些数字将调色板内的色调从最亮到最暗进行排序。 Angular Material 使用一个Sass map对象来表示调色板。该对象包含调色板的色调以及每种色调的对比色的另一个嵌套贴图。当使用色调作为背景色时，对比色用作文本颜色。下面的示例演示了调色板的结构。有关更多背景信息，请参阅 Material Design 颜色系统。 123456789101112131415$indigo-palette: ( 50: #e8eaf6, 100: #c5cae9, 200: #9fa8da, 300: #7986cb, // ... continues to 900 contrast: ( 50: rgba(black, 0.87), 100: rgba(black, 0.87), 200: rgba(black, 0.87), 300: white, // ... continues to 900 ),); 3.1. 创建您自己的调色板您可以通过定义与上面调色板部分中描述的结构相匹配的 Sass 映射来创建自己的调色板 。该贴图必须定义 50 种色调以及 100 到 900 之间的每一百种色调。该贴图还必须 contrast 为每种色调定义具有对比色的贴图。 您可以使用Material Design 调色板工具来帮助选择调色板中的色调。 3.2. 预定义调色板Angular Material 提供基于 2014 版 Material Design 规范的预定义调色板。有关完整列表，请参阅Material Design 2014 调色板。 除了编号从 0 到 900 的色调外，2014 年 Material Design 调色板还包含编号为 A100、A200、A400 和 A700 的不同强调色调。 Angular Material 不需要这些色调，但您可以在定义主题时使用这些色调，如下面的定义主题中所述。 123@use &quot;@angular/material&quot; as mat;$my-palette: mat.$indigo-palette; 4. 主题主题是颜色、排版和密度选项的集合。每个主题都包含三个用于确定组件颜色的调色板： 在整个应用程序中最常出现的颜色的主调色板 用于有选择地突出显示 UI 的关键部分的强调色或辅助调色板。 用于警告和错误状态的警告或错误调色板 您可以通过以下两种方式之一在应用程序中包含主题的 CSS 样式：使用 Sass 定义自定义主题，或导入预构建的主题 CSS 文件。 4.1. 使用 Sass 自定义主题主题文件是一个 Sass 文件，它调用 Angular Material Sass mixin 来输出颜色、排版和密度 CSS 样式。 4.2. core mixinAngular Material 定义了一个名为 core 的 mixin，其中包含多个组件使用的常见功能（例如波纹）的必备样式。core 即使您定义了多个主题，mixin 也必须在您的应用程序中包含一次。core 多次包含 mixin 会导致应用程序中出现重复的 CSS。 123@use &quot;@angular/material&quot; as mat;@include mat.core(); 4.3. 定义主题Angular Material 将主题表示为 Sass map，其中包含颜色、排版和密度选择，以及一些基本的设计系统设置。有关自定义排版的深入指南，请参阅 Angular Material Typography 。有关调整组件密度的详细信息，请参阅 下面的自定义密度。 构建主题首先需要定义主要调色板和强调调色板，以及可选的警告调色板。 Sass 函数 define-palette 接受一个调色板（如 上面的调色板部分所述）以及四个可选的色调数字。这四种色调按顺序表示：“默认”色调、“较亮”色调、“较暗”色调和“文本”色调。组件使用这些色调来为自身的不同部分选择最合适的颜色。 1234567@use &quot;@angular/material&quot; as mat;$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);// The &quot;warn&quot; palette is optional and defaults to red if not specified.$my-warn: mat.define-palette(mat.$red-palette); 您可以通过调用 define-light-theme 或 define-dark-theme 以及 efine-palette 的结果来构建主题。浅色主题与深色主题的选择决定了整个组件使用的背景色和前景色。 12345678910111213141516171819@use &quot;@angular/material&quot; as mat;$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);// The &quot;warn&quot; palette is optional and defaults to red if not specified.$my-warn: mat.define-palette(mat.$red-palette);$my-theme: mat.define-light-theme( ( color: ( primary: $my-primary, accent: $my-accent, warn: $my-warn, ), typography: mat.define-typography-config(), density: 0, )); 4.4. 将主题应用到组件Sass core-theme mixin 为多个组件使用的常见功能（例如波纹）准备一些基本的样式。每个主题必须包含此 mixin 一次。 每个 Angular Material 组件都有一个针对每个主题维度的 mixin ：基础、颜色、排版和密度。例如，MatButton 声明 button-base、button-color、 button-typography 和 button-density。每个 mixin 仅生成与该定制维度相对应的样式。 此外，每个组件都有一个“主题”mixin，它生成依赖于主题配置的所有样式。如果您向 define-light-theme 或 define-dark-theme 提供了相应的配置，则此主题 mixin 仅生成颜色、版式或密度样式，并且它始终生成基本样式。 通过包含每个主题 Sass mixins 来为应用程序中使用的每个组件应用样式。 123456789101112131415161718192021222324252627@use &quot;@angular/material&quot; as mat;@include mat.core();$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);$my-theme: mat.define-light-theme( ( color: ( primary: $my-primary, accent: $my-accent, ), typography: mat.define-typography-config(), density: 0, ));// Emit theme-dependent styles for common features used across multiple components.@include mat.core-theme($my-theme);// Emit styles for MatButton based on `$my-theme`. Because the configuration// passed to `define-light-theme` omits typography, `button-theme` will not// emit any typography styles.@include mat.button-theme($my-theme);// Include the theme mixins for other components you use here. 为了简化配置，在使用 Angular material 的过程中不必单独为每个组件的设置样式，Angular Material 提供了，其中包含库中所有组件设置样式的 Sass mixin：all-component-bases、 all-component-colors、all-component-typographies、all-component-densities 和 all-component-themes。这些 mixins 的行为与单个组件 mixins 相同，只不过它们为 Angular Material 中的所有 35+ 组件的 core-theme 生成样式。除非您的应用程序使用每个组件，否则这将产生不必要的 CSS。 12345678910111213141516171819@use &quot;@angular/material&quot; as mat;@include mat.core();$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);$my-theme: mat.define-light-theme( ( color: ( primary: $my-primary, accent: $my-accent, ), typography: mat.define-typography-config(), density: 0, ));@include mat.all-component-themes($my-theme); 要在应用程序中包含生成的样式，请将主题文件添加到项目的 angular.json styles file 数组中。 4.5. 主题内容Angular Material 主题分为四个维度的内容：基础、颜色、排版和密度。 4.5.1. 基础（base）设计系统的通用基本样式。这些样式不会根据您配置的颜色、排版或密度而改变，因此每个应用程序只需包含一次它们。这些 mixin 包括结构样式，例如 border-radius、border-width 等。所有组件都有一个基本 mixin，可用于包含其基本样式。 （例如， @include mat.checkbox-base($theme)） 4.5.2. 颜色 （color）与应用程序中的颜色相关的样式。这些样式应至少包含在您的应用程序中一次。根据您的需要，您可能需要使用不同的配置多次包含这些样式。 （例如，如果您的应用程序支持浅色和深色主题颜色。）所有组件都有一个颜色混合，可用于包含其颜色样式。 （例如， @include mat.checkbox-color($theme)） 4.5.3. 排版 （Typography）与应用程序中使用的字体相关的样式，包括字体系列、大小、粗细、行高和字母间距。这些样式应至少包含在您的应用程序中一次。根据您的需要，您可能需要使用不同的配置多次包含这些样式。 （例如，如果您的应用程序支持阅读衬线或无衬线字体的内容。）所有组件都有一个排版混合，可用于包含其排版样式。 （例如，@include mat.checkbox-typography($theme)） 4.5.4. 密度 (Density)与应用程序中元素的大小和间距相关的样式。这些样式应至少包含在您的应用程序中一次。根据您的需要，您可能需要使用不同的配置多次包含这些样式。 （例如，如果您的应用程序同时支持正常模式和紧凑模式）。所有组件都有一个密度混合，可用于包含其密度样式。 （例如，@include mat.checkbox-density($theme)） 4.5.5. 主题 mixin所有组件还支持主题 mixin，可用于一次性包含所有主题维度的组件样式。 （例如，@include mat.checkbox-theme($theme)）。 推荐的方法是依靠 mixins 来制定基本样式，如果需要，请使用单维 mixins 来覆盖应用程序部分的特定方面（请参阅一个文件中的多个主题 theme 部分。） 4.6. 使用预先构建的主题Angular Material 包括四个预构建的主题 CSS 文件，每个文件都选择了不同的调色板。如果您不想使用 Sass 定义自定义主题，则可以使用这些预构建主题之一。 主题 浅色还是深色？ 调色板（主要色、强调色、警告色） deeppurple-amber.css 浅色 深紫色、琥珀色、红色 indigo-pink.css 浅色 靛蓝、粉色、红色 pink-bluegrey.css 深色 粉色、蓝灰色、红色 purple-green.css 深色 紫色、绿色、红色 这些文件包括库中每个组件的 CSS。要仅包含组件子集的 CSS，您必须使用上面定义主题中详细介绍的 Sass API 。您可以参考这些预构建主题的源代码来查看完整主题定义的示例。 您可以在 Angular Material 的 npm 包 @angular/material/prebuilt-themes 中找到预构建的主题文件。要将预构建的主题包含在您的应用程序中，请将您选择的 CSS 文件添加到项目的 angular.json styles file 数组中。 4.7. 定义多个主题使用定义主题中描述的 Sass API ，您还可以 通过多次重复 API 调用来定义多个主题。您可以在同一主题文件或单独的主题文件中执行此操作。 4.7.1. 同一个文件中的多个主题在单个文件中定义多个主题允许您支持多个主题，而无需管理多个 CSS 资源的加载。然而，缺点是您的 CSS 将包含不必要的样式。 为了控制何时应用哪个主题，@includemixins 仅在通过 CSS 规则声明指定的上下文中。有关更多背景信息，请参阅Sass mixin 的文档。 1234567891011121314151617181920212223242526272829303132333435363738@use &quot;@angular/material&quot; as mat;@include mat.core();// Define a dark theme$dark-theme: mat.define-dark-theme( ( color: ( primary: mat.define-palette(mat.$pink-palette), accent: mat.define-palette(mat.$blue-grey-palette), ), // Only include `typography` and `density` in the default dark theme. typography: mat.define-typography-config(), density: 0, ));// Define a light theme$light-theme: mat.define-light-theme( ( color: ( primary: mat.define-palette(mat.$indigo-palette), accent: mat.define-palette(mat.$pink-palette), ), ));// Apply the dark theme by default@include mat.core-theme($dark-theme);@include mat.button-theme($dark-theme);// Apply the light theme only when the user prefers light themes.@media (prefers-color-scheme: light) { // Use the `-color` mixins to only apply color styles without reapplying the same // typography and density styles. @include mat.core-color($light-theme); @include mat.button-color($light-theme);} 4.7.2. 跨不同文件的多个主题您可以在单独的文件中定义多个主题，方法是为每个定义主题创建多个主题文件 ，然后将每个文件添加到您的 angular.json styles 中.但是，您必须另外将 每个文件的 inject 选项 设置为 false，以防止同时加载所有主题文件。将此属性设置为 false 时，您的应用程序将负责手动加载所需的文件。此加载的方法取决于您的应用程序。 4.8. 应用背景颜色默认情况下，Angular Material 不会将任何样式应用于其自身组件之外的 DOM。如果您想设置应用程序的背景颜色以匹配组件的主题，您可以： 如果您正在使用 MatSidenav，您可以将应用程序的主要内容放入其中mat-sidenav-container。或者 将 mat-app-background CSS 类应用到您的主要内容根元素（通常为body）。 4.9. 自定义样式范围您可以使用 Angular Material 的 Sass mixins 在应用程序的特定范围内自定义组件样式。包含 Sass mixin 的 CSS 规则声明决定了它的范围。下面的示例展示了如何自定义标有.my-special-section CSS 类的元素内所有按钮的颜色。 1234567891011@use '@angular/material' as mat;.my-special-section { $special-primary: mat.define-palette(mat.$orange-palette); $special-accent: mat.define-palette(mat.$brown-palette); $special-theme: mat.define-dark-theme(( color: (primary: $special-primary, accent: $special-accent), )); @include mat.button-color($special-theme);} 4.10. 从调色板中读取色调可以从主题中读取颜色以在您自己的组件中使用。有关这方面的更多信息，请参阅我们的主题化您自己的组件指南。 4.11. 定制密度Angular Material 的密度定制基于 Material Design 密度指南。该系统定义了一个比例，其中零代表默认密度。您可以减少该数字以获得更高的密度，并增加该数字以获得更低的密度。 密度系统基于密度标尺。比例从默认密度 开始0。每个整数步长（-1、-2等）都会将受影响的尺寸减小4px, 直至组件连贯渲染所需的最小尺寸。 出现在基于任务或弹出上下文中的组件（例如MatDatepicker）不会通过密度系统更改其大小。 Material Design 密度指南明确不鼓励增加此类交互的密度，因为它们不会占用应用程序布局中的空间。 您可以将自定义密度设置应用于整个库或使用密度 Sass mixin 的单个组件。 12345678910111213// You can set a density setting in your theme to apply to all components.$dark-theme: mat.define-dark-theme(( color: ..., typography: ..., density: -2,));// Or you can selectively apply the Sass mixin to affect only specific parts of your application..the-dense-zone { @include mat.button-density(-1);} 4.12. 强焦点指示默认情况下，大多数组件通过更改其背景颜色来指示浏览器焦点，如Material Design规范所述。然而，这种行为可能无法满足可访问性要求，例如WCAG，它需要更强的浏览器focus indicators。 Angular Material 支持在聚焦元素上渲染高度可见的轮廓。应用程序可以通过两个 Sass mixin 启用这些强焦点指示器： strong-focus-indicators和strong-focus-indicators-theme。 strong-focus-indicators mixin为所有组件生成结构指示器样式。该 mixin 应该在应用程序中只包含一次，类似于前面描述的core mixin。 strong-focus-indicators-theme mixin仅生成指示器的颜色样式。每个主题应该包含此 mixin 一次，类似于前面描述的主题 mixin。此外，在默认颜色与背景颜色对比不充分的情况下，您可以使用此混合来更改焦点指示器的颜色。 以下示例在应用程序中包含 Strong focus indicators样式以及自定义主题 API 的其余部分。 12345678910111213141516171819@use '@angular/material' as mat;@include mat.core();@include mat.strong-focus-indicators();$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);$my-theme: mat.define-light-theme(( color: ( primary: $my-primary, accent: $my-accent, )));@include mat.all-component-themes($my-theme);@include mat.strong-focus-indicators-theme($my-theme); 4.12.1. 定制强焦点指示您可以传递配置映射来自strong-focus-indicators定义指示器的外观。此配置包括border-style、border-width和border-radius。 您还可以使用 strong-focus-indicators-theme 自定义指示器的颜色。此 mixin 接受主题（如本指南前面所述）或 CSS 颜色值。提供主题时，指示器将使用主调色板的默认色调。 以下示例包括具有自定义设置的强焦点指示器样式以及自定义主题 API 的其余部分。 1234567891011121314151617181920212223@use '@angular/material' as mat;@include mat.core();@include mat.strong-focus-indicators(( border-style: dotted, border-width: 4px, border-radius: 2px,));$my-primary: mat.define-palette(mat.$indigo-palette, 500);$my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);$my-theme: mat.define-light-theme(( color: ( primary: $my-primary, accent: $my-accent, )));@include mat.all-component-themes($my-theme);@include mat.strong-focus-indicators-theme(purple); 4.13. 主题和风格封装Angular Material 假定默认情况下所有主题样式都作为全局 CSS 加载。如果要在应用程序中使用Shadow DOM，则必须在包含 Angular Material 组件的每个 Shadow root中加载主题样式。您可以通过在每个Shadow root中手动加载 CSS 或使用可构造样式表来实现此目的。 4.14. 用户偏好媒体查询Angular Material 不会根据用户偏好媒体查询应用样式，例如 prefers-color-scheme或prefers-contrast。相反，Angular Material 的 Sass mixins 使您可以根据对用户最有意义的条件灵活地应用主题样式。这可能意味着直接使用媒体查询或读取保存的用户首选项。 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 参考文档Theming Angular Material","link":"/angular/angular_material_2_theming.html"},{"title":"应用angular material design","text":"1. 前言 为什么选择 angular material design? 实际上如果想在自己的 web 项目中使用 material design 这套设计理念, 有多种选择, 一个是使用 bootstrap + mdbootstrap 这套架构和组件, 或者使用 bootstrap+materialize-css 这套解决方案. 其核心思想就是使用 bootstrap 去处理响应式 web ux 的问题以及跨浏览器, 跨各种大小屏幕兼容性问题, 而使用 mdbootstrap 或 materialize 去实现一套 material design 风格的组件库. 实际上这是一套很好的思路, 各方案专注自己的擅长的领域, 保持小而美的设计. 但是现实问题是 mdbootstrap 并不是免费的, 其 prime 版本是收费的, 而且对初创公司来说其收费还不便宜. materialize-css 是开源免费的, 但是截至 2022-05-29, 该项目已经 6 年没有更新了, 最近的一个版本是 6 年前发布的一个 1.0.0 版本. 所以目前要在 web 开发中使用 material design, 要么使用 angular material design, 而且该方案的底层基础设施是 angular, 如果你的项目不是基于 angular 开发的, 比如你使用的是 react 或 vue 作为基础设施,那么该方案是不适合的. 并且如果你的 responsive 方案采用的是 bootstrap 或其它方案如 tailwind 等等, 很可能由于组件的兼容性问题, 最后不得不将响应式编程(responsive)的部分替换成 angular material design 的解决方案, 最后导致你的所有基于 bootstrap 的第三方组件被放弃和替换成基于 angular material design, 简言之在 angular 框架之外使用 angular material design package 几乎是不可能, 在 angular 之内使用 angular material design 具在响应式编程(responsive)有很强的排他性, 这种排他性并不是 material design 的设计初衷, 也不是 angular material design 的设计初衷, 个人认为是在响应式编程方面各方参与者没有统一的标准, 从而导致基于不同响应式编程的方案的高级别组件不能与另一阵营兼容. 另外一个在 web 开发中使用 material design 的方案是使用 bootstrap + mdbootstrap 或者 bootstrap+materialize-css. 两种方案的底座部分都是 bootstrap, bootstrap 主要负责响应式编程部分的职责, 但是 bootstrap 不仅仅是一套响应式编程的框架和工具而已, 它还包含了一套组件, 而这套组件的没有一套设计原语, 由于它是一套开发的框架, 也不应该绑定与一套设计风格. 而这套组件是不符合 material design 规范的. 所有必须结合 material design 组件相关的框架才能构成完整的 material design web 解决方案. 之所以说这两套解决方案不完美, 还有很多其它的原因.比如 bootstrap 包含一套组件库, 而由于这套组件库需要实现动态效果, 需要结合使用 javascript, 故而引入了 jquery 框架, 以及 popperjs 等框架, 这就导致 bootstrap 十分臃肿. 而 jquery 这种直接操纵 HTML DOM 的框架逐渐在被已数据感知为基础的框架如 vue, react, angular 等替代. 所以由于 web 前端开发由于过分的违背单一职责原则, 而变得越来越臃肿.另外由于各解决方案中的组件都有动态部分, 这些动态部分的开发不可能基于 css 和 html 规范来实现, 它还依赖与 javascript, 一旦依赖于 javascript 就要考虑这部分使用原始的 javascrpt 来实现, 还是使用 javascript 框架, 这里先不考虑是使用 ES5 还是 ES6 还是 typescript, flow, coffeescript 等语言来开发, 而 js 框架本身也要考虑是使用 jquery, 还是使用 vuejs 还是 react 或者 angular 的问题.最后如果选择 bootstra+material 组件库方案, 那么将与 angular material design 这套方案彻底地分道扬镳, 因为 material 组件库方案由于它的开放性, 必须兼容目前主流的开发框架, 比如 js dom 框架, vue, react, angular. 而 angular material design 方案是单纯基于 angular 框架的解决方案. 就目前的现实状况来看, 在 web 开发中要实现横跨多种终端, 又要符合一套设计风格的情况下, 选择合适的技术方案还是要结合项目实际情况慎重考量的. 因为这就像一个技术的十字路口, 选择了一个方向就很难获得另一个方向的优势和便利. 就我自己当前的项目而言, 我选择的是 angular + angular material design 这套方案, 依据是这样的, 首先采用一套设计原语在现代 web 开发或前端开发是很有必要的, 在这个用户体验越来越被重视的时代, 采用设计风格也会成为未来的一种趋势, 无论是跟随 google 的 material design 也好, 微软的 fluent 设计风格也罢还是苹果的 Skeumorphism 设计概念, 或者蚂蚁的 ant design 也罢. 方向确定后再看现实状况中的实现, 现实状况是 bootstrap 仍然是响应式设计中的主流, 但是它离形成一种现代的或面向未来的设计风格还有很远的路要走, 而且个人确定 bootstrap 也在响应式编程方面更加开放, 成为响应式编程的底层架构, 而不应该绑定绑定于一种单一的设计风格, 而在其上绑定一种特有的风格应该是其生态圈的其它项目应该去完善的. 就目前来看 mdbootstrap 和 materialize-css, 前者开源但是不免费, 后者已经停止更新多年. 而 angular material design 目前更新非常频繁, 其下载量和星标数量也在快速增长. 另外结合个人项目的实际也是采用的 angular 框架,所以也适合采用 angular material design, 但目前投入在 bootstrap 上的努力将要部分或者全部作废, 组件使用 angular material design 替代. 将来 bootstrap 上更新带来的更好的开发便利也将获取不到. 这是一个艰难的决定, 但是出于一种设计直觉或者一种前瞻性, 我觉得应该先采用一种设计风格熟悉一种风格. 等待一种开放式的设计风格成熟以后再切换回开发式的设计风格, 这里所说的开放式是指不绑定与任何一种专有的框架, 一种编程语言, 基于一种开放的标准. 2. 创建一个 angular 项目这里采用的 angular 版本为 13.2.7, 截至 2022-06-01 为止最新的 angular 版本. 关于创建 Angular 项目的详细说明可以参考我的博客鹏叔的博客空间- 创建 Angular 项目 12ng new &lt;project_name&gt;# e.g. ng new angularmd 3. 安装 Angular Material 和 Angular CDK 模块首先介绍下 cdk。 cdk 是 angular 官方的一个 Component Dev Kit.顾名思义。他就是帮助你开发组件的。包含以下内容 Common Behaviors Accessibility, Bidirectionality, Drag and drop, Layout, Observers, Overlay, Platform, Portal, Scrolling, Text field Components Stepper, Table, Tree 确保在系统中安装 NodeJs。NodeJs 是开发 Angular Apps 所必需的。 使用下面的 nodejs 命令安装 angular Material 和 Angular CDK 模块。 1npm install --save @angular/material @angular/cdk @angular/core @angular/common 4. 安装 Angular Animations 模块有些 Material 组件依赖于 Angular 动画模块。使用以下命令安装 Angular 动画模块。 1npm install --save @angular/animations 5. 安装 HammerJS 以获得手势支持一些 Angular 材质组件，如 mat-slider、matTooltip、mat-slide-toggle，都依赖于 HammerJS 的手势。 123npm install --save hammerjs 6. 添加预构建的 Angular Material 主题当我们安装 Angular Material 时，一些预构建的主题会自动安装。可用的预建主题是 indigo-pink deeppurple-amber purple-green pink-bluegrey 将主题添加到全局 style.css 123@import '~@angular/material/prebuilt-themes/indigo-pink.css'; 7. 添加 Angular Material 图标如果要使用 Material 图标，请将官方图标字体加载到 index.html 文件中。 1234&lt;link href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot; rel=&quot;stylesheet&quot;/&gt; 然后，我们可以 mat-icon 组件标签来显示图标 1&lt;mat-icon&gt;favorite&lt;/mat-icon&gt; //Displays love symbol 现在，我们将在项目中添加一个 Material 模块。 完整的 Angular Material 图标列表 8. 添加自定义 Angular Material 模块使用以下 angular-cli 命令创建新的材料模块 1ng generate module material 我们将在项目中使用以下 Material UI 组件 MatButtonModule MatToolbarModule MatIconModule MatCardModule 将它们添加到 material.module.ts 文件中 12345678910111213141516171819import { NgModule } from &quot;@angular/core&quot;;import { CommonModule } from &quot;@angular/common&quot;;import { MatButtonModule } from &quot;@angular/material/button&quot;;import { MatToolbarModule } from &quot;@angular/material/toolbar&quot;;import { MatIconModule } from &quot;@angular/material/icon&quot;;import { MatCardModule } from &quot;@angular/material/card&quot;;@NgModule({ declarations: [], imports: [ CommonModule, MatButtonModule, MatToolbarModule, MatIconModule, MatCardModule, ], exports: [MatButtonModule, MatToolbarModule, MatIconModule, MatCardModule],})export class MaterialModule {} 我已经在 exports 中添加了它们，以便在其他模块中使用它们。 现在我们的 MaterialModule 已准备就绪，我们将在默认的应用程序模块中使用它。在 app.module.ts 文件中添加 MaterialModule 123456789101112131415161718192021import { NgModule } from &quot;@angular/core&quot;;import { FormsModule } from &quot;@angular/forms&quot;;import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { HttpClientModule } from &quot;@angular/common/http&quot;;import { BrowserAnimationsModule } from &quot;@angular/platform-browser/animations&quot;;import { AppComponent } from &quot;./app.component&quot;;import { MaterialModule } from &quot;./material/material.module&quot;;@NgModule({ declarations: [AppComponent], imports: [ BrowserModule, FormsModule, HttpClientModule, MaterialModule, BrowserAnimationsModule, ], providers: [], bootstrap: [AppComponent],})export class AppModule {} 请确保将其添加到 BrowserModule 之后，因为 Material 组件依赖于 BrowserModule。我添加了 BrowserAnimationModule 来支持动画。 Angular Material 已准备就绪。现在我们可以在模板文件中使用 Angular Material 组件了. 添加如下代码到 app.component.html 文件中. 12345678910111213141516171819&lt;div id=&quot;material-example&quot;&gt; &lt;h1&gt;ToolBar&lt;/h1&gt; &lt;mat-toolbar color=&quot;primary&quot;&gt; &lt;span&gt;Material Design Rocks!&lt;/span&gt; &lt;/mat-toolbar&gt; &lt;br /&gt; &lt;h1&gt;Buttons&lt;/h1&gt; &lt;mat-card&gt; &lt;button mat-button&gt;Basic&lt;/button&gt; &lt;button mat-raised-button&gt;Raised&lt;/button&gt; &lt;button mat-icon-button&gt;&lt;mat-icon&gt;favorite&lt;/mat-icon&gt;&lt;/button&gt; &lt;button mat-fab&gt;Fab&lt;/button&gt; &lt;button mat-mini-fab&gt;mFab&lt;/button&gt; &lt;/mat-card&gt;&lt;/div&gt; 我添加了不同类型的按钮，如基本（mat-button），凸起（mat-raised-button），图标按钮（mat-icon-button），浮動操作按钮（mat-fab）和迷你浮動操作按钮（mat-mini-fab）。 现在打开命令提示符，并在成功编译后键入 ng serve 命令，浏览 http://localhost:4200 以加载 Angular 材质项目。 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 10. 参考文档Angular Material Tutorial with examples","link":"/angular/angular_material_design.html"},{"title":"如何在Angular应用中使用Ng2-charts","text":"1. 前言图表帮助我们以易于理解和交互的方式可视化大量数据。 在 Angular 中，我们有各种图表库来创建图表。 在本文中，我们将使用 Ng2-Charts 在 Angular 中开发出色的图表。 在本文中我们将会讲述 ng2-charts 介绍 在 Angular 中安装 ng2-charts 的两种不同方法。 创建条形图 创建折线图 2. ng2-charts 介绍ng2-charts是一个基于chart.js的开源图表库。 Chart.js 是一个流行的 JavaScript 图表库。ng2-charts 是 Chart.js 的二次封装。它提供基础图表指令用于渲染图表。 ng2-charts 拥有约 2K 的 GitHub Stars，npm 上的每月下载量约为 76.7 万。 它支持以下图表类型： 折线图 饼图 条形图 圆环图 雷达图 极地面积图 气泡图 散点图 还提供许多自定义选项，例如： 反应能力 动效定制 图表标题 图例 标签 颜色 提示条 主题 组合图表 选项 ng2-charts 现在还提供 add 和 generate schematics 用于安装 ng2-charts 和生成上述支持图表。 3. 安装 ng2-charts使用以下命令创建一个新的 Angular 应用程序. 123ng new angular-ng2-charts-demo 我们有两种方法在 Angular 应用程序中安装 ng2-charts。 使用 ng add schematic 手动安装 安装前需要确认 ng2-charts 与 Angular 各版本的兼容关系, 参考ng2-charts 官方文档 Angular version ng2-chart v1.x v2.x v3.x v4.x v5.x 2 - 9 ✓ 10 ✓ 11 ✓ 12 ✓ 13 ✓ 14 ✓ ✓ 15 ✓ ✓ 16 ✓ 3.1. 使用 ng add schematic 安装 Ng2-Charts这是在 Angular 中安装 ng2-charts 的简单方法。执行以下命令ng add schematic 命令. 12345678ng add ng2-charts# 或者安装指定版本的ng2-chartsng add ng2-charts@x.y.z 这个命令， 自动安装 ng2-charts 和 chart.js 图表库 导入并添加 NgChartsModule 模块到 app.module.ts。 如果出现 Cannot find module ‘@angular/cdk/schematics’, 则需要安装 安装@angular/cdk.使用以下命令安装@angular/cdk npm install --save @angular/cdk 3.2. 手动安装 Ng2-Charts安装 ng2-charts 和 chart.js 使用以下命令进行打包. 关于 ng2-charts 和 chart.js 的兼容关系, 可以在确定 ng2-charts 的版本后, 打开 ng2-charts 对应版本的 package.json 文件查看. 例如对于 v4.1.1 版本的 ng2-charts, 打开https://github.com/valor-software/ng2-charts/blob/v4.1.1/package.json, 我们会发现其对应的 chart.js 版本为 4.0.1 1234567npm install ng2-charts --savenpm install chart.js --save# 或者安装特定版本的ng2-chartsnpm install ng2-charts@x.y.z --savenpm install chart.js@a.b.c --save 导入 NgChartsModule 模块在应用程序主模块中。 我们的最终应用程序模块看起来像： 12345678910111213import { NgModule } from &quot;@angular/core&quot;;import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { AppComponent } from &quot;./app.component&quot;;import { NgChartsModule } from &quot;ng2-charts&quot;;@NgModule({ declarations: [AppComponent], imports: [BrowserModule, NgChartsModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} 安装步骤完成。现在让我们看看如何使用 ng2-charts 开发图表。我们将创建一个条形图来显示每月销售数据。 4. 使用 Ng2-Charts 创建条形图ng2-charts 对所有图表类型都有一个指令：baseChart。我们将在画布上使用此指令来渲染图表。 我们首先准备图表数据. 4.1. 准备图表数据我们将创建如下图表数据，在演示中我使用静态数据, 在实际开发过程中我们可以动态的从后端获取数据。 123456789salesData: ChartData&lt;&quot;bar&quot;&gt; = { labels: [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;], datasets: [ { label: &quot;Mobiles&quot;, data: [1000, 1200, 1050, 2000, 500] }, { label: &quot;Laptop&quot;, data: [200, 100, 400, 50, 90] }, { label: &quot;AC&quot;, data: [500, 400, 350, 450, 650] }, { label: &quot;Headset&quot;, data: [1200, 1500, 1020, 1600, 900] }, ],}; labels : x 轴标签。对于线形态, 柱状图, 雷达图来说这是必要的。对于 polarArea,饼图和甜甜圈饼图, 当鼠标悬停在图形上是会显示 label。Label 可以是单个字符串，也可以是表示多行标签的 string[]，其中每个数组元素都位于新行上。 datasets: 数据集是多维数组。每个维度代表不同的数据集。这里标签显示为图例，值将映射到相应的 x 轴标签。 4.2. 图表选项我们可以使用各种图表选项来自定义图表。 123456789chartOptions: ChartOptions = { responsive: true, plugins: { title: { display: true, text: &quot;Monthly Sales Data&quot;, }, },}; 还有许多其他可用的自定义选项。在Chart.JS 文档中查看更多选项。 4.3. 在 html 模板上添加图表画布现在要在页面上呈现图表，我们必须添加&lt;canvas&gt;在模板上。我们将使用 baseChart 如下。 12&lt;canvas baseChart [data]=&quot;salesData&quot; [type]=&quot;'bar'&quot; [options]=&quot;chartOptions&quot;&gt;&lt;/canvas&gt; baseChart 的一些重要的属性 type: 表示图表类型，可以是：线、条形图、雷达、饼图、极地区域、甜甜圈data: 表示图表数据对象.options: 表示图表选项对象. 其他附加属性： labels: 除了在数据集中指定 x 轴标签外, 我们还可以使用 labels 属性创建一个单独的字符串数组并将其指定为签标属性. datasets: 除了在 ChartData 中指定数据集外, 我们可以通过 datasets 将该单独的数组作为数据集传递. colors: 数据颜色，如果未指定，将使用默认和|或随机颜色。. 生成的图表效果如下: 5. 使用 Ng2-Charts 创建折线图与条形图相同，我们可以生成折线图。 为了创建平滑的曲线折线图，我们将添加一个附加属性 tension: 0.5 在数据集中。 123456789salesData: ChartData&lt;&quot;line&quot;&gt; = { labels: [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;], datasets: [ { label: &quot;Mobiles&quot;, data: [1000, 1200, 1050, 2000, 500], tension: 0.5 }, { label: &quot;Laptop&quot;, data: [200, 100, 400, 50, 90], tension: 0.5 }, { label: &quot;AC&quot;, data: [500, 400, 350, 450, 650], tension: 0.5 }, { label: &quot;Headset&quot;, data: [1200, 1500, 1020, 1600, 900], tension: 0.5 }, ],}; 12&lt;canvas baseChart [data]=&quot;salesData&quot; [type]=&quot;'line'&quot; [options]=&quot;chartOptions&quot;&gt;&lt;/canvas&gt; 生成的图表效果如下: 6. 源代码本文中的源代码位于 github - angular-ng2-charts-demo 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 8. 参考文档Awesome Charts In Angular 13 With Ng2-Charts","link":"/angular/angular_ng2_charts.html"},{"title":"MDC-based Angular Material组件迁移","text":"1. 前言在 Angular Material v15 中，许多组件已基于官方的 Web Material Design Components (MDC) 进行了重构。 以下导入的组件已被重构： Import path Summary of changes @angular/material/autocomplete Style changes only @angular/material/button Style changes, API changes @angular/material/card Style changes only @angular/material/checkbox Style changes, changes to event behavior @angular/material/chips Complete rewrite @angular/material/core Style changes only @angular/material/dialog Style changes, changes to change detection behavior @angular/material/form-field Style changes, some appearances removed, API changes @angular/material/input Style changes only @angular/material/list Style changes, API changes @angular/material/menu Style changes, API changes @angular/material/paginator Style changes only @angular/material/progress-bar Style changes only @angular/material/progress-spinner Style changes only @angular/material/radio Style changes only @angular/material/select Style changes only @angular/material/slide-toggle Style changes only @angular/material/slider Complete rewrite @angular/material/snack-bar Style changes, API changes @angular/material/table Style changes only @angular/material/tabs Style changes, API changes @angular/material/tooltip Style changes only 与旧的实现相比，重构的组件具有多种优势，包括： 改进的无障碍 更好地遵守 Material Design 规范 由于基于通用基础设施，Material Design 规范未来版本的被采用速度更快 2. 发生了哪些变化？新组件具有不同的内部 DOM 和 CSS 样式。 然而，大多数 TypeScript API 和新组件的组件/指令选择器都尽可能接近旧的实现。 这使得迁移应用程序并使其与新组件一起运行变得简单。 由于新的 DOM 和 CSS，您可能会发现应用程序中的某些样式需要调整，特别是当您的 CSS 覆盖任何迁移组件上的内部元素的样式时。 为了与 MDC 集成，有一些组件对其 API 进行了较大的更改。 这些组件包括： form-field chips slider list 有关所有组件更改请参阅变更完整列表。 每个新组件的旧实现现已弃用，但仍可通过“legacy”导入使用。 例如，您可以导入旧的 mat-button 实现，可以通过导入旧的按钮模块来使用。 1import { MatLegacyButtonModule } from &quot;@angular/material/legacy-button&quot;; 3. 如何迁移您可以通过运行 Angular Material 的自动重构工具来开始迁移。该工具以Angular Schematic 的形式实现，可将大部分代码更新为新的组件版本。虽然一些后续工作是必要的，但您可以通过遵循以下最佳实践来减少手动工作量： 通过确保您的应用程序在迁移之前遵循良好实践，您可以减少所需的手动工作量 尽可能避免覆盖 Angular Material 元素的内部 css 样式。如果您发现自己经常覆盖 Angular Material 元素的样式，请考虑使用专为更多自定义样式而设计的组件，例如 Angular CDK 中提供的组件。 在测试中使用 component harnesses 与 Angular Material 组件交互，而不是检查组件的内部元素、属性或方法。使用 component harnesses 使您的测试更容易理解并且对 Angular Material 的变化更加稳健。 3.1. 更新至 Angular Material v15Angular Material 包含一个工作流工具(Schematic)，可帮助迁移应用程序以使用新的基于 MDC 的组件。首先，请将您的应用程序升级到 Angular Material 15。 1ng update @angular/material@15 作为此更新的一部分，将运行 Schematic 以自动移动您的应用程序以使用包含旧组件实现的“legacy”导入。这提供了一条让您的应用程序在 v15 上运行的快速路径，只需最少的手动更改。 3.2. 使用迁移工具当使用上面的命令升级到 Angular Material v15 之后, 我们可以运行迁移工具从旧的 Angular material 组件迁移到新的基于 MDC 的组件. 123ng generate @angular/material:mdc-migration 这条指令将会更新 TypeScript 文件, 样式单, 和 html 模板, 使用新的组件, 这条指令将尽可能多的自动转换, 但是后续人需要手工更新一些遗漏的地方. 3.2.1. 执行部分更新根据应用程序的大小和复杂性，您可能希望一次迁移单个组件或一部分组件，而不是一次迁移所有组件。您可能还想一次迁移一个模块，而不是一次性完成全部迁移。您可以在同一应用程序中同时使用旧实现和新实现，只要它们不在同一 NgModule 中即可。迁移脚本将指引您输入要迁移的目录和组件。 3.3. 检查迁移工具遗留下 TODO 备注某些情况下, 迁移工具不能自动更新你的部分代码, 它会在代码前加上一些 TODO 备注方便后续手段更新. 这些 TODO 备注的样式如下所示: 1// TODO(mdc-migration): ... 在您的 IDE 中使用关键字”TODO(mdc-migration):”即可以找打所有这些备注. 3.4. 验证应用运行完迁移工具并且手动处理完这些 TODO 备注后, 我们就可以着手验证我的应用程序是否依然能正常工作了. 运行自动化测试确保测试都能通过. 有些测试依赖旧组件的 Internal DOM 结构和异步时间详细信息, 这些测试可能需要修改. 如果您打算修改一些测试, 考虑使用component harnesses, 这样可以使得您的测试更加健壮. 将应用运行起来并验证新的组件是不是看起来是否有差异. 因为一些处理内部 DOM 和样式的代码, 你可能需要重新调整一些样式. 到这里迁移工作大致已经完成. 下面是从旧的 Angular Material 组件迁移到 MDC-based 组件的完整变更列表, 供您参考. 4. 完整变更列表4.1. 库范围的更改 组件大小、颜色、间距、阴影和动画都会在各个方面略有变化。这些更改通常会更加符合 Material Design 规范和可访问性。 所有组件的 DOM 结构都已更改，以改进可访问性并更好地遵循 Material Design 规范。 应用于组件的 CSS 类使用 mat-mdc-前缀，而以前它只是一个 mat-前缀。与旧实现中的元素大致对应的元素被赋予了相同的类名（前缀除外）。例如，按钮的主机类是 mat-mdc-button 而不是 mat-button。但是，并非先前实现中的所有元素在新实现中都具有等效元素。 与 mat-typography 关联的类样式不再自动生成。你必须使用 mat.typography-hierarchy mixin 来包含它们。 4.2. 主题mat.define-typeography-config 定义的默认排版级别已更新，以反映对 Material Design 规范的更改。现在，所有组件都具有可主题化的(themeable)密度。默认情况下，当包含 theme mixin 时，将包含默认密度 Level（0）的样式。 12345678910@use '@angular/material' as mat;$theme: mat.define-light-theme(( color: ...));// Adds density level 0 styles@include mat.all-component-themes($theme); 如果您喜欢不同的默认密度级别，可以在主题配置中进行设置： 123456$theme: mat.define-light-theme(( color: ..., density: -1)); 4.3. Autocomplete 长选项现在换行而不是截断。 选项高度不再限制在 48 像素。 选项列表现在有一个 8px 的顶部和底部填充。 选项列表现在具有打开和关闭时的动画。 4.4. Button图标按钮的高度和宽度是 48px，而不是 40px。 状态颜色（悬停、聚焦、活动）略有不同，以提高文本对比度。 字母间距为 1.25 像素，而非正常值。 FAB 支持具有 extended 输入属性的文本。 主题 mixins 被分为三个单独的 mixins： 普通按钮（默认、凸起、stroked、平面）：mat.mdc-button-theme 图标按钮：mat.mdc-Icon-button-theme FAB:mat.mdc-fab-theme 按钮内容中的图标位于按钮文本之前。添加 iconPositionEnd 属性以将它们放置在按钮文本之后。 按钮内容中的图标继承文本字体大小。只有图标而没有文本的按钮无法正确对齐（这不适用于图标按钮） 4.5. Card默认情况下，mat-card 不应用任何内部填充。相反，这种填充是在卡片内容区域上定义的：＜ mat-card-content ＞、＜ mat-card-header ＞和＜ mat-card-action ＞。＜ mat-card-content ＞不再设置任何排版样式，用户可以自由地将任何对其应用有意义的排版样式添加到＜ mat-card-content ＞本身或任何子元素中（视情况而定）。例如： 12@use &quot;@angular/material&quot; as mat;@include mat.typography-hierarchy(); 123&lt;mat-card&gt; &lt;mat-card-content class=&quot;mat-body-1&quot;&gt;...&lt;/mat-card-content&gt;&lt;/mat-card&gt; 4.6. Checkbox在新的 MDC-based Angular Material 组件中, 复选框的行为发生了一些变化. 在单击复选框时, 事件直接在原生复选框元素上触发, 而不是在填充 div 上触发. 原生复选框在单击事件中调用 preventDefault 时会有奇怪的行为，因此用户不应在单击时调用 preventDefault。 复选框触摸目标更大，现在是 40px，而不是 16px，这更容易访问。确保在布局中留出足够的空间，以便触摸目标不会与其他组件重叠。如果您不关心可访问性，您可以通过使用 density(-1) 作为复选框来匹配以前的大小。 12@use &quot;@angular/material&quot; as mat;@include mat.checkbox-density(-1); 由于复选框颜色变更为基于应用程序主题，复选框颜色可能会更改为白色或黑色。以前，复选框的颜色将设置为主题的背景色。对于 MDC，它是由白色还是黑色相对于原色具有最大的对比度来决定的。 对焦状态稍暗，提高对比度。 文本样式不是继承的；您需要专门针对复选框的标签来覆盖 typography 属性。 check 或者 uncheck 复选框时，波纹将保持可见，而不是动画消失。 4.7. ChipsChips 曾经是指令，但现在它们是组件。 这意味着它们不能再应用于其他组件。 Chips 组件已分为多个变体，与更适合可访问性的交互模式相对应。 原本的 mat-chip-list 使用 role=”listbox”，但这种交互模式并不适合所有用例。 新 Chips 具有： &lt;mat-chip-listbox&gt; 和 &lt;mat-chip-option&gt; - 这是最接近之前的交互模式。 这是唯一支持 Chips 选择状态的变体。 此模式与 Material Design 规范中指定的 filter chips 模式一致。 当您希望用户从选项列表中选择一个或多个值时，应使用此模式。 &lt;mat-chip-grid&gt; 和 &lt;mat-chip-row&gt; - 此模式应用于任何文本输入 + Chips 交互。 &lt;mat-chip-set&gt; 和 &lt;mat-chip&gt; - 此变体没有可访问模式，并假设将在应用程序级别应用一个模式。 这允许应用程序通过 Chips 视觉效果实现自定义模式。 迁移工具始终将旧版 &lt;mat-chip-list&gt; 更改为 &lt;mat-chip-listbox&gt; 以最大程度地减少前后差异。 您应该根据具体情况单独考虑更改为 &lt;mat-chip-grid&gt; 或 &lt;mat-chip-set&gt;。 有关更多根据用例选择适当组件的指南，请参阅Chips 交互模式。 4.8. Dialog.mat-dialog-container 不再包含 24px 填充。 但是可以使用内部对话框指令负责添加正确的填充。 如果您的对话框不使用 &lt;mat-dialog-content&gt; 等任何指令，这一点变化将会很明显。 mat-dialog-content 使用 Material Design 规范指定的字体设置，其中包括相当宽敞的行高。 如果您的对话框是信息密集型对话框, 在这些设置下会看起来不太好，您可以避免使用 &lt;mat-dialog-content&gt; 并仅使用带有自定义填充的 div，或者使用可与 mat.mdc-dialog-typography mixin 一起应用的自定义排版设置。 如果在旧对话框触发了额外的更改检测，在迁移时可能需要手动修复的更改检测问题。 4.9. Form Field“legacy”和“standard”表单字段外观设置不再存在，因为它们已从 Material Design 规范中删除。 如果未指定标签，则删除的“legacy”外观会将 placeholder 提升为浮动标签。 如果之前未提供，则所有较新的外观设置都需要显式指定 &lt;mat-label&gt;。 此更改解决了不交替使用标签和占位符的可访问性最佳实践。 默认情况下，MatFormField 仍然在字段下方保留一行空间用于提示或错误文本。 然而，有一个新选项@Input() subscriptSizing: ‘fixed’|’dynamic’。 当此设置设置为 fixed（默认）时，表单字段在布局中保留足够的空间来显示一行提示或错误文本。 当设置为动态时，表单字段会扩展和收缩布局所需的空间量来显示的错误/提示。 &lt;mat-hint&gt; 内的文本更大、更暗，以符合 W3C text 准则。 虽然以前的表单字段具有单个前缀指令 (matPrefix) 和单个后缀指令 (matSuffix)，但基于 MDC 的表单字段区分与输入文本基线对齐的文本前缀/后缀和图标前缀 /后缀在表单字段中居中对齐。 使用 matTextPrefix 或 matTextSuffix 指示文本前缀/后缀，使用 matIconPrefix 或 matIconSuffix 指示图标前缀/后缀。 旧的 matSuffix 和 matPrefix API 的行为类似于图标，尽管它们现在已被弃用。 floatLabel 输入不再接受“never”。 floatLabel=”never” 仅并旧表单字段外观支持。 它用于实现行为类似于占位符的浮动标签。 如果您需要此行为，请改用 &lt;input&gt; 上的占位符属性。 自定义表单字段控件可能需要调整其样式，因为表单字段 周围的 DOM 和样式可能已经改变了。 4.10. InputMatInput 必须位于 &lt;mat-form-field&gt; 内。 以前，如果页面在其他地方加载了表单字段样式，则可以使用不带表单字段的 &lt;input matInput&gt;。 基于 MDC 的 MatInput 会隐藏与 &lt;input matInput type=”date”&gt; 关联的原生日历选择器指示符，如果您希望此指示符在您的输入中显示，请使用以下样式： 123input.mat-mdc-input-element::-webkit-calendar-picker-indicator { display: block;} 4.11. ListAPI 已经过修改，以支持文本换行，并更好地与 Material Design 规范集成。以前，列表项通常是使用 matLine 指令创建多个 span 元素。每个 span 生成一行，第一行成为主要行。在新的 API 中，matLine 指令被拆分为两个更精细、更有意义的指令: matListItemTitle matListItemLine matListItemLine 之外的文本（所谓的“无范围内容”）将生成额外的行。 1234&lt;mat-list-item&gt; &lt;span matListItemTitle&gt;Title&lt;/span&gt; Second line&lt;/mat-list-item&gt; 该列表会自动推断文本内容的行数。例如，在上面的代码段中，列表项为两行呈现空间。使用新的 API，可以在&lt;mat-list-item&gt;上设置明确的行数，以手动控制换行。 12345&lt;mat-list-item lines=&quot;3&quot;&gt; &lt;span matListItemTitle&gt;Title&lt;/span&gt; This text will wrap into the third line. Space for three lines is acquired by the list item.&lt;/mat-list-item&gt; 请注意，matListItemTitle 或 matListItemLine 中的文本不会换行。根据提供的行数，只有无范围内容才会占用剩余空间。 除了行的组成方式不同之外，其他一些指令也被重命名为使用更明确的命名： matListIcon 变更为 matListItemIcon matListAvatar 变更为 matListItemAvatar最后，还有一个新指令（matListItemMeta）可用于将内容放入列表项的 meta section(通常是列表项的末尾）。列表项中以前无范围内容被放入 meta section。 List 建议的迁移步骤如下： 将第一个 matLine 更改为 matListItemTitle 将所有其他 matLine 更改为 matListItemLine 将所有 matListIcon 更改为 matListItemIcon 将所有 matListAvatar 更改为 matListItemAvatar 将所有无范围内容（matLine 之外的内容）包装在 matListItemMeta 容器中。 5. Menu无论 DOM 中的顺序如何，菜单项的图标都会出现在文本之前。如果您有一段内容（如＜ img ＞）要用来代替＜ mat-icon ＞，请使用 ngProjectAs=“mat-icon”将其投影到图标槽中。如果你需要你的图标出现在项目的末尾（规范不正式支持），你可以将文本和图标包装在一个 span 中，例如： 1234&lt;span&gt; &lt;span&gt;Text&lt;/span&gt; &lt;mat-icon&gt;end_icon&lt;/mat-icon&gt;&lt;/span&gt; 菜单项中的文本换行，而不是用省略号隐藏。 菜单项高度不再限制在 48 像素。 菜单标高从标高 8 开始，而不是从标高 4 开始。 5.1. Option / Optgroup长选项现在换行，而不是用省略号截断。 选项高度不再限制在 48 像素。 5.2. Paginatormat-paginator 内部的表单字段仅支持新表单字段提供的外观选项（fill 和 outline）。 5.3. Progress Bar内部元素的可见性现在设置为 visible。设置 visibility: hidden 将不再隐藏所有内部元素。如果要隐藏内部元素，使用 opacity:0、display:none 设置样式，或者使用 ngIf 将其完全删除。 高度始终设置为 4px，并且使用高度样式不会变矮或变高。 5.4. Progress SpinnerHost element 的 display 样式不再是可能影响布局的 display: block。若要解决布局问题，请将 display:block 添加回元素。 5.5. Radio单选按钮标签不再是宽度：100%。这有助于防止用户在单击页面上空白时意外选中单选按钮。 标签更小，离单选按钮更远，以符合“Material Design”规范。 触控目标现在更大，更容易触碰。确保在布局中留出足够的空间，以便触摸目标不会与其他组件重叠。如果你不关心可访问性，你可以通过对单选按钮使用 density-1 来匹配以前的尺寸。 12@use &quot;@angular/material&quot; as mat;@include mat.radio-density(-1); 5.6. SelectMatSelect 不再将下拉菜单中的选定选项与 trigger text 对齐。 长选项现在换行而不是截断。 选项高度不再限制在 48 像素。 选项列表现在有一个 8px 的顶部和底部填充。 选项列表动画已更改。 以前，下拉菜单的宽度可以比父 form-field 宽，但现在下拉菜单与父 form-field 的宽度相同 5.7. Slide Toggle为了提高可访问性，基于 MDC 的版本使用 &lt;button role=”switch”&gt; 来表示切换，而不是 &lt;input type=”checkbox”&gt;。 滑动切换将不再响应原生表单验证。 考虑使用表单验证的替代方法。 触摸目标更大且更容易触及。 请务必在布局中留出足够的空间，以便触摸目标不会与其他组件重叠。 如果您不关心可访问性，您可以通过使用滑动切换的密度 -1 来匹配以前的尺寸。 12@use &quot;@angular/material&quot; as mat;@include mat.slide-toggle-density(-1); 标签更靠近滑动切换按钮 5.8. SliderSlider 现在可以与移动设备屏幕阅读器配合使用。 滑块模板 API 已从单个&lt;mat-slider&gt;元素更改为包含一个或两个&lt;input&gt;元素（取决于滑块应为标准滑块还是范围滑块）的&lt;mat-srider&gt;元素。例如。 12345678910&lt;!-- Single slider --&gt;&lt;mat-slider&gt; &lt;input matSliderThumb /&gt;&lt;/mat-slider&gt;&lt;!-- Range slider --&gt;&lt;mat-slider&gt; &lt;input matSliderStartThumb /&gt; &lt;input matSliderEndThumb /&gt;&lt;/mat-slider&gt; ＜ mat-slider ＞上的新的 discrete 特性现在控制滑块是否具有 tick marks 和 value indicator 提示。它取代了 thumbLabel。 1234567&lt;!-- Before --&gt;&lt;mat-slider thumbLabel&gt;&lt;/mat-slider&gt;&lt;!-- After --&gt;&lt;mat-slider discrete&gt; &lt;input matSliderThumb /&gt;&lt;/mat-slider&gt; tickInterval 属性已被删除。要切换到新的 API，请使用 showTickMarks 创建带有刻度线的滑块，刻度线的间隔将与滑块的步长相匹配。tickInterval 属性正在考虑在将来的版本中重新添加。 1234567&lt;!-- Before --&gt;&lt;mat-slider tickInterval=&quot;5&quot; step=&quot;5&quot;&gt;&lt;/mat-slider&gt;&lt;!-- After --&gt;&lt;mat-slider step=&quot;5&quot; showTickMarks&gt; &lt;input matSliderThumb /&gt;&lt;/mat-slider&gt; displayValue 属性已被删除。控制数值指示器文本的建议替代方案是通过 displayWith 提供的函数。 1234567&lt;!-- Before --&gt;&lt;mat-slider [displayValue]=&quot;myDisplayValue&quot;&gt;&lt;/mat-slider&gt;&lt;!-- After --&gt;&lt;mat-slider [displayWith]=&quot;myDisplayWithFn&quot;&gt; &lt;input matSliderThumb /&gt;&lt;/mat-slider&gt; valueText 属性已经被删除，以便直接使用 native input 的 aria valueText 或使用 displayWith 属性指定的函数。 123456789101112&lt;!-- Before --&gt;&lt;mat-slider [valueText]=&quot;myValueText&quot;&gt;&lt;/mat-slider&gt;&lt;!-- After (Option 1) --&gt;&lt;mat-slider&gt; &lt;input [attr.aria-valuetext]=&quot;myValueText&quot; matSliderThumb /&gt;&lt;/mat-slider&gt;&lt;!-- After (Option 2) --&gt;&lt;mat-slider [displayWith]=&quot;myDisplayWithFn&quot;&gt; &lt;input matSliderThumb /&gt;&lt;/mat-slider&gt; slider API 也发生了更改，出现了两个新组件：MatSliderThumb 和 MatSliderRangeThumb。它们提供以下属性： @Input() value: number @Output() valueChange: EventEmitter&lt;number&gt; @Output() dragEnd: EventEmitter&lt;MatSliderDragEvent&gt; @Output() dragStart: EventEmitter&lt;MatSliderDragEvent&gt; percentage: number And the following methods: blur focus 为了适应范围滑块，实现方式已从作为表单控件的＜ mat-slider ＞元素更改为包含 1-2 个＜ input ＞元素的滑块，这些 input 元素用作表单控件。值、关联的事件（输入、更改）和标签（aria 标签）现在都存在于&lt;input&gt;元素中。垂直滑块和反转滑块不再受支持，因为它们不再是“材质设计”等级库的一部分。因此，反转和垂直特性已被删除。 垂直滑块和反转滑块不再受支持，因为它们不再是 Material Degsin 规范的一部分。因此，反转和垂直特性已被删除。 5.9. Snack Bar对于简单的、基于文本的 Snack Bar 来说，没有什么显著的变化。 对于带有动作按钮的简单 Snack Bar，其为使用 MDC-based 的 mat-button，因此您的应用程序需要包含基于 MDC 按钮的 Sass 主题 mixin。 对于使用自定义结构化内容的 Snack Bar（如果您调用 MatSnackBar.openFromComponent 或 MatSnackBar.openFromTemplate），您应该使用以下新指令来 annotate 您的内容： matSnackBarLabel 标记显示给用户的文本 matSnackBarActions 标记包含操作按钮的元素 matSnackBarAction 标记各个操作按钮 如果您没有指定这些指令中的任何一个，它将把整个自定义组件/模板视为文本。 那些打开 Snack Bar 的测试代码现在需要在尝试访问 Snack Bar 的内容之前调用 flush（）。在运行迁移工具之前更新您的测试以使用component harnesses应该可以实现无缝转换。 5.10. Table所有单元格都有 16px 的左右填充，而不仅仅是最左边和最右边的单元格有 24px 的填充。 标题单元格具有与数据行相同的颜色和文本大小，而不是具有更多的灰色和更小的文本。 默认情况下，单元格文本不再换行。可以通过对表格单元格应用 white-space: normal 来启用单元格换行。 行高是 52 像素，而不是 48 像素。 单元格的 box-sizing 是 border-box，而不是 content-box。这可能会影响自定义宽度样式。 表的最后一行不包括底部边框，因为 table 应具有底部边框。 MatTableDataSource 的 paginator 属性有一个通用接口，该接口与大多数分页器 API 匹配，但不是全部。您可能需要显式键入分页器才能访问完整的 API，例如：new MatTableDataSource&lt;MyData，MatPaginator&gt;（）； Flex tables（＜ mat-table ＞）在单元格上显示边框，而不是在行上显示边框。 Flex tables（＜ mat-table ＞）使用 height 而不是 line-height 来设置行高。 5.11. Tabs当 Tab 被选中时, 被选中的 Tab 标题标签文本颜色与主题颜色匹配 标题标签拉伸以填充 header 容器的宽度。但是这个行为可以被关闭, 要关闭拉升效果, 可以将&lt;mat-tab-group&gt;的 mat-stretch-tabs 属性设置为 false。 &lt;mat-tab-nav-bar&gt;需要使用 tabPanel 属性引用一个&lt;mat-tab-nav-panel&gt;。&lt;mat-tab-nav-panel&gt; 必须包裹连接到导航栏的内容。 123456&lt;!-- Before --&gt;&lt;mat-tab-nav-bar&gt;...&lt;/mat-tab-nav-bar&gt;&lt;!-- After --&gt;&lt;mat-tab-nav-bar [tabPanel]=&quot;tabPanel&quot;&gt;...&lt;/mat-tab-nav-bar&gt;&lt;mat-tab-nav-panel #tabPanel&gt;...&lt;/mat-tab-nav-panel&gt; 5.12. Tooltip背景颜色是不透明的，而不是略微透明的。这提高了可访问性。 默认字体大小是 12px，而不是 10px。 行高是 normal ，而不是 16px。 文本溢出是省略号而不是 clip。 有一个新的最小宽度 40px。 单行工具提示的文本对齐方式居中。多行工具提示使用左对齐。 6. 相关阅读本技术博客原创文章位于鹏叔的技术博客 - MDC-based Angular Material 组件迁移, 要获取最近更新请访问原文. 更多 Angular 相关文章请访问Angular 合集 | 鹏叔的技术博客, 更多 Material Design 相关文章请访问鹏叔的技术博客 - Material Design 专题. 更多技术博客请访问: 鹏叔的技术博客 更多 Angular Material 相关文章请站内搜索 Angular 和 Material. 7. 参考文档Migrating to MDC-based Angular Material Components What’s new in Angular Material and the CDK in Angular 15 Angular Schematics 介绍 Angular 15 现已上线：所有新功能、代码实践更改和弃用信息！ Guide to update your Angular application v13.0 -&gt; v15.0 对于 medium applications","link":"/angular/angular_migrate_to_mdc.html"},{"title":"Angular HTTP 拦截器：配置多个HTTP拦截器和 4 个拦截器代码示例","text":"拦截器在 Angular 中用于拦截 HttpRequest/HttpResponse。我们可以使用拦截器来记录 HttpRequest/HttpResponse 日志，或者在将其传递给服务器之前添加其他 HttpRequest 头部信息，以及更改请求主体或更改从服务器收到的响应的格式等。在本文中，我将解释如何使用多个拦截器以及拦截器的 6 种最常见用法（附示例）。 1. 如何添加多个拦截器？Angular 中可以添加多个拦截器，每个拦截器都有不同的用途。我们可以在一个拦截器中添加所有功能，但这可能会让事情变得混乱。因此，为了使应用程序模块化，我们为不同的目的创建不同的拦截器。 123456789101112131415161718192021222324252627282930313233import { HTTP_INTERCEPTORS } from &quot;@angular/common/http&quot;;import { AuthInterceptorService } from &quot;./Authentication/auth-interceptor.service&quot;;import { XML2JsonInterceptorService } from &quot;./ResponseFormat/xml2-json-interceptor.service&quot;;import { AjaxBusyIdentifierInterceptorService } from &quot;./AjaxBusyIndicator/ajax-busy-identifier-interceptor.service&quot;;import { RequestTimestampService } from &quot;./RequestTimestamp/request-timestamp.service&quot;;import { ErrorNotifierService } from &quot;./ErrorNotifier/error-notifier.service&quot;;import { RetryInterceptorService } from &quot;./RetryInterceptor/retry-interceptor.service&quot;;export const interceptorProviders = [ { provide: HTTP_INTERCEPTORS, useClass: RequestTimestampService, multi: true, }, { provide: HTTP_INTERCEPTORS, useClass: AjaxBusyIdentifierInterceptorService, multi: true, }, { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: XML2JsonInterceptorService, multi: true, }, { provide: HTTP_INTERCEPTORS, useClass: ErrorNotifierService, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: RetryInterceptorService, multi: true, },]; HTTP_INTERCEPTORS HttpInterceptor：代表已注册的数组的多 provider 令牌。 const HTTP_INTERCEPTORS: InjectionToken&lt;HttpInterceptor[]&gt;; provide: 将 useClass 作为一个 HTTP_INTERCEPTORS provider useClass HttpInterceptor：提及应该添加到数组中的类 multi:true 这是必需的设置，它告诉 angular token 是多提供者。如果将其设置为 false，应用程序将抛出错误。 1234567891011121314151617181920212223242526import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { NgModule } from &quot;@angular/core&quot;;import { AppComponent } from &quot;./app.component&quot;;import { interceptorProviders } from &quot;./interceptors&quot;;import { HttpClientModule } from &quot;@angular/common/http&quot;;import { AjaxBusyIndicatorDirective } from &quot;./AjaxBusyIndicator/ajax-busy-indicator.directive&quot;;import { BrowserAnimationsModule } from &quot;@angular/platform-browser/animations&quot;;import { ToastrModule } from &quot;ngx-toastr&quot;;import { RouterModule } from &quot;@angular/router&quot;;@NgModule({ declarations: [AppComponent, AjaxBusyIndicatorDirective], imports: [ BrowserModule, BrowserAnimationsModule, ToastrModule.forRoot(), HttpClientModule, RouterModule, ], providers: [interceptorProviders], bootstrap: [AppComponent],})export class AppModule {} 从 interceptors.ts 中导入 interceptorProviders。在装饰器@NgModule providers 中添加 InterceptorProviders 数组. 2. 实现 HttpInterceptor 的基本步骤1234567891011121314151617181920import { Injectable } from &quot;@angular/core&quot;;import { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest,} from &quot;@angular/common/http&quot;;import { Observable } from &quot;rxjs&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class BasicInterceptorService implements HttpInterceptor { intercept( req: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;any&gt;&gt; { return next.handle(req); }} BasicInterceptorService.service.ts： 从‘@angular/core’类导入 Injectable 并添加@Injectable({providedId:’root’})装饰器到类中以使其成为 Angular 服务。 从‘@angular/common/http’导入并实现 HttpInterceptor 以使其成为拦截器。 从‘@angular/common/http’中导入 HttpRequest, HttpHandler, HttpEvent 并实现 intercept 函数，继承/实现 HttpInterceptor。 intercept 函数将返回 next.handle(req);。这意味着我们将控制权传递给链中的下一个拦截器（如果有的话）。 您还可以传递自己的可观察对象并短路拦截器链，并忽略前面的拦截器和后端处理程序。例如： 123return of( new HttpResponse&lt;any&gt;({ body: &quot;dummy body&quot;, url: &quot;dummyurl.com&quot; })); 3. 拦截器示例3.1. 身份验证/会话拦截器身份验证拦截器可用于将身份验证标头添加到您的请求中。如果用户未经身份验证，您甚至可以将应用程序路由到登录页面。 1234567891011121314151617181920212223242526272829303132333435import { Injectable } from &quot;@angular/core&quot;;import { Observable } from &quot;rxjs&quot;;import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor,} from &quot;@angular/common/http&quot;;import { AuthService } from &quot;./auth.service&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class AuthInterceptorService implements HttpInterceptor { constructor( public auth: AuthService //,public router: Router ) {} intercept( request: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;any&gt;&gt; { if (this.auth.isAuthenticated) { request = request.clone({ headers: request.headers.set( &quot;Authorization&quot;, &quot;Bearer &quot; + this.auth.authToken ), }); } else { // this.router.navigate(['LoginPage']); } return next.handle(request); }} AuthInterceptorService.service.ts： 按照基本步骤实现 HttpInterceptor 在构造函数参数中添加 AuthService 依赖项。 使用 this.auth.isAuthenticated 检查用户是否通过身份验证 如果用户通过了身份验证，则将身份验证令牌添加到请求标头。这里我们使用是 request.clone()因为请求是不可变的对象。 如果用户未经身份验证，则将其路由到登录页面。 3.2. 请求格式拦截器有时我们可能会收到来自 Api 服务器的 XML 格式的响应。我们需要将 XML 数据的格式转换为 Json 格式才能在应用程序中使用它。我们可以使用拦截器来处理此类响应 123456789101112131415161718192021222324252627282930313233343536373839404142434445import { NgxXml2jsonService } from &quot;ngx-xml2json&quot;;import { Injectable } from &quot;@angular/core&quot;;import { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HttpInterceptor,} from &quot;@angular/common/http&quot;;import { Observable } from &quot;rxjs&quot;;import { map } from &quot;rxjs/operators&quot;;@Injectable({ providedIn: &quot;root&quot;,})export class XML2JsonInterceptorService implements HttpInterceptor { constructor(private xml2jsonService: NgxXml2jsonService) {} intercept( req: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;any&gt;&gt; { req = req.clone({ responseType: &quot;text&quot; }); return next.handle(req).pipe( map((event) =&gt; { if ( event instanceof HttpResponse &amp;&amp; event.headers.get(&quot;content-type&quot;).indexOf(&quot;application/xml&quot;) &gt;= 0 ) { const parser = new DOMParser(); const xml = parser.parseFromString(event.body, &quot;text/xml&quot;); event = event.clone({ body: this.xml2jsonService.xmlToJson(xml) }); } else if ( event instanceof HttpResponse &amp;&amp; event.headers.get(&quot;content-type&quot;).indexOf(&quot;application/json&quot;) &gt;= 0 ) { event = event.clone({ body: JSON.parse(event.body) }); } return event; }) ); }} xml2-json-interceptor.service.ts： 按照基本步骤来实现 HttpInterceptor。 从‘ngx-xml2json’导入 NgxXml2jsonService（XML 到 JSON 转换器服务）; 12# 您需要在项目中使用该包之前安装它。npm install ngx-xml2json --save 从‘@angular/common/http’ 导入 HttpResponse ; 将预期响应类型更改为 text 而不是 json。我们进行此更改是为了既可以接收 XML 响应 又可以接受 JSON 响应。 将 map 运算符应用于 next.handel(req)。注意：我们使用 map 运算符而不是 tap 因为我们只能使用来读取响应 tap。 在 map 运算符中，如果事件类型为 HttpResponse，并且内容类型为，’application/xml’我们使用以下代码将事件主体从 Xml 转换为 Json：我们使用因为如果不可变。 1234const parser = new DOMParser();const xml = parser.parseFromString(event.body, ‘text/xml’);event = event.clone({ body: this.xml2jsonService.xmlToJson(xml) });event.clone(..)HttpResponse 如果事件类型为 HttpResponse，内容类型为，则’application/json’我们使用将事件主体从文本转换为 Json event = event.clone({body:JSON.parse(event.body)});。我们将主体从文本转换为 JSON，因为我们要求响应类型为文本，但现在我们需要 Json 格式的主体，以便我们可以在应用程序中使用它。 3.3. AJAX动画拦截器拦截器的最佳示例之一是 ajax 动画拦截器。每当您的 Angular 应用程序发出 AJAX/XHR 请求时，此拦截器将帮助您在应用程序中显示动画。我们主要将加载动画添加到页面的 Header 部分。我们有 3 个部分供此服务使用 拦截器：将会通知指令。 通知服务：包含 API 请求的当前繁忙状态。如果有任何正在进行的 API 请求，busy则传递给的值为 true，否则为false。 指令：将作为 html 属性添加到需要在 api 调用时显示的动画 CSS 或 GIF 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import { Injectable } from '@angular/core';import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http'import { Observable, pipe } from 'rxjs';import { finalize, tap } from 'rxjs/operators';import { AjaxBusyNotifierService } from './ajax-busy-notifier.service'@Injectable({ providedIn: 'root'})export class AjaxBusyIdentifierInterceptorService implements HttpInterceptor { constructor(private abns: AjaxBusyNotifierService) { } requestCounter = 0; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { this.beginRequest(); return next.handle(req).pipe( finalize(() =&gt; { this.endRequest(); }) ); } beginRequest() { this.requestCounter = Math.max(this.requestCounter, 0) + 1; if (this.requestCounter === 1) { this.abns.busy.next(true); } } endRequest() { this.requestCounter = Math.max(this.requestCounter, 1) - 1; if (this.requestCounter === 0) { this.abns.busy.next(false); } }} ajax-busy-identifier-interceptor.service.ts： 按照基本步骤来执行HttpInterceptor。 this.beginRequest();在拦截函数的开头调用。它将增加requestCounter 或设置requestCounter为 1（如果小于或等于 0）。如果requestCounter等于 1，它将传递 true 给abns.busyBehaviourSubject。这将通知 ajax-busy-indicator 指令已发起 ajax 请求。 this.endRequest()在 内调用finalize(()=&gt;{})。如果 requestCounter 大于 1，它将减少 requestCounter，否则将其设置为 0。如果 reequestCounter 等于 0，我们将向abns.busyBehaviourSubject 传递 false。这将通知 ajax-busy-indicator 指令所有 ajax 请求都已完成（收到响应或失败）。 1234567891011121314151617import { Injectable } from '@angular/core';import {BehaviorSubject} from 'rxjs'@Injectable({ providedIn: 'root'})export class AjaxBusyNotifierService { busy:BehaviorSubject&lt;boolean&gt;; constructor() { this.busy = new BehaviorSubject&lt;boolean&gt;(false); this.busy.next(false); }} ajax-busy-notifier.service.ts： AjaxBusyNotifierService包含busy的对象属性BehaviorSubject&lt;boolean&gt;;。BehaviorSubject&lt;boolean&gt;其行为既像可观察对象又像观察者。在拦截器中，当它调用abns.busy.next(true)时，它的行为就像观察者。在指令中，当它调用abns.busy.subscribe((busy)=&gt;{…})时，它的行为就像可观察对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import { Directive, Input, OnInit, ElementRef, Renderer2 } from '@angular/core';import { interval, Subscription } from 'rxjs';import { AjaxBusyNotifierService } from './ajax-busy-notifier.service';@Directive({ selector: '[ajax-busy-indicator]'})export class AjaxBusyIndicatorDirective implements OnInit { @Input() showDelay: number = 50; @Input() hideDelay: number = 1000; hideTimer: Subscription; showTimer: Subscription; constructor(private el: ElementRef, private renderer: Renderer2, private abns: AjaxBusyNotifierService) { } cancelPendingHide() { if (this.hideTimer) { this.hideTimer.unsubscribe(); delete this.hideTimer; } } cancelPendingShow() { if (this.showTimer) { this.showTimer.unsubscribe(); delete this.showTimer; } } ngOnInit() { this.abns.busy.subscribe(busy =&gt; { if (busy) { this.cancelPendingHide(); // If a show is already pending, don't start a new one. if (!this.showTimer) { this.showTimer = interval(this.showDelay).subscribe(() =&gt; { this.renderer.removeClass(this.el.nativeElement, 'inactive'); this.showTimer.unsubscribe(); this.showTimer = null; }); } } }); this.abns.busy.subscribe(busy =&gt; { if (!busy) { this.cancelPendingShow(); // If a show is already pending, don't start a new one. if (!this.hideTimer) { this.hideTimer = interval(this.hideDelay).subscribe(() =&gt; { this.renderer.addClass(this.el.nativeElement, 'inactive'); this.hideTimer.unsubscribe(); this.hideTimer = null; }); } } } ); }} ajax-busy-indicator.directive.ts： 添加@Directive装饰器AjaxBusyIndicatorDirective类以使其具有指令性。 将选项添加selector:’[ajax-busy-indicator]’到装饰器。这将使其成为属性指令。现在我们可以添加ajax-busy-indicator到任何元素以应用此指令。 声明变量showDelay并hideDelay添加@Input 装饰器使其成为指令的输入属性。 声明showTimer和hideTimer订阅对象，以便我们可以取消订阅显示和隐藏计时器。 cancelPendingHide()将取消订阅 hideTimer 并将cancelPendingShow()取消订阅 showTimer。 在 ngOnInit 中，我们将为abns.busyBehaviourSubject 添加 2 个订阅者。一个用于隐藏内容（加载动画），另一个用于显示指令内的内容。 如果传递给的值为abns.busytrue a) 它将调用cancelPendingHide()取消订阅hideTimer。 b) 它将以 showDelay 作为计时器的周期来启动计时器。 在计时器内，它将从’inactive’指令元素中删除类，然后取消订阅计时器并启动计时器null。 abns.busy类似地，如果为false，我们将进行逆操作，清除动画。 3.4. 通知错误拦截器如果 AJAX/XHR 请求的响应有错误，可以使用通知错误拦截器来显示错误。 12345678910111213141516171819202122232425262728import { Injectable } from '@angular/core';import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';import { Observable } from 'rxjs';import { tap, retry, debounceTime } from 'rxjs/operators';import { ToastrService } from 'ngx-toastr';@Injectable({ providedIn: 'root'})export class ErrorNotifierService implements HttpInterceptor { constructor(private toasterService: ToastrService) { } intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): any { return next.handle(request).pipe( tap( event =&gt; { }, error =&gt; { if (error instanceof HttpErrorResponse) { this.toasterService.error(error.message, error.name, { closeButton: true }); } } )); }} 按照基本步骤来执行HttpInterceptor。 从ngx-toastr导入ToastrService。ToastrService 使用构造函数注入依赖项。constructor(private toasterService: ToastrService){}在使用 ToasteService 之前，我们需要使用 npm 安装它：npm install ngx-toastr — save @angular/animations包是默认 toast 所需的依赖项npm install @angular/animations --save 在拦截函数中，使用管道函数将运算tap符应用于next.handle(request):Observable。点击错误并使用toasterService显示它。 4. 参考文章Angular HTTP Interceptors : Multiple Interceptors and 6 Code Examples of Interceptors","link":"/angular/angular_multiple_interceptors.html"},{"title":"如何在Angular应用中使用Ngx-charts？","text":"1. 前言图表帮助我们以易于理解和交互的方式可视化大量数据。在 Angular 中，我们有各种图表库来创建图表。NGX-charts 就是其中之一。 ngx-charts 是 Angular2+ 的开源声明式图表框架。它由Swimlane维护 。 它使用 Angular 来渲染和动画 SVG 元素，并利用其所有的绑定和速度优势，并使用 d3 来实现出色的数学函数、比例、轴和形状生成器等。 通过让 Angular 完成所有渲染，它为我们带来了 Angular 平台提供的无限可能性，例如 AoT、Universal 等。 ngx-charts 支持各种图表类型，如条形图、折线图、面积图、饼图、气泡图、圆环图、仪表图、热图、树状图和数字卡片图。 它还支持自动缩放、时间线过滤、line interpolation、可配置轴、图例、实时数据支持等功能。 在本文中，我们将看到使用 Ngx-Charts 进行数据可视化以及如何在 Angx-Charts 中使用 Angx-Charts 我们会学到， 如何在 Angular 中安装 ngx-charts ？ 创建垂直条形图 创建饼图、高级饼图和饼图网格 2. Ngx-Charts 安装 使用以下命令创建一个新的角度应用程序 1ng new ngx-charts-demo 使用以下命令在角度应用程序中安装 ngx-charts 包。 123# ngx-charts依赖@angular/cdk, 所以需要先安装@angular/cdk, 再安装@swimlane/ngx-chartsnpm install @angular/cdk --savenpm install @swimlane/ngx-charts --save 导入 NgxChartsModule( from ngx-charts)模块到 AppModule 中 ngx-charts 还需要 BrowserAnimationsModule。将其导入 AppModule 中 所以我们的 AppModule 最终看起来像这样： 12345678910111213import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { NgModule } from &quot;@angular/core&quot;;import { AppComponent } from &quot;./app.component&quot;;import { NgxChartsModule } from &quot;@swimlane/ngx-charts&quot;;import { BrowserAnimationsModule } from &quot;@angular/platform-browser/animations&quot;;@NgModule({ declarations: [AppComponent], imports: [BrowserModule, BrowserAnimationsModule, NgxChartsModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} 安装步骤完成。现在让我们使用以下方法开发各种图表了。 3. 垂直条形图(Vertical Bar Chart)在制作条形图之前我们需要准备一些数据, 当然在示例中这些数据是静态的, 在实际开发过程中我们可通过 restful API 从后台获取数据.在本例中我们准备了一些简单的销售数据。我们将使用这些数据来生成各种图表。 12345678910111213141516import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.css&quot;],})export class AppComponent { saleData = [ { name: &quot;Mobiles&quot;, value: 105000 }, { name: &quot;Laptop&quot;, value: 55000 }, { name: &quot;AC&quot;, value: 15000 }, { name: &quot;Headset&quot;, value: 150000 }, { name: &quot;Fridge&quot;, value: 20000 }, ];} 要生成垂直条形图，ngx-charts 提供 ngx-charts-bar-vertical 组件，将其添加到 html 模板上，如下所示： 1234567891011121314&lt;ngx-charts-bar-vertical [view]=&quot;[1000,400]&quot; [results]=&quot;saleData&quot; [xAxisLabel]=&quot;'Products'&quot; [legendTitle]=&quot;'Product Sale Chart'&quot; [yAxisLabel]=&quot;'Sale'&quot; [legend]=&quot;true&quot; [showXAxisLabel]=&quot;true&quot; [showYAxisLabel]=&quot;true&quot; [xAxis]=&quot;true&quot; [yAxis]=&quot;true&quot; [gradient]=&quot;true&quot;&gt;&lt;/ngx-charts-bar-vertical&gt; ngx-charts-bar-vertical 组件的一些重要属性说明: results: 要呈现 salesData 图表，我们需要将此数据对象分配给 results view: 设置图表视图的宽度和高度 xAxisLabel: x 轴标签 legendTitle: 图例标题 legend : 如果要显示图例，请将其设置为 true，默认为 false showXAxisLabel : 设置 true 以显示 x 轴标签 showYAxisLabel: 设置 true 以显示 y 轴标签。 xAxis / yAxis : 设置 true 以显示特定数轴 gradient: 将其设置为 true 以显示具有渐变背景 4. 饼图(Pie Chart)我们可以使用 ngx-charts-pie-chart 组件生成饼图。将其添加到 html 模板中，如下所示。 12345678&lt;ngx-charts-pie-chart [results]=&quot;saleData&quot; [legend]=&quot;true&quot; [legendTitle]=&quot;'Product Sale Report'&quot; [view]=&quot;[1000,300]&quot; [labels]=&quot;true&quot;&gt;&lt;/ngx-charts-pie-chart&gt; 5. Advanced 饼图(Advanced Pie Chart)我们可以使用 ngx-charts-advanced-pie-chart 组件制作高级饼图如下: 12&lt;ngx-charts-advanced-pie-chart [results]=&quot;saleData&quot; [gradient]=&quot;true&quot;&gt;&lt;/ngx-charts-advanced-pie-chart&gt; 6. 饼图网格我们可以使用 ngx-charts-pie-grid 组件制作饼图网格如下: 1&lt;ngx-charts-pie-grid [results]=&quot;saleData&quot;&gt; &lt;/ngx-charts-pie-grid&gt; 我们已经使用 ngx-charts 制作了四种图表 7. 最终代码示例代码可以在github - ngx-charts-demo上找到 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 9. 参考文档ngx-charts 官方文档 How To Use Ngx-Charts In Angular Application ?","link":"/angular/angular_ngx_charts.html"},{"title":"将ngx-datatable替换为Angular material table","text":"1. 前言从 Angular 1.x 到 Angular 13 一直是用的 angular-data-table(for angularjs 1.x)和它的姊妹项目 ngx-datatable(for angular 2+), 但是最近需要将 Angular 项目从 Angular 14 升级到 Angular 16 的过程中发现了一些兼容性问题, 另外 ngx-datatable 也不支持 dark mode. 再次关注 ngx-datatable 以及网上的评论都有同感, ngx-datatable 的更新速度严重放缓了, 有些跟不上 Angular 更新的节奏了. 参考 reddit 上的一篇帖子Any better alternatives to ngx-datatable?, 也谈到了 ngx-datatable 更新放缓. 于是考虑将 ngx-datatable 组件替换掉, 这里有一些付费的项目, 在功能上可以完全替换, 比如ag-grid, Ignite UI for Angular Data Grid, Syncfusion Angular UI Components - Data Grid等等. 最后考察了 angular material table 在功能上完全服务我们的要求, sorting, pagination, server side pagination 之类的功能都有. 另外项目刚好使用的是 Material Design 设计风格, 那些付费方案的高级功能也用不上, 还要花时间学习, 另外考虑到 bundle 文件的大小, 最后坚定的选择了 Angular material table. 于是才有了这篇文章 2. 两种组件比较以下是两个典型的 ngx-datatable 和 mat-table 示例 123456789101112131415161718192021222324252627&lt;ngx-datatable #table class=&quot;material&quot; [headerHeight]=&quot;50&quot; [limit]=&quot;10&quot; [columnMode]=&quot;'force'&quot; [footerHeight]=&quot;50&quot; [rowHeight]=&quot;'auto'&quot; [rows]=&quot;datasource&quot; [loadingIndicator]=&quot;loadingIndicator&quot; [selected]=&quot;selected&quot; (select)=&quot;onSelect($event)&quot;&gt; &lt;ngx-datatable-column name=&quot;word&quot; [sortable]=&quot;true&quot;&gt; &lt;ng-template let-column=&quot;column&quot; ngx-datatable-header-template&gt; &lt;h3&gt;单词&lt;/h3&gt; &lt;/ng-template&gt; &lt;ng-template ngx-datatable-cell-template let-rowIndex=&quot;rowIndex&quot; let-value=&quot;value&quot; let-row=&quot;row&quot; &gt; &lt;span [textContent]=&quot;value&quot; (click)=&quot;wordSearch(row.word)&quot;&gt; &lt;/span&gt; &lt;/ng-template&gt; &lt;/ngx-datatable-column&gt;&lt;/ngx-datatable&gt; 123456789101112&lt;table mat-table [dataSource]=&quot;datasource&quot; matSort class=&quot;mat-elevation-z2 w-full&quot;&gt; &lt;tr mat-header-row *matHeaderRowDef=&quot;displayedColumns; sticky: true&quot;&gt;&lt;/tr&gt; &lt;tr mat-row *matRowDef=&quot;let row; columns: displayedColumns&quot;&gt;&lt;/tr&gt; &lt;ng-container matColumnDef=&quot;WORD&quot;&gt; &lt;th mat-header-cell *matHeaderCellDef mat-sort-header&gt;单词&lt;/th&gt; &lt;td mat-cell *matCellDef=&quot;let row&quot;&gt;{{ row.WORD }}&lt;/td&gt; &lt;/ng-container&gt; &lt;/table&gt; &lt;mat-paginator [pageSizeOptions]=&quot;[10, 25, 100]&quot;&gt;&lt;/mat-paginator&gt; &lt;/div&gt; 从示例我们可以看出 ngx-datatable 必须是一个 tag, 而 mat-table 可以是一个附着在 table 上的指令, 也可以是一个 tag 两者都需要绑定 datasource, ngx-datatable 使用 rows 属性绑定 datasource, 而 mat-table 使用 datasource 属性 ngx-datatable [rows]=”datasource” mat-table [dataSource]=”datasource” ngx-datatable 提供了 loadingIndicator 属性, 而 mat-table 没有提供, 不过可以参考Add a spinner when Mat-table is loading? 实现, 不是很复杂. 排序方面(sorting) ngx-datatable 默认是可排序的, 如果不希望 Column 支持排序, 需要显式的将其标为[sortable]=&quot;false&quot; mat-table 默认是不可排序的, 需要在 mat-table 上添加 matSort, 在 th 上需要添加 mat-sort-header 指令 分页(pagination) ngx-datatable 分页相关的属性在 ngx-datatable 上 而 mat-table 使用单独的 mat-paginator 标签 过滤(filtering) 两者都通过操纵 datasourcing 实现过滤 字段定义方式 ngx-datatable 有专门的定义字段的标签 ngx-datatable-column, 一个标签定义一个字段然后使用 let-column=&quot;column&quot;, let-rowIndex=&quot;rowIndex&quot; let-value=&quot;value&quot; let-row=&quot;row&quot;绑定数据 而 mat-table 几乎重用了 html 的 tr, td, th 标签, 使用 directive 来标记表头, 表格, 例如使用 mat-header-cell 标记表头, mat-cell 标记单元格 了解了以上差异和共同点我们就可以着手迁移 ngx-datatable 到 Angular material table 组件了 3. 开始迁移3.1. 备份或分支在正式迁移前, 我们需要指定备份, 或者创建一个迁移分支, 这样我们可以反复比较迁移以前和迁移之后的应用在功能上的变化. 3.2. 迁移步骤 将 ngx-datatable 替换为 mat-table, 精简后的 mat-table 只剩下如下内容. 迁移前的 ngx-datatable 的示例就不列举出来了, 可以参考上一节示例 1234567&lt;mat-table [dataSource]=&quot;datasource&quot; matSort class=&quot;mat-elevation-z2 w-full&quot;&gt; ... your row and column definition goes here ...&lt;/mat-table&gt;&lt;mat-paginator [pageSizeOptions]=&quot;[10, 25, 100]&quot; showFirstLastButtons&gt;&lt;/mat-paginator&gt; 建议将 matSort 加上, 往往有那么一两个字段是需要排序的.如果需要加入分页, 如上加上 mat-paginator 用于替换 ngx-datatable 的分页功能 去掉class=&quot;material&quot;, 因为 mat-table 默认已经是 material 样式 去掉 headerHeight, footerHeight, [rowHeight]=&quot;'auto'&quot; , [columnMode]=&quot;'force'&quot;属性让其自适应 将 rows 属性替换为[rows]=&quot;datasource&quot; =&gt; [dataSource]=&quot;datasource&quot; 将[loadingIndicator]=&quot;loadingIndicator&quot;替换为自定义实现 将[limit]=”10” 所定义的功能移动到 mat-paginator 标签上&lt;mat-paginator [pageSizeOptions]=&quot;[10, 25, 100]&quot;&gt;&lt;/mat-paginator&gt; 添加 header定义 displayedColumns 1displayedColumns: string[] = [&quot;columnName1&quot;, &quot;columnName2&quot;] 修改 html template 12&lt;mat-header-row *matHeaderRowDef=&quot;displayedColumns; sticky: true&quot;&gt;&lt;/mat-header-row&gt;&lt;mat-row *matRowDef=&quot;let row; columns: displayedColumns&quot;&gt;&lt;/mat-row&gt; ngx-datatable-column 替换为 ng-container, 以下是一款 column 模板, 将 columnName, “栏位标题”替换掉 12345&lt;ng-container matColumnDef=&quot;columnName&quot;&gt; &lt;mat-header-cell *matHeaderCellDef mat-sort-header&gt;栏位标题&lt;/mat-header-cell&gt; &lt;mat-cell *matCellDef=&quot;let row&quot;&gt;&lt;span [textContent]=&quot;row.columnName&quot;&gt;&lt;/span&gt;&lt;/mat-cell&gt;&lt;/ng-container&gt; 在 ts 文件中定义@ViewChild(MatPaginator) paginator: MatPaginator; 在 ts 文件中定义@ViewChild(MatSort) sort: MatSort; 在 ts 文件中定义datasource: MatTableDataSource&lt;any&gt;; 将 datasource 替换为包装类型this.datasource = new MatTableDataSource(data); 将 datasource 和 paginator 关联this.datasource.paginator = this.paginator; 将 datasource 和 sort 关联this.datasource.sort = this.sort; 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 5. 参考文档The Missing Guide to Angular Material","link":"/angular/angular_ngx_table_to_mat_table.html"},{"title":"深度刨析@angular&#x2F;platform-browser-dynamic","text":"1. 前言作为 angular 应用的入口模块，了解他的重要性是显而易见的！ 2. angular 之 main.tsmain.ts 是这个样子的，下面我就去解开 platformBrowserDynamic 神秘面纱！ 123platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =&gt; console.error(err)); 3. 解析 platformBrowserDynamicplatformBrowserDynamic 源码位于platform-browser-dynamic.ts 首先我们来看一下接口定义 123456/** * @publicApi */export declare const platformBrowserDynamic: ( extraProviders?: StaticProvider[] | undefined) =&gt; PlatformRef; 方法返回的是一个 PlatformRef, 可以接受一个或多个额外的 Providers. 先看一下返回值对象 PlatformRef, 这是 PlatformRef 的源码及介绍 Angular platform 是 Angular 在网页上的入口点。每一 web 页面有且仅有一个 platform。所有的服务（如反射）都绑定在其 scope 内并共享给整个 Angular application。当使用 Angular platform 创建平台时，页面的 platform 会隐式初始化factory，例如’PlatformBrowser’，或者通过调用’createPlatform（）’函数显式调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * The Angular platform is the entry point for Angular on a web page. * Each page has exactly one platform. Services (such as reflection) which are common * to every Angular application running on the page are bound in its scope. * A page's platform is initialized implicitly when a platform is created using a platform * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function. * * @publicApi */export declare class PlatformRef { private _injector; private _modules; private _destroyListeners; private _destroyed; /** * Creates an instance of an `@NgModule` for the given platform. * * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function * argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead. */ bootstrapModuleFactory&lt;M&gt;( moduleFactory: NgModuleFactory&lt;M&gt;, options?: BootstrapOptions ): Promise&lt;NgModuleRef&lt;M&gt;&gt;; /** * Creates an instance of an `@NgModule` for a given platform. * * @usageNotes * ### Simple Example * * ```typescript * @NgModule({ * imports: [BrowserModule] * }) * class MyModule {} * * let moduleRef = platformBrowser().bootstrapModule(MyModule); * ``` * */ bootstrapModule&lt;M&gt;( moduleType: Type&lt;M&gt;, compilerOptions?: | (CompilerOptions &amp; BootstrapOptions) | Array&lt;CompilerOptions &amp; BootstrapOptions&gt; ): Promise&lt;NgModuleRef&lt;M&gt;&gt;; private _moduleDoBootstrap; /** * Registers a listener to be called when the platform is destroyed. */ onDestroy(callback: () =&gt; void): void; /** * Retrieves the platform {@link Injector}, which is the parent injector for * every Angular application on the page and provides singleton providers. */ get injector(): Injector; /** * Destroys the current Angular platform and all Angular applications on the page. * Destroys all modules and listeners registered with the platform. */ destroy(): void; get destroyed(): boolean; static ɵfac: i0.ɵɵFactoryDeclaration&lt;PlatformRef, never&gt;; static ɵprov: i0.ɵɵInjectableDeclaration&lt;PlatformRef&gt;;} packages\\core\\src\\application_ref.ts 为给定平台创建“@NgModule”的实例。 123456789bootstrapModule&lt;M&gt;( moduleType: Type&lt;M&gt;, compilerOptions: (CompilerOptions&amp;BootstrapOptions)| Array&lt;CompilerOptions&amp;BootstrapOptions&gt; = []): Promise&lt;NgModuleRef&lt;M&gt;&gt; { const options = optionsReducer({}, compilerOptions); return compileNgModuleFactory(this.injector, options, moduleType) .then(moduleFactory =&gt; this.bootstrapModuleFactory(moduleFactory, options));} NgModuleFactory 的创建过程, 重点是创建 R3NgModuleFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export function compileNgModuleFactory&lt;M&gt;( injector: Injector, options: CompilerOptions, moduleType: Type&lt;M&gt;): Promise&lt;NgModuleFactory&lt;M&gt;&gt; { ngDevMode &amp;&amp; assertNgModuleType(moduleType); const moduleFactory = new R3NgModuleFactory(moduleType); // All of the logic below is irrelevant for AOT-compiled code. if (typeof ngJitMode !== &quot;undefined&quot; &amp;&amp; !ngJitMode) { return Promise.resolve(moduleFactory); } const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options); // Configure the compiler to use the provided options. This call may fail when multiple modules // are bootstrapped with incompatible options, as a component can only be compiled according to // a single set of options. setJitOptions({ defaultEncapsulation: _lastDefined( compilerOptions.map((opts) =&gt; opts.defaultEncapsulation) ), preserveWhitespaces: _lastDefined( compilerOptions.map((opts) =&gt; opts.preserveWhitespaces) ), }); if (isComponentResourceResolutionQueueEmpty()) { return Promise.resolve(moduleFactory); } const compilerProviders = _mergeArrays( compilerOptions.map((o) =&gt; o.providers!) ); // In case there are no compiler providers, we just return the module factory as // there won't be any resource loader. This can happen with Ivy, because AOT compiled // modules can be still passed through &quot;bootstrapModule&quot;. In that case we shouldn't // unnecessarily require the JIT compiler. if (compilerProviders.length === 0) { return Promise.resolve(moduleFactory); } const compiler = getCompilerFacade({ usage: JitCompilerUsage.Decorator, kind: &quot;NgModule&quot;, type: moduleType, }); const compilerInjector = Injector.create({ providers: compilerProviders }); const resourceLoader = compilerInjector.get(compiler.ResourceLoader); // The resource loader can also return a string while the &quot;resolveComponentResources&quot; // always expects a promise. Therefore we need to wrap the returned value in a promise. return resolveComponentResources((url) =&gt; Promise.resolve(resourceLoader.get(url)) ).then(() =&gt; moduleFactory);} 核心代码在 R3NgModuleFactory 的创建部分packages\\core\\src\\render3\\ng_module_ref.ts 123456789101112131415161718192021222324252627constructor(ngModuleType: Type&lt;T&gt;, public _parent: Injector|null) { super(); const ngModuleDef = getNgModuleDef(ngModuleType); ngDevMode &amp;&amp; assertDefined( ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`); this._bootstrapComponents = maybeUnwrapFn(ngModuleDef!.bootstrap); this._r3Injector = createInjectorWithoutInjectorInstances( ngModuleType, _parent, [ {provide: viewEngine_NgModuleRef, useValue: this}, { provide: viewEngine_ComponentFactoryResolver, useValue: this.componentFactoryResolver } ], stringify(ngModuleType)) as R3Injector; // We need to resolve the injector types separately from the injector creation, because // the module might be trying to use this ref in its constructor for DI which will cause a // circular error that will eventually error out, because the injector isn't created yet. this._r3Injector._resolveInjectorDefTypes(); this.instance = this.get(ngModuleType);} 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 5. 参考文章深度解析@angular/platform-browser-dynamicangular 源码分析之 platformBrowserDynamicAngular Platforms in depth. Part 1","link":"/angular/angular_platformBrowserDynamic.html"},{"title":"Angular platform是什么?","text":"1. Angular platform 是什么?原文: Angular Platforms in depth. Part 1. What are Angular Platforms? 2. 前言在这一系列文章中，我将向你们揭示 Angular 应用程序如何跨不同环境执行。此外，我们还将学习如何构建自定义 Angular Platforms 使用 ASCII 图形呈现系统终端内的应用程序。 Angular 框架被设计成平台独立的。即允许在不同的环境中执行 Angular 应用程序 — 浏览器、服务器、web-worker，甚至移动设备。 3. 目录 Angular 是一个跨平台框架 什么是 Angular 平台 Angular 如何运行跨平台执行 4. Angular 是一个跨平台框架正如我之前所说，Angular 的设计充分考虑到了灵活性。这就是 Angular 是一个跨平台框架的原因，它不受浏览器的限制。Angular 唯一需要是作为 JavaScript 引擎执行。让我们看看最流行的 Angular 环境。 4.1. 浏览器(Browser)当我们使用 Angular 命令行工具 ng new MyNewApplication创建新的 Angular 应用程序时，它会将浏览器环境设置为应用程序的默认环境。 4.2. 服务器(Server)Angular 应用程序可以在服务器端编译和执行。在这种情况下，我们可以将 Angular 应用程序编译成静态 HTML 文件，然后将这些文件发送给客户端。这种方法允许我们加快应用程序的加载速度，同时确保应用程序将被所有搜索引擎正确索引。 4.3. Web worker此外，我们可以将 Angular 应用程序的一部分移动到单独的线程执行例如在 web worker 线程中执行。在这种情况下，我们只将应用程序的一小部分留在主线程，这一部分将允许 web worker 部分与 dom API 进行通信。这种方法允许您生成一个更平滑, 流畅的 UI，因为应用程序的大多数计算将与 UI 分开进行。 注意: Web worker 环境从一开始就是实验性的，从 8 开始就被弃用了。 4.4. NativeScript此外，还有很多第三方库，允许我们在不同的环境中执行 Angular 应用程序, 例如 NativeScript。NativeScript 使 Angular 能够在移动设备上执行，利用 Native 应用的所有功能。 但是，如何在不同的环境中执行 Angular 应用程序呢？ 5. 什么是 Angular 平台但是，如何在不同的环境中执行 Angular 应用程序呢？ 答案就是是平台(angular platforms) 为了弄清楚什么是角度平台，我们需要查看每个角度应用程序的入口点 — main.ts 文件: 123import { platformBrowserDynamic } from &quot;@angular/platform-browser-dynamic&quot;;platformBrowserDynamic().bootstrapModule(AppModule); 在这里，我们可以注意到两个重要部分： platformBrowserDynamic()函数返回了一个对象。 该对象被用于引导我们的应用程序。 如果我们稍微重写一下，我们会发现一个有趣的细节： 12345678import { platformBrowserDynamic } from &quot;@angular/platform-browser-dynamic&quot;;import { PlatformRef } from &quot;@angular/core&quot;;// Create Browser Platformconst platformRef: PlatformRef = platformBrowserDynamic();// Bootstrap ApplicationplatformRef.bootstrapModule(AppModule); platformBrowserDynamic 是一个工厂方法 — 用于创建新平台实例的函数。调用 platformBrowserDynamic 函数返回的结果是 PlatformRef。PlatformRef 是一个简单的 angular 服务，它知道如何引导我们的应用程序。为了更好地理解 PlatformRef 实例是如何创建的，让我们深入了解 platformBrowserDynamic 实现： 12345678910export const platformBrowserDynamic = createPlatformFactory( // Parent platform factory platformCoreDynamic, // New factory name &quot;browserDynamic&quot;, // Additional services INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS); 在这里，我们可以看到 platformBrowserDynamic 函数只是 createPlatformFactory 函数的结果，它接受以下参数： 父 platform factory 函数 — platformCoreDynamic 新平台的名称 — ‘browserDynamic’ 其他 providers — INTERNAL_BROWSER_DYNAMIC_PLAFORM_PROVIDERS， platformCoreDynamic 是一个父 platform factory 函数。我们可以将 platformCoreDynamic 和 platformBrowserDynamic 之间的关系视为继承。所以，createPlatformFactory 函数只是帮助我们从一个平台工厂继承另一个平台工厂。就这么简单。更有趣的部分发生在继承层次结构的更深处。事实上，platformCoreDynamic 继承了 platformCore，而 platformCore 没有父级。 下面是 platformBrowserDynamic 的完整层次结构： 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文章Angular Platforms in depth. Part 1. What are Angular Platforms?","link":"/angular/angular_platforms.html"},{"title":"Angular PWA","text":"前言这里假设我们已经使用Angular开发了SPA应用, 我们希望在此基础上使用PWA做一些增强以获得更好的用户体验, 更好的性能. 什么是Service worker安装 pwa进入Angular项目根目录, 执行以下命令安装@angular/pwa. 1ng add @angular/pwa@13.3.1 这里最好指定@angular/pwa的版本与当前使用的angular一致, 否则会有兼容性问题. 该命令完成以下操作 添加@angular/service-worker到工程 在CLI中启用service worker构建支持 在application模块中导入并注册service worker 更新index.html文件:包括一个添加manifest.webmanifest文件的链接为主题颜色添加meta tag 添加图标文件 创建名为ngsw-config.json的service worker配置文件，该文件指定缓存行为和其他设置。 添加@angular/service-worker到工程 12345678@@ -28,10 +28,11 @@ &quot;@angular/material&quot;: &quot;13.3.1&quot;, &quot;@angular/platform-browser&quot;: &quot;13.3.1&quot;, &quot;@angular/platform-browser-dynamic&quot;: &quot;13.3.1&quot;, &quot;@angular/platform-server&quot;: &quot;13.3.1&quot;, &quot;@angular/router&quot;: &quot;13.3.1&quot;,+ &quot;@angular/service-worker&quot;: &quot;13.3.1&quot;, &quot;@nguniversal/express-engine&quot;: &quot;^13.1.0&quot;, 在application模块中导入并注册service worker src/app/app.module.ts 1234567891011121314151617181920212223242526 import { UserService } from &quot;./services/user.service&quot;; import { SharedModule } from &quot;./shared/shared.module&quot;; import { CustomOverlayContainer } from &quot;./utils/custom-overlay-container&quot;; import { WindowService } from &quot;./services/window.service&quot;; import { FlexLayoutModule } from &quot;@angular/flex-layout&quot;;+import { ServiceWorkerModule } from '@angular/service-worker';+import { environment } from '../environments/environment'; const DEFAULT_PERFECT_SCROLLBAR_CONFIG: PerfectScrollbarConfigInterface = { wheelPropagation: true, suppressScrollX: true, };@@ -50,11 +52,17 @@ const DEFAULT_PERFECT_SCROLLBAR_CONFIG: PerfectScrollbarConfigInterface = { PerfectScrollbarModule,- AppRoutingModule,+ AppRoutingModule,+ ServiceWorkerModule.register('ngsw-worker.js', {+ enabled: environment.production,+ // Register the ServiceWorker as soon as the application is stable+ // or after 30 seconds (whichever comes first).+ registrationStrategy: 'registerWhenStable:30000'+ }) ], declarations: [ AppComponent, 创建名为ngsw-config.json的service worker配置文件, 更多配置说明请参考Angular Service Worker Configuration 123456789101112131415161718192021222324252627282930{ &quot;$schema&quot;: &quot;./node_modules/@angular/service-worker/config/schema.json&quot;, &quot;index&quot;: &quot;/index.html&quot;, &quot;assetGroups&quot;: [ { &quot;name&quot;: &quot;app&quot;, &quot;installMode&quot;: &quot;prefetch&quot;, &quot;resources&quot;: { &quot;files&quot;: [ &quot;/favicon.ico&quot;, &quot;/index.html&quot;, &quot;/manifest.webmanifest&quot;, &quot;/*.css&quot;, &quot;/*.js&quot; ] } }, { &quot;name&quot;: &quot;assets&quot;, &quot;installMode&quot;: &quot;lazy&quot;, &quot;updateMode&quot;: &quot;prefetch&quot;, &quot;resources&quot;: { &quot;files&quot;: [ &quot;/assets/**&quot;, &quot;/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)&quot; ] } } ]} 更新index.html文件包括一个添加manifest.webmanifest文件的链接为主题颜色添加meta tag 12345678 &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt; + &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;+ &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;+ &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt; &lt;/body&gt; 启动angular PWA配置完成之后重新构建我们的项目 npm run build 构建完成之后再通过 npm run start 来启动我们的项目，启动成功后打开 http://127.0.0.1:8080 应该能够看到 注意: 如果使用的是angular 14.2以下的版本, 会遇到”Angular 无法注册 ServiceWorker : A bad HTTP response code (404) was received when fetching the script”的问题, 这是因为npm run start实际调用的是ng serve, 而该命令启动应用, 对于生成的ngsw-worker.js文件访问不了,解决办法是使用http-server 启动应用, 进入dist/下, 如果开启了ssr进入dist//browser启动项目npx http-server path-to-your-dist-folder对于angular 14.2或以上的版本, 可以使用如下方式启动, 好处是您现在可以测试您的service worker并同时享受到热加载带来的好处。ng serve 参考文档Angular PWA 渐进式 Web 应用 Getting started with service workers How to Use Ng Serve with Service Worker","link":"/angular/angular_pwa.html"},{"title":"如何替换 Angular 的CanActivate接口","text":"在本文中，我们将探讨 Angular 的“CanActivate”接口的弃用，并讨论如何用推荐的解决方案替换它。我们将介绍官方文档的建议以及解决此已弃用警告的替代解决方案。 1. 问题升级 Angular 15 版本后，您遇到了 Angular 中“CanActivate”接口已弃用的警告。官方Angular 文档提到“CanActivate”和“CanActivateChild”已弃用，应替换为纯 JavaScript 函数。您可能正在寻求有关如何调整代码以解决此弃用警告的指导。 2. 解决方案根据 Angular 官方文档，推荐的解决方案是将“CanActivate”和“CanActivateChild”替换为纯 JavaScript 函数。以下是实施该解决方案的方法： 123456789101112131415161718192021222324import { inject } from &quot;@angular/core&quot;;import { ActivatedRouteSnapshot, CanActivateChildFn, Router, RouterStateSnapshot,} from &quot;@angular/router&quot;;import { AuthenticationService } from &quot;../services/authentication.service&quot;;export const loginCheckGuard: CanActivateFn = ( route: ActivatedRouteSnapshot, state: RouterStateSnapshot) =&gt; { const authService = inject(AuthenticationService); const router = inject(Router); return authService.checkLogin().pipe( map(() =&gt; true), catchError(() =&gt; { router.navigate([&quot;route-to-fallback-page&quot;]); return of(false); }) );}; 说明: 使用 1234567891011bootstrapApplication(App, { providers: [ provideRouter([ { path: &quot;team/:id&quot;, component: TeamComponent, canActivate: [loginCheckGuard], }, ]), ],}); 通过使用 Angular 中的函数，您可以将和 inject()的实例注入 JavaScript 函数中。这允许您访问函数上下文中必要的依赖项。AuthenticationServiceRouter 该 canActivate 函数使用 执行必要的身份验证检查 AuthenticationService，如果用户未通过身份验证，它将使用 重定向到后备页面 Router。 3. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 4. 结论总之，Angular 的“CanActivate”接口已弃用的警告可以通过用纯 JavaScript 函数替换来解决。通过使用该 inject()函数，您可以访问函数内必要的依赖项。正如官方 Angular 文档所建议的，推荐的方法提供了一个简单的解决方案来解决此弃用警告。 此外，及时了解最新的 Angular 文档和最佳实践也很重要，以确保顺利迁移并避免潜在问题。 5. 参考文档How to Replace Angular’s “CanActivate” Interface: A Comprehensive Guide - Angular Angular CanActivate","link":"/angular/angular_replace_CanActivate.html"},{"title":"Angular Sentry前端错误监控","text":"本教程主要讲述, Angular 项目如何整合 Sentry 实现前端应用错误上报. 1. 什么是 Sentrysentry 是一个基于 Django 构建的现代化的实时事件日志监控、记录和聚合平台,主要用于如何快速的发现故障。支持几乎所有主流开发语言和平台,并提供了现代化 UI,它专门用于监视错误和提取执行适当的事后操作所需的所有信息,而无需使用标准用户反馈循环的任何麻烦。官方提供了多个语言的 SDK.让开发者第一时间获悉错误信息,并方便的整合进自己和团队的工作流中.官方提供 saas 版本免费版支持每天 5000 个 event. sentry 支持自动收集和手动收集两种错误收集方法.我们能成功监控到 vue 中的错误、异常，但是还不能捕捉到异步操作、接口请求中的错误，比如接口返回 404、500 等信息，此时我们可以通过 Sentry.caputureException()进行主动上报。使用 sentry 需要结合两个部分，客户端与 sentry 服务端；客户端就像你需要去监听的对象，比如公司的前端项目，而服务端就是给你展示已搜集的错误信息，项目管理，组员等功能的一个服务平台。 这个平台可以自己搭建，也可以直接使用 sentry 提供的平台（注册可用），当然如果是公司项目，当然推荐自己搭建. 2. 什么是 DSN？DSN 是连接客户端(项目)与 sentry 服务端,让两者能够通信的钥匙；每当我们在 sentry 服务端创建一个新的项目，都会得到一个独一无二的 DSN，也就是密钥。在客户端初始化时会用到这个密钥，这样客户端报错，服务端就能抓到你对应项目的错误了。之前版本的 sentry 对于密钥分为公钥和私钥，一般前端用公钥(DSN(Public))，但是现在的版本舍弃了这种概念，只提供了一个密钥。 3. 什么是 event每当项目产生一个错误，sentry 服务端日志就会产生一个 event，记录此次报错的具体信息。一个错误，对应一个 event。 4. 什么是 issue同一类 event 的集合，一个错误可能会重复产生多次，sentry 服务端会将这些错误聚集在一起，那么这个集合就是一个 issue。 5. Angular 项目中使用 Sentry5.1. 注册 sentry,本文示例采用 Self-hosted 版关于搭建 Sentry 可以参考我的博客 - 如何在 Ubuntu 22.04 上用 Docker 安装 Sentry. 登录到 sentry 选择创建项目 Chose your platform 项目类型选择 Angular Set your alert frequency 根据实际情况选择 Name your project and assign it a team 给项目设置一个名称, 并分配给 team 创建成功后, 会弹出提示关于 Angular sentry SDK 的指引提示框, 如果不小心关闭了提示框, 里面的一些关机信息可以到 Settings=&gt;Projects 中找到. 5.2. 配置 Angular sentry SDK创建完项目后, 系统会会给出安装 Angular sentry SDK 的指引, 安装指引进行配置. 以下是参考配置指引列出的步骤, 本文只讲解针对 Angular 12 以上版本的配置方法, 对于低于 Angular 12 的 Angular 项目, 可以参考安装指引进行配置. 5.3. 安装依赖包1234567npm install --save @sentry/angular-ivy# 或者yarn add @sentry/angular-ivy 5.4. 配置 SDK在应用程序加载期间，在初始化 Angular 之前，您应该尽快在 main.ts 文件中初始化 Sentry 浏览器 SDK： 123456789101112131415161718192021222324252627282930import { enableProdMode } from &quot;@angular/core&quot;;import { platformBrowserDynamic } from &quot;@angular/platform-browser-dynamic&quot;;import * as Sentry from &quot;@sentry/angular-ivy&quot;;import { AppModule } from &quot;./app/app.module&quot;;Sentry.init({ dsn: &quot;your_dsn_get_from_sentry_project_configuration&quot;, integrations: [ new Sentry.BrowserTracing({ // Set 'tracePropagationTargets' to control for which URLs distributed tracing should be enabled tracePropagationTargets: [], routingInstrumentation: Sentry.routingInstrumentation, }), new Sentry.Replay(), ], // Performance Monitoring tracesSampleRate: 1.0, // Capture 100% of the transactions // Session Replay replaysSessionSampleRate: 0.01, // This sets the sample rate at 10%. You may want to change it to 100% while in development and then sample at a lower rate in production. replaysOnErrorSampleRate: 1.0, // If you're not already sampling the entire session, change the sample rate to 100% when sampling sessions where errors occur.});enableProdMode();platformBrowserDynamic() .bootstrapModule(AppModule) .then((success) =&gt; console.log('Bootstrap success')) .catch((err) =&gt; console.error(err)); Sentry Angular SDK 导出一个函数来实例化 ErrorHandler 提供程序，该提供程序将自动发送 Angular 错误处理程序捕获的 JavaScript 错误。 123456789101112131415161718192021222324252627import { APP_INITIALIZER, ErrorHandler, NgModule } from &quot;@angular/core&quot;;import { Router } from &quot;@angular/router&quot;;import * as Sentry from &quot;@sentry/angular-ivy&quot;;@NgModule({ // ... providers: [ { provide: ErrorHandler, useValue: Sentry.createErrorHandler({ showDialog: true, }), }, { provide: Sentry.TraceService, deps: [Router], }, { provide: APP_INITIALIZER, useFactory: () =&gt; () =&gt; {}, deps: [Sentry.TraceService], multi: true, }, ], // ...})export class AppModule {} 5.5. 上传 Source Maps自动上传 Source Maps 以启用可读的堆栈跟踪错误。如果您喜欢手动设置源地图，请遵循本指南。 最简单的办法是 12npm install -g @sentry/wizardsentry-wizard 6. 收集用户反馈除了自动上报异常, Sentry 也可以用来主动收集用户的意见和建议, 而不必另外开发一套反馈程序. 可视化部分可以借助 Sentry 的管理界面, 非常省事. 12345678910111213141516import * as Sentry from '@sentry/browser'sendUserFeedback() { // const eventId = Sentry.captureMessage('User Feedback') const userFeedback = { event_id: eventId, name: 'John Doe', email: 'john@doe.com', comments: 'I really like your App, thanks!', } Sentry.captureUserFeedback(userFeedback)} 实现 sendUserFeedback, 将其绑定在定制的反馈界面的提交按钮的点击事件上. 配置过程参考上面讲到的配置 SDK 7. Verify以下代码片段包含一个故意的错误，可以用作测试，以确保一切正常。 1myUndefinedFunction(); 8. trouble shootingissue 1: 首次开启访问遇到 CORS is not allowed 问题12345Access to XMLHttpRequest at 'http://localhost:8888' from origin 'http://localhost:4200' has been blocked by CORS policy: Request header field baggage is not allowed by Access-Control-Allow-Headers in preflight response.instrument.js:123 an error happened when posting to apiServer HttpErrorResponse {headers: HttpHeaders, status: 0, statusText: 'Unknown Error', url: 'http://localhost:8888', ok: false, …}error: ProgressEvent {isTrusted: true, lengthComputable: false, loaded: 0, total: 0, type: 'error', …}headers: HttpHeaders {normalizedNames: Map(0), lazyUpdate: null, headers: Map(0)}message: &quot;Http failure response for http://localhost:8888 0 Unknown Error&quot;name: &quot;HttpErrorResponse&quot;ok: falsestatus: 0statusText: &quot;Unknown Error&quot;url: &quot;http://api_server&quot;[[Prototype]]: HttpResponseBasezone.js:2645 分析 1: 原因是由于 tracePropagationTargets: [&quot;localhost&quot;, /^https:\\/\\/yourserver\\.io\\/api/] 配置了 localhost, sentry sdk 捕获到请求, 在请求头添加了 sentry-trace 和 baggage 两个字段, 此字段不被服务器端接受, 所以拒绝了. 解决办法有两种: 如果没有分布式跟踪错误请求的需要, 可以在 sentry 配置中将 tracePropagationTargets 设置为空数组tracePropagationTargets: [] 如果需要跟踪错误的请求, 需要在服务器端 Access-Control-Allow-Headers 配置中添加 sentry-trace, baggage 字段. 对于解决办法 1: 可以参考https://stackoverflow.com/questions/71804069/sentry-get-cors-error-in-localhost-by-vuejs3 对于解决方案 2: 可以参考https://docs.sentry.io/platforms/javascript/guides/nextjs/usage/distributed-tracing/dealing-with-cors-issues/ issue 2: 开启SSR（服务器端渲染）后在日志中看到很多这样的错误”ErrorEvent is not defined”。12345678910111213ReferenceError: ErrorEvent is not defined at extractHttpModuleError (node_modules/@sentry/angular-ivy/fesm2015/sentry-angular-ivy.js:101:32) at SentryErrorHandler._defaultExtractor (node_modules/@sentry/angular-ivy/fesm2015/sentry-angular-ivy.js:187:20) at SentryErrorHandler._extractError (node_modules/@sentry/angular-ivy/fesm2015/sentry-angular-ivy.js:178:21) at SentryErrorHandler.handleError (node_modules/@sentry/angular-ivy/fesm2015/sentry-angular-ivy.js:135:37) at Object.apply [as next] (node_modules/@angular/core/fesm2022/core.mjs:28159:42) at Object.next (node_modules/rxjs/dist/cjs/internal/Subscriber.js:161:21) at SafeSubscriber._next (node_modules/rxjs/dist/cjs/internal/Subscriber.js:101:26) at SafeSubscriber.next (node_modules/rxjs/dist/cjs/internal/Subscriber.js:72:18) at cb (node_modules/rxjs/dist/cjs/internal/Subject.js:66:34) at Object.errorContext (node_modules/rxjs/dist/cjs/internal/util/errorContext.js:22:9) 原因分析： 正如您所知，当使用angular universal (Angular 17以前)或者 Angular SSR(Angular 17以后)开启时，您的页面可能是在服务器端预先渲染的。在服务器端，您将无法访问一些常见的浏览器元素，如窗口或文档等等。Sentry正在访问一些“违禁”物品。所以你需要做一些额外的努力。首先创建一个可注入类，该类仅在浏览器中运行时初始化sentry。 解决办法： 思路，首先创建一个可注入类，该类仅在浏览器中运行时初始化sentry。 9. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 10. 参考文档Sentry Angular Sentry 介绍与使用 Setup sentry application monitoring in an angular universal project","link":"/angular/angular_sentry_integration.html"},{"title":"Angular SEO 友好的编码实践","text":"如果您正在使用 Angular 开发网站或应用程序，您很可能希望它在搜索引擎中排名靠前。正如您可能已经读到的，这会带来一些挑战。Angular 是一个著名的前端框架，广泛用于构建单页面应用程序，即 SPA。它们以其流畅、即时的页面转换和出色的用户体验而闻名。但也存在一些缺点，尤其是在 SEO 性能方面。 1. Angular SEO 挑战当使用 Angular 构建 SEO 友好的应用程序时，您会遇到一些挑战。这些挑战是由于（默认情况下）您正在使用 Angular 构建 SPA 应用程序这一事实而产生的。当您构建 SPA 应用程序时，它将生成一些 CSS 文件、JS 包和一个 HTML 页面(index.html)。在这个 HTML 页面上，我们几乎没有发现任何内容，只有一些用于加载 CSS 和 JS 文件的脚本。然后，浏览器将处理 JS 文件以呈现应用程序的页面。这对于某些目的来说非常有用，但如果来自搜索引擎和社交媒体网站的爬虫只收到一页和一些 JavaScript 代码，它们可能会在索引您的页面时遇到困难。 有一些好消息，Google 的爬虫在对 JavaScript 内容进行索引方面已经相当出色，但它仍然无法与对结构良好的 HTML 文件及其中包含的所有内容进行索引相比。 SPA 应用程序给 SEO 带来的另一个缺点是它们的初始页面加载速度很慢。使用 SPA 应用程序，您可以预先加载完整的 JavaScript 模块，然后无缝地浏览应用程序页面的其余部分。但加载此 JavaScript 模块比加载 HTML 页面花费更多时间，导致初始页面加载缓慢。在优化 SEO 时，初始页面加载是一个重要因素，因此在构建 SEO 友好的 Angular 应用程序时，这也是一个注意点。如果您对 SPA 应用程序犹豫不决，您可以尝试通过创建轻量级应用程序模块并在重定向后延迟加载所有其他模块来使初始包尽可能小。 2. Angular SEO 友好的编码实践现在您已经更好地了解了构建 SEO 友好的 Angular 应用程序时面临的问题，让我们看看如何解决这些问题！简要概述可以采取哪些措施来改进 Angular 应用程序的 SEO： Angular Universal 和服务器端渲染：通过使用 Angular Universal 和服务器端渲染，我们可以大幅提高 Angular 应用程序的 SEO 性能 预渲染 Angular 应用程序：预渲染 Angular 应用程序是改进 Angular 应用程序 SEO 的另一种好方法 动态添加标题和元标记：在每个 HTML 页面上添加标题和元标记是页面 SEO 的关键部分。使用 Angular 的 Meta 和 Title 服务，您可以动态添加这些标签，以便每个页面都有自己的标签 添加站点地图：站点地图是一个 XML 文件，其中列出了您网站的所有 URL。这有助于搜索引擎了解您网站的结构，并使其更轻松地为您的页面建立索引 Robots.txt：Robots.txt 是一个文件，告诉搜索引擎您网站的哪些页面或部分不应编制索引 3. 使用 SSR 改进 Angular SEO当您谈论 SEO 友好的 Angular 应用程序时，首先要考虑的事情之一就是呈现内容的方式。正如前面通过 SPA 应用程序所解释的，内容通过浏览器中的 JavaScript 代码呈现在单个 HTML 文档中。出于 SEO 目的，如果应用程序的每个页面都有一个完整呈现的 HTML 页面，其中页面的所有内容都在 HTML 文档中，那就更好了。这样我们就可以将此 HTML 页面而不是一些 javascript 代码发送到浏览器，从而使搜索引擎更容易对页面建立索引。这不仅可以让搜索引擎更轻松地为您的页面建立索引，而且还可以再次提高您的初始页面加载量，从而提高您的 SEO 性能。 3.1. 那么您问这一切是如何实现的呢？为了实现这一点，您需要启用服务器端渲染，这意味着您有一个服务器将侦听页面 URL 上的请求，当它收到请求时，服务器将在服务器上渲染 HTML 页面并将 HTML 页面发送到浏览器。如果这一切听起来非常复杂，别担心，Angular 已经帮您解决了！Angular 附带了一个名为 Angular Universal 的软件包，它是您构建 SEO 友好的 Angular 应用程序时最好的朋友。 借助 Angular Universal，您只需运行一个命令即可将应用程序转换为服务器端渲染的应用程序： 1ng add @nguniversal/express-engine 此命令将为您生成一个 express.js 服务器，并向您的 Angular 应用程序添加一些配置和 Node js 脚本，以便可以在服务器上呈现它。如果您想要有关 Angular Universal 和服务器端渲染的完整操作方法，您可以阅读这些文章： Angular universal 服务器端渲染与预渲染 ， 使用 Angular Universal 时的重要注意事项 使用 Angular Universal 启用 SSR 后，您的页面将在服务器上呈现，使您的页面易于搜索引擎索引，并且它将改善您的初始页面加载，为您带来另一个 SEO 提升。Angular Universal 的另一个很酷的事情是它为您提供了两全其美的优势。页面在服务器上呈现，但页面加载后，它会将网站交换为 SPA 应用程序，为您提供 SPA 的即时导航功能。 4. 通过预渲染改进 Angular SEO改善 Angular SEO 的另一种方法是预渲染页面。在前面的示例 (SSR) 中，每次请求页面时，页面都会在服务器上呈现。通过预渲染，您可以在构建过程中渲染 HTML 页面。这仅适用于静态内容，但可以进一步改善页面加载以及对呈现的 HTML 页面的控制。它还可以帮助降低您的托管成本，因为预渲染的应用程序可以作为静态网站托管，而 SSR 应用程序需要托管您的服务器。 预渲染 Angular 应用程序也可以使用 Angular Universal 来完成，或者另一种流行的替代方案是使用Scully预渲染 Angular 应用程序的库。如果您想了解有关 Angular Universal 预渲染的完整操作方法，您可以阅读这篇文章： Angular 静态站点生成 - 完整指南 5. 为 Angular SEO 添加元标签当您使用 Angular 构建网站并希望确保其针对搜索引擎进行优化时，最重要的事情之一就是正确使用元标记。无论您正在构建 SPA、SSR 或 SSG Angular 应用程序，正确的元标记对于页面 SEO 至关重要。 首先，什么是元标签？ 简而言之，元标记是向搜索引擎提供有关网页的信息的代码片段。它们被放置在 HTML 代码的头部，对网站访问者来说是不可见的。元标记的一些示例包括关键字元标记，它告诉搜索引擎页面的关键字，以及描述标记，它给出页面内容的简短摘要。页面的标题添加了一个 title 标签，与 meta 标签类似，这个标签也需要动态添加到每个页面。 元标记在搜索引擎如何理解和排名您的网站方面发挥着至关重要的作用。当搜索引擎抓取您的网站时，它们使用元标记中的信息来确定您的页面的内容以及它们与用户搜索查询的相关程度。如果您有编写良好的元标记，您的网站更有可能在搜索引擎结果中显示得更高，这意味着您的可见度和流量更高。 在组件的 HTML 模板中添加元标记不起作用。在所有页面之间共享的元标记可以添加到 Angular 项目根目录下的 index.html 中。共享元标记的一些示例可能是： 1234567891011&lt;metaname=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;metaname=&quot;google-site-verification&quot; content=&quot;some-verification-key&quot;&gt;&lt;metaname=&quot;robots&quot; content=&quot;index, follow&quot;&gt;&lt;metaproperty=&quot;og:image:width&quot; content=&quot;300&quot;&gt;&lt;metaproperty=&quot;og:image:height&quot; content=&quot;300&quot;&gt; 可以使用元和标题服务添加其他特定于页面的元标记和标题标记。首先让我们看看如何使用@angular/platform-b​​rowser 中的 Meta 服务将元标记添加到 Angular 应用程序的页面中： 123456789101112import { Component } from &quot;@angular/core&quot;;import { Meta } from &quot;@angular/platform-browser&quot;;@Component({ selector: &quot;app-root&quot;, template: `&lt;h1&gt;My Angular App&lt;/h1&gt;`,})export class AppComponent { constructor(private meta: Meta) { this.meta.addTag({ name: &quot;description&quot;, content: &quot;My page description&quot; }); }} 正如您在示例中看到的，您从母鸡导入服务，并在组件类的构造函数中使用依赖项注入来注入它。现在您可以使用该方法将元标记添加到 HTML 文档的头部。如果将 addTag 方法放在 ngOnInit 中，它将适用于 SPA 和 SSR，但不适用于预渲染应用程序，因此最好只在构造函数中声明它们。Meta @angular/platform-browsers; taddTag() 将标题标签添加到页面非常相似。您还可以从@angular/platform-b​​rowsers 导入 Title 服务，并再次使用依赖项注入来注入它，并在构造函数中使用它，如下所示： 123456789101112import { Component } from &quot;@angular/core&quot;;import { Title } from &quot;@angular/platform-browser&quot;;@Component({ selector: &quot;app-root&quot;, template: `&lt;h1&gt;My Angular App&lt;/h1&gt;`,})export class AppComponent { constructor(private titleService: Title) { this.titleService.setTitle(&quot;Angular Tutorials&quot;); }} 以下是一些有用的元标记的列表，可以添加这些元标记以实现更好的 SEO 和社交媒体索引和可共享性。 12345678910111213141516171819&lt;meta name=&quot;twitter:description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;twitter:title&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;twitter:image&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;og:type&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;og:description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;og:title&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;og:image:secure_url&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;og:image&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; 6. 添加用于 SEO 的 sitemap.xml 和 robots.txt您已经快完成了，只需进行一些最后的润色即可改进您的 Angular SEO。我们在这篇博文中要做的最后一件事是添加 robots.txt 和 sitemap.xml。Robots.txt 是一个文件，它告诉搜索引擎您网站的哪些页面或部分不应编制索引。站点地图是一个 XML 文件，其中列出了您网站的所有 URL。这有助于搜索引擎了解您网站的结构，并使其更轻松地为您的页面建立索引。 这两个文件都可以添加到 Angular 项目的 src 中。 123456789User-agent: GooglebotDisallow: /nogooglebot/User-agent: *Allow: /Sitemap: https://example.com/sitemap.xml 站点地图的内容应如下所示： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt; &lt;url&gt; &lt;loc&gt;https://www.example.com&lt;/loc&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;https://www.example.com/folder1/test1&lt;/loc&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;https://www.example.com/folder2/test2&lt;/loc&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;https://www.example.com/folder3/test3&lt;/loc&gt; &lt;/url&gt;&lt;/urlset&gt; 7. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 8. 总结您的 Angular 应用程序可能不会从一开始就进行 SEO 优化，但通过 Angular Universal 以及元和标题服务，您可以制作 SEO 友好的 Angular 应用程序！无需太多努力，您就可以将 Angular 应用程序转换为服务器端渲染或预渲染的应用程序，其中包含 HTML 页面供搜索引擎索引。通过元标题服务，您可以向页面添加动态元和标题标签，以便搜索引擎可以轻松为您的页面建立索引。 9. 参考文档Angular SEO friendly coding practices","link":"/angular/angular_seo_friendly.html"},{"title":"Angular service worker介绍","text":"1. 前言Service Worker 增强了传统的 Web 部署模型，并使应用程序能够提供与 Native application 相当的可靠性,性能和用户体验。将服务工作进程添加到 Angular 应用程序是将应用程序转换为渐进式 Web 应用程序（也称为 PWA）的步骤之一。 简单来说，Service worker 是在 Web 浏览器中运行并管理应用程序缓存的脚本。 Service worker 充当网络代理。它们拦截应用程序发出的所有 HTTP 请求，并可以选择如何响应这些请求。例如，他们可以查询本地缓存并提供缓存的响应（如果有）。代理不仅限于通过编程 API 发出的请求，例如 fetch;它还包括 HTML 中引用的资源，甚至是对 index.html 的初始请求。因此，基于 Service worker 的缓存是完全可编程的，不依赖于服务器指定的缓存标头。 与组成应用程序的其他脚本（如 Angular application bundle）不同，服务工作进程在用户关闭选项卡后仍然保留。下次浏览器加载应用程序时，Service worker 首先加载，并且可以截获每个资源请求以加载应用程序。如果服务工作进程被设计为这样做，它可以完全满足应用程序的加载，而无需网络。 即使在快速可靠的网络中，往返延迟也会在加载应用程序时引入明显的延迟。使用服务工作进程来减少对网络的依赖可以显著改善用户体验。 2. Angular Service workerAngular 应用程序作为单页应用程序，也是 Service worker 的这项技术的主要受益者。从版本 5.0.0 开始，Angular 附带了一个 Service worker 实现。Angular 开发人员可以利用此 Service worker，并从它提供的更高的可靠性和性能中受益，而无需针对低级 API 进行编码。 Angular Service worker 旨在优化应用程序在慢速或不可靠网络条件下的最终用户体验，同时最大限度地降低由于缓存导致的过时内容的风险。 为了实现这一点，Angular 服务工作者遵循以下准则： 缓存应用程序类似于本地安装的应用程序。应用程序作为一个整体进行缓存，所有文件一起更新。 正在运行的应用程序将继续使用所有文件的相同版本运行。它不会突然开始从较新版本接收缓存文件，避免可能的不兼容性。 当用户刷新应用程序时，他们会看到完整的最新的版本。 更新在后台进行。在安装并准备好更新之前，将提供应用程序的先前版本。 Service worker 尽可能节省带宽。仅当资源发生更改时，才会下载资源。 为了支持这些行为，Angular Service worker 从服务器加载一个清单文件。该文件名为 ngsw.json（不要与 web 应用程序清单混淆），描述了要缓存的资源，并包括每个文件内容的哈希。当部署应用程序的更新时，清单的内容会发生变化，通知服务工作者应该下载并缓存应用程序的新版本。此清单是从 CLI 生成的名为 ngsw-config.json 的配置文件生成的。安装 Angular Service worker 非常简单。除了在浏览器中注册 Angular Service worker 外，还可以注入一些额外的服务，这些服务可与 Service worker 进行交互并控制 Service worker。例如，应用程序可以要求在新的更新可用时得到通知，或者应用程序可以请求服务工作程序检查服务器是否有可用的更新。 3. 使用 Service worker 的前提条件要利用 Angular 服务工作者的所有功能，请使用最新版本的 Angular 和 Angular CLI。 对于要注册的 Service worker，必须通过 HTTPS 而不是 HTTP 访问应用程序。浏览器会忽略通过不安全连接提供服务的页面上的服务工作进程。原因是 Service worker 非常强大，因此需要格外小心以确保服务工作进程脚本未被篡改。 此规则有一个例外：为了使本地开发更加简单，浏览器在访问 localhost 上的应用程序时不需要安全连接。 4. 关于浏览器支持要使用 Angular Service worker，您的应用程序必须在支持 Service worker 的 Web 浏览器中运行。目前，Service worker 在最新版本的 Chrome、Firefox、Edge、Safari、Opera、UC 浏览器（Android 版本）和 Samsung Internet 中得到支持。像 IE 和 Opera Mini 这样的浏览器不支持 Service worker。 如果用户使用不支持 Service worker 的浏览器访问您的应用程序，则不会注册服 Service worker，也不会发生离线缓存管理和推送通知等相关行为。具体来说： 浏览器不会下载服务工作者脚本和 ngsw.json 配置文件。 与 Service worker 进行交互的主动尝试（例如调用 SwUpdate.checkForUpdate()）会返回拒绝的 Promise。 相关服务的 observable 事件（例如 SwUpdate.available）不会被触发。 强烈建议您确保应用程序即使在浏览器不支持 Service worker 的情况下也能正常工作。尽管不支持 Service worker 缓存，但如果应用程序尝试与 Service worker 交互，它仍会报告错误。例如，调用 SwUpdate.checkForUpdate() 会返回拒绝的 Promise。为避免此类错误，请使用 SwUpdate.isEnabled 检查是否启用了 Angular Service worker。 要了解其他支持 Service worker 的浏览器，请参阅 Can I Use 和 MDN 文档。 5. 相关资源本节的其余文章专门介绍了 Service worker 的 Angular 实现。 App ShellService Worker CommunicationService Worker NotificationsService Worker in ProductionService Worker Configuration 有关 Service Worker 的详细信息，请参阅Service Workers: an Introduction。 有关浏览器支持的详细信息，请参阅 Service Workers：an Introduction的浏览器支持部分、Jake Archibald 的 Service worker 准备好了吗？和 Can I use。 有关其他建议和示例，请参阅： 使用 Angular Service Worker 进行预缓存使用 Angular CLI 创建 PWA 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Angular service worker introduction","link":"/angular/angular_service_worker_introduction.html"},{"title":"Angular如何配置多套环境","text":"1. 前言在 Angular 应用程序中，默认情况下构建了两个环境文件 dev 和 prod。基于目标环境，您的应用程序可能具有不同的设置。您可以根据需要配置多个自定义环境。在这里，您将看到如何配置多个环境，如 staging、beta、QA、prod 等 2. 创建不同的环境文件我们需要根据需要创建多个环境文件。这里我创建了两个文件： environment.stagging.ts environment.beta.ts 您可以使用 environment.prod.ts file 复制、粘贴和重命名（例如：environment.staging.ts），并根据需要设置环境变量值。 3. 修改 angular.json 文件123456789101112131415161718192021222324252627282930313233343536373839&quot;projectName&quot;: { ... &quot;architect&quot;: { &quot;build&quot;: { ... &quot;configurations&quot;: { &quot;production&quot;: { &quot;fileReplacements&quot;: [ { &quot;replace&quot;: &quot;src/environments/environment.ts&quot;, &quot;with&quot;: &quot;src/environments/environment.prod.ts&quot; } ] }, &quot;stagging&quot;: { &quot;fileReplacements&quot;: [ { &quot;replace&quot;: &quot;src/environments/environment.ts&quot;, &quot;with&quot;: &quot;src/environments/environment.stagging.ts&quot; } ], ... }, &quot;beta&quot;: { &quot;fileReplacements&quot;: [ { &quot;replace&quot;: &quot;src/environments/environment.ts&quot;, &quot;with&quot;: &quot;src/environments/environment.beta.ts&quot; } ], ... } } ... } ... } ...} 修改 serve 配置, 以支持多环境 1234567891011&quot;configurations&quot;: { &quot;production&quot;: { &quot;browserTarget&quot;: &quot;projectName:build:production&quot; }, &quot;stagging&quot;: { &quot;browserTarget&quot;: &quot;projectName:build:stagging&quot; }, &quot;beta&quot;: { &quot;browserTarget&quot;: &quot;projectName:build:beta&quot; }} 修改 e2e 配置, 以支持多环境 123456789&quot;production&quot;: { &quot;devServerTarget&quot;: &quot;projectName:serve:production&quot;},&quot;stagging&quot;: { &quot;devServerTarget&quot;: &quot;projectName:serve:stagging&quot;},&quot;beta&quot;: { &quot;devServerTarget&quot;: &quot;projectName:serve:beta&quot;} 4. 启动新环境123456ng serveng serve –configuration=staggingng serve –configuration=betang serve –prod 5. 编译新环境123456ng buildng build –configuration=staggingng build –configuration=betang build –prod 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 总结在本篇文章中我们讲了如何配置新环境, 以及如何编译运行新环境. 希望对你有帮助! 8. 參考文檔How To Configure Multiple Environments In Angular","link":"/angular/angular_setup_multiple_envs.html"},{"title":"Angular独立组件介绍","text":"Angular 14 引入了独立组件——该组件不属于任何 ngModule 的一部分，可以与其他独立或基于模块的组件一起使用。 从 Angular 14 开始，您可以创建整个应用程序，而无需制作任何自定义 Angular 模块，这可以通过使用独立组件来实现，这些组件提供了创建 Angular 应用程序的简化方法。 12345678910111213@Compnent( { selector: 'app-inventory', standalone: true, imports: [CommonModule], templateUrl: './inventory.component.html', styleUrls: ['./inventory.component.html'] })export class InventoryComponent implements OnInit, OnChanges { 1. 什么是独立组件独立组件是一种不属于任何 Angular 模块的组件。在 Angular 14 之前，通常当您创建组件时，您会将其传递到模块的声明数组中。如果你不这样做，Angular 就会报错并且无法编译。但是从 Angular 14 开始，您可以创建一个不属于任何 ngModule 的组件，该组件称为独立组件。 除了独立组件之外，在 Angular 14 中，您还可以创建： 独立指令 独立管道 您联合独立组件与以下组件一起使用： 基于模块的组件 其他独立组件 加载路由 延迟加载 独立管道如下所示： 1234567891011import { Pipe, PipeTransform } from &quot;@angular/core&quot;;@Pipe({ name: &quot;search&quot;, standalone: true,})export class SearchPipe implements PipeTransform { transform(value: unknown, ...args: unknown[]): unknown { return null; }} 2. 创建独立组件您可以使用ng generated component --standalone 命令中的标志创建独立组件、管道或指令： 12345ng g p search --standaloneng g d credit-card --standaloneng g c login --standalone 独立组件能否使 Angular 14 成为 Angular 历史上最大的升级？Alyssa Nicoll 认为是这样的. 成功运行上述最后一个命令后，您可以找到添加到应用程序中的登录组件，如下所示。在这里您会注意到组件装饰器的 standalone 属性为 true。 123456789101112131415import { Component, OnInit } from &quot;@angular/core&quot;;import { CommonModule } from &quot;@angular/common&quot;;@Component({ selector: &quot;app-login&quot;, standalone: true, imports: [CommonModule], templateUrl: &quot;./login.component.html&quot;, styleUrls: [&quot;./login.component.css&quot;],})export class LoginComponent implements OnInit { constructor() {} ngOnInit(): void {}} 独立组件、指令或管道不需要成为任何 ngModule 的一部分。如果您错误地尝试向模块添加独立组件，Angular 会抛出如下所示的错误. 123Component LoginComponent is standalone, and cannot be declaredin an NgModule. Did you mean to import it instead? (-996008)LoginComponent 您还可以通过将现有组件的 standalone 属性设置为 true, 将其转换为独立组件。将基于模块的组件转换为独立组件时，必须牢记以下三点： 将独立属性设置为 true。 将其从其所属模块的声明数组中删除。 使用导入数组添加依赖项。 3. 独立组件中的依赖关系独立组件可能依赖于其他成员、管道和指令。这些依赖可以分为两部分： 其他独立组件 其他模块中的组件 两种类型的依赖项都可以使用 imports 装饰器数组添加到独立组件中@Component。例如，ReactiveFormsModule 可以通过 imports 添加到 LoginComponent，如下所示 12345678@Component({ selector: 'app-login', standalone: true, imports: [CommonModule, ReactiveFormsModule, UserComponent], templateUrl: './login.component.html', styleUrls: ['./login.component.css']})export class LoginComponent implements OnInit { 说明 UserComponent 是一个独立组件 4. 使用独立组件您可以通过以下两种方式之一使用独立组件、指令或管道： 在另一个独立组件内 模块内部 要在属于 AppModule 一部分的 AppComponent 中使用它，您可以将其传递给导入数组，如下所示： 1234567@NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, LoginComponent], providers: [], bootstrap: [AppComponent],})export class AppModule {} 现在您可以在 AppComponent 上使用它，如下所示： 123&lt;h1&gt;App&lt;/h1&gt;&lt;app-login&gt;&lt;/app-login&gt; 可以通过将独立组件传递给 imports 属性来在另一个独立组件中使用该独立组件，如下所示： 12345678@Component({ selector: 'app-product', standalone: true, imports: [CommonModule, LoginComponent], templateUrl: './product.component.html', styleUrls: ['./product.component.css']})export class ProductComponent implements OnInit { 5. 独立组件引导应用程序Angular 14 允许您使用独立组件引导整个应用程序。要使用独立组件引导应用程序，请按照以下步骤操作。 在 main.ts 中，导入要引导的独立组件并 bootstrapapplication 运行，如下所示： 12import { bootstrapApplication } from &quot;@angular/platform-browser&quot;;import { ProductComponent } from &quot;./app/product/product.component&quot;; 之后，调用 bootstrapapplication 并传递其中的组件，如下所示： 123bootstrapApplication(ProductComponent, { providers: [],}); 接下来，在 index.html 上，替换 app-root 为您的组件。 1234&lt;body&gt; &lt;!-- &lt;app-root&gt;&lt;/app-root&gt; --&gt; &lt;app-product&gt;&lt;/app-product&gt;&lt;/body&gt; 现在，当您运行应用程序时，应用程序应该从 ProductComponent 引导 6. 使用独立组件进行路由企业级应用程序必须具有各种路由，以便用户可以通过更改 URL 来导航不同的组件。因此，为了支持此功能，还可以使用独立组件来创建路由并进行延迟加载。 可以使用独立组件创建路由。 在创建类似模块的路由时，独立组件也可以延迟加载。 子路由也可以与所有路由组件一起作为独立的延迟加载。 单独的注入器可以传递到独立的组件路由。 假设您已使用独立的 AppComponent 引导应用程序并将其添加&lt;router-outlet&gt;&lt;/router-outlet&gt;到模板中，以便可以在此处加载不同的路由。 123456789101112131415161718import { CommonModule } from &quot;@angular/common&quot;;import { Component } from &quot;@angular/core&quot;;import { RouterModule } from &quot;@angular/router&quot;;const template = `&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;`;@Component({ selector: &quot;app-root&quot;, standalone: true, imports: [CommonModule, RouterModule], template: template, styleUrls: [&quot;./app.component.css&quot;],})export class AppComponent { title = &quot;Stand alone component App&quot;;} 7. 添加路由现在，要创建路由，请添加一个文件并根据需要命名。我给它起了名字 app-routing.ts。在此文件中，配置导航到 Home 组件的路由，如下所示： 1234567891011121314import { Routes } from &quot;@angular/router&quot;;import { HomeComponent } from &quot;./home/home.component&quot;;export const APP_ROUTES: Routes = [ { path: &quot;&quot;, pathMatch: &quot;full&quot;, redirectTo: &quot;home&quot;, }, { path: &quot;home&quot;, component: HomeComponent, },]; 添加路由后，使用独立的 AppComponent 引导应用程序。为此，在 main.ts 中，导入 AppComponent、RouterModule、App_Routes 和 bootstrapapplication 函数，如下所示 123456import { enableProdMode, importProvidersFrom, inject } from &quot;@angular/core&quot;;import { bootstrapApplication } from &quot;@angular/platform-browser&quot;;import { environment } from &quot;./environments/environment&quot;;import { AppComponent } from &quot;./app/app.component&quot;;import { RouterModule } from &quot;@angular/router&quot;;import { APP_ROUTES } from &quot;./app/app-routing&quot;; 之后，调用 bootstrapapplication 并传递其中的组件，如下所示： 123bootstrapApplication(AppComponent, { providers: [importProvidersFrom(RouterModule.forRoot(APP_ROUTES))],}); 独立组件引导操作可能有许多依赖项，必须在 providers 数组中显式传递这些依赖项。其中一些依赖项可能是 ngModules 的一部分，因此可能需要该模块来配置依赖项注入。 此类示例之一是 RouterModule.forRoot()设置应用程序路由的依赖关系。为了进行设置，Angular 提供了一个实用程序 importProvidersFrom。这里该实用程序用于注入应用程序路由器依赖项： 123bootstrapApplication(AppComponent, { providers: [importProvidersFrom(RouterModule.forRoot(APP_ROUTES))],}); 运行应用程序时，您应该导航主路径并进行 HomeComponent 加载 到目前为止，您已经成功： 使用独立组件引导应用程序配置并添加路由 8. 延迟加载独立组件与模块一样，独立组件也可以延迟加载。loadComponent 您可以通过使用该语句并传递组件文件名来延迟加载路由中的独立组件。 1234567{ path: 'product', loadComponent: () =&gt; import('./product/product.component') .then(m =&gt; m.ProductComponent) } 您可以通过修改应用程序路由来添加带有延迟加载组件的产品路由： 1234567891011121314151617181920export const APP_ROUTES: Routes = [ { path: &quot;&quot;, pathMatch: &quot;full&quot;, redirectTo: &quot;home&quot;, }, { path: &quot;home&quot;, component: HomeComponent, }, { path: &quot;product&quot;, loadComponent: () =&gt; import(&quot;./product/product.component&quot;).then((m) =&gt; m.ProductComponent), }, { path: &quot;**&quot;, component: PagenotfoundComponent, },]; 如您所见，添加了一个新的路由产品，并且它正在使用 loadComponent()带有 import 语句的函数。 运行应用程序时，您会发现 ProductComponent 在导航产品路线时会延迟加载 9. 延迟加载多个子路由Angular 14 还延迟加载具有多个独立组件的子路由。 在路由文件中使用独立组件配置子路由，如下所示 12345678910export const ADMIN_ROUTES: Route[] = [ { path: &quot;&quot;, pathMatch: &quot;full&quot;, redirectTo: &quot;home&quot;, }, { path: &quot;home&quot;, component: AdminhomeComponent }, { path: &quot;users&quot;, component: AdminduserComponent }, { path: &quot;dashboard&quot;, component: AdmindashboardComponent },]; 当所有路由组件都是独立的时，您可以使用 loadChildren 带有 import 的方法来延迟加载子路由。这里上面的路由配置放在 admin.route 文件中。 1234{ path: 'admin', loadChildren: () =&gt; import('./admin/admin.route') .then(mod =&gt; mod.ADMIN_ROUTES) } 将所有内容与延迟加载的组件和子路由放在一起，应用程序路由应如下所示： 12345678910111213141516171819202122232425export const APP_ROUTES: Routes = [ { path: &quot;&quot;, pathMatch: &quot;full&quot;, redirectTo: &quot;home&quot;, }, { path: &quot;home&quot;, component: HomeComponent, }, { path: &quot;product&quot;, loadComponent: () =&gt; import(&quot;./product/product.component&quot;).then((m) =&gt; m.ProductComponent), }, { path: &quot;admin&quot;, loadChildren: () =&gt; import(&quot;./admin/admin.route&quot;).then((mod) =&gt; mod.ADMIN_ROUTES), }, { path: &quot;**&quot;, component: PagenotfoundComponent, },]; 运行应用程序时，您会发现导航管理路由时会延迟加载管理子路由。 10. 配置依赖注入在使用独立组件引导应用程序时，您还可以注入应用程序的依赖项，如下所示： 1234567bootstrapApplication(AppComponent, { providers: [ { provide: AppService, useClass: AppService }, { provide: BACKEND_URL, useValue: &quot;abc.com&quot; }, importProvidersFrom(RouterModule.forRoot(APP_ROUTES)), ],}); 11. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 12. 总结因此，如您所见，使用独立组件非常简单。如果您要创建新的 Angular 项目，请从 Angular 14 开始，并尝试使用独立组件引导应用程序。 13. 参考文章A guide to Standalone Components in Angular","link":"/angular/angular_standalone_components.html"},{"title":"Angular 样式隔离","text":"本文详细讲解如何在 Angular 使用样式隔离。 在讲解 Angular 样式隔离之前，我们先整体了解一下为什么要有 CSS 样式隔离，已经有哪些样式隔离方案。 1. 原生 CSS 的一些问题1.1. 无作用域样式污染CSS 有一个被大家诟病的问题就是没有本地作用域，所有声明的样式都是全局的（global styles） 换句话来说页面上任意元素只要匹配上某个选择器的规则，这个规则就会被应用上，而且规则和规则之间可以层叠（cascading） SPA 应用流行了之后这个问题变得更加突出了，因为对于 SPA 应用来说所有页面的样式代码都会加载到同一个环境中，样式冲突的概率会大大加大。由于这个问题的存在，我们在日常开发中会遇到以下这些问题： 很难为选择器起名字 为了避免和页面上其他元素的样式发生冲突，我们在起选择器名的时候一定要深思熟虑，起的名字一定不能太普通。举个例子，假如你为页面上某个作为标题的 DOM 节点定义一个叫做.title 的样式名，这个类名很大概率已经或者将会和页面上的其他选择器发生冲突，所以你不得不手动为这个类名添加一些前缀，例如.home-page-title 来避免这个问题 团队多人合作困难 当多个人一起开发同一个项目的时候，特别是多个分支同时开发的时候，大家各自取的选择器名字可能有会冲突，可是在本地独立开发的时候这个问题几乎发现不了。当大家的代码合并到同一个分支的时候，一些样式的问题就会随之出现 1.2. 无用的 CSS 样式堆积进行过大型 Web 项目开发的同学应该都有经历过这个情景：在开发新的功能或者进行代码重构的时候，由于 HTML 代码和 CSS 样式之间没有显式的一一对应关系，我们很难辨认出项目中哪些 CSS 样式代码是有用的哪些是无用的，这就导致了我们不敢轻易删除代码中可能是无用的样式。这样随着时间的推移，项目中的 CSS 样式只会增加而不会减少(append-only stylesheets）。无用的样式代码堆积会导致以下这些问题： 项目变得越来越重量级：加载到浏览器的 CSS 样式会越来越多，会造成一定的性能影响 开发成本越来越高：开发者发现他们很难理解项目中的样式代码，甚至可能被大量的样式代码吓到，这就导致了开发效率的降低以及一些奇奇怪怪的样式问题的出现 1.3. 基于状态的样式定义对于 SPA 应用来说，特别是一些交互复杂的页面，页面的样式通常要根据组件的状态变化而发生变化 最常用的方式是通过不同的状态定义不同的 className 名，这种方案代码看起来十分冗余和繁琐，通常需要同时改动 js 代码和 css 代码 “这个 CSS 重写一遍比修改老文件快”，这样的念头几乎所有人都曾有过，css 虽然看似简单，但是以上问题很容易写着写着就出现了，这在于提前没有选好方案 2. CSS 样式隔离方案解决以上 CSS 样式问题的思路就 CSS 隔离，让页面和页面之间， 组件与组件之间的 CSS 样式相互独立。于是诞生了以下几种解决方案。 BEM CSS Modules CSS in JS 预处理器 Shadow DOM 2.1. BEM是由 Yandex 团队提出的一种 CSS Class 命名方法，详情可以参考BEM: A New Front-End Methodology。 BEM 通过 css 选择器命名规范来避免 CSS 样式之间发生冲突，从而实现样式与样式之间互相隔离，BEM 的意思是块（Block）、元素（Element）、修饰符（Modifier）的简写 这种命名方法让 CSS 便于统一团队开发规范和方便维护以 .blockelement–modifier 或者说 block-nameelement-name–modifier-name 形式命名，命名有含义，也就是模块名 + 元素名 + 修饰器名如.dropdown-menu__item–active 社区里面对 BEM 命名的褒贬不一，但是对其的思想基本上还是认同的，所以可以用它的思想，不一定要用它的命名方式 BEM 思想通常用于组件库，业务代码中结合 Sass, less 等预处理器 2.1.1. BEM 优缺点分析优点： 人为严格遵守 BEM 规范，可以解决无作用域样式污染问题可读性好，一目了然是那个 dom 节点，对于无用 css 删除，删除了相应 dom 节点后，对应的 css 也能比较放心的删除，不会影响到其他元素样式 缺点 BEM 命名其最大的争议就是其命名风格，命名太长（个人开发习惯、部分人会觉得，我认为命名长提高了可读性，能解决一些问题，也不叫缺点），至于体积增大，gzip 可忽略 2.2. CSS Modules什么是 CSS Modules？ 顾名思义，css-modules 将 css 代码模块化，可以避免本模块样式被污染，并且可以很方便的复用 css 代码 根据 CSS Modules 在Gihub 上的项目，CSS Modules 解释为： A CSS Module is a CSS file in which all class names and animation names are scoped locally by default. All URLs (url(…)) and @imports are in module request format (./xxx and ../xxx means relative, xxx and xxx/yyy means in modules folder, i. e. in node_modules). CSS Modules 既不是官方标准，也不是浏览器的特性，而是在构建步骤（例如使用 Webpack，记住 css-loader）中对 CSS 类名和选择器限定作用域的一种方式（类似于命名空间） 依赖 webpack css-loader，配置如下，现在 webpack 已经默认开启 CSS modules 功能了 123456{ test: /.css$/, loader: &quot;style-loader!css-loader?modules&quot;} 我们先看一个示例： 将 CSS 文件 style.css 引入为 style 对象后，通过 style.title 的方式使用 title class： 1234567891011import style from './style.css';export default () =&gt; { return ( &lt;p className={style.title}&gt; I am KaSong. &lt;/p&gt; );}; 对应 style.css： 123.title { color: red;} 打包工具会将 style.title 编译为带哈希的字符串 1&lt;h1 class=&quot;_3zyde4l1yATCOkgn-DBWEL&quot;&gt;Hello World&lt;/h1&gt; 同时 style.css 也会编译： ._3zyde4l1yATCOkgn-DBWEL {color: red;} 这样，就产生了独一无二的 class，解决了 CSS 模块化的问题 使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 :local，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 :global。 :local 与 :global 的区别是 CSS Modules 只会对 :local 块的 class 样式做 localIdentName 规则处理，:global 的样式编译后不变 1234567.title { color: red;}:global(.title) { color: green;} 可以看到，依旧使用 CSS，但使用 JS 来管理样式依赖， 最大化地结合现有 CSS 生态和 JS 模块化能力，发布时依旧编译出单独的 JS 和 CSS 2.2.1. CSS Modules 的优缺点分析优点 能 100%解决 css 无作用域样式污染问题 学习成本低：API 简洁到几乎零学习成本 缺点 代码可读性差，hash 值不方便 debug，不利于问题排查。 写法没有传统开发流程有很大差异，需要频繁引入 style.css 等样式文件。 没有变量，通常要结合预处理器。 如果你不想频繁的输入 styles.，可以试一下 [react-css-modules](gajus/react-css-modules · GitHub)，它通过高阶函数的形式来避免重复输入 styles.css modules 通常结合 less 等预处理器在 react 中使用，更多可参考CSS Modules 详解及 React 中实践 2.3. CSS in JSCSS in JS 是 2014 年推出的一种设计模式，它的核心思想是把 CSS 直接写到各自组件中，也就是说用 JS 去写 CSS，而不是单独的样式文件里。 这跟传统的前端开发思维不一样，传统的原则是关注点分离，如常说的不写行内样式、不写行内脚本，如下代码 1&lt;h1 style=&quot;color:red;font-size:46px;&quot; onclick=&quot;alert('Hi')&quot;&gt;Hello World&lt;/h1&gt; CSS-in-JS 不是一种很新的技术，可是它在国内普及度好像并不是很高，它当初的出现是因为一些 component-based 的 Web 框架（例如 React，Vue 和 Angular）的逐渐流行，使得开发者也想将组件的 CSS 样式也一块封装到组件中去以解决原生 CSS 写法的一系列问题 CSS-in-JS 在 React 社区的热度是最高的，这是因为 React 本身不会管用户怎么去为组件定义样式的问题，而 Vue 和 Angular 都有属于框架自己的一套定义样式的方案 上面的例子使用 React 改写如下 12345678910111213const style = { color: &quot;red&quot;, fontSize: &quot;46px&quot;,};const clickHandler = () =&gt; alert(&quot;hi&quot;);ReactDOM.render( &lt;h1 style={style} onclick={clickHandler}&gt; Hello, world! &lt;/h1&gt;, document.getElementById(&quot;example&quot;)); 上面代码在一个文件里面，封装了结构、样式和逻辑，完全违背了”关注点分离”的原则。但是，这有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着 React 的走红和组件模式深入人心，这种”关注点混合”的新写法逐渐开始流行。 实现了 CSS-in-JS 的库有很多，据统计现在已经超过了 61 种。 从实现方法上区分大体分为两种： 唯一 CSS 选择器，代表库：styled-components内联样式（Unique Selector VS Inline Styles） 2.3.1. CSS-in-JS 优缺点分析优点 没有无作用域问题样式污染问题 通过唯一 CSS 选择器或者行内样式解决 没有无用的 CSS 样式堆积问题 CSS-in-JS 会把样式和组件绑定在一起，当这个组件要被删除掉的时候，直接把这些代码删除掉就好了，不用担心删掉的样式代码会对项目的其他组件样式产生影响。 而且由于 CSS 是写在 JavaScript 里面的，我们还可以利用 JS 显式的变量定义，模块引用等语言特性来追踪样式的使用情况，这大大方便了我们对样式代码的更改或者重构 更好的基于状态的样式定义 CSS-in-JS 会直接将 CSS 样式写在 JS 文件里面，所以样式复用以及逻辑判断都十分方便 缺点： 一定的学习成本 违背了”关注点分离”的原则 代码可读性差 大多数 CSS-in-JS 实现会通过生成唯一的 CSS 选择器来达到 CSS 局部作用域的效果。这些自动生成的选择器会大大降低代码的可读性，给开发人员 debug 造成一定的影响 运行时消耗 由于大多数的 CSS-in-JS 的库都是在动态生成 CSS 的。这会有两方面的影响。首先你发送到客户端的代码会包括使用到的 CSS-in-JS 运行时（runtime）代码，这些代码一般都不是很小，例如 styled-components 的 runtime 大小是 12.42kB min + gzip，如果你希望你首屏加载的代码很小，你得考虑这个问题。其次大多数 CSS-in-JS 实现都是在客户端动态生成 CSS 的，这就意味着会有一定的性能代价。不同的 CSS-in-JS 实现由于具体的实现细节不一样，所以它们的性能也会有很大的区别，你可以通过这个工具来查看和衡量各个实现的性能差异 不能结合成熟的 CSS 预处理器（或后处理器）Sass/Less/PostCSS，:hover 和 :active 伪类处理起来复杂 2.4. 预处理器CSS 预处理器是一个能让你通过预处理器自己独有的语法的程序 市面上有很多 CSS 预处理器可供选择，且绝大多数 CSS 预处理器会增加一些原生 CSS 不具备的特性，例如 代码混合 嵌套选择器 继承选择器 这些特性让 CSS 的结构更加具有可读性且易于维护 我们常见的预处理器： Sass LESS Stylus CSS 预处理器的模块化功能可以通过以下两种方式实现： 导入和导出：CSS 预处理器可以使用导入和导出语句来将 CSS 模块相互引用。导入语句用于将其他模块的样式引入当前模块，导出语句用于将当前模块的样式导出供其他模块使用。 命名空间：CSS 预处理器可以使用命名空间来为 CSS 模块分配唯一的名称。命名空间可以防止不同模块之间的 CSS 样式冲突。 例如，以下 Sass 代码使用导入和导出语句来实现模块化： 12345678910// 导入模块 `my-styles`@import './my-styles';// 定义模块 `main`.main { background-color: #fff; color: #000;} 以下 Sass 代码使用命名空间来实现模块化： 123456789101112131415// 定义模块 `my-styles` 的命名空间@namespace my-styles;// 使用命名空间定义模块 `my-styles`.my-styles { background-color: #fff; color: #000;}// 在其他模块中使用模块 `my-styles`.other-module { @import 'my-styles/my-styles';} 使用 CSS 预处理器的模块化和变量功能可以有效实现 CSS 隔离。通过 CSS 隔离，可以避免不同模块之间的 CSS 样式冲突，从而提高 CSS 代码的维护性和可扩展性。 2.4.1. 预处理器优缺点分析优点： 利用嵌套，人为严格遵守嵌套首类名不一致，可以解决无作用域样式污染问题 可读性好，一目了然是那个 dom 节点，对于无用 css 删除，删除了相应 dom 节点后，对应的 css 也能比较放心的删除，不会影响到其他元素样式 缺点 需要借助相关的编译工具处理 预处理器是现代 web 开发中必备，结合 BEM 规范，利用预处理器，可以极大的提高开发效率，可读性，复用性 2.5. Shadow DOM熟悉 web Components 的一定知道 Shadow DOM 可以实现样式隔离，由浏览器原生支持。 Shadow DOM 是通过将 DOM 树封装在一个 shadow root 中来实现 CSS 隔离的。shadow root 是一个独立的 DOM 树，它与主文档 DOM 树是隔离的。 shadow root 由 shadow host 元素创建。shadow host 元素是容纳 shadow root 的元素。 要创建 shadow root，可以使用 shadowRoot 属性。例如，以下代码创建了一个 shadow root 123&lt;div id=&quot;my-element&quot;&gt; &lt;button&gt;Click me&lt;/button&gt;&lt;/div&gt; 1234const myElement = document.getElementById(&quot;my-element&quot;);// 创建 shadow rootconst shadowRoot = myElement.shadowRoot; 一旦创建了 shadow root，就可以将 CSS 样式应用于 shadow root 中的元素。这些样式将仅影响 shadow root 中的元素，而不会影响主文档中的元素。 例如，以下代码将 CSS 样式应用于 shadow root 中的按钮： 1234#my-element &gt; shadow button { background-color: red; color: white;} 我们经常在微前端领域看到 Shadow DOM，如下创建一个子应用 123const shadow = document.querySelector('#hostElement').attachShadow({mode:'open'}); shadow.innerHTML = '&lt;sub-app&gt;Here is some new text&lt;/sub-app&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/antd/antd.min.css&quot; /&gt;'; 子应用的样式作用域仅在 shadow 元素下。 Shadow DOM 还可以帮助提高 CSS 代码的维护性和可扩展性。通过将 CSS 样式与组件封装在 shadow root 中，可以使 CSS 代码更加清晰和易于理解。 2.5.1. Shadow DOM 优缺点分析优点 浏览器原生支持 严格意义上的样式隔离，如 iframe 一样 缺点 浏览器兼容问题 只对一定范围内的 dom 结构起作用 普通业务开发我们还是用框架、如 Vue、React；Shadow DOM 适用于特殊场景，如微前端 2.6. 隔离方案小结 说明 优点 缺点 BEM 不同项目用不同的前缀+命名规则避开冲突 简单 依赖约定，容易出现纰漏 CSS modules 通过编译生成不冲突的选择器名 可靠易用，避免人工约束 只能在构建期使用，依赖打包工具如 css-loader CSS in JS CSS 和 JS 编码在一起，最终实现不冲突的选择器 基本彻底避免冲突 运行时开销大，缺失完整的 CSS 能力 预处理器 利用嵌套实现 简单，提高工作效率 同依赖约定，容易出现纰漏 Shadow DOM 浏览器原生 CSS 沙箱支持 原生支持 只适用与特定场景 3. Angular 样式隔离Angular 样式隔离在 Angular 领域有一个新的名词 View encapsulation（视图封装），其实现原理非常 Smart, 他为每个组件（也可以称为视图 view）添加了一个用于表示其唯一性的属性，而在最终生成的 css 样式，如果属于特定视图都会携带一个属性选择器。这样通过属性标识，特定组件的样式只会被应用于相应组件而不会污染其它组件，从而实现样式隔离。 这样的做法带来很多好处，开发人员依然使用以前在编写 MPA 时一样 CSS 编写习惯，在命名规范上不必有太多约束。而 Angular 平台或者框架在编译项目时，会处理所有样式隔离相关事项。 跟以上所有 CSS 隔离方案相比，它几乎没有给用户带来任何的约束和负担。比如 BEM 的命名规范；CSS Modules 在 CSS 引用方式的改变；CSS in JS 在样式定义以及引用方面的用户习惯改变；Shadow Dom 样式只能局限在子应用的局限，Angular 提供了混合模式，相比 Shadow Dom 它更加灵活，它提供了将组件样式应用到全局的能力。 预处理器是对 CSS 定义方式的一种增强，Angular 很好的结合预处理器在 CSS 处理上的优势。 3.1. Angular 样式隔离的原理这样描述 Angular 样式隔离有些抽象，我们以实际的例子来说明 Angular 样式隔离的原理。 我们来看一个样式污染的例子： 1234567891011121314&lt;body&gt; &lt;style&gt; /* style for component1 */ a { font-style: italic; } &lt;/style&gt; &lt;div id=&quot;component1&quot;&gt; &lt;a&gt;Link 1&lt;/a&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; 在上面的例子中， 我们的本意是给 component1 组件的超连接添加上斜体样式。当只有这一个组件的时候， 它工作得很好，与我们期待得一模一样。 123456789101112131415161718192021222324&lt;body&gt; &lt;style&gt; /* style for component1 */ a { font-style: italic; } &lt;/style&gt; &lt;style&gt; /* style for component2 */ a { color: red; } &lt;/style&gt; &lt;div id=&quot;component1&quot;&gt; &lt;a&gt;Link 1&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;component2&quot;&gt; &lt;a&gt;Link 1&lt;/a&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; 如上例，随着我们业务得增长， 我们又有了新的功能，这时我们添加了 Component2，这是一件很令人开心的事情. component2 的颜色我们为它设置为红色。但是当两个组件组合到一起时样式就发生了冲突，在引入 Component 2 后，component1 的 a 标签字体颜色发生了改变，而这种改变不是我们所期待的。component2 的样式也因为 component1 的存在也受到了影响变成。 上面的例子只是对现实 CSS 污染现象一个简化，我们不可能懒惰到不为组件添加区块标识，元素标识，以实现样式隔离。 而 Angular 为会为我们自动完成标识组件标识，只要我们的项目结构符合 Angular 规范。 123456789101112131415161718192021222324&lt;body&gt; &lt;style&gt; /* style for component1 */ a[componentIdentifier-xxzz] { font-style: italic; } &lt;/style&gt; &lt;style&gt; /* style for component2 */ a[componentIdentifier-yyqq] { color: red; } &lt;/style&gt; &lt;div id=&quot;component1&quot; componentIdentifier-xxzz&gt; &lt;a componentIdentifier-xxzz&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;component2&quot; componentIdentifier-yyqq&gt; &lt;a componentIdentifier-yyqq&gt;&lt;/a&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; 如上， Angular 会自动为我们添加上组件标识，从而避免样式污染, 这就是 Angular 样式隔离的基本原理。 3.2. Angular 三种视图封装模式Angular 的三种封装模式分别为 ViewEncapsulation.Emulated ViewEncapsulation.None ViewEncapsulation.ShadowDom 3.2.1. ViewEncapsulation.EmulatedEmulated的意思是模仿，效仿, 仿真的意思，就是效仿 shadowDom 的行为即模仿 shadowDom 样式隔离效果。 ViewEncapsulation.Emulated：这也是 Angular 的默认视图封装模式， 使样式仅应用于组件的视图，不会影响应用程序中的其他组件。组件的样式被添加到文档的&lt;head&gt;区域，使它们在整个应用程序中可用，但只影响它们各自组件模板中的元素。 Emulated 的基本原理在上一节已经讲过了，现在我们再看一个复杂一点的情况。再前面的例子中，我们提到的 component1 和 component2 属于兄弟关系即平级关系。我们再来看一个父子关系的例子。 在下面的例子中，component3 是 component2 的子组件。从示例可以看出 component2 和 component3 依然是互相隔离的。假设 component3 是第三方提供的组件，但是它的样式需要一些调整才能适应目前的使用环境。此时我们可以定义全局样式来修改 component3，这种办法可以解决问题，但是不是理想的解决方案，会带来文章开头列出的一些问题即样式污染等问题，随着时间的增长，代码变得难以维护。而且如果 component2 本身也是提供给其它系统使用的，我们也没有机会去操纵调用系统的全局属性，也应该尽量避免要求调用方强制引入某些全局属性。 更好的办法是在父组件范围内即本例中的 component2 范围内定义样式来改变子组件的样式。此时就需要用到 ::ng-deep 和 :host 关键字了。 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;style&gt; /* style for component1 */ a[componentIdentifier-xxzz] { font-style: italic; } &lt;/style&gt; &lt;style&gt; /* style for component2 */ a[componentIdentifier-yyqq] { color: red; } &lt;/style&gt; &lt;style&gt; /* style for component3 */ a[componentIdentifier-ppbb] { font-size: 50px; } &lt;/style&gt; &lt;div id=&quot;component1&quot; componentIdentifier-xxzz&gt; &lt;a componentIdentifier-xxzz&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;component2&quot; componentIdentifier-yyqq&gt; &lt;a componentIdentifier-yyqq&gt;&lt;/a&gt; &lt;div id=&quot;component3&quot; componentIdentifier-ppbb&gt; &lt;a componentIdentifier-ppbb&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; 当定义样式时加上::ng-deep, 那么 Angular 在编译时就不会给样式加上属性选择器了，如果单纯只使用::ng-deep 关键字，样式又会变成全局样式。 如果我们要限定样式子在父组件及其包含的子组件有效，此时需要在::ng-deep 前添加:host 加以限度，这样样式只会作用于父组件及其子组件。 这样描述比较抽象， 我们来看一个实际的例子。 比如我们在 component2 的样式中这样定义 1234567a { color: red;}:host ::ng-deep a { font-size: 16px;} 那么编译后的代码，类似下面这样。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;style&gt; /* style for component1 */ a[componentIdentifier-xxzz] { font-style: italic; } &lt;/style&gt; &lt;style&gt; /* style for component2 */ a[componentIdentifier-yyqq] { color: red; } /* ::ng-deep的作用及时告诉编译器要在选择器上添加属性选择器 :host的作用是限定样式只在组件2及其子组件中有效 */ [componentIdentifier-yyqq] a { font-size: 16px; } &lt;/style&gt; &lt;style&gt; /* style for component3 */ a[componentIdentifier-ppbb] { font-size: 24px; } &lt;/style&gt; &lt;div id=&quot;component1&quot; componentIdentifier-xxzz&gt; &lt;a componentIdentifier-xxzz&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;component2&quot; componentIdentifier-yyqq&gt; &lt;a componentIdentifier-yyqq&gt;&lt;/a&gt; &lt;div id=&quot;component3&quot; componentIdentifier-ppbb&gt; &lt;a componentIdentifier-ppbb&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; ::ng-deep 的作用及时告诉编译器要在选择器上添加属性选择器:host 的作用是限定样式只在组件 2 及其子组件中有效 以上是站在组件使用者的角度来考虑如何适配第三方组件。如果站在组件定义者的角度能否做一些事情，让自己定义的组件变得更能适应复杂环境呢？答案当然是有的，此时就是:host-context 登场的时候了。 在 component3 中我们这样定义样式，那么我们就为调用放准备了两套方案，一套是为超大屏幕准备的字体大小是 24px, 一套是为小屏幕准备的字体大小是 16px 123456:host-context(.screen-xl) a { font-size: 24px;}:host-context(.screen-sm) a { font-size: 16px;} 那么在调用放只要是由相应的 class 即可控制 component 的字体大小。 123456&lt;div class=&quot;.screen-xl&quot;&gt; &lt;a&gt;&lt;/a&gt; &lt;component3&gt;&lt;/component3&gt;&lt;div&gt; 编译后完整的代码类似这样 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;style&gt; /* style for component1 */ a[componentIdentifier-xxzz] { font-style: italic; } &lt;/style&gt; &lt;style&gt; /* style for component2 */ a[componentIdentifier-yyqq] { color: red; } &lt;/style&gt; &lt;style&gt; /* style for component3 */ .screen-xl a[componentIdentifier-ppbb] { font-size: 24px; } .screen-sm a[componentIdentifier-ppbb] { font-size: 16px; } &lt;/style&gt; &lt;div id=&quot;component1&quot; componentIdentifier-xxzz&gt; &lt;a componentIdentifier-xxzz&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;component2&quot; class=&quot;.screen-xl&quot; componentIdentifier-yyqq&gt; &lt;a componentIdentifier-yyqq&gt;&lt;/a&gt; &lt;div id=&quot;component3&quot; componentIdentifier-ppbb&gt; &lt;a componentIdentifier-ppbb&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;body&gt;&lt;/body&gt;&lt;/body&gt; 3.2.2. ViewEncapsulation.NoneViewEncapsulation.None：不使用任何类型的视图封装，为组件指定的任何样式都是全局应用的，并且影响应用程序中的任何 HTML 元素。组建的样式被添加到文档的&lt;head&gt;中，使它们在整个应用程序中可用，所以时完全全局的，并影响文档中的任务匹配元素。 ViewEncapsulation.None 顾名思义就是不封装，其中定义的任何属性都会作用于全局范围，这可能是 Angular 为了保存框架的灵活性。在某些特殊的使用场景下可能会用到这种模式。在使用此模式时，需要特别注意的地方是，前面提到的:host ::ng-deep :host-context 关机字都不会生效。我们要了解这些关键字生效也是有前提的。 3.2.3. ViewEncapsulation.ShadowDomViewEncapsulation.ShadowDom: Angualr 使用浏览器内置的 Shadow Dom API 将组件的视图封装在 ShadowRoot 中，用作组件的宿主元素，并以隔离的方式应用提供的样式(只对浏览器内置 Shadow Dom 支持时才起作用)。组件的样式只添加到 Shadow Dom 宿主中，确保它们只影响各自组件视图中的元素。 ShadowDom 使用了浏览器内置的 Shadow Dom API, 样式是放在组件内部而不是 head 区域。如果使用惰性加载，那么可以大大减少 head 区域 css 的内容，这对解决 FCP 问题有帮助，以及 SEO 都有帮助。另外在微前端案例中，ShadowDom 是一种不错的选择。Angular 定义这种模式更多的可能是为微前端准备的。 其原理参考 2.5 节中关于 Shadow DOM 的 介绍。 4. 相关阅读本技术博客原创文章位于Angular 样式隔离 | 鹏叔的技术博客, 要获取最近更新请访问原文. 更多 Angular 相关文章请访问Angular 合集 | 鹏叔的技术博客 更多技术博客请访问: 鹏叔的技术博客 5. 参考文档Angular 样式隔离(style isolation)及选择器(:host, :host-context, ::ng-deep)的使用 你知道几种 CSS 样式隔离方案？ 如何看待 CSS 中 BEM 的命名方式？ Introduction to Styling and Style Isolation in Angular","link":"/angular/angular_style_isolation.html"},{"title":"Angular sweetalert2","text":"1. 前言在本教程中，我们将学习如何在 angular 14 应用程序中使用 sweetalert2 来显示 sweetalert 弹出消息。 2. 安装 sweetalert2123npm install --save sweetalert2 如果是在 Angular 框架中使用 sweetalert2, 建议安装 123npm install --save sweetalert2 @sweetalert2/ngx-sweetalert2 安装 sweetalert2 主题, 有多种主题可供选择, 分别是 theme-dark, theme-bulma, theme-bootstrap-4, theme-minimal, theme-borderless, theme-wordpress-admin, theme-default 等. 我的应用中使用的是 material 风格, 所以此处需安装@sweetalert2/theme-material-ui 主题. 123npm install --save @sweetalert2/theme-material-ui 对于如何选择相应的版本, 请参考下表 Angular version Latest compatible version range Required SweetAlert2 version range Angular 14+ @sweetalert2/ngx-sweetalert2@^12.0.0 (current) sweetalert2@^11.0.0 Angular 12, 13 @sweetalert2/ngx-sweetalert2@^11.0.0 sweetalert2@^11.0.0 Angular 9 to 11 @sweetalert2/ngx-sweetalert2@~9.0.0 sweetalert2@^10.8.0 Angular 8 @sweetalert2/ngx-sweetalert2@~7.3.0 (⚠️ NOT ~7.4.0, broken AoT metadata) sweetalert2@^9.7.0 Angular 7 @sweetalert2/ngx-sweetalert2@^5.1.0 sweetalert2@^8.5.0 Angular 6 @sweetalert2/ngx-sweetalert2@^5.1.0 sweetalert2@^8.5.0 Angular 5 @sweetalert2/ngx-sweetalert2@^5.1.0 sweetalert2@^8.5.0 Angular 4 @toverux/ngx-sweetalert2@^3.4.0 sweetalert2@^7.15.1 Angular 2 Try Angular 4 versions requirements, or older versions like @toverux/ngsweetalert2 unknown 3. 配置在 src/styles.scss 中引入主题样式 1@import &quot;@sweetalert2/theme-material-ui/material-ui.scss&quot;; 4. 使用使用之前引入 sweetalert2 包 1import Swal from &quot;sweetalert2&quot;; 4.1. 一个最简单的模态对话框1Swal.fire(&quot;Any fool can use a computer&quot;); 4.2. 一个拥有标题文本以及图标的模态对话框12345Swal.fire( &quot;The Internet?&quot;, // 标题 &quot;That thing is still around?&quot;, // 文本内容 &quot;question&quot; //图标); 默认支持五种图标, 分别是: warning, error, success, info 和 question 4.3. 一个拥有标题,文本,图标以及 footer 的模态对话框123456Swal.fire({ icon: &quot;error&quot;, title: &quot;Oops...&quot;, text: &quot;Something went wrong!&quot;, footer: '&lt;a href=&quot;&quot;&gt;Why do I have this issue?&lt;/a&gt;',}); 4.4. 一个拥有自定义 HTML 描述和自定义按钮和 ARIA 标签的模态对话框123456789101112131415Swal.fire({ title: &quot;&lt;strong&gt;HTML &lt;u&gt;example&lt;/u&gt;&lt;/strong&gt;&quot;, icon: &quot;info&quot;, html: &quot;You can use &lt;b&gt;bold text&lt;/b&gt;, &quot; + '&lt;a href=&quot;//sweetalert2.github.io&quot;&gt;links&lt;/a&gt; ' + &quot;and other HTML tags&quot;, showCloseButton: true, showCancelButton: true, focusConfirm: false, confirmButtonText: '&lt;i class=&quot;fa fa-thumbs-up&quot;&gt;&lt;/i&gt; Great!', confirmButtonAriaLabel: &quot;Thumbs up, great!&quot;, cancelButtonText: '&lt;i class=&quot;fa fa-thumbs-down&quot;&gt;&lt;/i&gt;', cancelButtonAriaLabel: &quot;Thumbs down&quot;,}); 4.5. 一个拥有三个按钮的模态对话框1234567891011121314Swal.fire({ title: &quot;Do you want to save the changes?&quot;, showDenyButton: true, showCancelButton: true, confirmButtonText: &quot;Save&quot;, denyButtonText: `Don't save`,}).then((result) =&gt; { /* Read more about isConfirmed, isDenied below */ if (result.isConfirmed) { Swal.fire(&quot;Saved!&quot;, &quot;&quot;, &quot;success&quot;); } else if (result.isDenied) { Swal.fire(&quot;Changes are not saved&quot;, &quot;&quot;, &quot;info&quot;); }}); 4.6. 一个带动效的模态对话框动效采用 animate 库https://cdn.jsdelivr.net/npm/animate.css@4/animate.min.css 123456789Swal.fire({ title: &quot;Custom animation with Animate.css&quot;, showClass: { popup: &quot;animate__animated animate__fadeInDown&quot;, }, hideClass: { popup: &quot;animate__animated animate__fadeOutUp&quot;, },}); 123456789101112131415161718.animate__animated { -webkit-animation-duration: 1s; animation-duration: 1s; -webkit-animation-duration: var(--animate-duration); animation-duration: var(--animate-duration); -webkit-animation-fill-mode: both; animation-fill-mode: both;}.animate__fadeInDown { -webkit-animation-name: fadeInDown; animation-name: fadeInDown;}.animate__fadeOutUp { -webkit-animation-name: fadeOutUp; animation-name: fadeOutUp;} 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 参考文档@sweetalert2/ngx-sweetalert2 github repo sweetalert2 官方文档","link":"/angular/angular_sweetalert2.html"},{"title":"Angular结合TinyMCE实现富文本编辑器","text":"1. 背景介绍自己编写了一个博客系统，想要支持用户写作博客，考查了几种开源编辑器方案，例如 Quill, ckEditor，最后还是选择了 TinyMCE 编辑器。 原因主要在与它开箱即用，插件丰富，而且很多插件都是比其他编辑器做得优秀。 2. 创建 Angular 工程2.1. 创建工程首先创建一个 angular 工程. 工程的名字就叫 angular-richtext-editor. 123ng new angular-richtext-editor 2.2. 添加依赖这里需要添加 tinymce/tinymce-angular 依赖包, 以下是 tinymce-angular 与 Angular 之间的兼容关系. tinymce-angular， angular 的版本兼容性描述可以在tinymce-angular官网找到。 由于我目前使用的 angular 版本 17.3.2, 我选择的 tinymce-angular 为 8.x 版本。 1234cd angular-richtext-editornpm install --save @tinymce/tinymce-angular@^8 2.3. 安装 tinymce@tinymce/tinymce-angular 这个依赖包只是用来整合 angular 与 tinymce，但是真正需要的 tinymce 仍然没有包含在工程之中。 如果要安装 tinymce 有三种方法。 通过 CDN 安装 通过 npm manager 安装 通过.zip 文件安装 2.3.1. 通过 CDN 安装 tinyMCE使用 CDN 安装 tinyMCE 比较简单方便，但是需要到 tiny.cloud 上注册账号，并获取 apikey. 获取到 apikey 以后，将 apikey 配置到编辑器即可。 1&lt;editor apiKey=&quot;your-api-key&quot; [init]=&quot;init&quot; /&gt; 2.3.2. 通过 npm manager 安装 tinyMCE通过 npm manager 安装 tinyMCE 分为以下几个步骤： 安装 tinyMCE 依赖包 123npm install --save tinymce 配置 angular.json, 将 tinymce 单独编译为文件。 123&quot;assets&quot;: [ { &quot;glob&quot;: &quot;**/*&quot;, &quot;input&quot;: &quot;node_modules/tinymce&quot;, &quot;output&quot;: &quot;/tinymce/&quot; }] 加载 TinyMCE 要在编辑器初始化时加载 TinyMCE（也称为延迟加载），请使用 TinyMCE_SCRIPT_SRC 令牌向组件添加依赖项提供程序。 12345678910import { EditorComponent, TINYMCE_SCRIPT_SRC } from '@tinymce/tinymce-angular';/* ... */@Component({ /* ... */ standalone: true, imports: [EditorComponent], providers: [ { provide: TINYMCE_SCRIPT_SRC, useValue: 'tinymce/tinymce.min.js' } ]}) 或者：要在加载页面或应用程序时加载 TinyMCE，请执行以下操作： 打开 angular.json 并将 TinyMCE 添加到全局脚本标记中。 123&quot;scripts&quot;: [ &quot;node_modules/tinymce/tinymce.min.js&quot;] 更新编辑器配置以包括 base_url 和后缀选项。 12345678910export class AppComponent { /* ... */ init: EditorComponent['init'] = { /* ... */ base_url: '/tinymce', // Root for resources suffix: '.min' // Suffix to use when loading resources };} 2.3.3. 通过.zip 文件安装 tinyMCE通过 zip 包安装 tinyMCE,可以参考这篇文章 2.4. 配置 tinyMCE首先在 component 定义配置 1234567891011export class AppComponent { /* ... */ init: EditorComponent['init'] = { /* ... */ base_url: '/tinymce', // Root for resources suffix: '.min' // Suffix to use when loading resources /* ... */ };} 一份完整的配置列表如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142tinyConfig: EditorComponent['init'] = { plugins: 'preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars image link media codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons accordion fullscreen', editimage_cors_hosts: ['picsum.photos'], menubar: false, language: 'zh_CN', toolbar: 'undo redo | code preview | blocks fontfamily fontsize | bold italic underline strikethrough removeformat | align numlist bullist | link image media table | lineheight outdent indent| forecolor backcolor | charmap emoticons | save print | pagebreak anchor codesample | ltr rtl | fullscreen', autosave_ask_before_unload: true, autosave_interval: '30s', autosave_prefix: '{path}{query}-{id}-', autosave_restore_when_empty: false, autosave_retention: '2m', image_advtab: true, quickbars_insert_toolbar: false, link_list: [ { title: 'My page 1', value: 'https://www.tiny.cloud' }, { title: 'My page 2', value: 'http://www.moxiecode.com' }, ], image_list: [ { title: 'My page 1', value: 'https://www.tiny.cloud' }, { title: 'My page 2', value: 'http://www.moxiecode.com' }, ], image_class_list: [ { title: 'None', value: '' }, { title: 'Some class', value: 'class-name' }, ], importcss_append: true, file_picker_callback: this.filePickHandler.bind(this), height: 600, image_caption: true, quickbars_selection_toolbar: 'bold italic | quicklink h2 h3 blockquote quickimage quicktable', noneditable_class: 'mceNonEditable', contextmenu: 'link image table', skin: 'oxide', content_css: 'default', content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:16px }',}; 3. 使用tinyMCEapp.component.html 12345&lt;h1&gt;TinyMCE 7 Angular Demo&lt;/h1&gt;&lt;editor [init]=&quot;tinyConfig&quot;&gt;&lt;/editor&gt; 4. 设置语言修改语言设置，默认为英文 12345678tinyConfig: EditorComponent['init'] = { ...... language_url: '/assets/js/langs/zh_CN.js', language: 'zh_CN', .......} 从tiny cloud languagepacks 下载中文语言包，将其放置在例如：src/assets/js/langs/ 将 language_url 指向 zh_CN.js. Language 设置为 zh_CN。 修改 angular.json, 将 assets 包含在 assets 内。 1234&quot;assets&quot;: [ ...... &quot;src/assets&quot;, ...... 5. 如何上传图片到self hosted服务器首先将tinyMCE配置的file_picker_callback指向自定义函数filePickHandler file_picker_callback: this.filePickHandler.bind(this), 以下是一段客户端代码。 12345678910111213141516171819202122232425262728293031323334filePickHandler(callback: any, value: any, meta: any) { const input = document.createElement('input'); input.setAttribute('type', 'file'); input.setAttribute('accept', 'image/*'); let that = this; input.addEventListener('change', (e: Event) =&gt; { const target = e.target as HTMLInputElement; if (target.files &amp;&amp; target.files.length &gt; 0) { const file: File = target.files[0]; const formData = new FormData(); formData.append('file', file, file.name); that.http .post( 'url_to_file_upload_server', formData ) .subscribe({ next: (response: any) =&gt; { const href = response.url; /* call the callback and populate the Title field with the file name */ callback(href, { title: file.name }); }, error: (err: any)=&gt; { console.log(err) } }); } }); input.click();} url_to_file_upload_server 修改为服务端url. 服务端代码golang 版本如下： 由于涉及到安全性问题，这里只公开部分代码。 12345678910111213141516171819202122232425// @Summary 上传文件// @Description 上传文件// @Tags UploadCover// @Accept multipart/form-data// @Produce json// @Param file formData file true &quot;文件&quot;// @Success 0 {object} Response[string]// @Router /upload/file [post]func (ctrl *blogController) UploadCover(c *gin.Context) { _, fileHeader, err := c.Request.FormFile(&quot;file&quot;) if err != nil { control.ReturnError(c, control.ErrFileReceive, err) return } oss := upload.NewOSS() filePath, _, err := oss.UploadFile(fileHeader) //将文件保存至服务器。 if err != nil { control.ReturnError(c, control.ErrFileUpload, err) return } control.ReturnSuccessWithImgUrl(c, filePath)} 123456789101112131415161718192021222324252627282930313233343536373839404142// 文件上传到本地func (ls *Local) UploadFile(file *multipart.FileHeader) (filePath, fileName string, err error) { ext := path.Ext(file.Filename) // 读取文件后缀 name := strings.TrimSuffix(file.Filename, ext) // 读取文件名 name = utils.MD5(name) // 加密文件名 filename := name + &quot;_&quot; + time.Now().Format(&quot;20060102150405&quot;) + ext // 拼接新文件名 //conf := g.Conf.Upload storeDir := 获取服务器端存储位置文件夹子 displayPath := 文件上传后，获取文件的的url mkdirErr := os.MkdirAll(storeDir, os.ModePerm) // 尝试创建存储路径 if mkdirErr != nil { zap.S().Error(&quot;function os.MkdirAll() Filed&quot;, mkdirErr) return &quot;&quot;, &quot;&quot;, errors.New(&quot;function os.MkdirAll() Filed, err:&quot; + mkdirErr.Error()) } storePath := storeDir + &quot;/&quot; + filename // 文件存储路径 filepath := displayPath + &quot;/&quot; + filename // 文件展示路径 f, openError := file.Open() // 读取文件 if openError != nil { zap.S().Error(&quot;function file.Open() Failed&quot;, openError) return &quot;&quot;, &quot;&quot;, errors.New(&quot;function file.Open() Failed, err:&quot; + openError.Error()) } defer f.Close() // 创建文件 defer 关闭 out, createErr := os.Create(storePath) if createErr != nil { zap.S().Error(&quot;function os.Create() Failed&quot;, createErr) return &quot;&quot;, &quot;&quot;, errors.New(&quot;function os.Create() Failed, err:&quot; + createErr.Error()) } defer out.Close() // 创建文件 defer 关闭 _, copyErr := io.Copy(out, f) // 拷贝文件 if copyErr != nil { zap.S().Error(&quot;function io.Copy() Failed&quot;, copyErr) return &quot;&quot;, &quot;&quot;, errors.New(&quot;function io.Copy() Failed, err:&quot; + copyErr.Error()) } return filepath, filename, nil} 6. 参考文档Using the TinyMCE package with the Angular framework","link":"/angular/angular_tinyMCE_editor.html"},{"title":"Angular universal服务器端渲染与预渲染","text":"1. 前言 2. 什么是 Angular universal 3. 为什么需要 SSR(服务器端渲染) 4. Angular Universal 如何解决 FCP 和 SEO 问题 5. 开启 SSR 6. 开启客户端水合(Client Hydration) 7. 使用 Universal 构建和运行 8. Prerender 预渲染静态 HTML 8.1. 预渲染路径配置 9. SEO 优化 9.1. 关键词与描述的优化 9.2. 内部跳转优化 9.3. 样式文件打包 9.4. 添加 robots.txt 9.5. 自动生成 sitemap 10. 使用 Nginx 部署 10.1. 安装 Nginx 10.2. 安装 Node 10.3. 安装 PM2 10.4. 配置并启动 pm2 10.5. 配置 Nginx 反向代理 11. troubleshooting 11.1. 问题 1: Configuration ‘development’ is not set in the workspace 11.2. 问题 2: ReferenceError: window is not defined 11.3. 问题 3: Flex Layout loaded on the server without FlexLayoutServerModule 11.4. 问题 4: XMLHttpRequest is not defined 11.5. 问题 5： \\dist\\demo-web\\browser...ReferenceError: Image is not defined 12. 相关阅读 13. 参考文档 1. 前言当初选择将应用做成 SPA(单页应用)的时候主要是觉得用户体验非常丝滑, 当时也知道 SPA 很难做 SEO, 还是毅然决然的选择做成 SPA 应用. 当时还是 Angularjs 1.X 的时候, 就觉得 Angular 的理念跟自己对前端的看法特别契合, 后来将框架升级到 Angular 11 继而 13, 虽然费了很多时间和精力, 但是收获非常多, 由于本文的重点是 SSR 与 prerendering,所以这里不赘述原因了. 之前也了解到 Angular Universal 是做服务器端渲染的套件(SSR), 乘最近有空刚好将其引入到项目. 实现地过程中虽然遇到问题, 但是还是有些小兴奋的感觉, 一来解决了首次访问应用时白屏的问题, 二来将当初打算舍弃的 SEO 能力也找了回来, 而且整个对引入 SSR 实现 SEO 的过程还是相当轻松的, 特写此文, 以防遗忘, 也希望给后来者有所帮助. 2. 什么是 Angular universalAngular universal 是一个用于服务器端渲染 Angular 应用程序的框架. 它允许在服务器上生成 HTML, 以便在浏览器中更快地呈现应用程序, 这对于提高应用程序的性能和搜索引擎优化(SEO)非常有用. 在使用 Angular Universal 时, 应用程序的初始加载时间可能会增加, 但是在浏览器中呈现应用程序的速度会更快, 因为大部分工作已经在服务器上完成了. 3. 为什么需要 SSR(服务器端渲染)在深入了解 Angular universal 之前, 我们需要了解一下 SSR(服务器端渲染), 一项技术的出现并流行, 一定是它解决了一类问题或者是解决了一些痛点. 那么 SSR(Server Side Rendering)的出现解决了哪些痛点呢? 相对于 MPA(Multiple Page Application)风格来说,SPA 这种架构风格有很多的优点,但是也存在非常明显两个的缺点, 而 SSR 技术的出现就是为了解决这两个痛点的. 根据本文的主题 SPA 的优缺点列举如下, 比如: 更快的用户体验 更好的交互性 更好的可维护性 SPA 架构风格也存在两个非常大的痛点: 初始加载时间较长 未经优化的 SPA 应用在进行首次内容绘制(FCP - First Contentful Paint)时会存在非常严重的首页白屏问题, 由于用户首次访问 SPA 时需要加载大量的 JS 代码, 而且要经过解析后才能开始渲染页面, 整个过程需要耗费大量的时间, 往往会大大超过用户原意等待时间 3 秒, 而且随着应用的功能增加问题越来越严重. SEO 不友好 SPA 不利于搜索引擎的抓取, 由于搜索引擎使用网络爬虫来索引网页, 这些爬虫依赖 HTML 内容来理解网页的结构和内容. 然而, 在 SPA 中, 内容是由 JavaScript 动态生成的, 这意味着发送到浏览器的初始 HTML 文件通常为空或包含非常少的内容. 这使得搜索引擎难以正确索引页面, 因为它们可能无法看到由 Javascript 生成的内容. 强如 google 这样的索引擎虽然可以索引 SPA 网页内容, 但是这并不总是可靠的. 如果你想要确保 SPA 网页内容能被搜索引擎正确索引, 最好使用服务器端渲染来生成 HTML 内容并将其发送到浏览器. 而 SSR 就是为解决以上两个痛点而是的. 4. Angular Universal 如何解决 FCP 和 SEO 问题Angular Universal 允许我们为 Angular 应用程序进行服务器端渲染. 这意味着我们可以在服务器上生成 HTML 内容并将其发送到浏览器, 而不是在浏览器中使用 Javascript 动态生成内容. 这样, 搜索引擎可以看到页面的全部内容并正确索引它, 从而解决 SPA 应用程序的 SEO 问题. 此外, Angular Universal 还可以解决 FCP(首次内容绘制)性能问题. 由于 SPA 应用程序的初始 HTML 文件通常为空或者包含非常少的内容, 因此它们需要大量的 JavaScript 代码来生成内容. 这会导致长时间的初始加载时间, 从而影响 FCP 性能. 使用 Angular Universal 进行服务器端渲染可以解决这个问题, 因为它可以在服务器上生成完整的 HTML 内容并将其发送到浏览器, 从而在让浏览器快速展现页面轮廓, 减少白屏时间, 于此同时浏览器会加载整个应用所需的 Javascript 代码, 从而提高整体的用户体验. 读到这里读者可能会有一个疑惑, 那就是 SPA 不又变成 MPA 了吗? 其实不然, HTML 内容只是为了减少用户等待时间, 在 Javascript 完全加载完成之前,给用户展示页面内容, 一旦 Javascript 加载完成, 前端页面会被重新绘制, 然后完全接管用户的交互任务. 所以在 javascript 加载完成后页面有一个非常短的闪烁, 那就是 Javascript 重新绘制 First Content 的过程. 当然这样的闪烁动作对要求苛刻的系统来说也是不可接受的, Angular 也有相应的解决办法, 后面文章会讲到. 那么具体来讲, Angular Universal 是如何进行服务器端渲染的呢? 我们知道 Javascript 是可以通过 Node.js 在在服务器端执行的, 每错 Angular Universal 正式通过 Express 这个 Node.js 应用程序框架提供的强大功能和工具在后端处理请求, 再将生成的 HTML 页面发送到前端或者喂给爬虫, 这样前端就能快速渲染页面, 爬虫也能得到某个页面完整的 HTML 内容, 从而正确地为页面建立索引. 当然这并不是完美地解决 FCP 和 SEO 问题, 因为 Node.js 执行 javascript 仍然需要时间和占用大量的服务器资源, 一旦请求增多, 频率加快, express 将会称为瓶颈, 是一个非常影响 TTFB(Time to first byte)指标的问题. 那么怎样进一步解决该问题呢, 这里有两种思路: 一种是采用数据库缓存例如 Redis 或 Memcached, 将页面缓存起来, 当下次访问相同页面时从缓存调取, 从而避免 express 重新执行 javascript 从而提高性能. 而此方案不是本文讲解的重点, 如果要采用此方案, 请自行百度或 google 了解相关详情. 另外一种方案叫 Prerender 技术. 它在构建时就为应用程序的每个页面生成静态 HTML 文件, 而不是依赖 JavaScript 在运行时动态生成内容. 当用户请求页面时, 这些静态 HTML 文件可以直接发送到用户浏览器, 从而提高首次内容呈现(FCP)的时间, 并使搜索引擎更容易爬取和索引内容. 5. 开启 SSR您可以使用@nguniversal/express-engine 依赖包在 Angular 应用程序中启用服务器端渲染，如下: 12345# 进入项目根目录# 添加express-engineng add @nguniversal/express-engine 说明: Angular Universal 需要 Node.js 的 Active LTS 版本或维护 LTS 版本。有关信息，请参阅版本兼容性指南以了解当前支持的版本。 该命令更新应用程序代码以启用 SSR，并向项目结构中添加额外的文件。 该命令会新增以下三个文件, 并修改以下一些文件 123src / main.server.ts; // &lt;-- * server-side application configuration (standalone app only)src / app / app.server.module.ts; // &lt;-- * server-side application module (NgModule app only)server.ts; // &lt;-- * express web server angular-universal-demo/angular.json 注意: 此处的 angular.json 有一些手动更改, 主要在”serve-ssr”这个节点, 主要是为了解决 Angular 的一个 bug.bug 详情请参考这个issue report - Congiguration ‘development’ is not set in the workspace 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384--- a/angular-universal-demo/angular.json+++ b/angular-universal-demo/angular.json@@ -36,7 +36,7 @@ &quot;build&quot;: { &quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;, &quot;options&quot;: {- &quot;outputPath&quot;: &quot;dist/angular-universal-demo&quot;,+ &quot;outputPath&quot;: &quot;dist/angular-universal-demo/browser&quot;, &quot;index&quot;: &quot;src/index.html&quot;, &quot;main&quot;: &quot;src/main.ts&quot;, &quot;polyfills&quot;: &quot;src/polyfills.ts&quot;,@@ -152,6 +152,73 @@ &quot;devServerTarget&quot;: &quot;angular-universal-demo:serve:dev&quot; } }+ },+ &quot;server&quot;: {+ &quot;builder&quot;: &quot;@angular-devkit/build-angular:server&quot;,+ &quot;options&quot;: {+ &quot;outputPath&quot;: &quot;dist/angular-universal-demo/server&quot;,+ &quot;main&quot;: &quot;server.ts&quot;,+ &quot;tsConfig&quot;: &quot;tsconfig.server.json&quot;,+ &quot;optimization&quot;: false,+ &quot;sourceMap&quot;: true,+ &quot;extractLicenses&quot;: false+ },+ &quot;configurations&quot;: {+ &quot;production&quot;: {+ &quot;outputHashing&quot;: &quot;media&quot;,+ &quot;fileReplacements&quot;: [+ {+ &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,+ &quot;with&quot;: &quot;src/environments/environment.prod.ts&quot;+ }+ ],+ &quot;optimization&quot;: true,+ &quot;sourceMap&quot;: false,+ &quot;extractLicenses&quot;: true+ },+ &quot;dev&quot;: {+ &quot;fileReplacements&quot;: [+ {+ &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,+ &quot;with&quot;: &quot;src/environments/environment.dev.ts&quot;+ }+ ]+ }+ },+ &quot;defaultConfiguration&quot;: &quot;production&quot;+ },+ &quot;serve-ssr&quot;: {+ &quot;builder&quot;: &quot;@nguniversal/builders:ssr-dev-server&quot;,+ &quot;options&quot;: {+ &quot;browserTarget&quot;: &quot;angular-universal-demo:build&quot;,+ &quot;serverTarget&quot;: &quot;angular-universal-demo:server&quot;+ },+ &quot;configurations&quot;: {+ &quot;production&quot;: {+ &quot;browserTarget&quot;: &quot;angular-universal-demo:build:production&quot;,+ &quot;serverTarget&quot;: &quot;angular-universal-demo:server:production&quot;+ }+ }+ },+ &quot;prerender&quot;: {+ &quot;builder&quot;: &quot;@nguniversal/builders:prerender&quot;,+ &quot;options&quot;: {+ &quot;routes&quot;: [+ &quot;/&quot;+ ]+ },+ &quot;configurations&quot;: {+ &quot;production&quot;: {+ &quot;browserTarget&quot;: &quot;angular-universal-demo:build:production&quot;,+ &quot;serverTarget&quot;: &quot;angular-universal-demo:server:production&quot;+ },+ &quot;development&quot;: {+ &quot;browserTarget&quot;: &quot;angular-universal-demo:build:development&quot;,+ &quot;serverTarget&quot;: &quot;angular-universal-demo:server:development&quot;+ }+ },+ &quot;defaultConfiguration&quot;: &quot;production&quot; } angular-universal-demo/package.json 1234567891011121314151617181920212223242526272829--- a/angular-universal-demo/package.json+++ b/angular-universal-demo/package.json@@ -9,7 +9,11 @@ &quot;buildProd&quot;: &quot;ng build --configuration production&quot;, &quot;test&quot;: &quot;ng test&quot;, &quot;lint&quot;: &quot;ng lint&quot;,- &quot;e2e&quot;: &quot;ng e2e&quot;+ &quot;e2e&quot;: &quot;ng e2e&quot;,+ &quot;dev:ssr&quot;: &quot;ng run angular-universal-demo:serve-ssr&quot;,+ &quot;serve:ssr&quot;: &quot;node dist/angular-universal-demo/server/main.js&quot;,+ &quot;build:ssr&quot;: &quot;ng build &amp;&amp; ng run angular-universal-demo:server&quot;,+ &quot;prerender&quot;: &quot;ng run angular-universal-demo:prerender&quot; }, &quot;private&quot;: true, &quot;dependencies&quot;: {@@ -18,24 +22,27 @@ &quot;@angular/cdk&quot;: &quot;13.3.1&quot;, &quot;@angular/platform-browser-dynamic&quot;: &quot;13.3.1&quot;,+ &quot;@angular/platform-server&quot;: &quot;13.3.1&quot;, &quot;@angular/router&quot;: &quot;13.3.1&quot;, &quot;@swimlane/ngx-charts&quot;: &quot;19.1.0&quot;, &quot;@swimlane/ngx-datatable&quot;: &quot;20.0.0&quot;,+ &quot;@nguniversal/express-engine&quot;: &quot;^13.1.0&quot;, &quot;@angular/cli&quot;: &quot;13.3.1&quot;, &quot;@angular/compiler-cli&quot;: &quot;13.3.1&quot;, &quot;@angular/language-service&quot;: &quot;13.3.1&quot;,+ &quot;@nguniversal/builders&quot;: &quot;^13.1.0&quot;,+ &quot;@types/express&quot;: &quot;^4.17.0&quot;, app.module.ts 1234567891011--- a/angular-universal-demo/src/app/app.module.ts+++ b/angular-universal-demo/src/app/app.module.ts@@ -33,7 +33,7 @@ const DEFAULT_PERFECT_SCROLLBAR_CONFIG: PerfectScrollbarConfigInterface = { @NgModule({ imports: [- BrowserModule,+ BrowserModule.withServerTransition({ appId: 'serverApp' }), BrowserAnimationsModule, FormsModule, HttpClientModule, Angular 会把 appId 值（它可以是任何字符串）添加到服务端渲染页面的样式名中，以便在客户端应用启动时可以找到并移除它们。 app.routing.ts 1234567891011121314151617--- a/angular-universal-demo/src/app/app.routing.ts+++ b/angular-universal-demo/src/app/app.routing.ts@@ -19,10 +19,10 @@ export const routes: Routes = [ @NgModule({ imports: [ RouterModule.forRoot(routes, {- preloadingStrategy: PreloadAllModules,- relativeLinkResolution: 'legacy',- // useHash: true- })+ preloadingStrategy: PreloadAllModules,+ relativeLinkResolution: 'legacy',+ initialNavigation: 'enabledBlocking'+}) ], exports: [ RouterModule “enabledBlocking”-在创建根组件之前开始初始化导航。引导程序将被 blocked，直到初始导航完成。此值是服务器端渲染工作所必需的。 1234567891011121314151617181920--- a/angular-universal-demo/src/main.ts+++ b/angular-universal-demo/src/main.ts@@ -9,5 +9,15 @@ if (environment.production) { enableProdMode(); }-platformBrowserDynamic().bootstrapModule(AppModule)+function bootstrap() {+ platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.error(err));+ };+++if (document.readyState === 'complete') {+ bootstrap();+} else {+ document.addEventListener('DOMContentLoaded', bootstrap);+} 6. 开启客户端水合(Client Hydration)客户端水合是在客户端上恢复服务器端呈现的应用程序的过程。这包括重用服务器呈现的 DOM 结构、持久化应用程序状态、传输服务器已经检索到的应用程序数据以及其他进程。您可以通过修改 app.module.ts 文件来启用水合 如果是 Angular 11 以上 16 以下的版本, 要达到 Hydration 的效果可参考如下配置, 需要引入 BrowserTransferStateModule. 1234567891011121314import { BrowserModule } from &quot;@angular/platform-browser&quot;;import { NgModule } from &quot;@angular/core&quot;;import { AppComponent } from &quot;./app.component&quot;;import { BrowserTransferStateModule } from &quot;@angular/platform-browser&quot;;@NgModule({ declarations: [AppComponent], imports: [ BrowserModule.withServerTransition({ appId: &quot;serverApp&quot; }), BrowserTransferStateModule, ], bootstrap: [AppComponent],})export class AppModule {} 如果 Angular 16 为了达到 Hydration 的效果, 可以参考如下配置:。从@angular/platform-browser 导入 provideClientHydration 函数，并将函数调用添加到 AppModule 的 providers 部分，如下所示。 1234567891011import { provideClientHydration } from &quot;@angular/platform-browser&quot;;// ...@NgModule({ // ... providers: [provideClientHydration()], // add this line bootstrap: [AppComponent],})export class AppModule { // ...} 更新: 2023/11/10 即使升级到 Angular 15, 16 以后, 如果使用的是 NgModule 的方式引导启动应用程序, 本教程还是完全适用的. 另外 Angular 15 对 以 standalone component 启动应用并且开启 ssr 的支持没有 16 完善, 在条件许可的情况下建议升级完 15 后接着升级到 16, 如果坚持使用 15 的话, 建议不要使用 standalone component 来引导应用程序, 到 16 以后就可以放心大胆使用 standalone component 来启动应用了. 在 Angular 15, 16 中, 如果使用的是 Angular standalone component 引导启动应用程序, 以下三个文件 server.ts, src/main.server.ts, app.config.server.ts 的写法是跟本教程稍有不同, 为了不破坏文档的结构, 也避免制造一些混乱, 这里不将这种配置上差异列举出来了. 具体差异可以结合 github 上的一个示例angular-v16-universal-standalone, 参考本文档, 可以解决大部分的问题. 7. 使用 Universal 构建和运行构建 SSR 1npm run build:ssr 构建完应用之后，启动服务器 1npm run serve:ssr 或者构建同时启动服务器 1npm run dev:ssr 8. Prerender 预渲染静态 HTML经过上面的步骤后，如果我们通过npm run build:ssr 构建项目，你会发现在 dist/&lt;your project&gt;/browser 下面只有 index.html 文件，打开文件查看，发现其中还有 &lt;app-root&gt;&lt;/app-root&gt; 这样的元素，也就是说你的网页内容并没有在 html 中生成。这是因为 Angular 使用了动态路由，比如 /product/:id 这种路由，而页面的渲染结果要经过 JS 的执行才能知道，因此，Angular 使用了 Express 作为 Web 服务器，能在服务端运行时根据用户请求（爬虫请求）使用模板引擎生成静态 HTML 界面。 而 prerender（npm run prerender）会在构建时生成静态 HTML 文件。比如我们做企业官网，只有几个页面，那么我们可以使用预渲染技术生成这几个页面的静态 HTML 文件，避免在运行时动态生成，从而进一步提升网页的访问速度和用户体验。 8.1. 预渲染路径配置需要进行预渲染（预编译 HTML）的网页路径，可以有几种方式进行提供： 通过命令行的附加参数: 123ng run &lt;app-name&gt;:prerender --routes /product/1 /product/2 这里有个需要注意的地方, 即使我只指定了两个路径, Angular universal 还是会使用 guess-parser 解析 routes 猜测可能的路径帮助渲染一堆路径, 实际上这种猜测有些鸡肋, 根本不会准确, 没有太大帮助. 此时可以使用 –no-guess-routes 选项将其关闭. 123ng run &lt;app-name&gt;:prerender --no-guess-routes --routes /product/1 /product/2 或者修改 angular.json, 将 guessRoutes 设置为 false 123456789&quot;prerender&quot;: { &quot;builder&quot;: &quot;@nguniversal/builders:prerender&quot;, &quot;options&quot;: { &quot;routes&quot;: [ &quot;/product/1&quot;, &quot;/product/2&quot; ], &quot;guessRoutes&quot;: false } 如果路径比较多，比如针对 product/:id 这种动态路径，则可以使用一个路径文件： routes.txt 1234/products/1/products/23/products/145/products/555 然后在命令行参数指定该文件： 1ng run &lt;app-name&gt;:prerender --routes-file routes.txt 或者在 angular.json 中指定 routes-file 1234567&quot;prerender&quot;: { &quot;builder&quot;: &quot;@nguniversal/builders:prerender&quot;, &quot;options&quot;: { &quot;guessRoutes&quot;: false, &quot;routesFile&quot;: &quot;routes-to-prerender.txt&quot; // 在这里指定routes-file }, 在项目的 angular.json 文件配置需要的路径 1234567891011&quot;prerender&quot;: { &quot;builder&quot;: &quot;@nguniversal/builders:prerender&quot;, &quot;options&quot;: { &quot;routes&quot;: [ // 这里配置 &quot;/&quot;, &quot;/main/home&quot;, &quot;/main/service&quot;, &quot;/main/team&quot;, &quot;/main/contact&quot; ] }, 配置完成后，重新执行预渲染命令（npm run prerender 或者使用命令行参数则按照上面&lt;1&gt;&lt;2&gt;中的命令执行），编译完成后，再打开 dist/&lt;your project&gt;/browser 下的 index.html 会发现里面没有 &lt;app-root&gt;&lt;/app-root&gt; 了，取而代之的是主页的实际内容。同时也生成了相应的路径目录以及各个目录下的 index.html 子页面文件。 9. SEO 优化9.1. 关键词与描述的优化SEO 的关键在于对网页 title，keywords 和 description 的收录，因此对于我们想要让搜索引擎收录的网页，可以修改代码提供这些内容。 在 Angular 14 中，如果路由界面通过 Routes 配置，可以将网页的静态 title 直接写在路由的配置中： 1{ path: 'home', component: AbmHomeComponent, title: '&lt;你想显示在浏览器 tab 上的标题&gt;' }, 另外，Angular 也提供了可注入的 Title 和 Meta 用于修改网页的标题和 meta 信息： 12345678910111213import { Meta, Title } from &quot;@angular/platform-browser&quot;;export class ExampleComponent implements OnInit { constructor(private _title: Title, private _meta: Meta) {} ngOnInit() { this._title.setTitle(&quot;&lt;此页的标题&gt;&quot;); this._meta.addTags([ { name: &quot;keywords&quot;, content: &quot;&lt;此页的 keywords，以英文逗号隔开&gt;&quot; }, { name: &quot;description&quot;, content: &quot;&lt;此页的描述&gt;&quot; }, ]); }} 9.2. 内部跳转优化这个是指应用内部页面跳转尽量使用 a 标签，而不是使用别的标签加(click)事件进行跳转。 9.3. 样式文件打包另外一个需要注意的地方是，如果网站的样式很多很复杂，那么网站发布的时候 angular.json 中 extractCss 需要设置为 true,即单独打包一个独立的样式文件，而不是将样式全部包含在发布后的 index.html 中。 全部包含在 index.html 中会造成抓取保存的静态 html 文件过大，百度不能正确保存快照（百度限制了缓存文件大小，好像是 100k）。 9.4. 添加 robots.txt在网站优化过程中，有些时候，网站中有重要及私密的内容，站长并不希望某些页面被蜘蛛抓取，比如后台的数据，测试阶段的网站，还有一种很常见的情况，搜索引擎抓取的大量没有意义的页面。 robots.txt 是一个纯文本文件，用于声明该网站中不想被蜘蛛访问的部分，或指定蜘蛛抓取的部分，当蜘蛛访问一个站点时，它会首先检查该站点是否存在，robots.txt，如果找到，蜘蛛就会按照该文件中的内容来确定抓取的范围，如果该文件不存在，那么蜘蛛就会沿着链接直接抓取。即，只有在需要禁止抓取某些内容是，写 robots.txt 才有意义. robots 配置方法如下： 在 project_root/src 路径下创建 robots.txt 文件，里面输入你的 robots 配置，如果不懂，可以百度 robots 的语法，修改后保存即可提交。 下面是一个简单的 robots.txt 的例子 123User-agent: *Disallow:Sitemap: http://your_domain/sitemap.xml 还需要修改 angular.json 文件, 这样 robots.txt 文件才能被访问到 12345678&quot;build&quot;: { ...... &quot;assets&quot;: [ &quot;src/favicon.ico&quot;, &quot;src/robots.txt&quot;, &quot;src/sitemap.xml&quot;, &quot;src/assets&quot; ], 9.5. 自动生成 sitemap安装工具 ngx-sitemap 1npm install ngx-sitemap --save-dev 在 prerendering 后运行以下命令, 就可以生成 sitemap.xml 1234$./node_modules/.bin/ngx-sitemap ./dist/angular-universal-demo/browser htts://your_domainsitemap.xml successfully created in './dist/angular-universal-demo/browser/' 10. 使用 Nginx 部署整个 topo 结构是这样的, 首先要使用 pm2 将服务器端渲染程序运行起来, 然后通过 Nginx 将请求反向代理到 pm2. 这样 PM2 就会实际处理所有请求, 对于已经 prerender 过的页面 PM2 会直接去 browser 文件夹中去取, 对于没有 prerender 的页面, 首先会在服务器端渲染然后传送到浏览器端.页面到达流量器端后, 首先页面有一个基本的静态呈现, 与此同时会继续向后端请求 javascript, 直到 javascript 下载完成后, 将会进行 CSR(客户端渲染), 如果没有使用到 hydration 技术, 此时页面会有一个比较明显的闪烁, 如果使用了 hydration 技术此时会 CSR 渲染会比较平滑地替代 SSR 渲染的页面, 除了页面被重新渲染以外, 前端路由也会被 javascript 接管. 此时如果用户不刷新页面, 整个应用就运行在 SPA 模式下了. 对于搜索引擎爬虫, 由于它只读取页面文本内容, 不会去执行 javascript 代码, 所以相对于浏览器访问, 爬虫只是爬取那一页的内容, 不会有 javascript 下载过程, 更不会有 CSR, 以及 hydration 的过程. 整个部署过程是这样的, 首先安装 Nginx, node 以及 PM2. 然后启动 PM2, Nginx 反向代理到 PM2. 10.1. 安装 Nginx参考我的博客 鹏叔的技术博客-nginx 安装教程 10.2. 安装 Node安装 Nodejs 可以参考博客 安装并配置 nodejs | 鹏叔的技术博客 10.3. 安装 PM2安装 pm2 来支持 SSR 12345# 安装pm2npm install -g pm2# 查看pm2版本pm2 --v# 5.3.0 10.4. 配置并启动 pm2为了能在任意位置都能执行 pm2, 我们将 pm2 添加到 PATH 下, 添加的方法是在/usr/bin 下创建一个软连接 123ln -s /usr/local/node-v14.17.5-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/bin/pm2 我们顺便查看一下 pm2 的版本并确保软连接创建有效 1234pm2 --version[PM2] Spawning PM2 daemon with pm2_home=/root/.pm2[PM2] PM2 Successfully daemonized5.3.0 接下来, 我们就可以使用 PM2 启动服务器端渲染了,这里我们假设已经将程序部署到了服务器的/var/your_app/webapp 目录, 结构如下 1234tree -L 1 /var/your_app/webapp/var/your_app/webapp├── browser└── server 启动 SSR 123pm2 start --name app_ssr /var/your_app/webapp/server/main.js 注意: 使用 angular cli 默认生成的 distFolder 部署到服务器, 会出现 index 文件找不到.这里可以修改以下让其相对于 main.js 查找 index 而不是 process.cwd() vi server.ts 12const parentFolder: string = join(__dirname, &quot;../&quot;);const distFolder: string = join(parentFolder, &quot;browser&quot;); 设置开机自启动 123456789# 保存要在机器重新启动时重新生成的列表pm2 save# 生成开机自启动服务pm2 startup# enable pm2开机自启systemctl enable pm2-root 另外一些有用的 pm2 命令 123456789# 查看进程pm2 list# 关闭prcesspm2 stop process_name# 删除进程pm2 delete process_name# 查看process 详情pm2 show process_name 至此 PM2 配置完成, ssr 默认会监听在 4000 端口, 可以通过如下命令查找端口号 1grep &quot;process.env\\[\\&quot;PORT\\&quot;\\]&quot; /var/your_app/webapp/server/main.js 其他一些有用的 pm2 命令 查看日志某个任务的日志 123pm2 log the_process_name 10.5. 配置 Nginx 反向代理修改/etc/nginx/conf.d/defaut.conf 将之前的配置由如下 1234567location / { root /var/your_app/webapp/; index index.html index.htm; try_files $uri $uri/ /index.html; } 改成 1234567location / { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:4000/; } 11. troubleshooting11.1. 问题 1: Configuration ‘development’ is not set in the workspace描述: 当执行npm run dev:ssr 系统抛出如下错误 Configuration ‘development’ is not set in the workspace. 原因: 原因实际上是一个 bug, Angular 开发人员未考虑到, 我们的配置于他们期望的有差异.详细原因和解决方案请参考this issue也请注意, 我贴出来的ng add @nguniversal/express-engine自动配置的 angular.json 的 serve-ssr 部分是有修改过的, 目的就是为了解决这个问题. 11.2. 问题 2: ReferenceError: window is not defined描述: 当执行’npm run dev:ssr’ 系统抛出如下错误 ReferenceError: window is not defined 原因: 问题的原因是在 Nodejs 运行时, 没有 window, document, navigator 等等浏览器端对象. 可以参考我的博客使用 Angular Universal 时的重要注意事项,里面提到了三种解决该问题的策略, 这里我选择了 策略 3：Shims, 相应的修改如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'zone.js/dist/zone-node'; import { join } from 'path';-+import &quot;localstorage-polyfill&quot;; import { AppServerModule } from './src/main.server'; import { APP_BASE_HREF } from '@angular/common';-import { existsSync } from 'fs';-+import { existsSync,readFileSync } from 'fs';+import { createWindow } from &quot;domino&quot;; // The Express app is exported so that it can be used by serverless Functions. export function app(): express.Express { const server = express(); const distFolder = join(process.cwd(), 'dist/angular-universal-demo/browser'); const indexHtml = existsSync(join(distFolder, 'index.original.html')) ? 'index.original.html' : 'index';+ applyDomino(indexHtml) // Our Universal express-engine (found @ https://github.com/angular/universal/tree/master/modules/express-engine) server.engine('html', ngExpressEngine({ bootstrap: AppServerModule, }));@@ -35,26 +36,41 @@ export function app(): express.Express { }); return server; }+function applyDomino(indexHtml: string): void {++ const win = createWindow(indexHtml)++ console.log(&quot;applying mock window &quot;)+ global[&quot;localStorage&quot;] = localStorage;++ // Polyfills+ (global as any).window = win;+ (global as any).document = win.document;+ (global as any).navigator = win.navigator;+ (global as any).location = win.location;++}+ 11.3. 问题 3: Flex Layout loaded on the server without FlexLayoutServerModule描述: 当执行npm run dev:ssr 或者 npm run prerender时, 频繁的输出警告 Warning: Flex Layout loaded on the server without FlexLayoutServerModule 原因分析: FlexLayout 需要在 js 运行时确定屏幕大小等等信息, 在 server side 由于没有 screen 的概念所以需要模拟浏览器端的行为, FlexLayout 专门为 ssr 提供了一套 Module 来模拟浏览器端的行为, 所以最好在服务器端程序引入 FlexLayoutServerModule, 也即在 app.server.module.ts 中引入 FlexLayoutServerModule 1234567891011//app.server.module.tsimport {NgModule} from '@angular/core';import {FlexLayoutServerModule} from '@angular/flex-layout/server';@NgModule({ imports: [ ... other imports here FlexLayoutServerModule, ]}) 以及定义在 SSR 配置渲染时模拟的屏幕大小, 修改 app.module.ts 12345678//app.module.ts to simulate breakpoints@NgModule({ imports: [ ... other imports here FlexLayoutModule.withConfig({ssrObserveBreakpoints: ['xs', 'lt-md']}) ]}) 11.4. 问题 4: XMLHttpRequest is not defined描述: 当执行npm run dev:ssr 或者 npm run prerender时, 系统抛出如下错误 ReferenceError: XMLHttpRequest is not defined 原因分析: 原因是我的代码中调用了 ajax 这个 rxjs operator import { ajax, AjaxResponse } from 'rxjs/ajax';其底层实现需要 XMLHttpRequest,而在 Sever side javascript 环境中没有引入 xmlhttprequest 这个包. 解决办法: 解决办法可以有多种, 我选择了将 ajax 这个 rxjs operator 全部替换成了 HttpClient call, 例如 123456concatMap((remoteServerUri: string) =&gt; { const headers = new HttpHeaders({ Authorization: &quot;Basic &quot; + idToken, }); return this.httpClient.get&lt;any&gt;(remoteServerUri + url, { headers: headers }); }), 参考文章 How to resolve window is not defined on npm run serve:ssr 11.5. 问题 5： \\dist\\demo-web\\browser...ReferenceError: Image is not defined问题分析： 当页面使用 const bookImage = new Image(); 的时候， 在 server side rendering 时报如题错误。问题的原因是由于代码运行在 nodejs 运行时环境，而不是浏览器环境。正如我的博客使用 Angular Universal 时的重要注意事项中所提到的，服务器上不存在或不支持某些功能 Canvas，image 等对象. 三次尝试：第三次成功 即使我尝试使用const bookImage = this.document.createElement('img'); 尝试使用 domino 的 document 对象的实现方式， 仍然遇到dist\\demo-web\\browser...Error: NotYetImplemented的错误。虽然这是由于 domino 仍然没有实现创建 image 对象的方法。 123456789101112constructor(@Inject(DOCUMENT) private document: Document) {}ngAfterViewInit() { const bookImage = this.document.createElement('img'); bookImage.src = 'assets/img/wb/cover_template.png' this.ctx = this.wbCoverCanvas?.nativeElement.getContext('2d') bookImage.onload = () =&gt; { this.drawCover(bookImage) }} 后来尝试使用 canvas nodejs 包npm install canvas， 依然出现错误。参考问题ReferenceError: Image is not defined，node-canvas，仍然报错node_modules/canvas/types/index.d.ts:3:26 - error TS2307: Cannot find module 'stream' or its corresponding type declarations. 尝试解决以上错误，还是遇到很多问题。 最终还是回到 使用 Angular Universal 时的重要注意事项中所提到的办法 - 策略 2：Guard 将 drawCover 抽取到一个 service 中， 当运行 server 端代码时， 专门针对 server side 注入不同的 canvas service， 跳过 canvas 创建，这样并不会影响用户体验， 当客户端水合过程中毕竟会重绘 canvas. 12. 相关阅读本技术博客原创文章位于Angular universal 服务器端渲染与预渲染 | 鹏叔的技术博客, 要获取最近更新请访问原文. 更多 Angular 相关文章请访问Angular 合集 | 鹏叔的技术博客 更多技术博客请访问: 鹏叔的技术博客 13. 参考文档Server-side rendering (SSR) with Angular Universal Important Considerations when Using Angular Universal 2022 前端性能优化最佳实践 使用 Angular Universal 时的重要注意事项 Angular 服务器渲染常遇的坑 Angular SSR 探究 Angular 7 SSR 之后使用 node + nginx 部署在 linux Better Approach for Styles for SSR (Angular Universal) Feature Request: ability to produce and load CSS via link tag in index.html angular-v16-universal-standalone","link":"/angular/angular_universal.html"},{"title":"Angular上传图片","text":"前言在本教程中，您将学习如何在 angular 12/11 应用程序中制作带有预览功能的图像上传示例。 此外，本教程将逐步指导您如何在角度 11/12 中上传图像。并且还将反应式表单与表单组一起使用，以上传带有预览的图像。 反应式表单图像上传，可在 Angular 12/11 中预览使用以下步骤在响应式 angular 11/12 应用程序中上传带有预览的图像： 第 1 步 – 创建新的 Angular 应用程序第 2 步 – 导入模块第 3 步 – 使用代码查看文件第 4 步 – 使用组件 ts 文件第 5 步 –创建Upload.php文件第 6 步 - 启动Angular应用程序和PHP服务器 第 1 步 – 创建新的 Angular 应用程序首先，打开您的终端并在其上执行以下命令以安装 angular 应用程序： 123ng new my-new-app 第 2 步 – 导入模块然后，打开 app.module.ts 文件并将 HttpClientModule、FormsModule 和 ReactiveFormsModule 导入到 app.module.ts 文件中，如下所示： 1234567891011121314151617181920212223import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { HttpClientModule } from '@angular/common/http';import { FormsModule, ReactiveFormsModule } from '@angular/forms'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, HttpClientModule, FormsModule, ReactiveFormsModule ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 第 3 步 – 使用代码查看文件在此步骤中，使用input file元素和图像标签创建简单的反应式表单。因此，请打开 src/app/app.component.html 并将以下代码更新到其中： 1234567891011121314151617181920212223242526272829303132333435&lt;h1&gt;Angular 11 Image Upload with Preview - tutsmake.com&lt;/h1&gt; &lt;form [formGroup]=&quot;myForm&quot; (ngSubmit)=&quot;submit()&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input formControlName=&quot;name&quot; id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;div *ngIf=&quot;f.name.touched &amp;&amp; f.name.invalid&quot; class=&quot;alert alert-danger&quot;&gt; &lt;div *ngIf=&quot;f.name.errors.required&quot;&gt;Name is required.&lt;/div&gt; &lt;div *ngIf=&quot;f.name.errors.minlength&quot;&gt;Name should be 3 character.&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;file&quot;&gt;File&lt;/label&gt; &lt;input formControlName=&quot;file&quot; id=&quot;file&quot; type=&quot;file&quot; class=&quot;form-control&quot; (change)=&quot;onFileChange($event)&quot;&gt; &lt;div *ngIf=&quot;f.file.touched &amp;&amp; f.file.invalid&quot; class=&quot;alert alert-danger&quot;&gt; &lt;div *ngIf=&quot;f.file.errors.required&quot;&gt;File is required.&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;img [src]=&quot;imageSrc&quot; *ngIf=&quot;imageSrc&quot; style=&quot;height: 300px; width:500px&quot;&gt; &lt;button class=&quot;btn btn-primary&quot; type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 第 4 步 – 修改app.component.ts文件在此步骤中，访问 src/app 目录并打开 app.component.ts。然后在 component.ts 文件上添加以下代码，如 formGroup 和 formControl 元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { Component } from '@angular/core';import { HttpClient } from '@angular/common/http';import { FormGroup, FormControl, Validators} from '@angular/forms'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { imageSrc: string; myForm = new FormGroup({ name: new FormControl('', [Validators.required, Validators.minLength(3)]), file: new FormControl('', [Validators.required]), fileSource: new FormControl('', [Validators.required]) }); constructor(private http: HttpClient) { } get f(){ return this.myForm.controls; } onFileChange(event) { const reader = new FileReader(); if(event.target.files &amp;&amp; event.target.files.length) { const [file] = event.target.files; reader.readAsDataURL(file); reader.onload = () =&gt; { this.imageSrc = reader.result as string; this.myForm.patchValue({ fileSource: reader.result }); }; } } submit(){ console.log(this.myForm.value); this.http.post('http://localhost:8001/upload.php', this.myForm.value, httpOptions) .subscribe(res =&gt; { console.log(res); alert('Uploaded Successfully.'); }) }} 第 5 步 –创建Upload.php文件在此步骤中，创建upload.php文件并将以下代码更新到其中： 12345678910111213141516171819202122232425&lt;?php header(&quot;Access-Control-Allow-Origin: *&quot;); header(&quot;Access-Control-Allow-Methods: PUT, GET, POST&quot;); header(&quot;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept&quot;); $folderPath = &quot;upload/&quot;; $postdata = file_get_contents(&quot;php://input&quot;); $request = json_decode($postdata); $image_parts = explode(&quot;;base64,&quot;, $request-&gt;fileSource); $image_type_aux = explode(&quot;image/&quot;, $image_parts[0]); $image_type = $image_type_aux[1]; $image_base64 = base64_decode($image_parts[1]); $file = $folderPath . uniqid() . '.png'; file_put_contents($file, $image_base64); ?&gt; 请注意，upload.php文件代码将帮助您从 angular 11 应用程序在服务器上上传图像。 第 6 步 - 启动Angular应用程序和PHP服务器在此步骤中，在终端上执行以下命令以启动Angular应用程序和php服务器： 12345ng servephp -S localhost:8001 参考文档Image Upload With Preview in Angular 12/11 Angular 9/8 Image Upload and Cropper with Preview Example ngx-image-cropper demo-app Go Gin 实现文件的上传下载流读取 Go 如何利用multipart/form-data实现文件的上传与下载 Angular文件上传:完整指南 File、Blob、Base64各种图片格式之间的转换","link":"/angular/angular_upload_img.html"},{"title":"从Angular 13升级到Angular 15","text":"1. 前言升级应用程序或者框架是软件生命周期中非常重要的一项活动. 因为其有风险性, 很多人不愿意去做, 久而久之随着技术债务的积累变成了一件不能去做的事情. 在我的职业生涯中见到过很大这样逐渐失去生命活力的系统, 这里就不具体举例了, 以免引起不必要的争论, 明白的人自然明白. 本文最新更新发布于从 Angular 13 升级到 Angular 15 | 鹏叔的技术博客 其中的风险, 主要来自新旧版本的不兼容性. 如果兼容旧版本, 无疑是库开发者负责任承担起了这种风险, 但是也导致库变得臃肿, 因循守旧, 开发低效, 逐渐地失去活力. 如果库开发者一路更新向前, 不考虑向前兼容, 库开发走得轻快了, 也该库或者框架的使用者带来了很多创新性的体验, 但是把兼容性风险留给了使用者. 在兼容性, 和创新节奏, 库的活力之间看似鱼和熊掌很难兼得. 而 Angular 在兼容性和变革之间很好地为我们做出了一个榜样, 也是将来版本升级很好的榜样. 首先 Angular 是大胆变革的. 其主版本号没 6 个月就有一次变更, 自从 2016 年发布 Angular 2.x 版本后, 如今一直保持着相似的节奏, 一路升级到 Angular 16.x. 而每次主版本号的变更可能包含了大量的 breaking change 和新特性. 其中有好几个大版本之间差异是很大的. 而 Angular 是如何做到既大胆创新, 又兼顾历史遗留的呢? 那就是 Angular schematics, 它不是简单的代码生成工具. 它也是一个代码重构工具, 这样 Angular 就可以大版本变化是使用一个或多个 schematics 帮助老旧系统自动完成绝大多数的重构工作. 这样旧系统就可以轻松的升级到新版本的 Angular 了. 只要按照 Angular 提供的升级路线, 库或框架使用者就能轻松的完成升级 而 Angular 也不必在新的库中考虑老用户一些传统的习惯和使用方式, 做到轻松上阵. 无独有偶, gitlab 的升级方式也是类似的, 在大版本之间提供 postscript 来弥合新旧版本的差异, 并给使用者提供了清晰的升级路线图. 所以可以预测在将来的开发中, 这种在新旧版本之间使用 postscript 或 Schematics 的方式将逐渐成为一种版本升级的趋势. 开发过库代码的人肯定知道向前兼容是一件多么烧脑和让代码逻辑变得扭曲的事情. 而这种方式带来的坏处就是, 升级变得不像以前那么简单了, 以前升级只需要改个数字, 而现在需要去查升级路线图, 还要执行相应的弥合裂缝的代码. 但是深入思考一下, 这种牺牲还是很值得的, 因为以前开发人员改一下版本号是轻松, 但是将潜在的问题留给了测试人员, 甚至留给了运维人员, 甚至更后, 变得越来越昂贵. 而现在有一条清晰的升级路线, 而这条路线是无数人踩过的, 心里总是会踏实很多. 2. 升级前的准备工作升级前最好阅读一遍 Angular 14, 15 的 release notes. 本文讲述的是从 Angular 13 升级到 Angular 15, 所以需要阅读这两个 release notes: Angular 14 release notes 和Angular 15 release notes 里面详细描述了有那些 breaking change 那些新的弃用, 多我们的迁移工作会非常有帮助. 另外我们需要阅读一下更新指南, 这个更新指南是一个动态的指南, 需要选择从哪个版本升级到哪个版本, 项目中用到了哪些特殊包, 在此基础上系统自动帮我们生成一份更新指南, 非常人性化, 这是 Angular 升级特殊之处, 也是很容易被忽视的一点. 更新指南可以在这里找到 3. 开始升级由于本文的目标是从 Angular 13 升级到 Angular 15, 所以升级路径首先是从 Angular 13 升级到 Angular 14 再从 Angular 14 升级到 Angular 15, 不能一次性升级到 Angular 15. 3.1. Angular 13 升级到 Angular 143.1.1. 升级前准备工作阅读 angular 13-14更新指南 3.1.2. 步骤一: 更新所有 Angular 的组件到 141ng update @angular/core@14 @angular/cli@14 --force 注意，不加–force 无法正常升级。同时，还要事前事后都要 commit 一次。 3.1.3. 步骤二: 升级 Angular Material 到 v141ng update @angular/material@14 --force 该步骤只适用于使用了 Angular Material 的项目。 3.1.4. 步骤三: 更新 eslint 到 v141ng update @angular-eslint/schematics@14 如果项目中使用了 angular-eslint, 可以使用以上命令升级到 v14。 3.1.5. 步骤四：更新一些非 Angular 官方的组件123npm i @angular/flex-layout@14.0.0-beta.41 ngx-markdown@14.0.1 3.1.6. 步骤五：更新 typescript 到 4.6官方文档说，Angular 14 支持 4.6，没必要安装更新的 Typescript 版本，免得无谓的不兼容问题。 1npm install typescript@4.6.4 -D 3.1.7. 步骤六，更新代码手动解决一些更新指南中的内容. 另外一个问题，如果使用了 moment、lodash 这样的库，会报出一条 warning： material-moment-adapter.mjs depends on ‘moment’. CommonJS or AMD dependencies can cause optimization bailouts. 官方文档：链接答案是按如下更新 Angular.json 1234&quot;allowedCommonJsDependencies&quot;: [ &quot;lodash&quot;, &quot;moment&quot; ] 3.1.8. 步骤七：启动程序, 手动测试现在可以启动程序了 npm run start 或者 ng serve, 并进行一些测试和检查. 3.2. Angular 14 升级到 Angular 153.2.1. 升级前检查一下当前的环境升级前检查一下当前的环境, 做到心中有数. 123456789101112131415161718192021222324252627282930313233343536$ng version _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | '_ \\ / _` | | | | |/ _` | '__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/Angular CLI: 14.2.0Node: 18.16.1 (Unsupported)Package Manager: npm 9.5.1OS: win32 x64Angular: 14.2.0... animations, cdk, cli, common, compiler, compiler-cli, core... elements, forms, language-service, material... platform-browser, platform-browser-dynamic, platform-server... router, service-workerPackage Version---------------------------------------------------------@angular-devkit/architect 0.1402.1@angular-devkit/build-angular 14.2.1@angular-devkit/core 14.2.1@angular-devkit/schematics 14.2.0@nguniversal/builders 14.2.3@nguniversal/express-engine 14.2.3@schematics/angular 14.2.0rxjs 7.4.0typescript 4.8.4Warning: The current version of Node (18.16.1) is not supported by Angular. 3.2.2. 升级前准备工作阅读 angular 14-15更新指南 3.2.2.1. 升级 node.js由于 Angular 15, 不再支持 node.js versions 14.[15-19].x or 16.[10-12].x. PR #47730 目前兼容性比较好的是 14.20.x, 16.13.x 或者 18.10.x. 所以需要升级到其中某个版本 Angular, node 以及 typscript 的兼容性可以参考表格 Actively supported versions 升级 Nodejs 可以参考我的博客 Windows 上安装 nvm 和 nodejs 或者 安装并配置 nodejs 3.2.3. 升级 typescriptAngular 15 中不再支持 typescript 4.8 以下的版本, 如果 typescript 不是 4.8 及以上版本, 需要升级 typescript下面以typescript@4.8.4为例 1npm install typescript@4.8.4 -D 3.2.4. 步骤一: 更新所有 Angular 的组件到 151ng update @angular/core@15 @angular/cli@15 @angular/material@15 --force 为了防止一些次要组件不兼容导致主要的升级过程失败, 可以加上–force 选项. 当然如果你想再主要组件升级之前解决所有阻碍升级的问题, 则可以去掉 force 选项. 如果使用到@angular-eslint, 可以使用如下命令更新@angular-eslint 到 v15 1ng update @angular-eslint/schematics@15 3.2.5. 步骤三: 升级@nguniversal 版本如果项目中使用到@nguniversal, 需要将@nguniversal 升级到与 angular 15 匹配的版本 1234npm install --save @nguniversal/express-engine@15.2.1npm install -D @nguniversal/builders@15.2.1 完成这些步骤, 基本上应用程序可以编译, 运行! 除了 material 组件没有迁移到 MDC-based 组件, 应用的样式, 行为应该跟前一致. 3.2.6. 步骤二: 迁移 Legacy Angular material 组件到 MDC-based Angular material 组件因为从 Angular 14 到 15, material design 组件发生了比较大的变化, 所以需要执行这一步骤. 详情请阅读鹏叔的技术博客 MDC-based Angular Material 组件迁移 如果项目非常大且复杂, Angular Material component 的迁移可以 module by module, 也可以 component by component. 如果项目不是很大, 可以一次性迁移到 MDC-based Angular material 1ng generate @angular/material:mdc-migration 这条 migration 指令提供了交互式的选项，根据本身项目的特点进行选择。 3.2.7. 步骤三: 执行测试指令1ng test 在新的版本上对原代码进行编译和测试，有助于升级后的问题发现和解决。 3.2.8. 步骤四：启动程序, 手动测试现在可以启动程序了 npm run start 或者 ng serve, 并进行一些测试和检查. 123npm run start# 或者ng serve --open 4. 问题排查4.1. Issue 1升级到 Angular 15 后重新编译, 遇到如下警告 1TypeScript compiler options &quot;target&quot; and &quot;useDefineForClassFields&quot; are set to &quot;ES2022&quot; and &quot;false&quot; respectively by the Angular CLI. 分析: 在 Angular 15, typescript 的编译目标是 ES2022, 然后在通过 Babel 再次将 ES2022 编译到.browserslistrc 中定义的最终目标 所以如果 tsconfig.json 中的指定的 target 如果不是 ES2022, 编译器会给出警告. 解决办法: 这里建议升级后将 ts 的 target 修改为 ES2022, 反正最终 js 目标是由.browserslistrc 中的配置决定的. 详细分析请查看, Typescript target warnings after Angular 15 update 4.2. Issue 2在运行 prod 编译的过程中, 遇到如下错误. 如下问题 1ng build --configuration=production &amp;&amp; ng run your-app:prerender:production 123456Error: Optimization error [325.3c5087ba2c9c5885.js]: X [ERROR] Transforming const to the configured target environment (&quot;chrome114.0&quot;, &quot;edge114.0&quot;, &quot;firefox102.0&quot;, &quot;ios10.3&quot;, &quot;safari11.0&quot;) is not supported yet 325.3c5087ba2c9c5885.js:5737:6: 5737 │ const scale = this._cachedMeta.rScale; Angular 15 已经不再支持一些较旧的浏览器版本了, 基本上只能运行 ES5 版本的浏览器都不再支持了. 解决办法: 调整.browserslistrc 的配置, 如果 Angular 15 不支持的浏览器版本, 建议去除掉. 5. 相关阅读本文原文位于从 Angular 13 升级到 Angular 15, 欢迎访问原文以获得最近更新.更多 Angular 相关文章请访问Angular 合集 | 鹏叔的技术博客 6. 参考文档Angular：升级 Angular 13 到 Angular 14 Angular: 升级 Angular 14 到 Angular 15 Fix broken Angular material legacy styles glitch @material Code labs","link":"/angular/angular_upgrade_13_to_15.html"},{"title":"在Angular中使用TailwindCSS","text":"1. 前言 2. 创建 Angular 项目 3. 安装 Tailwind CSS 4. 配置您的 html 模板路径 5. 将 Tailwind 指令添加到您的 CSS 中 6. 构建 Angular 7. 开始在您的项目中使用 Tailwind 8. 插件和配置设置 8.1. 语法支持 8.2. IntelliSense for VS Code 8.3. 自动 class 排序 8.3.1. 安装 prettier-plugin-tailwindcss 9. Angular 系列文章 10. 参考文档 1. 前言本文主要讲述如何在 Angular 项目中设置 Tailwind CSS。 2. 创建 Angular 项目如果您还没有设置一个新的 Angular 项目，请首先创建一个新的 Angular 项目。 最常见的方法是使用 Angular CLI, 具体细节请参考鹏叔的技术博客 - 创建 Angular 项目 12ng new my-projectcd my-project 3. 安装 Tailwind CSS通过 npm 安装 tailwindcss，然后运行 init 命令生成 tailwind.config.js 文件。 1234npm install -D tailwindcss postcss autoprefixernpx tailwindcss init 4. 配置您的 html 模板路径配置您的模板路径在 tailwind.config.js 文件中添加所有模板文件的路径。 12345678/** @type {import('tailwindcss').Config} */module.exports = { content: [&quot;./src/**/*.{html,ts}&quot;], theme: { extend: {}, }, plugins: [],}; 5. 将 Tailwind 指令添加到您的 CSS 中将 Tailwind 每个层的 @tailwind 指令添加到 ./src/styles.css 文件中。 123@tailwind base;@tailwind components;@tailwind utilities; 6. 构建 Angular使用 终端中使用ng serve 运行构建过程。 123ng serve 7. 开始在您的项目中使用 Tailwind开始使用 Tailwind 的实用程序类来设计您的内容。 1&lt;h1 class=&quot;text-3xl font-bold underline&quot;&gt;Hello world!&lt;/h1&gt; 8. 插件和配置设置插件和配置设置，可以改善开发人员在使用 Tailwind CSS 时的体验。 8.1. 语法支持Tailwind CSS 在@Tailwind、@apply 和@screen 等规则中使用了大量自定义 CSS，在许多编辑器中，这可能会在无法识别这些规则的 IDE 下触发警告或错误。解决方案几乎是为编辑器/IDE 安装一个插件，以支持 PostCSS 语言，而不是常规 CSS。 如果你使用的是 VS Code，官方 Tailwind CSS IntelliSense 插件包括一个专用的 TailwindCSS 语言模式，该模式支持 Tailwind 使用的所有自定义 at-rules 和 functions。 在某些情况下，如果编辑器对 CSS 文件中的语法要求非常严格，则可能需要禁用原生 CSS linting/validation。 8.2. IntelliSense for VS Code官方 Tailwind CSS IntelliSense VS Code 扩展为用户提供了自动完成、语法高亮显示和 linting 等高级功能，从而增强了 Tailwind 的开发体验。 Autocomplete: 对类名以及 CSS 函数和指令的智能建议。Linting: 突出显示 CSS 和标记中的错误和潜在错误。Hover Previews: 将鼠标悬停在 Tailwind 类名上，查看完整的 CSS。Syntax Highlighting: 提供语法定义，以便正确高亮显示 Tailwind 功能。 在GitHub 上查看该项目以了解更多信息，或将其添加到 Visual Studio Code 中以立即开始。 8.3. 自动 class 排序我们为 Tailwind CSS 维护了一个官方的 Prettier 插件，它会按照我们推荐的类顺序自动对您的类进行排序。 该插件能与定制的 Tailwind 配置无缝配合，因为它只是一个 Prettier 插件，所以它可以在 Prettier 工作的任何地方工作——包括所有流行的编辑器和 IDE，当然也可以在命令行上工作。 查看GitHub 上的插件，了解更多信息并开始使用。 8.3.1. 安装 prettier-plugin-tailwindcssTailwind CSS v3.0+ 的 Prettier 插件，可根据我们推荐的类顺序自动对类进行排序。 只需安装 prettier-plugin-tailwindcss 作为开发依赖项： 123npm install -D prettier prettier-plugin-tailwindcss 9. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 10. 参考文档Install Tailwind CSS with Angular Modern CSS in Angular: Layouts","link":"/angular/angular_with_tailwind.html"},{"title":"使用Angular Universal时的重要注意事项","text":"1. 介绍尽管 Angular Universal 项目的目标是能够在服务器上无缝渲染 Angular 应用程序，但您应该考虑一些不一致之处。首先，服务器和浏览器环境之间存在明显的差异。在服务器上渲染时，应用程序处于短暂或“快照”状态。应用程序被完全渲染一次，返回完整的 HTML，而整个过程中的产生的状态被销毁，直到下一次渲染开始, 再重新计算这些状态。接下来，服务器环境本质上不具有与浏览器相同的功能（也有可能服务器拥有而浏览器没有的功能）。例如，服务器没有任何 cookie 的概念。您可以将此功能和其他功能 polyfill，但没有完美的解决方案来弥合这种差异。在后面的部分中，我们将介绍潜在的缓解措施，以减少在服务器上渲染时的错误机会。还请注意 SSR 的目标：提高应用程序的初始渲染时间。这意味着，应该避免或充分防范任何可能在初始渲染中降低应用程序速度的情况。同样，我们将在后面的部分中回顾如何实现这一点。 2. “window is not defined”使用 Angular Universal 时最常见的问题之一是服务器环境中缺少浏览器全局变量。这是因为 Angular Universal 项目使用 domino 作为服务器 DOM 渲染引擎。因此，服务器上不存在或不支持某些功能。这包括 window 和 document 全局对象、cookie、某些 HTML 元素（如 canvas）以及其他一些元素。没有详尽的列表，所以请注意，如果您看到这样的错误，其中没有定义以前可访问的全局对象，很可能是因为该全局无法通过 domino 获得。 Fun fact: Domino stands for “DOM in Node” 3. 如何解决上述问题3.1. 策略 1：Injection通常，所需的全局可以通过依赖注入（DI）通过 Angular 平台获得。例如，我们可以通过@Inject(DOCUMENT)获得 document 对象。此外，还可以通过 DOCUMENT 对象获取 window 和 location 对象。例如： 1234567891011121314151617181920// example.service.tsimport { Injectable, Inject } from &quot;@angular/core&quot;;import { DOCUMENT } from &quot;@angular/common&quot;;@Injectable()export class ExampleService { constructor(@Inject(DOCUMENT) private _doc: Document) {} getWindow(): Window | null { return this._doc.defaultView; } getLocation(): Location { return this._doc.location; } createElement(tag: string): HTMLElement { return this._doc.createElement(tag); }} 但是我们不要期望这种方法能解决所有问题. localStorage 就是一个例外, localStorage 是一个经常被请求的 API，它无法在浏览器以外良好地工作。如果您需要编写自己的库组件，而且使用到 localstorage, 请考虑使用某种方法让其在服务器上和浏览器上提供相似的功能（这就是 Angular CDK 和 Material 所做的, 可以作为一种参考）。针对 localStorage 可以使用第三方组件例如 localstorage-polyfill 来替代. 3.2. 策略 2：Guard如果我们不能从 Angular platform 注入所需的适当全局值，那么我们可以浏览器代码的调用的地方包装一层 Guard，只要您不需要在服务器上访问该代码。例如，全局窗口元素的调用通常是为了获取窗口大小或其他一些视觉元素。然而，在服务器上，没有“Screen”的概念，因此很少需要此功能。您可以在网上或其他地方阅读到，建议使用 isPlatformBrowser 或 isPlatformServer。这种指南不太合适的方法。这是因为您最终会在应用程序代码中创建特定于平台的 if-else 分支代码。这不仅不必要地增加了应用程序的复杂度，而且还增加了必须维护的复杂性。通过依赖注入（DI）将代码分离为单独的特定于平台的模块和实现，您的业务代码可以保留关于业务逻辑的内容，而特定与平台的差异部分可以留给特定与平台的模块来处理, 并逐个案例逐个案例的完善抽象出来的 Guard 层。下面是一个例子： 123456789// window-service.tsimport { Injectable } from &quot;@angular/core&quot;;@Injectable()export class WindowService { getWidth(): number { return window.innerWidth; }} 12345678910// server-window.service.tsimport { Injectable } from &quot;@angular/core&quot;;import { WindowService } from &quot;./window.service&quot;;@Injectable()export class ServerWindowService extends WindowService { getWidth(): number { return 0; }} 123456789101112// app-server.module.tsimport {NgModule} from '@angular/core';import {WindowService} from './window.service';import {ServerWindowService} from './server-window.service';@NgModule({ providers: [{ provide: WindowService, useClass: ServerWindowService, }]}) 如果您有一个由第三方提供的组件，该组件与在各 Angular platform 上的行为不兼容，那么除了基本应用程序模块外，您还可以为浏览器和服务器创建两个单独的模块。基本应用程序模块将包含您所有的平台无关代码，浏览器模块将包含所有特定于浏览器的代码, 而服务器模块包含所有特定于服务器的代码. 而如果该组件对浏览器友好, 那么浏览器模块不必写太大代码，反之亦然。为了避免编辑过多的模板代码，可以创建一个无操作组件来放置库组件。下面是一个例子： 123456789// example.component.tsimport { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;example-component&quot;, template: `&lt;library-component&gt;&lt;/library-component&gt;`, // this is provided by a third-party lib // that causes issues rendering on Universal})export class ExampleComponent {} 123456789// app.module.tsimport {NgModule} from '@angular/core';import {ExampleComponent} from './example.component';@NgModule({ declarations: [ExampleComponent],}) 12345678910// browser-app.module.tsimport {NgModule} from '@angular/core';import {LibraryModule} from 'some-lib';import {AppModule} from './app.module';@NgModule({ imports: [AppModule, LibraryModule],}) 12345678// library-shim.component.tsimport { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;library-component&quot;, template: &quot;&quot;,})export class LibraryShimComponent {} 12345678910// server.app.module.tsimport { NgModule } from &quot;@angular/core&quot;;import { LibraryShimComponent } from &quot;./library-shim.component&quot;;import { AppModule } from &quot;./app.module&quot;;@NgModule({ imports: [AppModule], declarations: [LibraryShimComponent],})export class ServerAppModule {} 3.3. 策略 3：Shims如果以上所有策略都不能符合要求，并且您只需要访问某种浏览器功能，那么您可以修补服务器环境的 Global 变量，以包括所需的全局。例如： 1234// server.tsglobal['window'] = { // properties you need implemented here...}; 这种策略可以应用于任何浏览器环境有而服务环境未定义的元素。当你这样做的时候请小心，因为玩全局变量通常被认为是一种反模式。 fun fact：同样是功能补丁，shim 在以及存在的各 Angular platform 上永远不受支持。而 polyfill 是计划被支持的功能补丁，或者在较新版本的 platform 上以及被支持的功能 4. 应用程序速度慢，甚至无法渲染Angular Universal 渲染过程很简单，但也可以被善意或无意识的代码阻止或减慢。首先，渲染过程的一些异步进程。当对 platform-server （Angular Universal 平台）发出渲染请求时，将执行单一路线导航。当导航完成时，也就是说所有 Zone.js 宏任务都完成了，无论当时处于什么状态(完整或不完整)的 DOM 都会返回给用户。 A Zone.js macrotask is just a JavaScript macrotask that executes in/is patched by Zone.js 这意味着，如果有一个进程（如 microtask）需要占用一定数量的 CPU 时间片来才能完成，或者存在一个非常耗时的 HTTP 连接请求，则渲染过程将无法完成或者需要相当长的时间。宏任务包括对全局变量（如 setTimeout 和 setInterval）以及 Observables 的调用。调用它们而不取消它们，或者让它们在服务器上运行的时间超过所需的时间可能会导致渲染效果欠佳。 如果您还不知道微任务和宏任务的差别，可能值得复习 JavaScript 事件循环并学习微任务和宏任务之间的区别。这里有一个很好的参考。 5. HTTP，Firebase，WebSocket 等在渲染之前不会完成与上面关于等待宏任务完成的部分类似，另一方面是平台不会等待微任务完成才完成渲染。在 Angular Universal 中，我们修补了 Angular HTTP 客户端，将其转换为宏任务，以确保给定渲染的任何所需的 HTTP 请求都已完成。但是，这种类型的补丁可能并不适合所有微任务，因此建议您对如何进行进行最佳判断。您可以查看代码参考，了解 Universal 如何包装任务以将其转换为宏任务，或者您可以简单地选择更改给定任务的服务器行为。 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Important Considerations when Using Angular Universal","link":"/angular/consideration_on_angular_universal.html"},{"title":"使用Gradle整合angular和Spring boot","text":"1. 前言 2. 前置条件 3. 创建后端项目 4. 创建前端项目 5. 使用 gradle 将前后端整合 5.1. 配置 angular 项目 5.2. 配置 spring boot 项目 5.3. 自动化工程 6. Angular 系列文章 7. 总结 8. 参考文档 1. 前言本文讲述如何使用 Gradle 搭建一个以 springboot 技术栈作为后端, 使用 Angular 作为前端技术栈, 同过 gradle 将其整合成一个项目的实践经验. 这里只是作为一种实践, 并不建议在生产环境中将前后端耦合在一起. 本文的目的是拓展 Spring 在(SPA)Single page Application 一种能力, 即将实现项目依赖关系, 测试,打包等等自动化. 实现思路就是通过 Gradle task 触发 npm build, 将编译后的静态资源文件, 部署到 springboot 的静态资源文件目录, 然后沿用后端打包过程, 将前后端应用程序整合在一起. 2. 前置条件项目需要用到 Nodejs, angular cli, gradle, 需要提前储备相关知识和安装环境. 3. 创建后端项目可以使用Spring’s Initializr 工具来快速的创建一个工程. 也可以参考我的文档如何手动创建一个 springBoot 项目, 里面有对 springBoot 项目的详细解释. 4. 创建前端项目创建完成后端 springboot 项目后, 进入 src/main/目录下创建前端项目. 123ng new webapp 对于如何创建 Angular 项目,详细信息可以参考我的博客创建 Angular 项目 5. 使用 gradle 将前后端整合将 springboot 项目和 angular 项目整合的关键就是: 首先调用 ng build, 将编译后的文件放到 springboot 的 static 目录下. 5.1. 配置 angular 项目首先我们修改一下 angular 的配置文件 angular.json, 找到 architect.build.options.outputPath 属性, 将其指向 springBoot 项目的 src/resources 目录 这里我们使用相对路径. 1&quot;outputPath&quot;: &quot;../resources/static&quot;, 此时我们以及可以手动编译一下前端工程, 看其是否会将编译后的文件输出到指定路径下. 1234cd webappng build 此时我们可以看到编译的结果输出到了 resources/webapp 123456789$tree ../resources/staticstatic├── 3rdpartylicenses.txt├── favicon.ico├── index.html├── main.e25f0772ec365244.js├── polyfills.8e0c5f95042fa80f.js├── runtime.2ab56e4f659c1314.js└── styles.ef46db3751d8e999.css 注意这里的 index.html, 当我们在稍后启动了 springboot, 使用浏览器访问http://localhost时首先需要加载的就是这个文件. 5.2. 配置 spring boot 项目此时我们已经有了 html 文件, 以及 js 等等文件, 我们只需要在 springboot 项目的配置文件中, 将静态资源文件目录指向../resources/webapp. 修改 springboot 项目的配置文件 1spring.resources.static-locations=classpath:/static 并指定端口号 80, 此项配置是可选的, 默认 springBoot web 会监听在 8080, 此处只是为了方便后续讲解, 所以将端口号修改到 80 端口. 1server.port= 80 此时我们启动 springBoot 1./gradlew bootRun 启动成功后, 打开浏览器访问http://localhost 即可看到一个 default 的 angular 应用了. 5.3. 自动化工程前面的过程中, 我们需要手动执行ng build命令将 web 相关文件输出到 src/resources/static 目录下. 每次编译还需要手动清理文件. 而我们的目标是执行./gradlew bootRun时自动执行这一过程. 将这一段加入到我们 build.gradle 中即可在编译, 打包, 运行之前执行我们手动执行的部分. 代码很好理解, 注释也已经写的很清楚了, 这里就不做过多解释了, 也就是手工过程的替代. 12345678910111213141516171819202122232425262728293031323334def webappDir = &quot;$projectDir/src/main/webapp&quot;processResources { dependsOn &quot;buildAngular&quot;}task buildAngular(type:Exec) { // installAngular should be run prior to this task dependsOn &quot;installAngular&quot; workingDir &quot;$webappDir&quot; inputs.dir &quot;$webappDir&quot; // Add task to the standard build group group = BasePlugin.BUILD_GROUP // ng doesn't exist as a file in windows -&gt; ng.cmd if (System.getProperty(&quot;os.name&quot;).toUpperCase().contains(&quot;WINDOWS&quot;)){ commandLine &quot;ng.cmd&quot;, &quot;build&quot; } else { commandLine &quot;ng&quot;, &quot;build&quot; }}task installAngular(type:Exec) { workingDir &quot;$webappDir&quot; inputs.dir &quot;$webappDir&quot; group = BasePlugin.BUILD_GROUP if (System.getProperty(&quot;os.name&quot;).toUpperCase().contains(&quot;WINDOWS&quot;)){ commandLine &quot;npm.cmd&quot;, &quot;install&quot; } else { commandLine &quot;npm&quot;, &quot;install&quot; }} 完成以上配置我们就可以执行以下命令, 启动 springBoot 项目了, 在浏览器上敲入http://localhost就可以访问基于 Angular 的 SPA 应用了. 123./gradlew bootRun 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 总结本文详细讲述了如何创建 springBoot 工程以及 Angular 工程, 并通过 gradle 将前后端工程整合起来. 秘诀就是将 angular 工程的 output 输出到 springboot 的静态资源目录下. 如果要更加深入的探索 Angular 以及 SpringBoot, 可以移步到鹏叔的技术博客https://pengtech.net, 空间中提供了博客内搜索功能, 输入相关关键字进行探索吧. 8. 参考文档Angular + Spring Boot integration using Gradle","link":"/angular/integrate_springboot_angular_using_gradle.html"},{"title":"如何手动引导 Angular 应用程序","text":"Angular 官方文档指出，要引导应用程序，您必须将以下内容放入文件中 main.ts： 1. Angular 应用启动过程1platformBrowserDynamic().bootstrapModule(AppModule); 声明的第一部分 platformBrowserDynamic()创建了一个平台。Angular 文档将该平台描述为： 网页上 Angular 的入口点。每个页面都只有一个平台，并且该页面上运行的每个 Angular 应用程序所共有的服务（例如反射）都绑定在其范围内。 Angular 还有一个running application instance的概念，您通常可以使用令牌注入该实例 ApplicationRef。一个平台上可能有许多应用程序。每个应用程序都是从基于 Module 定义使用 bootstrapModule 创建的。正如示例中 main.ts 所做的一样。因此，文档中显示的语句首先创建一个平台，然后创建应用程序实例。 创建应用程序时，Angular 会检查模块（ 例如： AppModule）的 bootstrap 属性用于引导应用程序的： 1234567@NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],})export class AppModule {} 该属性通常引用您想要用来引导应用程序的组件。然后 Angular 在 DOM 中找到引导组件的选择器元素并初始化该组件。 上述过程意味着您知道要使用哪个组件来引导应用程序。但想象一下这样一种情况：引导应用程序的组件是由服务器在运行时定义的。当您获得此信息后，如何引导应用程序？ 2. NgDoBootstrap假设我们有两个组件 A 组件 和 B 组件。我们将在运行时决定应用程序中应使用哪一个组件。让我们定义这两个组件： 12345678910111213import { Component } from &quot;@angular/core&quot;;@Component({ selector: &quot;a-comp&quot;, template: `&lt;span&gt;I am A component&lt;/span&gt;`,})export class AComponent {}@Component({ selector: &quot;b-comp&quot;, template: `&lt;span&gt;I am B component&lt;/span&gt;`,})export class BComponent {} 我们将它们注册到 AppModule 中： 123456@NgModule({ imports: [BrowserModule], declarations: [AComponent, BComponent], entryComponents: [AComponent, BComponent],})export class AppModule {} 这里需要强调的一点是我们不将它们注册在 bootstrap 属性，因为我们将手动引导它们。另外，我们应该在 entryComponents 中注册它们，因为我们希望编译器为它们创建工厂。Angular 会自动将入口组件属性中指定的所有组件添加到 bootstrap，这就是为什么您通常不将根组件添加到 entryComponents. 另外，由于我们不知道是否会使用 A 或 B 组件，因此我们没有在 index.html 中指定选择器，所以现在 index.html 看起来像这样： 123&lt;body&gt; &lt;h1 id=&quot;status&quot;&gt;Loading AppComponent content here ...&lt;/h1&gt;&lt;/body&gt; 现在，如果您现在运行该应用程序，您将收到以下错误： 1The module AppModule was bootstrapped, but it does not declare “@NgModule.bootstrap” components nor a “ngDoBootstrap” method. Please define one of these Angular 通过错误信息告诉我们没有指定应该使用什么组件来进行引导。而且我们事先并不知道。稍后我们将手动引导应用程序，为此我们需要将 ngDoBoostrap 方法添加到 AppModule 中： 123export class AppModule { ngDoBootstrap(app) {}} Angular 将以 ApplicationRef 的形式将对正在运行的应用程序的引用传递给 ngDoBootstrap 方法。稍后，当我们准备好引导应用程序时，我们将使用 ApplicationRef 的 bootstrap 方法来初始化根组件。 让我们定义一个自定义方法，bootstrapRootComponent 该方法将负责在根组件可用时引导它： 123456789101112131415161718192021// app - reference to the running application (ApplicationRef)// name - name (selector) of the component to bootstrapfunction bootstrapRootComponent(app, name) { // define the possible bootstrap components // with their selectors (html host elements) const options = { &quot;a-comp&quot;: AComponent, &quot;b-comp&quot;: BComponent, }; // obtain reference to the DOM element that shows status // and change the status to `Loaded` const statusElement = document.querySelector(&quot;#status&quot;); statusElement.textContent = &quot;Loaded&quot;; // create DOM element for the component being bootstrapped // and add it to the DOM const componentElement = document.createElement(name); document.body.appendChild(componentElement); // bootstrap the application with the selected component const component = options[name]; app.bootstrap(component);} 我还创建了一个模拟 fetch 函数，它模拟向服务器发送请求，并返回 b-comp 的选择器： 1234567function fetch(url) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(&quot;b-comp&quot;); }, 2000); });} 现在我们有了 bootstrap 引导根组件的函数，让我们在 ngDoBootstrap 模块的方法中使用它： 12345678export class AppModule { ngDoBootstrap(app) { fetch('url/to/fetch/component/name') .then((name)=&gt;{ this.bootstrapRootComponent(app, name)}); }} 就是这样。这是演示解决方案的stackblitz 示例。 3. 它可以与 AOT 一起使用吗？是的，当然可以。您只需预编译所有组件并在引导应用程序时使用工厂： 123456789101112131415161718192021import { AComponentNgFactory, BComponentNgFactory,} from &quot;./components.ngfactory.ts&quot;;@NgModule({ imports: [BrowserModule], declarations: [AComponent, BComponent],})export class AppModule { ngDoBootstrap(app) { fetch(&quot;url/to/fetch/component/name&quot;).then((name) =&gt; { this.bootstrapRootComponent(app, name); }); } bootstrapRootComponent(app, name) { const options = { &quot;a-comp&quot;: AComponentNgFactory, &quot;b-comp&quot;: BComponentNgFactory, }; }} 请注意，我们不需要在 entryComponents 中指定组件，因为我们已经有了工厂并且不需要编译它们。 4. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 5. 参考How to manually bootstrap an Angular application","link":"/angular/manually_bootstrap_an_Angular_application.html"},{"title":"使用mat-paginator在Angular mat表中进行服务器端分页","text":"1. 前言在上一篇文章中，我们学习了如何使用 Angular 添加客户端分页。mat-tablemat-paginator 在客户端分页中，我们将从服务器一次获取所有记录并使用 mat-paginator 组件应用分页。 但是，如果我们的数据量很大，即记录数量较多，那么应用客户端分页并不是一个好主意。 这可能会导致严重的性能影响。 在这种情况下，我们将在 Angular mat-table 中实现服务器端分页。 2. 什么是 Angular 服务器端分页？假设我们必须在 Angular mat-table 组件中显示 1000 条记录. 在客户端分页示例中, 我们将从服务器获取所有 1000 条记录并将其绑定到 mat-table 的数据源，并进一步使用 mat-paginator 组件实现分页功能。 使用 HttpClient.get()从服务器获取 1000 条记录可能会很慢。 服务器必须从数据库中读取所有记录并将其以 JSON 格式返回给客户端。JSON 数据会非常大。 可能 1000 条记录没什么大不了的，想象一下加载大约 1,00,000 条记录会怎样？ 这样带来的后果是, 每次用户请求数据时, 服务器的内存, 包括 CPU 的处理压力会非常大, 网络带宽占用会非常严重. 客户端也会显得特别卡顿, 延迟会非常久. 通常情况下, 用户一次也浏览不了如此多的数据, 造成了非常大的性能浪费, 而带来的实际用户体验也不好. 于是 Server side 分页技术应运而生. Server side 分页是怎样做的呢? 在 mat-table 的服务器端分页分页技术中, 我们只展示首页数据, 相应的页数和每一页的记录条数. 通过单击下一页或页码，它将再次去服务器端获取并呈现相应页面的数据。 假设我们的页面大小是“10”。 我们将在初始加载时仅从服务器获取前 10 条记录并将其显示在 UI 中，而不是一次性获取 1000 条记录。 如果用户点击第二页，我们将再次调用服务器来获取接下来的 10 条记录。 所以每次我们点击下一页或页码时我们都会去服务器获取相应的页面记录。这称为服务器端分页。 服务器 API 应该接受页面大小和页码参数。 这是在 Angular 中实现服务器端分页的最低要求。 来自服务器的数据应具有以下数据格式。 12345678910Server API : &quot;/api/users?currentPage=1&amp;pageSize=6&quot;// returns{ data: [{},{}] currentPage: 1 pageSize: 6 totalPages: 2 totalRecords: 12} 该 data 属性包含要在 mat-table 中显示的记录. currentPage 只是页码。 其余属性 pageSize、totalPages 和 totalRecords 比较好理解。 您的 JSON 数据不必采用上述格式，但这些属性是必要的，并且在显示表记录时会很有帮助。 它是广泛接受的服务器端分页格式。 3. 在 Angular 中实现服务器端分页的步骤3.1. 添加 mat-paginator 到 mat-table首先，我们将使用 向材料表添加分页 mat-paginator。 123456789101112131415&lt;table mat-table [dataSource]=&quot;dataSource&quot; class=&quot;mat-elevation-z8&quot;&gt; &lt;ng-container [matColumnDef]=&quot;column&quot; *ngFor=&quot;let column of displayedColumns&quot;&gt; &lt;th mat-header-cell *matHeaderCellDef&gt;{{ column }}&lt;/th&gt; &lt;td mat-cell *matCellDef=&quot;let emp&quot;&gt;{{ emp[column] }}&lt;/td&gt; &lt;/ng-container&gt; &lt;tr mat-header-row *matHeaderRowDef=&quot;displayedColumns&quot;&gt;&lt;/tr&gt; &lt;tr mat-row *matRowDef=&quot;let emprow; columns: displayedColumns&quot;&gt;&lt;/tr&gt;&lt;/table&gt;&lt;mat-paginator #paginator [pageSizeOptions]=&quot;pageSizes&quot; showFirstLastButtons&gt;&lt;/mat-paginator&gt; 在 component.ts 文件中 1234567dataSource = new MatTableDataSource&lt;Employee&gt;();@ViewChild('paginator') paginator: MatPaginator;pageSizes = [3, 5, 7]; 在此示例中，我们将在 mat-table 显示员工列表。 123456789export interface Employee { id: number; first_name: string; last_name: string; email: string; avatar: string;} 3.2. 添加 length 属性 mat-paginator 上mat-paginator 有一个属性叫 length，它表示 mat-table 中的记录总数。 我创建了一个名为的变量 totalDataRecords 并将其绑定到该 length 属性。 我创建了一个名为的变量 totalDataRecords 并将其绑定到该 length 属性。 12345678&lt;mat-paginator #paginator [length]=&quot;totalDataRecords&quot; [pageSizeOptions]=&quot;pageSizes&quot; showFirstLastButtons&gt;&lt;/mat-paginator&gt; 3.3. 创建支持页码和页面大小参数的 API如上所述，我们的服务器 API 应该接受页码和页面长度参数，以实现服务器端分页。 这里, 我没有打算讲解服务器端如何实现这样的 API, 我打算利用一个第三方实现的 API, 我们将重点放在前端 mat-table 和 mat-paginator 的讲解上. 至于后端使用什么技术实现, 如何优雅地实现, 我们将有单独的文章讲解, 关注鹏叔的技术博客第一时间获得更新. 当前我将使用第三方 API https://reqres.in，它返回员工详细信息列表，并且还接受两个名为 page 和的参数 per_page。 1https://reqres.in/api/users?page=1&amp;per_page=5 这里 page 只是页码，per_page 代表页面大小。 3.4. 创建服务现在我们将创建一个名为 的服务 EmployeeService，其方法为 getEmployees()。 在这个方法中，使用方法我们将调用 API。HttpClient.get() 123456789101112export class EmployeeService { constructor(private http: HttpClient) {} public getEmployees( pageNumber: Number, pageSize: Number ): Observable&lt;EmployeeTable&gt; { const url = `https://reqres.in/api/users?page=${pageNumber}&amp;per_page=${pageSize}`; return this.http.get&lt;EmployeeTable&gt;(url); }} 在上面的代码中，我使用了 EmployeeTableobject 而不是 Employee，这是因为我们的服务器 API 以以下格式返回数据。 1234567export interface EmployeeTable { data: Employee[]; page: number; per_page: number; total: number; total_pages: number;} 将此服务注入到我们的 component.ts 文件中。 1234567constructor(public empService: EmployeeService) {} getTableData$(pageNumber: Number, pageSize: Number) { return this.empService.getEmployees(pageNumber, pageSize); } 我在 component.ts 文件中添加了一个本地方法，该方法 getEmployees()调用 EmployeeService. 3.5. 订阅 mat-paginator 页面事件mat-paginator 包含一个名为 的属性 page，其 EventEmitter 类型为 PageEvent。 并且会在分页器更改页面大小或页面索引（即页码）时触发。 在 ngAfterViewInit()方法中，可以订阅 this.paginator.page 事件。 1234567891011121314151617181920212223242526ngAfterViewInit() { this.dataSource.paginator = this.paginator; this.paginator.page .pipe( startWith({}), switchMap(() =&gt; { return this.getTableData$( this.paginator.pageIndex + 1, this.paginator.pageSize ).pipe(catchError(() =&gt; observableOf(null))); }), map((empData) =&gt; { if (empData == null) return []; this.totalDataRecords = empData.total; return empData.data; }) ) .subscribe((empData) =&gt; { this.EmpData = empData; this.dataSource = new MatTableDataSource(this.EmpData); }); } 以上示例使用了一系列 Rxjs 算子，例如 startWith 和 switchMap 和 map 以及分页器的 PageEvent。 在 switchMap 操作符中，我返回 getTableData$带有页码和页面大小参数的 observable。 mat-paginator 包含 pageIndex 和 pageSize 属性，表示 的页码和页面大小。 mat-table 从零开始 pageIndex，我将添加+1 到页面索引。 在 map 运算符中，我从 dataEmployeeTable 的属性 totalDataRecords 返回员工记录总条数。 最后在订阅方法中，将员工数据分配给 mat-table 的数据源。 每当 发生变化时 mat-paginator，即当我们单击上一页/下一页链接或更改页面大小时，就会调用上述页面事件，并且表数据将相应更新。 3.6. 添加进度条由于我们在每个 mat-paginator 更改事件都会调用服务器 API ，因此最好将进度条添加到 mat-table 如果服务器调用花费太多时间，则会向用户指示数据正在加载。 我们用它 mat-progress-bar 来表示表记录的加载。 123456789101112131415161718&lt;h2&gt;mat-table server side pagination&lt;/h2&gt;&lt;table mat-table [dataSource]=&quot;dataSource&quot; class=&quot;mat-elevation-z8&quot;&gt; &lt;ng-container [matColumnDef]=&quot;column&quot; *ngFor=&quot;let column of displayedColumns&quot;&gt; &lt;th mat-header-cell *matHeaderCellDef&gt;{{ column }}&lt;/th&gt; &lt;td mat-cell *matCellDef=&quot;let emp&quot;&gt;{{ emp[column] }}&lt;/td&gt; &lt;/ng-container&gt; &lt;tr mat-header-row *matHeaderRowDef=&quot;displayedColumns&quot;&gt;&lt;/tr&gt; &lt;tr mat-row *matRowDef=&quot;let emprow; columns: displayedColumns&quot;&gt;&lt;/tr&gt;&lt;/table&gt;&lt;mat-progress-bar mode=&quot;indeterminate&quot; *ngIf=&quot;isLoading&quot;&gt;&lt;/mat-progress-bar&gt;&lt;mat-paginator #paginator [length]=&quot;totalData&quot; [pageSizeOptions]=&quot;pageSizes&quot; showFirstLastButtons&gt;&lt;/mat-paginator&gt; 并使用 isLoading 变量显示顶部的进度条 mat-paginator。 4. mat-table 服务器端分页示例 StackBlitz Demo这是 mat-table 分页示例的演示https://stackblitz.com/edit/angular-mat-table-server-side-pagination-example 5. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 6. 参考文档Server Side Pagination in Angular mat-table using mat-paginator","link":"/angular/server_side_pagination.html"},{"title":"Service worker和PWA","text":"1. 前言本文向你介绍什么是 PWA, 以及如何在 Angular 项目中启用 PWA。然后使用一个示例向您展示一个正在运行的 service worker，演示如何加载和如何在客户端缓存数据。 2. 什么是渐进式应用 PWA？渐进式 Web 应用程序可提供高水平的用户体验，因为它具有与 Native app 相同的功能。如今，PWA 已经成为一件大事，越来越多的公司正在转向渐进式 Web 应用程序 (PWA)。 PWA 不需要通过应用商店部署；相反，我们采取稍微不同的方法，通过 URL 通过 Web 服务器进行部署。为了制作与原生应用程序相同的 PWA，我们必须满足以下要求。 2.1. 响应式(Responsive)几乎可以在适配所有设备桌面、移动设备或平板电脑上运行。 2.2. 自动更新Service worker 始终保持更新。 2.3. 安全的使用 HTTPS 提供内容，确保内容在传输过程中是安全的。 2.4. 可靠连接Service Worker 支持使其在离线和低速网络上工作。 2.5. 渐进式的Web 应用程序采用现代 Web 功能为每个用户提供类似应用程序的体验。 2.6. 可搜索可以通过搜索引擎进行搜索 2.7. 注重用户体验通过采用与 Native app 相同的交互方法，在性能上获得类似于 Native app 的用户体验。 3. 前置条件在阅读本文以前最好对Angular service worker有基本的了解 4. 在项目中添加 Service Worker要在项目中设置 Angular Service Worker，请使用 CLI 命令 ng-add@Angular/pwa。它通过添加@angular/service-worker 包以及设置必要的支持文件，将您的应用程序配置为使用 Service Worker。 1ng add @angular/pwa --project &lt;project-name&gt; 该命令完成以下操作 添加@angular/service-worker 到工程 在 CLI 中启用 service worker 构建支持 在 application 模块中导入并注册 service worker 更新 index.html 文件:包括一个添加 manifest.webmanifest 文件的链接为主题颜色添加 meta tag 添加图标文件 创建名为 ngsw-config.json 的 service worker 配置文件，该文件指定缓存行为和其他设置。 现在, 我们再次编译项目 123ng build Angular 项目现在已设置为使用 Angular service worker。 5. 探究 Service worker本节使用一个示例应用程序演示 service worker 如何工作. 5.1. 初始加载在服务器运行的情况下，打开浏览器访问http://localhost:8080.应用程序应该正常被加载。 提示: 在测试 Angular Service worker 时，最好使用无痕浏览模式或者私密浏览模式在浏览器开一个全新的窗口，以确保 Service worker 不会从以前的剩余状态中读取信息，避免一些怪异行为。If you are not using HTTPS, the service worker will only be registered when accessing the application on localhost.注意: 在使用 HTTPS 访问应用或 HTTP 访问 localhost 上的应用时才会注册 service worker 。 5.2. 模拟网络问题若要模拟网络问题，请禁用应用程序的网络交互。在 Chrome 中：选择“工具”&gt;“开发工具”（从右上角的 Chrome 菜单中）。转到“网络”选项卡。在“限制”下拉菜单中选择“脱机”。 现在应用程序无法访问网络。对于不使用 Angular service worker 的应用程序，现在刷新会显示 Chrome 的断开互联网连接的页面，上面写着“没有互联网连接”。随着 Angular service worker 的加入，应用程序的行为发生了变化。刷新时，页面加载正常。从“网络”选项卡可以看出 service worker 处于 active 状态。 注意: 在“size”列下，请求状态为（ServiceWorker）。这意味着没有从网络加载资源。相反，它们是从 service worker 的缓存中加载的。 5.3. 哪些内容被缓存了？请注意，浏览器渲染此应用程序所需的所有文件都已缓存。ngsw-config.json 样板文件配置用于缓存的特定资源： index.html favicon.ico Build artifacts (JS and CSS bundles) Anything under assets 直接在配置的 outputPath（默认情况下./dist/&lt;projectname&gt;/）或 resourcesOutputPath 下的图像和字体。有关这些选项的详细信息，请参阅 ng build。 注意两个关键点：生成的 ngsw-config.json 包括一个有限的可缓存字体和图像扩展列表。在某些情况下，您可能需要修改 glob 模式以满足您的需要。如果在生成配置文件后修改了 resourcesOutputPath 或 assets 路径，则需要在 ngsw-config.json 中手动更改路径。 5.4. 对应用程序进行更改现在，您已经了解了 service worker 如何缓存应用程序，下一步是了解更新的工作原理。对应用程序进行更改，并观察 service worker 安装更新： 如果您正在在无痕模式下进行测试，请打开第二个空白标签页。这样可以在测试期间保持无痕状态和缓存处于活动状态。 关闭应用程序选项卡，但不关闭窗口。这也应该关闭开发者工具。 关闭 http-server。 打开 src/app/app.component.html 进行编辑。 更改文本欢迎使用 ！to Bienvenue à Service worker和PWA！. 再次构建并运行服务器： 12ng buildhttp-server -p 8080 -c-1 dist/&lt;project-name&gt; 5.5. 在浏览器中更新应用程序现在看浏览器和 service worker 如何处理更新后的应用程序。 在同一窗口中再次打开 http://localhost:8080, 注意是同一个窗口。会发生什么？ 此时页面内容没有变化, 即使我们已经修改了页面内容. 这里出了什么问题？实际上没什么。Angular service worker 正在执行其工作并提供已安装的应用程序版本，即使页面有更新也是如此。为了提高速度，服务工作进程不会在为已缓存的应用程序提供服务之前等待检查更新。 查看 http-server 日志信息可以看到 service worker 向服务器端请求了 /ngsw.json。但是为了追求响应速度 service worker 没有等待/ngsw.json 中的更新到来即返回了之前 installed 的页面内容, 这是服务工作进程检查更新的方式。 刷新页面 让我们刷新一下页面, 此时我们就能看到更新后的内容了.此过程中, service worker 在后台安装了应用程序更新后的版本，重新加载页面时，服务工作进程将切换到最新版本。 5.6. 更多关于 Angular service worker 的信息您可能还对以下内容感兴趣： App Shell Communicating with service workers 6. Angular 系列文章最新更新以及更多 Angular 相关文章请访问 Angular 合集 | 鹏叔的技术博客 7. 参考文档Getting started with service workers PWA ng-add schematic does not work if bootstrapApplication is used (standalone)","link":"/angular/service_workers_and_pwa.html"},{"title":"useSignal()才是Web框架的未来","text":"signal 是一种存储应用程序状态的方法，类似于 React 中的 useState()。但有一些关键的差异赋予了 Signals 另外的优势。 什么是 signal 信号和状态之间的主要区别在于信号返回一个 getter 和一个 setter，而非响应式系统返回一个值（和一个 setter）。注意：一些反应式系统一起返回 getter/setter，有些作为两个单独的引用返回，但想法是相同的。 状态参考 vs. 状态值问题在于“State”一词混淆了两个不同的概念。 StateReference：状态引用是对状态的引用。StateValue：这是存储在状态引用/存储中的实际值。 为什么返回 getter 比返回值更好？因为通过返回 getter，您可以将状态引用的传递与状态值的读取分开。 让我们以这个 SolidJS 代码为例。 1234export function Counter() { const [getCount, setCount] = createSignal(0); return &lt;button onClick={() =&gt; setCount(getCount() + 1)}&gt;{getCount()}&lt;/button&gt;;} createSignal()：分配 StateStorage 并将其初始化为 0。getCount：对您可以传递的 store 的引用。getCount()：表示检索状态值。 我不明白！对我来说看起来一样上面的例子解释了信号与良好的旧状态有何不同，但没有解释为什么我们应该这样做。 信号是反应性的！这意味着他们需要跟踪谁对状态（订阅）感兴趣，并且如果状态发生变化，则通知订阅者状态变化。 为了做出反应，信号必须收集谁对信号的值感兴趣。他们通过观察状态获取器在什么上下文中被调用来获取此信息。通过从 getter 检索值，您可以告诉信号该位置对该值感兴趣。如果值发生变化，则需要重新评估该位置。换句话说，调用 getter 会创建一个 subscription。 这就是为什么传递状态获取器而不是状态值很重要。状态值的传递不会向信号提供有关该值实际使用位置的任何信息。这就是为什么区分状态参考和状态值在信号中如此重要。 为了进行比较，这里是 Qwik 中的相同示例。请注意， (getter/setter) 已被替换为具有.value 属性（代表 getter/setter）的单个对象。虽然语法不同，但内部工作原理保持不变。 1234export function Counter() { const count = useSignal(0); return &lt;button onClick={() =&gt; count++}&gt;{count.value}&lt;/button&gt;;} 重要的是，当单击按钮并且值增加时，框架只需将文本节点从 0 更新为 1。它可以做到这一点，因为在模板的初始渲染期间，信号已获知 count.value 仅由文本节点访问。因此它知道如果 count 值发生变化，它只需要更新文本节点而无需更新其他内容。 useState()的缺点我们来看看 React 是如何使用的 useState()以及它的缺点。 1234export function Counter() { const [count, setCount] = useState(0); return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;} React useState()返回一个状态值。这意味着 useState()不知道状态值如何在组件或应用程序内部使用。这意味着，一旦您通过 setCount()调用通知 React 状态更改，React 就不知道页面的哪一部分需要更改，因此必须重新渲染整个组件。这种计算开销是昂贵的。 useRef()与 useSignal()的区别React 有 useRef()，与 类似 useSignal()，但它不会导致 UI 重新渲染。这个例子看起来很相似，但是它与 useSignal()还是有一些区别。 1234export function Counter() { const count = useRef(0); return &lt;button onClick={() =&gt; count.current++}&gt;{count.current}&lt;/button&gt;;} useRef()与 useSignal() 表面上看起来完全相同，用于传递对状态的引用而不是状态本身。但是 useRef()缺少的是订阅跟踪和通知。 好的一点是，在基于信号的框架中，useSignal() 和 useRef()是写法上几乎是相同的。useSignal()可以算是 useRef()加上订阅跟踪。这进一步简化了框架的 API 接口。 useMemo()内置信号很少需要记忆，因为它们开箱即用的工作量最少。 考虑这个包含两个计数器和两个子组件的示例。 1234567891011121314151617181920212223export function Counter() { console.log(&quot;&lt;Counter/&gt;&quot;) const countA = useSignal(0); const countB = useSignal(0); return ( &lt;div&gt; &lt;button onClick$={()=&gt; countA.value++}&gt; A &lt;/button&gt; &lt;button onClick$={()=&gt; countB.value++}&gt; B &lt;/button&gt; &lt;Display count={countA.value}&gt; &lt;Display count={countB.value}&gt; &lt;/div&gt; );}export const Display = component$( ({count}: {count: number}) =&gt; { console.log('&lt;Display count={${count}}/&gt;'); return &lt;div&gt; {count}!&lt;/div&gt;; }) Display 在上面的示例中，仅更新两个组件之一的文本节点。未更新的文本节点在初始渲染后将永远不会打印。 123456# Initial render output&lt;Counter /&gt;&lt;Display count=&quot;{0}&quot; /&gt;&lt;Display count=&quot;{0}&quot; /&gt;# Subsequent render on click (blank) 实际上你无法在 React 上实现同样的目标，因为至少有一个组件需要重新渲染。 那么让我们看看如何在 React 中记住组件以最大程度地减少重新渲染的次数。 1234567891011121314151617181920212223242526export function Counter() { console.log(&quot;&lt;Counter/&gt;&quot;) const [countA, setCountA] = useState(0); const [countB, setCountB] = useState(0); return ( &lt;div&gt; &lt;button onClick$={()=&gt; setCountA(countA+1)}&gt; A &lt;/button&gt; &lt;button onClick$={()=&gt; setCountB(countB+1)}&gt; B &lt;/button&gt; &lt;Display count={countA}&gt; &lt;Display count={countB}&gt; &lt;/div&gt; );}export const MemoDisplay = memo(Display)export function Display ({count}: {count: number}) =&gt; { console.log('&lt;Display count={${count}}/&gt;'); return &lt;div&gt; {count}!&lt;/div&gt;; }) 但即使有了记忆，React 也会重新运行更多的重新渲染。 12345678# Initial render output&lt;Counter /&gt;&lt;Display count=&quot;{0}&quot; /&gt;&lt;Display count=&quot;{0}&quot; /&gt;# Subsequent render on click&lt;Counter /&gt;&lt;Display count=&quot;{1}&quot; /&gt; 如果没有记忆，我们会看到： 123456789# Initial render output&lt;Counter /&gt;&lt;Display count=&quot;{0}&quot; /&gt;&lt;Display count=&quot;{0}&quot; /&gt;# Subsequent render on click&lt;Counter /&gt;&lt;Display count=&quot;{1}&quot; /&gt;&lt;Display count=&quot;{0}&quot; /&gt; 这比 Signals 要做的工作要多得多。因此，这就是为什么信号的工作方式就好像您记住了所有内容，而实际上不必自己记住任何内容. Prop drilling让我们举一个实现购物车的常见示例。 app 123456789101112export default function App() { console.log(&quot;&lt;App/&gt;&quot;); const [cart, setCart] = useState([]); return { &lt;div&gt; &lt;Main setCart={setCart} /&gt; &lt;NavBar cart={cart} /&gt; &lt;/div&gt; }} Main 1234567891011121314151617181920export function Main({ setCart }: any) { console.log(&quot;&lt;Main/&gt;&quot;); return ( &lt;div&gt; &lt;Product setCart={setCart} /&gt; &lt;/div&gt; );}export function Product({setCart}: any) { console.log('&lt;Product/&gt;') return ( &lt;div&gt; &lt;button onClick={ ()=&gt; setCart((cart: any)=&gt;[...cart, &quot;product&quot;]) }&gt; Add to cart &lt;/button&gt; &lt;/div&gt; )} 1234567891011121314151617export function NavBar({cart}: any) { console.log('&lt;NavBar/&gt;') return ( &lt;div&gt; &lt;Cart cart={cart}&gt; &lt;/div&gt; )}export function Cart({cart}: any) { console.log('&lt;Cart /&gt;') return &lt;div&gt; Cart: {JSON.stringify(cart)} &lt;/div&gt;;} 购物车的状态通常会被拉到购买按钮和呈现购物车的位置之间的最高公共父级。由于购买按钮和购物车在 DOM 中相距较远，因此通常非常接近组件渲染树的顶部。在我们的例子中，我们将其称为共同祖先组件。 共同祖先组件有两个分支： 一种setCart通过多层组件钻取功能直到到达购买按钮的方法。 另一个cart通过多层组件钻取状态，直到到达呈现购物车的组件。 问题是，每次单击购买按钮时，大部分组件树都必须重新渲染。这会导致类似于以下的输出： 123456# &quot;buy&quot; Button clicked&lt;App /&gt;&lt;Main /&gt;&lt;Product /&gt;&lt;Navbar /&gt;&lt;Cart /&gt; 如果您确实使用记忆化，那么您可以避免setCartprop-drilling 分支，但不能避免cartprop-drilling 分支，因此输出仍然如下所示： 1234# &quot;buy&quot; Button clicked&lt;App /&gt;&lt;Navbar /&gt;&lt;Cart /&gt; 对于信号，输出如下： 12# &quot;buy&quot; Button clicked&lt;Cart /&gt; 这大大减少了需要执行的代码量。 哪些框架支持 signal？支持信号的一些更流行的框架包括Vue、Preact、Solid和Qwik。 现在，信号并不是什么新鲜事。在此之前它们已经存在于Knockout和可能的其他框架中。不同的是，信号近年来通过巧妙的编译器技巧和与JSX 的深度集成极大地改进了它们的 DX ，这使得它们非常简洁并且使用起来很愉快 - 这部分是真正的新部分。 结论信号是在应用程序中存储状态的一种方式，类似于 useState()React。然而，关键的区别在于信号返回一个 getter 和一个 setter，而非响应式系统仅返回一个值和一个 setter。 这很重要，因为信号是反应性的，这意味着它们需要跟踪谁对状态感兴趣并通知订阅者状态更改。这是通过观察调用状态获取器的上下文来实现的，这会创建订阅。 相比之下，useState()React 只返回状态值，这意味着它不知道状态值是如何使用的，并且必须重新渲染整个组件树以响应状态变化。 近年来，信号已经达到了 DX，这使得它们并不比传统系统更难使用。因此，我认为您将使用的下一个框架将是响应式的并且基于信号。 参考文档useSignal() is the Future of Web Frameworks","link":"/angular/useSignal_is_the_future_of_web_frameworks.html"},{"title":"为 Astro 网站添加身份验证鉴权功能","text":"Clerk 号称是最开箱即用的登录鉴权 serverless 服务，确实可以帮助开发者避免前期重复无聊的鉴权逻辑从而快速开发一些小玩具。 Astro 是一个用于构建快速、轻量级网站的现代前端框架，特别适合静态网站生成和内容丰富的网站，如博客、文档站点等。 今天我们要讲解的是在基于 Astro 框架构建的网站中，如何使用 Clerk 快速地为网站添加用户身份鉴证和鉴权功能。 首先创建 Astro website这部分可以参考我之前的博客 使用 Astro 快速搭建自己的博客系统，里面介绍了多种构建 Astro website 的方法。 准备 Clerk 开发环境配置环境变量的步骤如下，也可以直接参考官方文档： 浏览器访问Clerk，注册 Clerk 账号 点击 Create application 创建一个应用，也就是我们现在开发的这个项目。 配置鉴权选项，例如第三方登录提供商。这里需要事先声明的是，第三方登录提供商在开发环境是可以随意增加的，但是在生产环境每一个都需要额外的配置。所以这边量力而行。 进入 Clerk 控制台 找到 API keys，分别是一个公钥和私钥，将这个配置复制到我们项目中的环境变量里。 在项目中引入 Clerk这里的 npm 包管理以 pnpm 包管理器为例，其他包管理器可以自行调整。 123pnpm add @clerk/astro 设置环境变量将在 clerk 开发环境准备阶段获得的公钥和私钥以环境变量的形式提供给 clerk SDK。 这些密钥始终可以从 Clerk Dashboard 的 API 密钥页面中找到。 12PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_c2F2ZWQtbWFsbGFyZC04LmNsZXJrLmFjY291bnRzLmRldiQCLERK_SECRET_KEY=sk_test_8CaJCC4MAMjukdxDw76WvVQ06cJOGldHgxe6Z7UcH1 更新 astro.config.mjs要在您的 Astro 应用程序中配置 Clerk，您需要修改 astro.config.mjs。 将 Clerk integration 添加到 integrations 列表中。 安装 SSR 适配器 。对于此快速入门，我们选择了 @astrojs/node 适配器。您可以使用任何您想要的基于 Node 的适配器。 设置 output 为 server。部署到支持 SSR 的主机时这是必需的。 123456789import { defineConfig } from &quot;astro/config&quot;;import node from &quot;@astrojs/node&quot;;import clerk from &quot;@clerk/astro&quot;;export default defineConfig({ integrations: [clerk()], adapter: node({ mode: &quot;standalone&quot; }), output: &quot;server&quot;,}); 将中间件添加到您的应用程序clerkMiddleware() 授予您访问整个应用程序、任何路由或页面上的用户身份验证状态的权限。它还允许您保护特定路由免受未经身份验证的用户的侵害。要添加 clerkMiddleware() 到您的应用程序，请按照以下步骤操作： 在您的目录中创建一个 middleware.ts 文件 src/。 在您的 middleware.ts 文件中，导出一个 onRequest 常量并将函数的结果分配 clerkMiddleware 给它。 12345import { clerkMiddleware } from &quot;@clerk/astro/server&quot;;export const onRequest = clerkMiddleware(); 默认情况下，clerkMiddleware()不会保护任何路由。所有路由都是公开的，您必须选择加入路由保护。请参阅参考 clerkMiddleware() 以了解如何要求对特定路由进行身份验证。 即使没有路由也需要配置clerkMiddleware，他是初始化过程的重要一步，否则的话在访问clerk组件的时候会出现类似Astro2.locals.auth is not a function的错误。 添加 TypeScript 声明更新目录 src/中的 env.d.ts 文件。 12/// &lt;reference types=&quot;astro/client&quot; /&gt;/// &lt;reference types=&quot;@clerk/astro/env&quot; /&gt; 向您的应用添加验证鉴权相关组件123456789101112131415161718192021222324252627--- import { SignedIn, SignedOut, UserButton, SignInButton } from'@clerk/astro/components' ---&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/favicon.svg&quot; /&gt; &lt;meta name=&quot;generator&quot; content=&quot;{Astro.generator}&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;{title}&lt;/h1&gt; &lt;nav&gt; &lt;SignedOut&gt; &lt;SignInButton mode=&quot;modal&quot; /&gt; &lt;/SignedOut&gt; &lt;SignedIn&gt; &lt;UserButton /&gt; &lt;/SignedIn&gt; &lt;/nav&gt; &lt;/header&gt; &lt;article&gt; &lt;slot /&gt; &lt;/article&gt; &lt;/body&gt;&lt;/html&gt; 创建你的第一个用户现在访问您的应用主页 http://localhost:4321。注册以创建您的第一个用户。 参考文档Clerk Astro Quickstart 如何在 Next.js 全栈应用程序中无缝实现身份验证","link":"/astro/astro_authentication.html"},{"title":"使用 Giscus 为 Astro 网站添加评论功能","text":"考虑到每篇博客都有可能有错误的地方，需要用户及时反馈，我能相应的做出修改，逐渐完善整个博客系统，所以评论功能对我来说非常重要。 目前Astro添加评论功能的方式不多，因为毕竟是一个比较新的框架，使用像 Astro 这样的静态站点生成器，添加评论系统可能会有点困难，因为您的内容主要托管在 Git 存储库内的 Markdown 文件中。如果你使用 Astro 搭建博客并希望在帖子中添加评论，本指南将演示如何使用 Giscus 在几分钟内完成操作。 什么是 GiscusGiscus是一个由 GitHub Discussions 提供支持的评论系统，允许访问者通过 GitHub 在任何网站上发表评论和反应！它是免费的，不需要任何数据库或自建身份验证系统。您的所有评论都将存储在 GitHub Discussions 中，让您完全控制您的数据。 开启github仓库讨论功能首先，确保您的 GitHub 存储库上已启用讨论功能。（您的博客的 GitHub 存储库应该是公开的。） 创建一个名为“评论讨论”的新类别Blog Post Comments。确保将类别设置为Open-ended discussion. 导航到https://github.com/your_id/your_repo/settings，开启discussion 然后导航到 https://github.com/your_id/your_repo/discussions/categories， 点击new category, 如下图所示，创建一个新的category。 为github仓库安装giscus app导航到giscus app，点击Install按钮， 进入安装界面。 获取 giscus 代码片段现在，转到giscus.app，去检验配置，并获取添加到您网站的代码片段。 输入您的github repo，如果满足所有条件，您将看到一条成功消息，类似于下面的消息。 确保选择Discussion title contains page URL映射嵌入页面和嵌入讨论的选项。 最后的选项是配置讨论类别、外观和加载方式： 对于类别，选择您之前创建的类别：Blog Post Comments. 对于外观，请选择Github light主题或其他， 当您在选择主题时， giscus页面的主题会跟随变化，让您实时了解主题的含义。 对于加载方式，选择Lazy仅当用户滚动到评论部分时加载评论。 最后，您将获得一个可以添加到您的网站的片段。其中repo, repo-id, category id等等信息，只要我们按前面的指引进行了设置和选择，这些信息都会自动生成，不需要我们去查找。 12345678910111213141516171819&lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;username/repo&quot; data-repo-id=&quot;repo-id&quot; data-category=&quot;Blog Posts Comments&quot; data-category-id=&quot;DIC_kwDOB3LMn84CaXpn&quot; data-mapping=&quot;pathname&quot; data-strict=&quot;0&quot; data-reactions-enabled=&quot;1&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;bottom&quot; data-theme=&quot;light&quot; data-lang=&quot;zh-CN&quot; data-loading=&quot;lazy&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt; 将 Giscus 添加到你的 Astro 博客现在您已经准备好 Giscus 配置，让我们创建一个名为的组件PostComments并向其中添加代码片段。 src/components/PostComments.astro 123456789101112131415161718192021&lt;section class=&quot;giscus mx-auto mt-10 w-full&quot;&gt;&lt;/section&gt;&lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;username/repo&quot; data-repo-id=&quot;repo-id&quot; data-category=&quot;Blog Posts Comments&quot; data-category-id=&quot;DIC_kwDOB3LMn84CaXpn&quot; data-mapping=&quot;pathname&quot; data-strict=&quot;0&quot; data-reactions-enabled=&quot;1&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;bottom&quot; data-theme=&quot;light&quot; data-lang=&quot;zh-CN&quot; data-loading=&quot;lazy&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt; 现在，让我们将组件导入到我们的博客文章布局中并将其添加到页面底部。 12345678910111213141516171819202122---import Layout from &quot;@layouts/Layout.astro&quot;;import Footer from &quot;@components/Footer.astro&quot;;import PostComments from &quot;@components/PostComments.astro&quot;;---&lt;Layout&gt; &lt;main id=&quot;main-content&quot;&gt; &lt;article id=&quot;article&quot; role=&quot;article&quot; class=&quot;prose mx-auto mt-8 max-w-3xl prose-pre:border-[1px] prose-pre:border-skin-line prose-pre:border-solid&quot; &gt; &lt;Content /&gt; &lt;/article&gt; &lt;PostComments /&gt; &lt;/main&gt; &lt;Footer /&gt;&lt;/Layout&gt; 完成，恭喜 🚀 您的 Astro 博客上现在有一个评论部分。 你想尝试一下吗？在下面留言，让我知道你的想法。😀 参考文章Add comments Section to your Astro blog Astro Introduction","link":"/astro/astro_blog_comments.html"},{"title":"SEO教程","text":"1. 前言本文详细讲解了如何为网站执行 SEO, 文章中的部分内容及方法有些过时了, 但是涉及理念依然有效, 而且内容比较全面, 希望对正你的 SEO 工作有帮助. 2. 目录 1. 前言 2. 目录 3. 名词解释 3.1. 域名 3.1.1. 域名的概念 3.1.2. 域名的特点 3.1.3. 域名的称呼 3.1.4. 域名的分类 3.1.5. 域名购买 3.1.5.1. 域名的价格 3.1.5.2. 域名的注册查询 3.1.5.3. 新域名和老域名的区别 3.1.5.4. 域名商的介绍 3.1.5.5. 如何购买 3.1.6. 域名的使用 3.1.6.1. 域名的解析 3.1.6.2. 域名的绑定 3.1.7. 域名备案 3.1.7.1. 什么是备案 3.1.7.2. 备案时间 3.1.7.3. 为什么有人会讲”空间备案” 3.1.7.4. 需要备案的网站 3.2. 服务器 3.2.1. 服务器介绍 3.2.1.1. 服务器系统 3.2.1.2. 对网站的重要性 3.2.2. 服务器主机类型 3.2.3. 绑定域名 3.2.4. IP 3.2.4.1. ip 概念 3.2.4.2. ip, 域名, 网站关系 3.2.4.3. 独立 IP 和共享 IP 3.2.5. 日志 3.3. 网站程序 3.3.1. 网站程序介绍 3.3.2. 博客 3.3.3. 企业 3.3.4. 论坛 3.3.4.1. 论坛介绍 3.3.4.2. 常见论坛程序 3.3.5. 商城 3.3.5.1. 商城网站介绍 3.3.5.2. 商城程序介绍 3.3.5.3. 商城网站案例演示 3.3.6. 其他 3.4. SEO 基础 3.4.1. 内容 3.4.1.1. 三大标签 3.4.1.2. 关键词 3.4.1.3. 文章 3.4.1.3.1. 文章组成 3.4.1.3.2. 文章分类 3.4.1.3.3. 文章对 SEO 的影响 3.4.1.4. 用户体验 3.4.2. 链接 3.4.2.1. 链接概念 3.4.2.1.1. 链接的三种形式 3.4.2.2. 链接分类 3.4.2.3. 概念和举例 3.4.2.4. 链接应用 3.4.2.4.1. 友情链接 3.4.2.4.2. 网站地图 3.4.2.4.3. 死链接 3.4.3. HTML 3.4.3.1. HTML 概念 3.4.3.2. HTML 语法规则 3.4.3.3. 网页结构 3.4.3.4. html 常用工具 3.4.3.5. html 常用标签 3.4.3.6. html 静态化 3.4.3.7. nofollow 3.4.3.8. DIV+CSS 3.4.3.9. Alt 属性(替换文本) 3.4.3.10. 网页地址 3.4.4. 技术 3.4.4.1. http 状态码 3.4.4.2. 爬虫 3.4.4.3. 搜索引擎入口 3.4.4.4. 权重 3.4.4.5. Page rank 3.4.4.6. Robots 3.4.4.7. 百度开放平台 3.4.4.8. 指令 3.4.4.8.1. site 指令 3.4.4.8.2. 网页快照 3.4.4.8.3. 外链工具 3.4.4.8.4. 站长工具 3.4.4.8.5. 统计工具 3.4.4.8.6. 百度指数 3.4.4.8.7. 其他工具 3.4.5. 黑帽 3.5. SEO 应用 3.5.1. 淘宝客 3.5.2. SEO 顾问 3.5.2.1. SEO 团队 3.5.2.2. SEO 方案 3.5.3. 广告联盟 3.5.3.1. 概念 3.5.3.2. 形式和常见联盟 3.5.4. 推广 3.6. PPC 4. SEO 模型 4.1. 排名 4.1.1. 原理 4.1.1.1. 优化对象 4.1.1.2. 超链接分析 4.1.1.3. 相关页面 4.1.1.4. SEO 模型 4.1.2. 选词 4.1.2.1. 重要性 4.1.2.2. 选择的原则 4.1.3. 关键词布局 4.1.3.1. 关键词分类 4.1.3.2. 导航型搜索 4.1.3.3. 信息型搜索 4.1.3.4. 交易型搜索 4.1.4. 标题 4.1.5. 页面内容 4.1.6. 外链 4.1.6.1. 权重和 PR 的概念 4.1.6.2. 外链的价值 4.1.6.3. 外链的形式 4.1.6.4. 操作原则 4.2. 建站 4.3. 内容 4.3.1. 挖词 4.3.1.1. 确定行业 4.3.1.2. 确定目标关键词 4.3.1.3. 如何判断竞争度 4.3.1.3.1. 关键词搜索结果前三页 4.3.1.3.2. 竞争对手页面和域名年龄 4.3.1.3.3. 竞争对手的收录和外链 4.3.1.3.4. 竞争对手的网站结构 4.3.1.4. 长尾词策略 4.3.1.5. 长尾词词根挖掘思路 4.3.1.6. 海量长尾词挖掘 4.3.2. 整站布局 4.3.2.1. 导航型搜索关键词布局 4.3.2.2. 信息型搜索关键词布局 4.3.2.3. 交易型搜索关键词布局 4.3.3. 标题 4.3.3.1. 标题的写法和注意点 4.3.4. 文章 4.3.4.1. 文章原创 4.3.4.2. 文章质量 4.3.4.3. 文章技术 4.3.4.4. 文章频率 4.3.5. 结构 4.3.5.1. 用户行为分析和 F 型, 树形结构 4.3.5.2. 调用相关和最新文章 4.3.5.3. 次导航 4.3.5.4. 站内站 4.3.6. 站内优化 4.3.6.1. 长尾词列表 4.3.6.2. 锚文本 4.3.6.3. SEO 频道 4.4. 外链 4.4.1. 外链的历史 4.4.2. 外链的价值 4.4.3. 外链的资源分析 4.4.4. 外链操作 4.4.4.1. 外链计划 4.4.4.2. 外链收集 4.4.4.3. 外链筛选 4.4.4.4. 外链执行监控 4.4.4.5. 外链实际操作演示 4.4.4.6. 发布外链注意事项 4.4.4.7. 外链策略 4.5. 心态 5. SEO 系统 5.1. 算法 5.1.1. 算法历史 5.1.2. SEO 原理 5.1.3. 分词技术 5.1.4. SEO 指南 5.1.4.1. 百度优化指南 5.1.4.2. 谷歌优化指南 5.1.5. SEO 最新动态 5.1.6. 百度站长工具简介 5.2. 策略 5.2.1. 项目分析 5.2.1.1. SEO 项目策划和分析 5.2.2. 增加收录 5.2.2.1. 影响收录因素 5.2.2.2. 搜索引擎爬虫爬取方式, 收录原理 5.2.2.3. 影响爬虫爬取的内部因素 5.2.2.4. 影响爬虫爬取的外部因素 5.2.2.5. 技术对收录的影响 5.2.2.6. 内容对收录的影响 5.2.3. 提高排名 5.2.3.1. SEO 排名模型 5.2.3.2. 网站 SEO 排名内部因素 5.2.3.3. 网站 SEO 排名外部因素 5.2.3.4. 单一页面排名和多个页面排名 5.2.3.5. SEO 频道 5.2.4. 提升点击率 5.2.5. 日志分析 5.2.5.1. 日志分析解读 5.2.5.2. 日志分析工具和使用 5.2.5.3. 日志分析案例和注意事项 5.2.6. 词库 5.2.6.1. 需求分析 5.2.6.2. 思路 5.2.6.3. 拓展和整理 5.2.7. 方案撰写 5.2.7.1. 准备阶段 5.2.7.2. 执行阶段 5.2.8. 团队建设 6. 数据分析 6.1. 综述 6.2. 流量 6.3. 爬虫 6.4. 底层 6.5. 运营 6.6. 竞争对手 7. 营销推广 7.1. 微博营销 7.2. 软文 7.3. EDM 8. 参考文档 3. 名词解释3.1. 域名3.1.1. 域名的概念什么是域名? a) 域名就相当于一个人的人名, 别人通过人名可以很容易地找到这个人. b) 通过您的域名我们可以很轻松地访问您的网站, 而且通过域名很容易记住您的这个网站. c) 域名是一个网站必备的三要素之一, 另外两个是空间和程序, 我们其它章节给大家做了详细介绍. 3.1.2. 域名的特点 独一无二, 全世界唯一;比如 baidu.com, 百度公司注册之后我们就不能注册了, 这样的域名全世界只有一个. 一般都是租用的, 是按照年来付费的. 域名每年都要交相应的服务费; 我们通常讲的”购买域名”, “选购域名”严格来讲是不正确的; 我们可以选择两年, 五年的费用一起支付. 3.1.3. 域名的称呼 中文: 域名 英文全名: Domain name 米在某些行业当中也被称为”米”, 比如”炒米”, 就是炒域名的意思.“炒米”经典案例: g.cn 一年的维护费用也就几块钱, 但是谷歌当年花了千万级美金的钱才收购了它. 3.1.4. 域名的分类 顶级域名:a) 国际域名常用的是: .com, .net, .org;我们推荐大家用.com示范: taobao.com, dangdang.comb) 国家域名中国国家域名: .cn, 美国国家域名: .us;考虑政策原因, cn 域名请个人网站慎重使用;企业网站可以正常使用, 示范: net.cn(中国万网) 非顶级域名: 二级域名:示范: www.baidu.com, zhangzhang.baidu.com; 三级域名:示范: bbs.zhangzhang.baidu.com 免费域名:不建议使用 3.1.5. 域名购买3.1.5.1. 域名的价格常规价格: 域名价格一般在 60 元/年左右, 不同的注册商提供的价格是不一样的. 注意点: 很多不良域名注册商在第一年注册价格很低, 但是第二年价格会过分提价,尽量选择口碑比较好的注册商或者注册商代理. 参考依据: 价格参考: 世界上最大的域名注册商 godaddy 的价格比较稳定, 大家可以做个参考. 3.1.5.2. 域名的注册查询查询目的: a) 任何一个域名都是全世界唯一的, 所以必须确保我们的域名没有被注册才能用;b) 查询域名的价格. 查询地址: 所有的域名注册商(包括代理网站), 都可以查询域名是否已经被注册, 而且基本上都是同步更新的. 查询演示: 打开百度, 输入万网(中国知名域名注册商, 比较权威), 单击域名注册, 输入我们要查询的域名. 3.1.5.3. 新域名和老域名的区别老域名: 已经被使用过很长时间后被我们购买过来的域名, 或者域名所有者放弃使用后我们注册过来的域名就是一个老域名. 新域名: 从来没被使用过的域名, 或者停用了很长时间的域名. 区别: 老域名往往比新域名得到搜索引擎信任更加多一点, 而且拥有一些以前的资源, 比如外链(外链的概念其它章节会详细介绍.) 注意点: 如果老域名之前有不良记录, 我们建议使用新域名. PS: 一般的域名都是没有问题的, 不良记录可以通过外链来查询, 外链的概念和查询方法其它章节做了详细介绍. 3.1.5.4. 域名商的介绍国内较为知名的三家域名注册商: 万网(北京万网志成科技有限公司)网址: &lt;www.net.cn&gt; 新网 (北京新网数码信息技术有限公司)网址: &lt;www.xinnent.com&gt; 新网互联(北京新网互联科技有限公司)网址: &lt;www.dns.com.cn&gt; 世界知名的域名注册商: godaddy: 网址: &lt;www.godaddy.com&gt; 3.1.5.5. 如何购买演示: 所有的注册商(包括它们的代理)购买流程都是类似的. 注意点: 如果我们到时候忘记续费, 域名将会延后一段时间删除, 国际域名和国家域名删除时间是不一样的, 详情大家可以咨询您的注册商客服. 在注册商代理那里注册一定要确保域名可以转出, 因为域名转出必须要有转出密码, 否则转不出来, 一些代理很可能在第二年过分提价或者不再提供服务, 这时候我们就要想办法转移我们的域名. 3.1.6. 域名的使用3.1.6.1. 域名的解析什么是域名解析: 假如把域名比作人名的话, 解析就是让你的人名和你的身份证号码匹配也就是对应起来. 简单来讲就是把域名和服务器的 IP 对应起来. 服务器和 IP 简介: a) 服务器: 放置我们网站的地方;b) IP 就是一个服务器的”身份证号码” 这两个概念在其他章节有详细介绍. 3.1.6.2. 域名的绑定什么是域名的绑定? a) 一台服务器上可以放置很多个网站, 就像是一个大房子, 里面分好几个房间, 对应着不同的人名.b) 域名绑定就是把您的域名跟某一个放置网站的空间对应起来. 空间: 服务器的一部分(其它章节有详细介绍) 3.1.7. 域名备案3.1.7.1. 什么是备案什么是备案? 主要是指您使用的网站信息在相关部分登记一下, 经过审核通过后方能开通使用, 一个网站当中最重要的信息是域名(独一无二), 所以一般主要是指域名备案. 备案和域名的关系: 备案跟您的域名注册地没有关系, 在国外网站注册和在国内注册没什么差别, 但是如果我们的网站放置在大陆空间(国内空间)的话, 这个域名都是需要备案的, 相反如果您使用的网站放置在大陆以外的地区那您的域名就不需要备案了. 为什么要备案? 这个是我们国家的法律要求, 如果域名不备案, 那您的网站就无法使用大陆的空间, 但是可以使用香港, 美国或者韩国的空间: 这些地区和国家的空间对域名是否备案没要求. 3.1.7.2. 备案时间正规备案: 一般来讲需要 20 个工作日, 算上周六周日, 大概一个月的时间, 这是正规备案所需要的时间. 非正规备案: 这类备案时间上可以很短, 有时候三天可以完成, 但是极有可能是把您的域名登记在别人的信息之下. 目前备案管理不是特别的严格, 域名是你的, 备案信息添加到别人的信息之下也是可以的, 但是会存在”掉备案号”(相当于没有备案)的风险. 备案号掉了是什么意思? 这种情况一般就是我们没有按照正规备案流程走造成的, 被相关部门查出来有问题, 就把我们的备案号去掉了, 这个时候也就相当于我们的域名没有备案, 那么大陆的空间也就不能用了. PS: 一般讲的国内空间其实专指大陆空间, 空间是服务器的一部分. 3.1.7.3. 为什么有人会讲”空间备案”到底是域名需要备案还是空间需要备案? 一般我们购买的任何空间都不需要我们去备案, 但是使用这个空间的域名可能需要备案(国内空间), 我们常常讲的”国内空间需要备案”其实是使用国内空间必须要用备案过的域名的简称, 后面几个字省略掉了. 注意点: 是否备案跟域名本身没有关系, 只是跟该域名使用的空间有关. 基本上除了国内(大陆空间)需要备案之外, 其它国家和地区都是不需要备案的. 3.1.7.4. 需要备案的网站必须要备案的网站: 网站使用的空间是大陆的, 域名必须要备案.建议: 如果您的客户以大陆人为主的话尽量备下案. 没太大必要备案的网站: 如果您使用的空间是在大陆以外的地区, 那么域名不需要备案, 因为这类空间在我们国家相关监管范围之外. 如何备案: 备案的主体是空间商, 我们需要做的就是提供给空间商一些必要的信息, 比如域名, 网站信息, 联系方式, 身份证信息, 核验单等, 一般空间商都会免费提供这项服务, 具体情况请联系空间商, 不同的地方标准和方式也不太一样的. 3.2. 服务器3.2.1. 服务器介绍a) 服务器概念 放在机房提供公共性或者商业性服务的电脑就称为服务器. “空间”, “主机”, “服务器”(专业性, 口语化) 服务器是需要 24 小时运行的. b) 服务器分类 按照服务器的外观, 可以分为台式服务器和机架式服务器. 机架式包括普通机架式和刀片式. c) 服务器的外形和位置 位置: 机房(温度, 电源, 地板, 防火系统…) 3.2.1.1. 服务器系统a) 定义 安装在服务器上的操作系统 b) 分类 常见的服务器系统有 Windows, Linux, Unix.(Windows server 2003 2008, Linux 最稳定) vs (Window7, 苹果 mac osx) 常见的服务器软件有 iis, Apache, SQL 数据库.(Iis, Apache, SQL)vs(QQ, 360, YY 语音软件) 网站就是基于这些软件的组合功能实现的 3.2.1.2. 对网站的重要性影响网站哪些因素 影响客户体验和 SEO 排名 a) 确保网站持续稳定 网站 24 小时都可以访问(硬件配置, 操作系统, 应用软件…)(比如用 Linux 系统比 windows 系统稳定) b) 确保网站速度够快 网站可以瞬间打开(避免流量大的机房, 独立 IP, 带宽…) 3.2.2. 服务器主机类型主机定义(是什么) 主机(也叫空间)是存放网站程序和数据的地方, 是搭建网站的三要素之一.(服务器, 主机, 空间) 参数介绍: 按地域分类: 国内主机, 国外主机(香港, 美国) 按照程序语言: PHP 主机, ASP 主机, 全能主机 按操作系统分类: Linux 主机, Windows 主机 其它参数: 数据库(大小), FTP(后面详细讲), 流量计算(不限流量空间) 我们搭建网站只需要购买相应配置主机就行, 不需要自己搭建服务器. 主机分类 a) 虚拟机(初学者) 网络服务器上划分出一定的磁盘空间供用户放置站点. 容量比较小, 适合小型网站(淘宝客, 企业站, 博客站) b) 专享主机/vps(老站长) 专门面向中高端用户的性价比超值的独立操作系统, 用户可以自主控制, 灵活配置, 容量一般, 适合中小型网站(论坛, 商城) c) 托管主机(专业级/公司级) d) 免费主机(练手) 免费的提供虚拟空间给您使用(主机屋, 新浪云平台) 3.2.3. 绑定域名a) 绑定域名定义 为了确保访问者访问你的域名的时候会打开你存放在该空间上的网页, 在服务器上设置该域名有权限访问的过程就是绑定域名(也叫域名绑定) b) 绑定域名和域名解析的关系 域名解析就是把域名解析到空间 ip 上, 绑定域名就是在空间上绑定域名允许域名访问空间的内容. 域名解析, 域名绑定两个工作都做, 才能让网站正常访问. 如何绑定 在空间商购买空间, 空间都有操作后台, 在控制面板会有一项功能选项, 就是绑定域名, 填写要绑定的域名, 点击确认即可. 判断绑定是否成功 访问网站看能否打开显示主机开通的默认页面 绑定需要的时间: 绑定后马上有效果 3.2.4. IP3.2.4.1. ip 概念a) 为什么会有 IP? 在网络上有成千上万台主机, 为了区分这些主机, 人们给每台主机都分配了一个专门的地址, 这个地址就叫 IP b) IP 的组成 IP 地址由 4 部分数字组成, 每部分都不大于 256, 各部分之间用小数点分开, 每个 IP 地址都是唯一的. 举例: 192.168.1.1 3.2.4.2. ip, 域名, 网站关系域名与 IP 关系 由于要访问网络时, 记 IP 地址比较麻烦从而给 IP 转换了一种比较简单易记的名称, 就是域名. 如果把域名当作人的名称, IP 就是他的身份证号码. 通过身份证号码也可以找到这个人. 而且身份证和人都是唯一的, 域名和 IP 也是唯一的. IP 和网站的关系 网站是由域名, 空间, 程序组成的, 在域名和空间结合起来的时候, 需要 ip, 比如 IP 绑定和域名解析的时候用到 IP, IP 就是域名和空间的桥梁. 3.2.4.3. 独立 IP 和共享 IPa) 定义和区别 独立 IP: 网站主机自己有一个单独的 IP 地址 共享 IP: 网站主机和其它网站共同用一个 IP 地址. 区别在于对 SEO 的影响: 独立 IP 更有优势. b) 如何判断是独立 IP 还是共享 IP? 如何查询某 IP 下有多少站点 IP 反查询工具 常用共享 IP 网站数量控制在 50-100 内即可 c) 如何购买独立 IP 跟空间提供商说明情况即可. 3.2.5. 日志概念 网站日志: 是服务器日志的统称, 它是记录 web 服务器接收处理请求以及运行时错误等各种原始信息的以.log 结尾的文件. 日志内容包括: 服务器错误信息+ 用户访问信息+蜘蛛爬行信息. (SEO 中用到的主要是蜘蛛爬行信息和服务器错误信息) 用处: 了解访问情况通过网站日志可以清楚地得知访客的详细信息, 比如 IP, 时间, 操作系统, 是否成功访问某页面等等.(这部分主要是用户访问信息) 指导 SEO 工作由于网站日志可以记录各搜索引擎蜘蛛机器人在网站爬行的详细情况, 所以网站管理员可以通过日志了解网站在搜索引擎中的表现, 从而根据日志分析结果来调整 SEO 策略. (这部分主要是蜘蛛爬行信息+服务器错误信息) 生成与分类 生成在服务器后台可以选择日志生成的时间间隔, 参数, 格式等.比如我们可以选择 24 小说生成一次也可以选择 1 小时生成一次. 分类网站所在服务器类型的不同, 产生的日志表现形式也是不同的. 3.3. 网站程序3.3.1. 网站程序介绍网站搭建方法: 程序员开发 所需技能: web 语言基础(asp, php, javascript…) 快速搭建(建站程序) 什么是建站程序? 能够用来搭建网站的程序包或源码文件. 建站程序特性: 流行元素(使用人多) 开源性(免费下载) 问题易解决 常见建站程序: z-blog, wordpress, shopex, ecshop, discuz, 114 啦, dedecms, 帝国 CMS… WEB 语言的解读: 概念: WEB 编程语言, 主要是用来编写网页程序的计算机语言. web 语言分类: 静态语言: HTML(超文本标记语言)动态语言: asp, php, javascript, java, CGI 等. 常见建站程序 WEB 语言分类: 常见建站程序 程序 WEB 语言 wordpress php z-blog asp discuz php shopex php dedecms php 3.3.2. 博客免费博客: 新浪博客, 百度空间, QQ 空间 独立博客: 独立域名的博客 常见的博客程序: wordpress 官网: http://cn.wordpress.org/语言: php+sql案例: SEO 史记, 淘宝 UED z-blog 官网: http://blog.rainbowsoft.org/语言: asp+access 案例: 月光博客 其他的博客程序: emlog http://www.emlog.net/ 3.3.3. 企业企业网站概念: 企业网站, 就是企业在互联网上进行网络建设和形象宣传的电子商务平台. 企业网站的分类: 电子商务型已网络销售为主要目的的企业网站类型. 多媒体广告型用来展示企业形象, 打造企业品牌. 产品展示型针对定向用户展示企业产品详细参数, 提供服务咨询的企业网站类型. 搭建企业网站的必要性: 增加企业产品竞争力; 企业营销多样化; 时代发展趋势; 常见企业网站建站程序: 注意: 企业网站实现的功能大多和博客网站类似, 所以很多能够搭建博客或 CMS 网站的程序都可以搭建企业类型的网站. 以下是常用到的 CMS 建站程序. DEDECMS DEDECMS 织梦内容管理系统, 基于 PHP+MySQL 的技术架构, 是目前国内使用人群居多的一套开源流行的 CMS 内容管理系统建站程序, 可以搭建出很多界面精美的企业网站. DEDECMS: https://www.dedecms.com/ 帝国 CMS: 帝国 CMS, 简称”Ecms”, 也是国内比较流行的 CMS 建站系统, 由于其功能强大, 被誉为”万能建站工具”. 帝国 CMS: http://www.phome.net wordpress wordpress 随着无数主题和插件的开发, 对于搭建企业网站已经非常方便, 并且在 SEO 优化, 用户体验方面也有明显的优势, 对于搭建企业网站也是不错的选择. wordpress: http://cn.wordpress.org/ 建站程序的比较: DEDECMS 和帝国 CMS 因其强大内容管理功能, 可以秒杀一切 CMS 门户网站, 然而对于功能需求并不是很大的企业网站却显得功能臃肿多余了. 而 wordpress 程序, 因为有以下优势更适于搭建企业类型的网站: 安装使用简单: (5 分钟搭建程序) SEO 优化好: (N 多的 SEO 辅助插件)all in one seo pack(设置网站关键词, 描述和标题) 百度地图插件(SEO 优化必备), 谷歌地图插件. 模板主题容易定制; 主题大多免费. wordpress 企业网站案例演示: http://www.chuangxin.com/ 3.3.4. 论坛3.3.4.1. 论坛介绍论坛又名 BBS(Bulletin Board System), 译为: 电子公告板, 主要是为了实现信息发布, 用户讨论, 聊天互动的一种电子信息服务系统. 论坛的分类: 综合型论坛 大而全的信息发布平台, 适合信息来源大的团队, 例如: 海内论坛: http://www.hnlt.org/ 专题论坛 往往专注于一个行业, 吸引志同道合的人群交流讨论, 例如: 电脑爱好者论坛, 电影动漫论坛, 购物论坛等. 3.3.4.2. 常见论坛程序discuz “令人惊异的讨论区” 是北京康盛新创科技有限责任公司推出的一套通用社区论坛软件系统, 采用流行的 web 编辑组合 PHP+MySQL 实现, 具备完善功能, 最强负载能力和高度定制的论坛服务, 是目前国内论坛网站搭建使用最多用户的论坛建站程序. 编年史: 2001-6 由戴志康创建;2010-8 月被腾讯收购. discuz: http://www.discuz.net/ phpwind PHPWind(简称: PW) 也是一套基于 PHP+MySQL 的论坛程序, 是国内另一个使用人群比较大的论坛建站程序, 论坛风格大气简约, 适合建立企业社区论坛. 于 2009-12 月被阿里巴巴集团收购. phpwind: http://www.phpwind.net 3.3.5. 商城3.3.5.1. 商城网站介绍商城的概念: 商城就是以电子商务软件来构建的大型商品电子交易平台, 其主要作用就是通过商城交易平台向客户准确, 快捷的销售产品. 商城, 消费者和物流构成了电子商务中最核心的三要素, 其中商城是实现电子商务活动的载体. 商城的构建: 通过综合网店平台建立自己的网店或商城, 比如: 淘宝, 拍拍等. 通过使用独立商城软件来构建网上商城. (商城程序). 商城模式: B2B: Business-to-Business(商家对商家) 代表: 阿里巴巴, 慧聪网;B2C: Business-to-Customer(商家对顾客) 代表: 京东, 当当, 凡客;C2C: Customer-to-Customer(顾客对顾客) 代表: 淘宝网. 3.3.5.2. 商城程序介绍shopex ShopEx 是国内市场占有率最高的网店软件. ShopEx 基于免费开源但却性能卓越的 Lamp(Linux+Apache+Mysql+Php)架构 ShopEx 软件完全免费, 免费下载, 免费使用, 免费升级 支持的功能: 商品管理功能 订单功能 会员功能 支付和配送功能 模板管理功能 文章, 广告, 营销, 统计等. shopex: http://www.shopex.cn/software/ ecshop ECShop 是康盛创想(Comsenz)公司推出的一款 B2C 独立网店系统, 适合企业及个人快速构建个性化网上商店. 系统是基于 PHP 语言及 MYSQL 数据库架构开发的跨平台开源程序. 2008 年 10 月被 shopex 收购. 目前两套程序做了很大的整合, 并且程序之间可以实现互转, 我们如果需要搭建商城网站, 只需学习其中一套即可. 3.3.5.3. 商城网站案例演示名鞋库: http://www.s.cn/五芳斋: http://www.51wfz.com/尚客茶品: http://www.sumcl.com/优美世界: http://www.umishop.com.cn/态爱网: http://www.taiai.com/唐狮: http://www.tonlion.com/ 3.3.6. 其他其他建站程序介绍: 任何网站类型基本上都可以找到相应的建站程序. 例如搭建以下类型的网站 团购网站: 最土团购程序 http://www.zuitu.com/ 交友网站: ucenter home http://u.discuz.net/ 视频网站: maxcms http://www.maxcms.net/download.html 微博: Xweibo http://x.weibo.com/ 导航网站: 114 啦 http://open.114la.com/ 地方门户: 163k http://www.163k.com/menhu/ 百科网站: 维基百科 http://kaiyuan.hudong.com/down.php FAQ 系统网站: phpMyFAQ http://www.phpmyfaq.de/ php 开源网站程序汇总: http://www.php-open.org/ 3.4. SEO 基础源代码: 源代码简单来理解就是浏览器解释网页给搜索引擎看的”语言”, 搜索引擎看到的东西跟我们看到的不一样. 我们已搜狐首页举例 title 标签: &lt;title&gt;搜狐&lt;/title&gt; keywords 标签 &lt;meta name=Keywords content=搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧&gt; description 标签 &lt;meta name=Description content=搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。&gt; 3.4.1. 内容3.4.1.1. 三大标签对 SEO 的作用: title 标签: 这是一个页面当中最重要的标签之一, 搜索引擎判断页面属性, 最为重要的参考. keywords 标签: 它确实是关键词的意思, 但是只是放置关键词的地方, 以前这个标签很重要, 现在已经被搜索引擎放弃, 甚至成为判断网站是否过度优化的依据. keywords 标签给大家的建议是不写任何内容. description 标签: 单从这个标签来讲 SEO 的影响可以忽略不计, 但是会直接关系到用户体验和点击率, 而这些确实会影响到 SEO. 3.4.1.2. 关键词关键词: SEO 真正的价值是带来定向客户, 定向客户是通过搜索一些词语来到我们网站的, 这些客户要搜索的词语就是关键词. 简单来讲关键词就是讲来您的潜在客户要搜的词, 所有我们潜在客户在搜索引擎上面要搜索的词我们都可以称之为关键词. 主关键词: 一般我们用最权重页面(比如首页) 去优化的词我们叫做主关键词, 是我们将来的网站客户搜索量最大, 商业价值也最大的词. 比如手机行业当中的”手机”这个词, 就是这个行业当中的主关键词, 初学者我们建议前期在首页安排 1-3 个主关键词. 长尾关键词: 跟我们主关键词相关, 但是搜索量没有主关键词大的一些词, 一般用内页来优化, 比如手机行业当中的”诺基亚 7610 北京哪里有卖”? 注意点: 主关键词和长尾关键词都是相对的, 比如”长城汽车”这个词, 在长城汽车官网(www.gwm.com.cn)上是把它作为主关键词来优化的, 但是对于汽车之家(www.autohome.com.cn)这个网站来讲, “长城汽车”就是一个长尾词. 用户搜索习惯 概念: 我们这里的用户搜索习惯主要就是研究人们在使用搜索引擎时习惯搜索哪些词. 用户的搜索习惯直接关系到我们的 SEO 效果. 3.4.1.3. 文章3.4.1.3.1. 文章组成我们做搜索引擎优化最重要的就是页面内容, 页面内容当中最重要的就是组织一篇优质的文章. 文章主要由哪些部分组成的呢? 文章标题: a) 给人看的文章标题 示范: http://health.sohu.com/s2012/zhuanjiyin/这个页面的标题就叫做: 数据说了算, 数字表态度, 调查见真相; 这里的标题在整个页面是显而易见的, 每一个正常的人都是可以看到的. b) 给搜索引擎看的标题 &lt;title&gt; &quot;黄金大米&quot;悬案 - 搜狐健康 &lt;/title&gt; 这个是指该页面的 title 标签, 搜索引擎在我们的页面上看到的跟我们正常人看到的不一样, 它们看到的标题是这个标签的内容. 文章内容: a) 给用户看的内容 完全站在用户的角度去写文章, 组织内容, 给用户解决相关问题. 比如: 比如 QQ 空间中的文章, 基本上是给 qq 好友看的, 对搜索引擎(百度)友好度不高, 很少被搜索引擎收录. b) 给搜索引擎看的内容 这部分的内容是站在搜索引擎的角度来进行组织, 为了让搜索引擎更容易抓取, 排名更好才设置的. c) 我们的建议 以前的 SEO 从业者更多的是站在搜索引擎的角度去组织内容, 但是现在搜索引擎的算法对于用户体验越来越重视, 我们一定要兼而顾之. 3.4.1.3.2. 文章分类原创: a) 从字面意思来理解就是自己写的文章, 在 SEO 行业里原创文章是搜索引擎没有见过的文章. b) 例子 1: 比如你自己写一篇你今天的生活日记, 就是一篇原创文章. 例子 2: 各大搜索引擎的数据库是独立的, 所以您把谷歌收录的一篇文章放到您的网站上, 而如果这篇文章百度没见过的话, 那就是一篇很好的原创文章. 伪原创: a) 在一些搜索引擎已经抓取过的文章基础上经过加工编辑成的文章.b) 比如我们把原本网络已经存在的文章, 交换下段落, 替换下关键词, 就是一篇伪原创文章.c) 由于搜索引擎只是一些机器和程序, 不像人一样能看懂文章, 而且中国的汉字常用的也就几千个, 英文单词也就是 26 个字母, 所以原创和伪原创没有严格的界限, 搜索引擎对他们的区别就是重复度越小越好. 哪个更好: 最重要的区别是内容是否对用户有用, 同等条件下优先收录原创度高的文章. 3.4.1.3.3. 文章对 SEO 的影响文章是一个网站必备的因素: 文章是我们优化一个网站必要的手段, 因为要想让一个网页有排名且有转化一个很重要的前提就是要提供有价值的内容. 文章是 SEO 的基础: “内容为王” 无论什么时候在网络上都成立, 页面内容对于搜索引擎来讲最重要的就是文章. 好的文章可以增强页面在整个网络的权威, 相反不好甚至作弊的文章可能毁掉整个网站在搜索引擎上积累的信任度. 3.4.1.4. 用户体验概念: 具体含义: 我们这里讲的所谓用户体验就是访问我们网页的客户对我们网站不同的页面用户对它们的反应是不一样的. 举例: 比如我们打开标题党的页面, 可能会因为受骗, 而马上关掉, 但是打开一个关于养生的页面就很有可能非常认真地阅读, 甚至还可能把它收藏起来, 因为怕忘记了这个页面. 这些行为都叫做用户体验, 我们在第二个页面的感受要远远好于第一个, 这就叫用户体验. 意义: 用户体验对于 SEO 越来越重要 我们已经知道搜索引擎是看不懂文章的, 所以它只能从用户行为来推算我们的页面质量, 进而对我们的页面进行评价. 举例: 直观的数据: 比如用户在网页上的停留时间, 点开该网站的页面数量, 该网站网页的用户收藏量. 非直观的数据: 比如别的网页对您这个网页的推荐, 您这个网页在网络上的流行度等. 这些数据都是搜索引擎对网页进行判断的重要参考, 如果在这些参数上取得很好的成绩, 对于该网页的排名会有很多帮助, 网页的质量提升了, 搜索引擎对于整站的信任度也会增加. 如何知道我们做得怎么样? 关于获取这些数据的工具我们在本阶段的工具部分会给大家进行详细介绍. 3.4.2. 链接3.4.2.1. 链接概念3.4.2.1.1. 链接的三种形式链接: 链接也称超级链接, 是指从一个网页指向一个目标的连接关系, 所指向的目标可以是另一个网页, 也可以是相同网页上的不同位置, 还可以是图片, 电子邮件地址, 文件, 甚至是应用程序. 简单来理解就是我们点击一下就可以打开一个页面的这样的一个东西. 比如我们点击这个链接: http://www.baidu.com/ 反向链接: 假如有 A,B 两个页面, 不管 A,B 是否属于同一个网站, 但是只要在 A 页面上有指向 B 页面的超链接, 我们就认为 A 给 B 做了一个反向链接. 任何一个链接都是某一个网页对另一个页面的反向链接. 任何一个超链接都是一个页面对另外一个页面的信任投票. 锚文本: 就是在文本上加上超链接比如: 百度, 这是对另外一个页面最好的信任投票. 直接告诉了搜索引擎这个链接的属性. URL 超链接: 就是网址的超级链接, 比如: http://www.baidu.com/ URL 就是网址的意思. 文本链接: 就是一个 URL 或者网址: http://www.baidu.com/ 注意点: 搜索引擎判断 URL 超链接或者文本链接的属性是根据这个链接周围文字来判断的. 比如”百度 http://www.baidu.com/“ 这种形式的效果跟锚文本”百度“很接近. 3.4.2.2. 链接分类3.4.2.3. 概念和举例内链: 内链是反向链接的一种形式, 主要是指我们网站内部页面之间, 比如首页和内页, 内页和内页之间的相互超链接. 示范: 内链接的形式很多, 比如首页的导航, 首页调用的一些内页, 标签等. 比如汽车之间(http://www.autohome.com.cn) 内链的作用: 搜索引擎优化讲究”内容为王”, 如果把内容比作网站的内功的话, 那么内链接就是把内功盘活的气, 再好的内功不运气也是不行的. 内链是重要的反向链接: a) 它可以让搜索引擎更多地抓取我们的页面, 以及可以让网页之间互相进行投票.b) 内链具备相关, 稳定的特点. 而这两个特点在反向链接中非常重要. 注意事项: 内部链接虽然非常重要, 但是我们在刚开始做一个新网站的时候要注意, 不要加太多内部链接, 因为有过度优化的嫌疑. 外链: 外链是反向链接的一种形式, 主要是指在别的网站网页上对我们网站的网页进行的信任投票. 外链的示范: 只要是在别的网站上出现了我们网页的链接就叫做外链, 比如新浪博客, 友情链接, 招聘网站, 新闻门户网站等. 外链的作用 外链反映了该网页的受欢迎程度: 在同等条件下, 外连接数量越多, 排名和稳定性越好. 同等条件下, 越是相关的页面给的外连接越有价值. 外链接是反向链接的重要组成部分: 外连接是其他网站对本网站的信任投票, 利于搜索引擎对我们网页权威性的评价. 注意点: “内容为王, 外链为皇” 第一句在任何时候都成立, 但是第二句在建站初期并不成立, 尤其在我们的网站内容并不丰富的时候, 建议大家不要建立太多外链接. 内容是内功, 外链是招式. “内功”可以持续提升, 但是招式不要胡来, 否则”内功”跟不上的话, 很容易”走火入魔”. 3.4.2.4. 链接应用3.4.2.4.1. 友情链接概念: 简单来理解就是两个网站之间互相进行信任投票, 我给你加一个链接相当于我给您投了一票, 您再给我加个链接, 相当于您又给我投了一票. 本来我们各自一张票也没有, 而现在我们各有了一张, 本质: 团结就是力量. 举例: 我们打开京东商城网站, 下面有一个友情链接锚文本, 里面有一个网站叫做大豆网, 它和京东商城做了友情链接. 3.4.2.4.2. 网站地图概念: 网站地图其实就是给搜索引擎一个查看我们网站的”指示牌”, 搜索引擎查看页面的路径就是链接, 所以由我们网站上所有网页的链接所组成的”链接地图”就是我们的网站地图, 当然我们客户查找我们网站相关页面的时候也可以用这个地图. 作用: 增加搜索引擎查阅我们网站的效率, 可以显著提升我们网站在搜索引擎面前的曝光量, 增加搜索引擎对我们网页的到访次数. 就像一些小巷子里的饭馆, 经常在主干道上竖一个牌子”往前走 100 米, 右拐 50 米即到”用来引导客户一个道理. 3.4.2.4.3. 死链接死链接: 就是一个打不开的链接, 比如原来可以打开的一个页面被删除了, 那么这个页面的链接就成为了一个死链接. 影响: 死链接对于优化来讲非常不利, 如果这样的链接多了, 那么搜索引擎就会认为我们的网站非常不稳定且是存在很大问题的, 进而会对我们的网站进行惩罚. 就像我们给某家企业打客服电话, 经常没有人接的话, 那我们对这家企业的信任度就会降低. 3.4.3. HTML3.4.3.1. HTML 概念什么是 HTML? HTML(Hypertext Markup language)是用来描述网页的一种标记性语言, 是一种规范, 一种标准, 它通过标记符合来显示网页中的各个部分. html 指的是超文本标记语言. html 不是一种编程语言, 而是一种简单标记语言. 利用一套标记符合(标签), 来描述网页. 组成的文件后缀为.html 或.htm 3.4.3.2. HTML 语法规则 &lt;元素名&gt;内容&lt;/元素名&gt; 书写格式解读: &lt;元素名 /&gt; 书写格式解读:被称为空标签或短标签;在开始标签中进行关闭常用标签举例:图片标签&lt;img /&gt;折行标签 &lt;br /&gt; 3.4.3.3. 网页结构html, head, body 3.4.3.4. html 常用工具dreamweaver, UltraEdit, Notepad++, 记事本 3.4.3.5. html 常用标签头部标签 HTML 网页标题标签 &lt;title&gt;&lt;/title&gt; HTML 描述和关键词标签: &lt;meta name=&quot;description&quot; content=&quot;SEO培训手册&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;SEO&quot; /&gt; 主体标签: HTML 文本标题标签: &lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt; HTML 段落标签 &lt;p&gt;&lt;/p&gt; HTML 段落标签 3.4.3.6. html 静态化静态网页和动态网页: 静态网页: 服务器上真实存在的页面, 不需要编译, 用户就可以直接访问. 页面后缀为.html 或.htm. 动态网页: 通过执行 asp, php, jsp, .net 等程序生成客户端网页代码的网页. 静态页面和动态页面的优劣: 对比 静态页面 动态页面 优势 访问速度快, 可以跨平台和服务器 通过用户请求返回数据库页面, 网站易于维护, 可以实现用户注册, 登录, 在线调查等多种数据处理功能. 劣势 占用空间资源, 页面多, 难管理, 修改不方便 页面不是真实存在, 对搜索引擎(技术不成熟) 不友好. 静态化的作用: 有利于搜索引擎抓取;因为现阶段搜索引擎技术的限制, 对于动态页面和静态页面的抓取量的差别, 所以需要动态页面静态化处理. 提高程序性能静态页面打开速度快, 一些大型网站平台所必须要采取的方式. 静态化的方法: 插件静态化:例如 windows 下的 IIS Rewrite 模块静态化, Apach HTTP 服务器的 mod_rewrite 代码静态化 HttpWebRequest 返回页面重定向法 总结: 静态化处理和我们购买的空间有很大的关系, 购买时注意选择和咨询. 3.4.3.7. nofollownofollow 的概念: nofollow 是一个 HTML 标签的属性值. 这个标签的意义是告诉搜索引擎”不要追踪此页面上的链接”或”不要追踪此特定链接”. &lt;a rel=&quot;nofollow&quot; href=&quot;/index.html&quot;&gt;&lt;/a&gt; nofollow 的作用: 是站长管理者和搜索引擎之间对待一个页面中的链接或特定链接的方式. 解读: 比如 A 页面中有一个链接向 B 页面, 如果我给这个链接加上 nofollow 这个属性, 那么 A 页面的这个链接就不属于 B 页面的反向链接, 并且也不会分散 A 页面的权重. 3.4.3.8. DIV+CSSDIV 标签 DIV 是一个 html 布局标签(虚容器), 主要用来实现网页布局和模块添加. 例如: &lt;div&gt;&lt;/div&gt; CSS 概述 CSS 指层叠样式表(Cascading Style Sheets)样式定义如何显示 HTML 元素样式通常存储在样式表文件中解决内容与表现分离的问题外部样式表可以极大提高工作效率 CSS 产生的原因: 用来取代之前网页中陈旧的表格布局技术, 提高网页编辑和修改效率. 网页采用 CSS 的优势: 清晰网页布局; 更精确的控制网页模块样式; 简化代码, 加速网页访问速度; 有利于搜索引擎优化. 3.4.3.9. Alt 属性(替换文本)当网页图片丢失或路径错误的时候所显示的图片文字信息. 举例: 123&lt;img src=&quot;/&quot; /&gt;&lt;img src=&quot;/&quot; alt=&quot;&quot; /&gt; 对于 SEO 的作用: 搜索引擎无法识别图片含义, 然而会把 Alt 属性的内容纳入到页面的文本分析中. 灵活的在网页图片中插入 Alt 属性(比如关键词), 可以提高网页的关键词密度. 3.4.3.10. 网页地址网页地址的分类: 绝对地址: 文件在网络或本地的绝对位置, 具有唯一性.相对地址: 就是被链接文件相对于当前页面的地址. SEO 的考虑: 含有绝对地址的网页对 SEO 优化更有利. 原因: 对于未作 301 重定向的网站, 不利于搜索引擎确定主域名; 相对地址为他人镜像网站提供方便; 绝对地址用于网址规范化以及首选域问题的考虑. 3.4.4. 技术3.4.4.1. http 状态码介绍: a) 定义 我们访问任何一个网页, 服务器都会生成网站的日志. 在日志里面会有一个 3 位数字代码, 这 3 位数字代码就记录了我们访问的动作, 比如是”正常访问” “访问被拒绝”还是”无法打开该网页”等, 这个 3 位数字代码就是 http 状态码. b) http 状态码是服务器和客户端之间交流信息的语言. 客户端包含: “用户”或”爬虫” 常用形式 a) 常用的形式 HTTP 协议状态码表示的意思分以下几类: 2xx 请求已成功被服务器接收 200 服务器已成功处理了请求并提供了请求的网页. 访问正常204 服务器成功处理了请求, 但没有返回任何内容. 3xx 为完成请求客户需要进一步细化请求(重定向) 301 请求的网页已永久移动到新位置.302 请求的网页临时移动到新位置304 如果网页自请求者上次请求后没有更新. 4xx 客户端错误 400 服务器不理解请求的语法403 服务器拒接请求404 服务器找不到请求的网页. 错误页面 5xx 服务器错误 500 服务器遇到错误, 无法完成请求503 服务器目前无法使用(由于超载或停机维护). 这只是暂时状态 b) 查询工具 c) 对 SEO 的意义 通过状态码可以查看搜索引擎爬虫在你网站的爬取情况. 通过状态码可以看网站出现什么问题. 3.4.4.2. 爬虫定义: 网络爬虫(也叫网络蜘蛛), 是一种自动获取网页内容的程序, 爬虫抓取的网页将会被搜索引擎系统存储, 进行一定的分析, 过滤, 并建立索引, 以便之后的用户能够查询到这个页面. 这个获取信息的程序就是爬虫. 爬虫与搜索引擎的关系 爬虫为搜索引擎收集内容, 搜索引擎展示的内容大部分是爬虫收集的. 工作流程: 爬虫通过漫游的形式进行抓取, 爬虫爬到一个页面后, 看到一个链接, 然后顺着那个链接又爬到另外一个页面, 爬虫是不停地从一个页面跳到另一个页面的, 它一边下载这个网页, 一边在提取这个网页中的链接, 那个页面上所有的链接都放在一个公用的待抓取列表里. 而且爬虫有个特点, 就是他在访问你的网站之前, 不去做判断你这个网页本身怎么样的, 不对页面内容判断就抓取, 但是会有优先级的划分, 尽可能不抓重复的内容, 尽量抓重要内容(比如网站的公共部分就不重复抓取了). 搜索引擎同时会派出多个爬虫进行多线程的抓取, 所有被爬虫抓取的网页将会被系统存储, 进行一定的分析, 过滤(去重), 并建立索引, 以便之后的查询和检索. 爬虫分类: 根据搜索引擎来进行分类 百度爬虫 Baiduspider 百度蜘蛛 谷歌爬虫 Googlebot 谷歌机器人 soso 爬虫 sosospider 3.4.4.3. 搜索引擎入口a) 自动收录 欢迎你向搜索引擎提交网站, 让搜索引擎快速收录你的新网站, 搜索引擎会自动收录网页. b) 提交方式 3.4.4.4. 权重概念: 搜索引擎对一个网站的信任度. 注意点: a) 决定一个网站权重的因素包含一个网站的很多方面, 至少有二百多个方面(谷歌数据). b) 权重没有特定的工具可以测量出来. 3.4.4.5. Page rank概念: PR 值全程为 PageRank(网页级别) 注意点: a) 是 Google 用于用来标识网页的等级, 重要性的一种方法, 是 Google 用来衡量一个网站的好坏的重要标准之一. b) 仅仅是谷歌的评价网页的一项参数值, 而且在权重计算中参考价值呈逐渐下降趋势. PR 是可以测量出来的 3.4.4.6. Robots概念: 一个协议, 告诉搜索引擎爬虫什么可以抓取什么不可以抓取(就相当于一个公司门口的公告一样) 功能: 屏蔽无用的信息, 节省服务器的带宽资源, 提升收录. 举例: 没有屏蔽爬虫的网站 robots.txt 屏蔽百度爬虫的网站 robots.txt 1234User-agent: BaiduspiderDisallow: /User-agent: baiduspiderDisallow: / 用法: 使用百度站长平台 robots.txt 工具 3.4.4.7. 百度开放平台百度开放平台是基于百度”框计算”最先进的信息技术与服务机制, 针对用户需求, 为广大站长和开发者免费提供的开放式数据分享暨对接平台. 以此, 站长和开发者可以将结构化的数据或具体应用直接提交到百度开放后台, 使其同步运行于百度大搜索之中, 并以最佳展现形式与最优展现样式的搜索结果, 与数亿用户的需求直接对接. 3.4.4.8. 指令3.4.4.8.1. site 指令我们要想知道网站被搜索引擎收录了多少页面以及具体哪些页面的时候, 我们就会用到 site 指令, 搜索结果显示的数量, 便是我们网站在当前搜索引擎的收录数据. site 指令是我们查询网站收录的工具. 用法: site+英文冒号+域名 site: www.abc.com (把www.abc.com换成你的域名) 3.4.4.8.2. 网页快照搜索引擎在收录网页时, 对网页进行备份, 存在自己的服务器缓存里, 当用户在搜索引擎中点击”网页快照”链接时, 搜索引擎将蜘蛛系统当时所抓取并保存的网页内容展现出来, 称为”网页快照”. 功能: 如果无法打开某个搜索结果, 或者打开速度特别慢, 该怎么办? 网页快照帮您解决问题. 快照回档 快照回档是指百度的快照被退回到之前日期的快照. 快照回档原因 一个是网站自身原因: 主机空间不稳定, 网站首页的改动, 作弊等 一个是搜索引擎自身原因: 服务器宕机. 3.4.4.8.3. 外链工具外链是指从别的网站(B)导入到自己网站(A)的链接 外链工具: 查询外链数量的工具 如何使用外链工具? 演示(百度站长平台) 第一步, 注册并登录百度站长平台第二步, 提交并验证归属, 具体验证网站归属(根据提示操作即可)第三步, 选择左侧”外链分析”第四步, 在已认证归属的站点列表中选择需要查询的站点第五步, 可查看自己网站的外链详情. link 和 domain a) link 指令 百度, link 并不代表一个指令, 只是一个普通的关键字. link:www.abc.com 搜索结果是包含这个关键字(link:www.abc.com)词组的所有网页, 与其他普通关键字的搜索一样, 并不是查找反向链接. Google, 查找的是反向链接, 但只包含网站所有反向链接的少部分. 我们推荐使用 Google 网站管理员工具查网站所有反向链接. b) domain 指令 百度, 查网页内容中包含某关键词. 如: domain:www.abc.com搜索结果是包含关键字词组(www.abc.com)的所有网页. 同理, domain:seo 指的是包含 seo 的所有网页, 与直接搜索 SEO 相似. 如果要查找有多少网页内容中包含你的网址, domain 可以排上用场. Google, domain 并不代表一个指令. 只是一个普通的关键字 3.4.4.8.4. 站长工具站长工具定义 站长建站的时候用到的对做站有帮助的一些工具, 简称站长工具. 常用的站长工具: 友情链接检测工具, alexa, whois 信息查询, 检测网站死链接, 网站流量统计等. 对 seo 有用的站长工具: HTML 格式检测, 网站速度测试, 友情链接检查, 网站域名 IP 查询, PR 值查询, 权重查询, 搜索引擎收录查询工具, 关键字排名查询工具, 网站备案查询等常见的站长工具 爱站, Chinaz 站长之家 3.4.4.8.5. 统计工具a) 统计工具的概念 准确记录来访某一页面的访问者流量信息. b) 流量统计工具 CNZZ, 51LA, 百度统计, google 分析(GA), 量子恒道统计. c) 工具使用(CNZZ 为例进行演示) 网站如何放流量统计代码 PV, UV, IP, 跳出率等概念及查询方法 3.4.4.8.6. 百度指数a) 百度指数的定义 百度指数是用以反映关键词在过去 30 天内的网络曝光率及用户关注度! 它能形象地反映该关键词的每天的变化趋势! 百度指数是以百度网页搜索和百度新闻搜索为基础的免费海量数据分析服务, 用以反映不同关键词在过去一段时间里的”用户关注度”和”媒体关注度”. 百度指数每天更新一次, 并且提供用户查询从 06 年 6 月 1 日到今天的数据. b) 功能: 获取行业关键词指数, 掌握商机 检测网站关键词变化数据 百度指数低于 50 不与显示. c) 其他查询工具 百度搜索推广后台 谷歌 Adwords 工具 3.4.4.8.7. 其他工具ftp 工具scp 工具ssh 工具 3.4.5. 黑帽黑帽和白帽 黑帽简单理解就是所有不符合搜索引擎优化规范的优化技巧和方法. 白帽就是所有符合搜索引擎优化规范的优化手段和技巧. 明显区别: 它们最大的区别就在于是否站在了用户的角度去调整优化我们的网站. 黑帽的典型表现是纯粹站在搜索引擎的角度去做优化, 几乎或者完全不考虑用户感受, 甚至存在欺骗用户, 欺骗搜索引擎的行为. 就像一个人想升值, 白帽就是凭业绩, 勤奋和努力, 黑帽就是用一些取巧的方式, 比如行贿, 背后陷害对手等方式. 黑帽的价值: 黑帽并非一无是处, 好的黑帽是白帽 SEO 的基础, 是 SEO 的试雷区, 是我们探索搜索引擎底线的工具. 常规的黑帽手法如果滥用过度影响到正常的搜索秩序的时候, 搜索引擎必然会做出调整. 调整带来的直接后果就是对网站的惩罚. 常见的惩罚: a) 收录大量减少b) 排名全面下降c) 直接从搜索引擎数据库中删除该网站(K 站) 常见的应对措施: 使用最多的就是换域名. 黑帽的思路: 黑帽追求的是短期利益, 一旦抓住了搜索引擎某一个漏洞, 他们会立刻放大. 我们的观点: 正式网站绝不要使用已知的黑帽手段. 3.5. SEO 应用3.5.1. 淘宝客概念 什么是淘宝客: 淘宝客是指通过互联网帮助淘宝卖家推广商品, 并按照成交效果获得佣金的人或集体(可以是个人, 网站, 团体, 公司). 简单来理解就是我们免费从淘宝联盟(阿里妈妈)得到一个链接, 如果有其他人通过这个链接购买了东西(有交易产生), 那么淘宝会按照交易额的某种比例给我们佣金, 这就叫做淘宝客, 其实就是做淘宝或者天猫的网络推广员. 特点: 0 成本, 高转化率, 产品丰富. 推广方式: qq 群, SEO, SNS(人人网, 开心网), 微博, 留言等可以获取流量的方式. 后台演示 SEO 如何推广 3.5.2. SEO 顾问a) 概念: 用 SEO 技术做营销是企业推广自己业务, 见效快, 花钱少的一种主流方式, 但是很多企业, 自己没有独立的 SEO 部门, 或者自己 SEO 部门的技术水平有限, 这时候就需要聘请公司以外的 SEO 技术人员(SEO 工程师)或者 SEO 专家来帮忙指导, 这种指导的方式是以外部顾问的形式展开, 这个就是 SEO 顾问. 做 SEO 顾问的人员一般都是 SEO 行业经验丰富的人, 有独立操作 SEO 项目的能力和项目经验. b) 工作: SEO 策划书书写SEO 团队建立, 培训项目预算, 实施, 整改, 决策数据监控, 分析, 报告等 c) 其他: SEO 接单 靠提供 SEO 技术盈利, 除了可以在 SEO 行业做顾问以及去招聘 SEO 岗位外, 也可以自己独立的去承接 SEO 优化单, 可以去一些站长, SEO 论坛 SEO 任务区, 承接一些优化单子. 一般优化的周期是 1-3 个月, 优化的价钱是根据关键词来定的, 常见的是某某关键词做到首页, 多少钱, 只要价格合理, 一般都能谈成, 服务周期一般都是一年. 常见两种合作方式: 第一种, 是首付 30%费用, 约定好关键词, 等排名稳定后再付余款. 第二种, 是根据效果付费, 比如站点收录了给多少费用, 排名进入多少页给多少费用, 或者达到多少流量给多少费用. 合作的方式可以自己定, 把握一个维度即可. SEO 接单可以让你接触更多的行业, 看到更多的数据, 掌握更多的 SEO 实战经验, 当然也可以给自己赚取一定费用. 3.5.2.1. SEO 团队a) SEO 团队 由个人或者企业内部负责 SEO 项目的一部分人形成的组织或者团体就是 SEO 团队. b) 组成 SEO 团队基本组成需要 SEO 主管, 程序员, 数据分析专员, SEO 执行人员 4 类型人员. (不同的团队人员安排不同) SEO 主管: 一个 SEO 项目的统帅, 掌握整体权利. 一般 2 个人最好, 能够充分监督项目实施. 程序员: 负责网站程序和代码, 配合 SEO 人员实施 SEO 工作 数据分析专员: 负责市场分析, 调研, 关键词挖掘, 词库拓展收集和整理数据并进行多种维度的分析工作. SEO 执行人员: 主要是内容编辑和外链专员. 内容编辑负责网站稳当的书写整理和发布. 外链专员负责网站外部链接建设和友情链接交换等工作. 3.5.2.2. SEO 方案a) 概念 是指针对某个网站, 依靠 SEO 技术和经验结合 SEO 手法定制出适合这个网站的 SEO 推广思路和策略. b) 分类 SEO 方案有很多种, 常见的有 SEO 诊断方案和 SEO 执行方案. c) 方案的书写(要点) PS: 每个 SEO 方案都不同, 但是写作模式和技巧基本类似. 介绍 SEO 的重要性, 作用, 范围. 介绍 SEO 的优化方法 分析客户网站目前的状况对客户网站的诊断, 并给出一系列基本数据(比如收录数, 关键词排名, 反链等) 分析客户竞争对手网站的情况并做出一系列基本数据, 对客户网站哪些地方对搜索引擎不友好及给出建议. 对客户网站关键词进行分析并且说明具体的优化步骤 给出明确的服务方式和收费标准 介绍自己留下联系方式 3.5.3. 广告联盟3.5.3.1. 概念又叫网络广告联盟, 指集合中小网络媒体资源(又称联盟会员, 如中小网站, 个人网站, WAP 站点等)组成联盟, 通过联盟平台帮助广告主实现广告投放, 并进行广告投放数据检测统计, 广告主则按照网络广告的实际效果向联盟会员支付广告费用的网络广告组织投放形式. 08 年以来非常流行的一种”网赚”, “网络赚钱”方法 3.5.3.2. 形式和常见联盟CPA 及联盟 按照行为付费, 将广告以弹窗, 图片, 文字等各类广告模式投放到会员站点, 而按广告投放实际效果, 即按回应的有效行为来计费的广告模式. 常见的行为又注册, 下载, 调查等. 常见的 CPA 联盟 成果网, 领克特, 亿起发 CPS 及联盟 按照成交付费, 根据用户每成功达成一笔交易支付佣金, 按不同的商品支付不同比例的佣金. 举例: 京东商城旗下联盟 常见的 CPS 联盟 淘宝联盟, 京东联盟, 当当联盟, 亚马逊联盟, 乐淘联盟, 麦包包联盟等 CPM 及联盟 按照展示付费. 主要在网站的首页投放, 当打开该页面的同时弹出客户的网址. 以 24 个小时内唯一 IP 弹出窗口为准, 即当用户访问会员站点的时候, 会员站点自动将广告主的站点指定宣传页面弹出来. CPM 以及作为”按广告每千次被展现收费”的广告模式. 计费形式: 按照弹出窗口 IP 数计费 计费单价: xx 元/1000ip b) 举例: (弹窗广告主要以网页游戏为主) CPC 及联盟 按点击付费. 根据广告被点击的次数收费 举例: (百度联盟) 常见的 CPC 联盟 百度联盟和 google adSense 3.5.4. 推广SEO 对于推广的价值 SEO 是电子商务当中的一门技术, 电子商务的本质就是买流量, 流量是所有电子商务企业的根本, 而搜索引擎又是网络上流量的一个极为重要的入口, 所以用 SEO 可以做很多有意义的事情. 比如推广我们的品牌, 推广我们的平台, 推广我们的产品等. 推广品牌: 现在很多人开始关注品牌的线上推广, 而 SEO 成为了一个必不可少的工具, 品牌作为一个企业的形象, 在搜索结果当中的排名会直接影响到企业对于客户的体验. 推广平台(商城): 现在我们国家的电子商务网站发展正处于一个发展的初级阶段, 用户的很多需求都没有满足, 主流的电子商务网站太过于关注大众需求(尽管有太多的空白还没有补上), 小众需求并没有引起太多关注, 于是很多创业者选择了自己搭建交易平台来解决这些需求关系, 就像当初的阿里巴巴一样, SEO 为他们创业初期获取了非常重要的流量. 推广产品: 搜索引擎的流量当中有相当多的精准流量, 对于我们产品的销售可以起到很好的辅助作用. 3.6. PPC什么是 PPC? PPC 是英文 Pay Per Click 的缩写形式, 其中文意思就是点击付费广告. 这里跟 SEO 有关的就是搜索引擎 PPC(付费排名). 自然排名: 不管任何关键词在百度搜索结果当中每页肯定会有 10 个网页是按搜索引擎规则得出的顺序进行排列的, 这些网站的排名就叫自然排名. PPC: 与自然排名相对的就是搜索引擎的 PPC, 比如百度推广(原百度竞价), 您给的钱越多, 您的排名越靠前, 排名的时间依据投放的金钱, 给的钱越多, 您排名的时间也就越长. 搜索引擎的 PPC 和 SEO 的区别 搜索引擎的 PPC SEO 本质 付费排名 自然排名 时间 见效快, 立竿见影 需要一定的时间来实现价值 流量来源 关键词搜索结果首页的流量 以关键词搜索结果首页的流量为主 成本 按照点击量收费 工作相对繁琐且耗费时间, 主要是人工费用 现状 每年花费 1000 万的账号很多 100 万的投资都算大手笔 投资回报率 是 SEO 的十分之一 是 PPC 的 10 倍 4. SEO 模型4.1. 排名4.1.1. 原理4.1.1.1. 优化对象网站和网页: 一个网站是由网页组成的, 网站是一个或者多个页面组成的. 优化对象: SEO 优化的对象是网页而不是网站. 就像评选诺贝尔文学奖, 不是针对国家而是针对个人的奖项, 排名的最基本单位是网页. 误区: 我们通常讲的”网站排名”, “网站优化”严格来讲是不正确的. 4.1.1.2. 超链接分析简介: a) “超链分析”是一项专利, 意思就是通过分析链接网站的多少来评价被链接的网站质量, 这保证了用户在搜索时, 越受用户欢迎的内容排名越靠前. b) 百度总裁李彦宏就是超链分析专利的唯一持有人, 目前该技术已成为世界各大搜索引擎普遍采用. 理解: a) 简单来讲, 某个页面是否优秀或者权威, 其它的页面的意见很重要. 即便一个网页并不优秀但是只要其他网页对它的信任投票(反向链接)超过了其它页面, 那么它的排名也会靠前, 甚至排名第一; b) 比如”国际站”这个词, &lt;www.alibaba.com&gt;页面上甚至连一个中文都没有, 但是在这个词的上的排名却很好, 原因就是阿里巴巴旗下的数量庞大的网页都给了它一个信任投票(锚文本) 注意点: a) “超链分析”当初奠定了李彦宏在国际上搜索引擎领域的地位, 是排名的一个重要参考. b) 它并不是排名的唯一参考. 4.1.1.3. 相关页面a) 相关页面就是内容相关的页面; b) 比如我这个页面是关于手机功能介绍的, 您那个页面是关于手机厂商介绍的, 那么我们这两个页面就是手机的相关页面. 相关页面的互相推荐: a) 意思就是相关页面之间互相链接;b) 比如在我这个页面介绍完了手机功能之后, 我还要给访客介绍一些手机制造商, 那么我会给他们推荐您的网页, 也就是在我的网页上放置上了您这个网页的链接, 同样的在您这个网页介绍完手机制造商之后, 您也可以给您的访客推荐我的网页, 也就是在您的网页上放上我网页的链接, 这就是相关推荐. 对于排名的意义: a) 相关页面之间的互相推荐, 它让用户对网页有了更好的体验.b) 搜索引擎会更加信任被推荐的网页. 4.1.1.4. SEO 模型a) 全世界的网页有很多, 它们通过链接来联系, 搜索引擎通过链接来访问他们, 搜索引擎会挑选获得相关页面链接有优势的页面排名靠前, 这种优势包括页面的质量和数量, 排名靠前的这种页面就符合 SEO 模型. b) 质量: 质量就是指给我们反向链接的页面的权重和相关性. 新浪首页给我们的网页一个反向链接, 跟新浪的一个个人免费博客页给我们的反向链接的效果肯定是不一样的. 如果我们的网站是卖汽车的, 那一个卖轮胎胎的网页给我们的一个反向链接效果肯定比一个卖锅炉的网页给的反向链接要好得多. c) 数量: 五个网站的首页给我们 5 个反向链接, 和 10 个同等水平的网站首页各给我们一个反向链接效果肯定是不一样的. SEO 模型的”热力图” a) 为了让大家更好地理解 SEO 模型, 我们来看下下图: 在网络上有 ABCDEF 这些页面, 假如他们都是关于手机的相关页面, 也都获得了其它某些页面的推荐(反向链接), 搜索引擎会选择获得最多相关反向链接的页面 A 排名靠前, 因为搜索引擎通过相关页面的推荐判断这个页面在整个网络当中是最权威的, 也就是符合像 A 这种条件的页面会排名靠前. b) 这张图类似一个”热力图”. 假如这些页面都是关于”手机”的相关页面, 那么热力图最高的页面 A, 肯定在手机这个词上排名会更好. 注意点: 稳定地获得其它页面的链接或者”信任投票”的前提是我们这个页面的页面质量自身得非常优秀, 标准可以最大程度解决访客的问题. 通俗解释: a) 比如我们国家的铁路交通图: 全国的铁路交通枢纽最重要的城市是北京. 为什么呢? 因为它符合”热力图理论” 从北京的火车站出发通过铁路路线图可以很方便地到达全国任何一个城市, 同样的全国任何一个城市从他们当地的火车站都可以到达北京, 这种效果虽然很多城市都可以实现, 但是最方便的就是北京, 换句话说他是关于铁路交通”热力度”最高的城市’ b) 搜索引擎执行的是人的意志, 用的原理跟以上类似. 4.1.2. 选词4.1.2.1. 重要性SEO 的真正的价值: SEO 的真正价值是给我们带来定向客户(潜在客户). 客户如何找到我们? 这些客户是通过在搜索引擎里搜索关键词, 在搜索结果里看到我们的网页, 进而进入到我们的网站. 选关键词是 SEO 的核心: 关键词在搜索结果中有排名是我们获得 SEO 流量的唯一途径, 我们要优化的词, 直接关系到未来我们流量的质量. 而流量的数量和质量直接影响我们最后的转化和成交. 关键词选择的重要性: 不是任何一个关键词对我们都是有价值, SEO 所需要获得的是定向流量, 除非能带来定向流量, 否则这些关键词对我们没有意义, 选择大于努力. 4.1.2.2. 选择的原则有人搜索: a) 必须有人搜索b) 搜索量尽量大 因为任何一个关键词搜索结果当中都会有最少 10 个网页来跟我们分享这个关键词带来的流量. 如果搜索量不行的话, 那么最终来到我们网站的流量就更少了. 竞争度小: 记住一句话: 如果某个关键词您没有能力优化到搜索结果首页的话, 那基本上这个词就可以放弃了. 因为极少有人会看搜索结果第二页的内容, 所以尽量选择竞争度较小, 好优化的词语. 比如 “新浪” “搜狐之类的词语”尽管流量很大, 但是基本上个人不用考虑了. 转化率高: a) 因为我们的客户都是通过搜索关键词来到我们网站的, 所以关键词直接决定了这个未来的流量质量. b) 假如我们是一家律师事务所, 那么: “律师” “北京律师” “北京海淀律师”这三个 4.1.3. 关键词布局4.1.3.1. 关键词分类不同的页面应该优化不同的关键词, 我们利用用户意图来对关键词进行分类. 用户意图: a) 如果我们的网站在用户有需求的时候, 第一时间给了他们想要的答案和帮助, 那么这样的网站肯定是最受欢迎的, 任何一个网站都喜欢做一个这样的网站; b) 当一个搜索者输入一个搜索请求的时候, 他到底想得到什么? 这个问题不要说我们 SEO 从业人员, 即便是经过了大量的数据分析的搜索引擎的顶级研究人员, 他们也对此深感困扰; c) 以上事实并不意味着这件事毫无希望, 虽然难但是还是有一些工作是我们可以做的, 而这些工作会极大的改善您的搜索营销. 根据用户意图关键词主要分为: 到航行搜索者搜索的词语, 信息型搜索者搜索的词语, 交易型搜索者搜索的词语 关键词的布局: 知道分类之后我们要根据用户的需求对关键词进行布局: 不同的页面针对不同的用户优化不同的关键词. 4.1.3.2. 导航型搜索导航性搜索词分析: 这类人搜索这些关键词的目的只是为了找到特定的网站, 他们具体想找什么并不是很清楚, 尽管他们知道不需要什么. 首页符合他们的需求: a) 他们不需要得到网站更深入的信息, 他们需要的只是一个首页;b) 这样的词一般也是我们网站当中的关键词, 比如汽车, 空调, 洗衣机;c) 这类关键词相对指数比较高, 竞争比较激烈, 这样的词一般我们的首页去优化. 4.1.3.3. 信息型搜索信息型搜索者分析: a) 信息型搜索者要的是关于特定主题的深层次信息, 信息型搜索相信这种深入的信息是存在的, 但是并不知道它在哪里, 所以这类搜索者想要的答案并不是唯一的一个; b) 他们的理想是最好有多个来自不同网站但都与主题相关的页面, 这个时候搜索者还没有特定要买的产品, 处于”被争取”的阶段, 这个时候我们要提供较为详细的信息来满足搜索者的需求. 频道页最符合需求: a) 符合这样要求的页面, 在我们的网站中是频道页, 因为在一个网站当中, 频道页上聚集了文章页的标题, 能够给搜索者更加详细的信息和更多选择; b) 这类关键词一般是商业价值仅次于主关键词的优质长尾词, 比如海尔变频空调, 长城腾翼系列等等; c) 信息型搜索词我们用频道页去优化. 4.1.3.4. 交易型搜索交易型搜索者分析: a) 这类搜索者的目的性非常强, 他们并不是寻找信息, 而是想”做点什么”; b) 他们的注意点集中在任务上: 购买产品, 下载电子书, 访问数据库等. 文章页最符合需求: a) 在我们网站当中做这项工作的是我们的文章页, 文章页就是用来解决用户碰到的具体问题的; b) 这类关键词在我们优化的时候主要是一些超级长尾词, 比如: “长城汽车腾翼 C30 2011 款价格” 等, 这类词语竞争度极小, 非常好优化; c) 这种交易型搜索词一般用文章页来优化. 4.1.4. 标题标题是极为重要的: 这里我们讲的标题主要是我们的 title 标签里面的内容, 它是搜索引擎判断一个页面属性最为重要的参考. 写好一个标题, 页面的 SEO 也就成功了至少 50%: a) 他就像一个人的外表, 虽然决定一个人未来的是他的内心(页面内容), 但是外表带给人的第一印象不容忽视, 有时候甚至直接决定了成败(或许您外表没有过关, 也就直接失去了表现得机会); b) 同等条件下, 标题写得好得页面优先获得排名. 遵守的原则: 原创: 第一无二的标题, 深受搜索引擎青睐. 包含要优化的关键词:这些关键词包括您的品牌名, 目标客户要搜索的词, 广告语等, 尽量包含您想要传递给用户的最重要的信息. 字数:一般我们建议标题的字数不要太多, 30 个字以内为佳, 但是也不要太少, 否则容易导致不收录. 4.1.5. 页面内容原创的意义: a) 原创往往可以给用户带来更多的价值;b) 互联网上的原创的内容极度匮乏;c) 搜索引擎的服务器数量是有限的, 不可能所有页面都处理. 内容为王: 流量不是优化来的, 而是内容吸引过来的: 一个页面之所以有流量是因为它提供了有价值的内容, 真正优质稳定的流量是搜索引擎给的, 不是我们网页用所谓的”SEO 技术”截取的. 网络上, 内容永远为王: 网络其实也是一种媒体, 内容是网络存在的基石. 没有优质的内容, 再好的排名也只是墙头草. 内容决定了转化: a) 内容为王除了在流量上的价值之外, 在我们电子商务的终端也有重要的意义;b) 电子商务的目的就是为了转化, 没有转化再高的流量也是没有用的;c) 如何让访客原意为你的产品买单, 原意为你的服务付费, 这个就需要我们的内容去建立信任, 去说服, 让我们的内容成为访客信任的顾问是我们建设内容的目标. 关键词分布: 用户是来找答案的: 为什么我们的访客要用搜索引擎? 因为他们要找答案. 排名可以靠关键词命中的: a) 为什么我们网页排名会靠前, 因为我们的网页关键词命中了它的问题;b) 比如有人搜索: 女儿红就是女儿国产的吗? 排名第一的网站, 命中了”女儿红酒” “国产”, 尽管”国产”这个词与此并不匹配, 但是这个网页比其他网页更多的命中了用户搜索的词语, 所以它的排名就靠前了. 密度用来打江山: a) 除了 title 标签之外, 搜索引擎判断网页属性最重要的就是我们网页的内容. 而体系是否跟某个关键词相关, 关键词密度是个很重要的参考; b) 比如某篇关于婚礼的文章, 通篇只出现了一次”汽车”, 大篇幅都在介绍婚礼如何进行的, 那搜索引擎在这篇文章”汽车”这个词上给予的权重就肯定不高. 同义词或者相关词用来守江山: a) 由于关键词密度经常被一些投机者, 作弊者反复使用, 因为它确实是排名的一个参考, 作为反制, 近年来, 相关词语, 同义词也成为了一个很重要的参考; b) 比如一篇写汽车的文章, 当出现汽车这个词的时候我们可以让乘用车, 轿车, 两厢车等之类的词语多出现一些, 同时一些相关的词语比如轮胎, 方向盘, 刹车等等在我们的网页上也合理出现, 这样我们的网页排名更加稳定, 而且容易命中更多的需求, 吸引来更多的流量. 导出链接是页面的重要组成部分: 浏览我们网页的用户, 除了阅读我们提供的文章之外, 他们还会对一些相关的链接感兴趣, 所以导出链接对于提升用户体验有很大的帮助. 导出链接能提升我们页面的权威性: a) 任何一个网页都不可能完全满足访客的需求, 寻找与此相关的网页, 同样是访客很重要的需求, 一个优秀的网页一定是开放的网页; b) 比如: 一个没有任何导出链接的网页就像是清朝时期闭关锁国一样, 并不算优秀的网页, 相反, 有关导出链接的网页就像是一个开放的国度, 优秀只是时间问题. 4.1.6. 外链4.1.6.1. 权重和 PR 的概念权重: a) 就是搜索引擎对一个网页的信任度;b) 权重目前并没有一个具体的测量工具. PR: 是谷歌用于用来标识网页的等级, 重要性的一种方法, 是谷歌用来衡量一个网站的好坏的重要标准之一. 注意点: a) 我们平常讲的”百度权重”, 百度官方从来没有提出来过, 只是第三方工具自己搞出的数据; b) PR 只是谷歌页面权重的一个重要参考, 不是权重的全部, 而且谷歌一直在降低其在排名因素当中的影响. 4.1.6.2. 外链的价值站外优化的唯一途径: 除了我们网站内部进行优化之外, 站外的优化也很重要. 增加收录: 收录的意思就是让我们的网页出现在搜索引擎的数据库当中, 收录是我们的网站优化第一个要解决的问题. 如果我们某些页面不收录的话, 可以在一些高权重的网站发布下我们的页面链接, 吸引到了蜘蛛以后, 收录的概念就会增大. 增加权重: 每一个有效的外链, 都是对我们网页的信任投票, 我们每增加一个外链就相当于别的网页也给我们投了张票. 4.1.6.3. 外链的形式锚文本: 锚文本是最好的外部链接. url 超链接: 这个跟锚文本类似, 效果比锚文本差一点. 文本链接: 这种是比较常见的外链方式, 因为前两种很多网站不让发. 4.1.6.4. 操作原则相关性: 这是外链最为重要的原则, 不相关的外链有时候非但不能给我们带来权重的增加, 相反可能还会让搜索引擎多我们进行惩罚. 频率: a) 外链的建设最重要的是该持续增加;b) 一个真正优秀的网站它的外链应该一天比一天多, 而不是忽高忽低. 注意: 外链为皇建站初期并不成立; a) 我们的外链应该和我们的内容相匹配, 内容是内功, 外链是招式;b) 在内容不够丰富的时候不要发太多外链, 极有可能被认为是作弊;c) 就像我们只有内功足够强大的时候, 我们的招式才能随心所欲且事半功倍, 否则很可能被惩罚. 我们在内功不到家的时候去练一些上乘武功, 极有可能走火入魔. 4.2. 建站省略 4.3. 内容4.3.1. 挖词4.3.1.1. 确定行业选择行业 选择大于努力: a) 我们正准备优化之前我们必须要搞清楚我们要进入的行业, 比如农业, 工业, 服务业等; b) 行业的不同直接决定了您的投入和产出, 选择大于努力! 尽量选择 SEO 机会大的行业: a) 现在各行各业都需要电子商务, 都可以电子商务, 同样 SEO 也可以运用到很多行业; b) 某些行业 SEO 高手云集, 我们要清楚 SEO 大有可为, 没有必要扎堆竞争, 换句话说投资回报率太低的行业还是三思而行. 选择参考: a) 淘宝客: 淘宝客(www.alimama.com)后台给提供了很多可选择的产品; b) 行业企业站: 百业网(www.100ye.com)给我们提供了很多行业, 大家可以选择下. 用户分析: 用户需求是 SEO 的根本: 用户只有有需求的时候才会使用搜索引擎, 他们需要的是答案, 是解决方案. 解决不了的需求不予考虑:a) 我们只有了解了用户需求才能更好地组织我们的网站, 只有页面组织好了才能吸引更多的流量, 了解用户需求更重要的是为了最后的转化;b) 我们在组织该页面之前必须要了解我们有没有那个能力去解决未来访客的问题, 因为如果我们没有能力解决的话, 即便流量来了, 我们也转化不了. 比如: 工业上很多词很有价值, 比如 “吊车”. 相关的词语优化上去之后会有很多人来咨询你吊车的价格, 但是你手头没有这类的资源, 只是懂 SEO, 连最基本的营业执照都没有, 所以完成销售几乎不可能, 但是如果你跟一家吊车商家合作, 他们会很高兴, 因为吊车的相关流量对他们很重要, 你拿提成就好了. 转化率分析 转化率太低的行业不予考虑: 比如对我们个人来讲, 去做手机的淘宝客就非常不明智, 这是经过测试证明的, 因为用户在网络上的需求并不是购买, 只是了解, 大家更喜欢到线下去购买. 如何辨别转化率: a) 没有特定的工具可以使用;b) 只能通过自己的经验和阅历, 或者通过测试得出结果;c) 比如有些团队在确定某些行业词转化率的时候是这么做的: 挑选出他们认为这个行业转化率最好的词和最差的词去投竞价, 如果这个词的转化率可以达到理想状态, 那么就交给 SEO 部门去优化. 4.3.1.2. 确定目标关键词各大搜索引擎关于关键词的搜索量查询都非常相似: a) 国内我们主要的对象是百度, 我们就拿百度来举例, 其他搜索引擎类似; b) 我们来查询一个词: “骆家辉”, 我们打开百度指数:http://index.baidu.com/ c) 我们可以发现: 2013 年 11 月 20 日, 他发表声明, 宣布将于 2014 年初辞职, 随后两天”骆家辉”这个词的指数一路飙升. 注意点: a) 百度指数和百度推广后台都可以查询到各个关键词的搜索量;b) 根据我们的经验百度指数并不特别准确,相对来讲百度推广更加准确一点, 但是指数的趋势还是没问题的;c) 在同等条件下我们选择搜索量大的 确定转换率: a) 转化率是关键词的最重要的属性, 因为排名也好, 流量也好, 最终的目的就是为了转化, 没有转化率的词是没有价值的; b) SEO 的目的是获得定向流量, 所谓的定向就是指我们的转化率, 转化率越高就越定向. 转化率是相对的: a) 比如”刘德华演唱会”这样的词对我们普通制造业的企业站来讲没有太大的价值, 也就是转化率几乎为 0; b) 但是对于视频网站, 比如优酷, 搜狐视频这样的网站来讲, 转化率就比较可观, 因为他们的后端比较强大: 他们可以在视频上放置广告, 卖门票等. 测试转化率: 一般来讲没有特别好的办法, 主要是凭借我们的阅历, 经验, 测试去做判断, 比如用百度推广去测试(原百度竞价) 4.3.1.3. 如何判断竞争度4.3.1.3.1. 关键词搜索结果前三页高权重网页: a) 一个普通网站当中权重最高的页面就是首页;b) 大型资讯门户网站的内页权重一般也比我们个人网站的首页还要高. 搜索结果前三页高权重页面的数量: a) 如果搜索结果前三页大部分都是一些网站首页的话, 那说明这些站长全部在用他们权重最高的页面在优化这个词, 它的竞争度就显而易见了; b) 如果一个词比如”马云”搜索结果前三页都是一些大型咨询门户网站页的话, 那竞争也很激烈. 4.3.1.3.2. 竞争对手页面和域名年龄原创文章的更新频率: a) SEO 讲究”内容为王”;b) 如果我们的竞争多少原创文章更新频率我们了解了之后, 我们就清楚他为这个行业的贡献, 他为之付出的努力有多少, 事实上, 搜索引擎喜欢原创的文章, 你竞争对手原创文章更新频率直接决定了他在”内容为王”上的水平. 原创页面的质量: a) 页面质量决定了该网站的整体水平, 一个能够给用户真正解决问题的网页, 是不愁外链的. 我们可以简单的认为他做到了”外链为皇”, 那这样的网站实力是很厉害的; b) 如果他把自己网站上的文章当作软文去发外链的话, 外链是不愁的. 比如: ZAC 的博客(seozac.com)纯粹就是一个个人博客, 全是一个人在更新, 就会从不自己发外链, 最近文章更新也少了, 但是这个博客的排名并不见降低, 其原因就是因为这个博客的页面质量, 文章质量太好了, 大量的相关网站愿意去转载, 并且很多都留下来了链接. c) 软文是最好的外链方式之一. 域名的年龄: 对于同一个行业的关键词排名来讲, 如果有一个域名年龄很长的网站排名在首页(比如超过 10 年), 那想超越它一定要有足够大的心理准备. 4.3.1.3.3. 竞争对手的收录和外链收录: a) 收录是一个网站获得排名最基本的条件, 一个做的再好的网站, 没有收录就无法谈排名; b) 收录直接反映了该网站首页获得的方向链接数量; c) 比如: 竞争对手的首页往往是我们最重视的, 如果我们知道对手网站的收录情况后, 就可以知道它首页在它网站上得到的反向链接数量了, 因为一个优化良好的网站, 每一个内页上都应该有指向首页的链接, 这些指向首页的超链接就相当于给首页做了一个反向链接. 一个网站除了首页全部都是内页, 所以收录数据知道后, 就很清楚地知道它在网站内部得到的反向链接数量了. PS: 这也是首页权重高的一个最重要的因素. 外链: a) 外部链接向来被 SEO 从业人员重视, 外链代表了目标网页在网络上的受欢迎程度, 是搜索引擎判断网页是否优秀的重要标准; b) 我们看某些关键词的竞争对手的时候, 他们的外链也是它们实力的一个重要的指标, 外链工具大家可以用百度外链工具; c) 外链应该包括: 域名总链接数据, 首页外部链接数据, 内页外部链接数量, 外部链接总域名数, 锚文本分布等, 还可以进一步查看外部链接来自于哪个网站, 是否以交换链接, 论坛, 博客留言等低质量外链为主. 4.3.1.3.4. 竞争对手的网站结构网站结构的重要性: 网站结构是一个网站优化的基础, 一个排名靠前的网站如果网站结构不过关, 排名靠前仅仅是因为外链的话, 那么我们就会有很大的机会. 影响因素: 对于初学者, 网站结构所要注意的包括而不仅限于以下几点: a) 页面 title 标签是否包含关键词;b) 网站栏目分布是否清晰合理;c) URL 是否静态化;d) 网站链接结构是否合理有效;e) 内页距离首页点击距离有多远, 是否能在四次点击以内可以到达所有的内页;f) 我们的主要页面是否有实质内容. 4.3.1.4. 长尾词策略流量来源: SEO 的实质: a) SEO 的实质是带来定向的客户;b) 定向客户是指那些转化率高的客户;c) 转化率高的客户往往不是我们搜索量大的”主关键词”带来的;比如想在网络上购买手机的人, 一般不会在搜索框里搜索”手机”的 长尾词策略的本质: a) 网络上产生购买的流量当中, “主关键词”带来的流量只占不到 5%, 95%的有转化的流量都是长尾词带来的; 比如”手机”这个词每天搜索量很大, 远远高于”诺基亚 直板 红色 130 万像素 水货” (长尾词)这样的词, 但是抓化率跟后面这个词相差很远. b) 95%以上的流量没人要; 受传统看法影响, 流量为王的概念深入人心, 很多人唯流量是从, 但是实际上有些流量对于我们来讲实在没什么价值, 华而不实. 比如麦包包这家电子商务网站(主打箱包产品)曾经在”淘宝网”这个词的搜索结果当中稳定地排在首页长达两年时间, 但是”行李箱”这个定向且相关的词却一直没有排名. c) 长尾词策略才能体现出 SEO 真正的价值; 如果想获得某行业最多的定向流量, 就一定要尽可能多地解决该领域的问题, 而最多的问题就集中在长尾词. 用户是来找答案的, 长尾词的问题解决了, 主关键词的问题也就水到渠成了. 举例: 如果我们把关于感冒的所有长尾词对应的网页建立好, 等这些关于感冒的长尾词拿到排名后, “感冒” “感冒药”这样的词排名一般也差不多了, 还是那句话: 搜索引擎给您排名不是因为您 “优化”了某个词, 而是因为您提供了正确的内容. 常见误区: a) SEO 就是做排名, 看一个站 SEO 怎样, 主要是看某”主关键词”排名如何;b) 排名比流量重要;c) 长尾词指数太低, 可以忽略;d) 不存在转化率高竞争度小的词;e) 某行业竞争是否激烈主要看主关键词. 4.3.1.5. 长尾词词根挖掘思路长尾词的挖掘步骤: a) 先找一个某类的词根, 词根是挖掘长尾词的基础. 比如”诺基亚 直板 红色 130 万像素 2000 以下” 这个长尾词的词根就是”诺基亚”. b) 更加”词根” 用工具来挖掘跟这个词相关的长尾词. 如何找词根: 词根就是根据您的行业密切相关的大词, 比如我们想卖护肤品, 那么跟护肤品有关的词根有哪些呢? 我们挖掘的思路就是根据护肤品属性来寻找相关的词根, 比如年龄, 位置, 功能等 比如: a) 我们根据年龄来区分 20 岁护肤;30 岁护肤;40 岁护肤等. b) 我们根据护肤的位置来区分: 脸部;颈部;背部;手部等; c) 根据护肤的功能来分: 美白;祛痘;祛斑;去油等; 当然护肤这个词有很多属性, 我们还可以找到很多. 这些思路怎么获得: a) 头脑风暴;b) 借助工具: 百度百科, 百度新闻, 相关搜索, 我们身边的所见所闻等等都可以成为我们挖掘词根的素材. 4.3.1.6. 海量长尾词挖掘在我们获得词根之后接下来我们要做的事情就是关于海量长尾词语的挖掘, 我们这里给大家推荐三种方法: 手动挖掘: a) 比如我们搜索”保湿”, 那么我们拖到搜索结果的底部, 我们把那些相关搜索复制下来, 用其中的一个词放在搜索框, 同样的方法再次获得很多的相关搜索; b) 这种方法比较累, 而且不知道相关词语的搜索量. 百度推广后台: a) 我们打开百度, 输入百度推广, 打开搜索结果的第一位, 先登录;b) 登录之后, 选择搜索推广, 点击进入;c) 看到百度推广的广告, 我们点击稍后再说;d) 点击导航上的关键词; 除了百度网页来帮助我们寻找相关词根之外, 利用其它工具也是可以实现的, 我们来给大家介绍一个免费工具: 金花关键词工具&lt;www.1n11.com&gt; 这个工具比较方便 使用步骤: a) 在百度输入”金花关键词工具”, 单击搜索结果的第一个;b) 点击下载;c) 打开该软件;d) 我们输入保湿, 然后可以选择我们要包含的词, 或者不想包含的词;e) 点击开始搜索;f) 搜索停止或者我们点击下停止搜索, 我们就可以把它下载的数据保存下来了. 以上就是使用这个工具的步骤 注意点: a) 这个工具来源于网络b) 同样的道理, 您挖掘结束以后, 还可以根据您挖掘的词进行深度挖掘 4.3.2. 整站布局4.3.2.1. 导航型搜索关键词布局我们现在已经拥有了很多关键词, 我们在开始优化之前必须对这些关键词做一个规划. 关键词布局的原则(URL 的唯一性): a) 一个关键词只能对应一个 URL, URL 就是网址的意思.b) 一个 URl 可以对应多个关键词, 像”汽车”, “汽车网站” 都可以用一个页面来优化.c) 按照一个关键词只能对应一个 URL 的原则(URL 的唯一性), 为了便于我们更好地布局关键词, 我们把关键词进行了分类: 导航型搜索词, 信息型搜索词, 交易型搜索词. 导航型搜索的目的: a) 搜索这类词语的人, 他们其实并没有什么目的, 只是想找一个页面了解下这个行业;b) 满足这种需求的页面应该是提供最多选择的页面, 关于某产品详细属性的一个导航页面, 比如产品的图片, 简介, 价格, 评测, 销售商等等;c) 举例:比如汽车行业, 导航型搜索词比如”汽车”, 我们来分析下, 搜索”汽车”的人是什么心理, 以下是个典型例子: 比如您以前家里穷, 但是突然有一天您中彩票了:500 万, 这个时候您想买辆车, 但是对车不了解, 您对车的印象就停留在十个轮子, 一个发动机, 一个方向盘的阶段, 去 4S 店问又怕店员笑话, 所以您会在网络上搜索”汽车”, 您的目的很简单, 就是想要一个能够给您提供关于汽车最全信息的一个页面, 比如汽车的品牌, 汽车的报价, 汽车的新闻, 汽车的评测等最全的信息; 如何优化: a) 在我们的网站中能满足这些需求的页面只有首页;b) 这类词往往指数比较高, 商业价值比较大, 竞争也比较激烈;c) 这类词我们是当做主关键词用首页(一般权重很高)来优化的. 举例: 导航型搜索词: 汽车, 对应的是这家网站的首页 http://www.autohome.com.cn 4.3.2.2. 信息型搜索关键词布局信息型搜索的目的: a) 搜索这类词的人已经对产品, 服务或者特定的信息已经有所了解了, 但是并不能满意; b) 他们再次通过这样的关键词来寻找更加详细的信息, 其实他甚至并不在乎您向他推销您的产品, 他只要获取到关于此类产品或者服务的更加详细全面的信息; c) 举例: 比如: 如果”汽车”是导航型词的话, 那么”速腾”, “宝来”这些词就属于信息型搜索, 因为搜索这类词的人都是对汽车已经有了了解, 但是对汽车中的这类产品不是特别了解的人, 所以我们要尽量详细地提供关于该产品的全面的介绍, 比如宝来的新闻, 宝来的评测, 宝来的图片, 宝来的报价, 宝来的经销商, 经销商联系电话等等; 如何优化: a) 在我们网站当中最能满足这些需求的就是我们的频道页;b) 这类词搜索量, 商业价值, 竞争度仅次于导航型搜索词;c) 这类词我们频道页来优化. 4.3.2.3. 交易型搜索关键词布局交易型搜索的目的: a) 搜索这种词的人已经对产品很了解了, 搜索这类词的目的其实是想”做点什么”.b) 我们必须满足他们的需求, 他们已经对信息, 资讯已经满足或者暂时满足, 他们想寻找的就是可以完成”任务”, 比如确认价格, 下载使用说明, 查看具体的信息等.c) 这类词语属于比较细的需求, 或者说是最详细的需求, 他们需要的不再是全面, 有很多选择的页面, 这个时候的需求极为明确和单纯. 那比如”到达某旅游景点的某路公交车沿线最便宜的酒店是哪家”. 如何优化: a) 在 SEO 优化上面, 这类关键词指数相对比较低, 属于比较个性化的需求, 满足这类需求的就是我们的文章页.b) 这类词搜索量, 商业价值, 竞争度比较低, 但是却属于需求最大的一类长尾词, 绝大部分真正在网络上产生购买的流量就是来源于这类关键词, 所以我们要引起重视.c) 我们一般用我们的权重最低的页面来优化, 也就是我们的文章页来优化. 举例: 交易型搜索词: 新宝来 10.78-14.83 万 对应的是这家网站的一个文章页: http://www.autohome.com.cn/news201212/440315.html 注意点: a) 导航型, 信息型, 交易型这三种关键词的分类, 并不是绝对的, 而是相对的.b) 比如对于汽车之家这家网站(http://www.autohome.com.cn)来讲, “长城汽车” 这个词对于它来讲就是信息型搜索词, 是用频道页优化的, 但是对于长城汽车的官网(&lt;www.gwm.com.cn&gt;)来讲 “长城汽车”就是一个导航型搜索词, 是用首页来优化的. 总结: a) 关键词布局直接关系到接下来的具体优化, 对于网站结构, 优化策略有重要影响, 希望引起到家的注意; 导航型搜索 信息型搜索 交易性搜索 举例 “汽车” “宝来” “新宝来 10.78-14.83 万” 所对应关键词 主关键词 较有价值的长尾关键词 普通长尾关键词 指数 高 中 小 竞争度 大 中 小 转化率 低 中 高 优化页面 首页 频道页 文章页 4.3.3. 标题a) 标题的概念 标题又叫 title, 是一个网页表明文章, 作品等内容的简短语句. 在 SEO 技术中, 标题的作用非常大, 标题是包含关键词的, 并且带有一些营销成分, 网页的标题就是告诉访客这个网页是介绍什么的, 是网页上主要内容的简化版总结. b) 标题的分类 标题是根据网页类型分类的, 一般网页都有标题. 常见的有: 首页标题, 栏目标题, 文章标题 4.3.3.1. 标题的写法和注意点a) 标题的两种写法(格式) 标准写法 网站页面包含首页, 目录页, 内容页, 这些页面都有标题. 1, 首页: 关键词 1关键词 2关键词 3_广告语(1-3 个相关关键词为主) 举例: 济南真人 cs济南拓展训练玩真人 cs, 就来济南拓界俱乐部 目录页: 目录名称_网站名称 举例: 真人 cs 游戏济南真人 cs济南拓展培训_玩真人 cs, 就来济南拓界俱乐部 文章页: 文章 title目录名称网站名称 举例: 遭遇战玩法简介真人 cs 游戏济南真人 cs济南拓展培训玩真人 cs, 就来济南拓界俱乐部 注意: 首页包含关键词: 真人 cs 游戏, 济南真人 cs, 济南拓展培训,玩真人 cs, 就来济南拓界俱乐部 第二种写法 首页: 网站名称_提供服务介绍 OR 产品介绍(分词技术, 命中更多词语) 举例 举例: 济南拓界-专项拓展培训师和拓展基地提供真人 cs 野战, 拓展训练 目录页: 目录名称_网站品牌名称 举例: 真人 cs 游戏_济南拓界俱乐部 文章页: 文章 title_网站品牌名称 举例: 遭遇战玩法简介_济南拓界俱乐部 注意: 首页包含关键词: 济南拓展培训, 济南真人 cs, 济南拓展培训师, 济南拓展基地, 济南拓展训练, 济南 cs 野战… b) 写标题注意点: 1, 总长度不能超过 30 字符, 过长不能在搜索结果中完全显示.2, 常用符号: “_“表示空格的意思. “|” “-“ 就是间隔符. “*“仅仅仅为了醒目, 并无它意.3, 分词技术: 搜索引擎针对用户提交查询的关键词串进行的查询处理后根据用户的关键词串用各种匹配方法进行的一种技术.(写文章标题的时候尽量的多命中长尾词)4, 标题最好是独特的, 唯一的. c) 两种标题写法的对比(优缺点) 关键词个数 排名速度 流量潜力 客户体验 流量趋势 标题一 1-3 快 少 良好 有限 标题二 多个 慢 多 优秀 无限 没有谁对谁错, 选择优点使用即可. 4.3.4. 文章4.3.4.1. 文章原创a) 原创的重要性: (为什么要原创) 1, 搜索引擎角度看, 因为搜索引擎本身是没有内容的, 他只有靠爬虫程序, 来爬取网站信息, 把有用的信息放入他的数据库里面, 喜欢扩充他的数据库里面没有的文章, 这样才能更好的为用户展示搜索结果. 2, SEO 角度看, 原创文章必定收录, 但是只是时间问题, 搜索引擎会把数据库中没有的文章都收录. 3, 用户角度看, 流量是搜索引擎给与的, 并不是我们获取的, 我们做 SEO 并不是去获取流量, 而是搜索引擎给你流量, 因为搜索看你网站的内容足够优秀, 内容足够的满足用户的需求. 只有把握这个原则, 你在写文章的时候就有了明确的目标. 比如在线下, 我们想开一家生产手机的公司进入手机这个行业, 在这个行业苹果是非常有实力的, 那么我们短时间内打不败苹果, 因为他们很早就开始做了, 只有我们有更好的模式, 然后才能足以跟他抗衡. 就跟我们做 SEO 一样, 比如说某个词, 有一个网站已经排名 10 年了, 我们通过单纯的 SEO 技术是打不败它的, 只有靠比他网站更加符合这个词的搜索习惯, 更能满足用户的需求, 那么搜索引擎才有可能给我们部分流量. 严格意义上, 一切通过某种方式坐上排名的都是黑帽, 那么我一切从用户出发, 满足用户需求为己任的写文章, 那么就不算作弊了. b) 文章写作方式: (那么我们怎么做?) 在写文章之前, 把你要坐的行业进行一个初略的了解, 至少知道用户关系什么(买产品还是获取服务), 用户需求是什么(产品或服务能给他们带来什么)了解了这些我们就可以在写文章的时候更好的满足他们的需求. 1, 自己动脑写或者花钱请人写.(淘宝)2, 找相关内容组合起来. (可以参看书籍, 材料等)3, 伪原创(不鼓励) 与原创相反的就是伪原创. 原创和伪原创实质的区别不好区分, 互联网上面提到一些伪原创工具和伪原创方法不建议大家使用, 大家如果写原创真的很困难的话, 建议采用整理知识点的方式, 把网站的需求总结下来. 4.3.4.2. 文章质量文章除了要原创外, 还要注意文章的质量. 质量里面包含: 内容质量和技术质量. 今天我们讲内容质量以及写文章具体做法. a) 什么是内容质量? 内容上要符合用户需求, 并且合理把 SEO 技巧融入到文章, 使文章既符合客户体验又符合 SEO. 1, 网站信息丰富, 网页文字能清晰, 准确地表述要传达的内容, 有一定独特价值. 文章中更多的去涉及到和该网页有关的信息, 足以让更多的流量通过搜索一系列组合关键词来到我们网页. 不要为搜索引擎创造内容, 完全以用户为基础. 具体做法: 1, 文章与标题要对应2, 指数在 500-1000 字3, 词语多命中相关关键词(解决需求)4, 排版要合理参考”报纸”的排版(分段落, 层次分明) 2, 把 SEO 的技巧融入到网页, 让网页更加符合 SEO. 具体做法: 1, 关键词非常重要(一篇文章里面放首段, 一段话里面尽量放句首, 不要太刻意)2, 文章内要放锚文本链接(站内优化时候会详细讲)3, 文章避免堆砌关键词. (堆砌关键词属于作弊)4, 注意关键词密度(关键词占整个网页文章的比例, 一般是在 2-8%, 关键词密度已经不是很重要了)5, 遇词必链(在网站中遇到关键词的时候就去链接到该关键词所属页面, 同页面遇到只链接一次就可以. 学习”百度百科”内链加法)6, 网页中有图片的时候, 要加上 alt 属性. alt 属性就是对图片的描述, alt 里面写关键词. 写作的一些注意点: 1, 最好每篇文章都模仿软文方式来写, 不是一天能练成的需要你有朝着这个方向努力的态度.2, 如果你不会写文章, 可以总结互联网上面的文章把他们最重要的知识点组合起来就形成一篇新的文章了. 4.3.4.3. 文章技术上一节课我们讲了内容质量, 要写有价值的原创文章, 并且注意运用 SEO 技巧, 我们这节课讲技术质量方面内容, 技术方面也同样重要. 技术质量方面 a) 请不要创建多个包含大量重复内容的网页, 子域或域. 搜索引擎会尽量收录提供不同信息的网页, 如果您的网站包含了大量重复的内容, 那么搜索引擎会减少相同内容的收录, 同时认为该网站提供的内容价值偏低. 当然如果网站上相同的内容是通过不同形式展现(如论坛的简版页面, 打印页), 可以使用 robots.txt 禁止 spider 抓取网站不想向用户展现的形式, 这也有助于节省带宽. b) 请不要制作欺诈性或安装有病毒, 特洛伊木马或其他有害软件的首页 百度站长平台安全检测工具. c) 内容的格式书写有时候我们需要用到 html 格式书写时候请注意标签的完整性. 4.3.4.4. 文章频率a) 更新频率的概念 频率是指单位时间内完成某项活动的次数. 文章更新频率是指网站持续更新文章的天数和每天更新文章的数量. b) 文章持续更新的重要性 1, 对用户, 网站的内容得到了填充, 用户会更加喜欢你的网站, 增加了用户的信任感和粘性, 信息得到了良好的传递, 能够促进收益. 2, 对搜索引擎, 网站文章经常更新有助于收录量提升, 收录是靠 SEO 技术获取流量的基础. 爬虫收录的原理: 爬虫会通过链接来到你网站, 去爬取你刚刚发布的文章, 然后去辨别网站文章质量, 如果是原创, 一定会被抓取, 然后决定是否收录.(第五阶段会详细讲收录原理) 3, SEO 角度来看, 网站文章的更新, 能够增加权重, 利于排名. 收录增加, 网站的权重会增加, 另外网站每更新一篇文章, 就增加了页面数量, 这个对于排名有很大帮助(SEO 模型原理) c) 更新内容多少合适? 网站规模越大, 内容更新量越多, 频率越高, 一般的企业站每周更新几篇就好, 大中型网站更新的频率比较高, 因为网站的规模不同, 吸引的爬虫不同, 权重不同. 权重越高, 可能爬虫就越多, 更新的就越多, 收录的就越多, 这类推荐更新文章内容多少根据网站的实际情况来决定, 至少要做到每天都更新. 一般小网站每天更新几篇文章即可, 大型网站更新的内容就要有一定的量了 d) 更新注意点 1, 文章更新越及时, 收录就会慢慢变多, 正常情况下流量就会增长越快.2, 我们主张网站更新按照一定的规律发布文章, 最好是递增的梯度.3, 更新的文章要保证原创, 内容质量和技术质量过关, 才有效果. 4.3.5. 结构4.3.5.1. 用户行为分析和 F 型, 树形结构a) 概念用户行为分析, 是指在获得网站访问量基本数据的情况下, 对有关数据进行统计, 分析, 从中发现用户访问网站的规律, 并将这些规律与网络营销策略等相结合, 从而发现目前网络营销活动中可能存在的问题, 并为进一步修正或重新制定网络营销策略提供依据. b) 对 SEO 的价值 用户行为分析应该包含以下重点分析数据: 用户的来源地区, 来路域名和页面; 用户在网站的停留时间, 跳出率, 回访者, 新访问者, 回访次数, 回访相隔天数; 注册用户和非注册用户, 分析两者之间的浏览习惯; 用户所使用的搜索引擎, 关键词, 关联关键词和站内关键词; 用户选择什么样的入口形式(广告或者网站入口链接)更为有效; 用户访问网站流程, 用来分析页面结构设计是否合理; 用户在页面上的网页热点图分布数据和网页覆盖图数据; 用户在不同时段的访问量情况等; 用户是否对网站的字体颜色的喜好程度. c) 树形结构和 F 型结构 通过用户分析我们能够得到两种模式网站更加有利于用户体验同样符合 seo. 1, 树形结构: 是数据元素之间存在着”一对多”的树形关系的数据结构. 可表示从属关系, 并列关系. 网站的结构像树形一样. 2, F 型结构: 网站安排采用左上角是最重要位置. 网站的结构像字母 F 的网站结构. 两种结构的价值 F 型或者树形都是满足了网站扁平化的需求, 网站爬虫能够顺利的去爬网页, 更利于搜索引擎的抓取. 爬虫抓取深度是有限的, 但是通过这种扁平化的网站结构更利于爬虫爬取, 结构上符合了 SEO, 是我们做 SEO 的第一步. 4.3.5.2. 调用相关和最新文章a) 相关推荐板块 在很多的网站上文章页面部分都有一个板块, 这个板块里面的内容和我们浏览的网页的内容基本类似, 这个板块通常的名称就是相关推荐. b) 演示 SEO 每日一贴, 腾讯新闻等网站 c) 相关推荐为什么很重要 1, 增加网站的 PV, 用户粘度增加 形成网站的 SEO 模型, 让网站更多相关页面链接起来, 形成外部链接提升排名 2, 减少了跳出率, 用户更多的去点击推荐网页了 3, 形成了 SEO 模型, 让网站更多页面链接起来, 形成反向链接起来提升排名. d) 如何调用 不同程序, 实现方法不同, 调用代码实现即可 e) 其他板块: 最新文章板块 最近文章板块能够让网站的页面更加的活跃. 更新带动器 4.3.5.3. 次导航a) 次导航定义 通常网站有导航, 相对于网站主导航而言, 一般放在网站的页脚位置. 当因为某些原因主导航不能放置关键词的时候, 我们可以在网站页脚做关键词锚文本指向对应的 URL. 做好次导航对于提升网站关键词在搜索引擎上优化排名有着推动作用. 次导航, 又叫”全站链接”. b) 演示 京东商城为例 c) 次导航对 SEO 的影响 1, 组建 SEO 模型. 增加了反向链接的数量对网站的排名非常好.2, 用户体验更好. 增加了用户寻找同类信息的机会.3, 增加首页入口页面. 通过点击可以进入首页, 去访问更多的内容. d) 次导航注意要点 不要放置太多, 不要堆砌. e) 次导航怎么做 放在网页 footer 即可 4.3.5.4. 站内站a) 概念 在二级目录下面放一个独立的网站程序, 形成二级目录下面也一个网站的形式, 这个二级目录下面的站点就是站内站. b) 举例 演示 wp 百科网 c) 站内站如何做 在安装网站的时候我们通常是安装到首页的, 这里以二级目录形式来安装. 比如常见的: www.abc.com/bbs/ d) 对 SEO 的影响 1, 构建 SEO 模型, 让更多的相关页面链接起来.2, 收录增加3, 获取更多的流量. 4.3.6. 站内优化4.3.6.1. 长尾词列表长尾词列表 a) 概念 记录网站关键词的链接 URl 地址的表单. 网页上面涉及到的关键词就会记录下来关键词和地址, 放入 EXCEL 表格中. b) 为什么要做呢? 关键词多的时候便于记忆以及统一管理, 在 SEO 执行过程中会多次用到. 比如(文章内部加内部链接的时候会用到, 网站发布外链接的时候也会用到等) d) 长尾词列表的扩充和整理 我们的长尾词列表要不断的增加的, 因为网站不断的增加文章, 不断的增加关键词. 未来长尾词列表会做成”词库” 4.3.6.2. 锚文本a) 锚文本的概念 锚文本又称锚文本链接, 是链接的一种形式, 锚文本实际上是建立了文本关键词与 URL 链接的关系. b) 锚文本的作用 1, 锚文本为”搜索引擎”页面添加的链接一般来说都应该跟页面有直接相关的联系, 搜索引擎可以根据指向某一个页面的链接的锚文本描述来判断该网页的内容属性. 2, 锚文本对搜索引擎起的作用还表现为可以收集一些搜索引擎不能索引的文件. c) 锚文本的使用 1, 写文章时候在内容中添加. 遇词必链, 学习百度百科的内链方法. 2, 发外部链接的时候最好是锚文本形式. 或者 URL 的话那么在他左右文字就是相当于锚文本. d) 注意点 切记锚文本不要使用太密集, 造成优化过度, 而且涉及到”锚文本轰炸” 4.3.6.3. SEO 频道a) SEO 频道概念 用大量的普通页面, 关键词链接指向网站内部的几个或者一批页面, 将普通页面的优势集合起来展现给搜索引擎, 这个就是 SEO 频道. 传统的 seo 做法是将这一堆页面都链接向首页或者栏目页. 但栏目页有时候不适合作为 seo 流量导入页面, 大部分流量都集中在首页, 首页数量上比较多, 而且零散, 我们不能保证每个内页都收录并且有好的排名, 这时候很多的关键词就集中在了首页或者内页上, 这时候我们需要另外单独做一批页面, 这批页面把内页的一些非常有价值的信息通过组合展示出来, 这些页面就是 SEO 频道页面. b) 举例: 我们之前讲过做长尾词记录单, 我们发现济南真人 cs 游戏项目非常多如果每个页面都介绍一个的话, 不能确保每一个页面都能收录并且有好排名, 这个时候我们在想, 能不能根据他们的共同特点做出一个页面出来, 这个页面上面囊括他们比较多的优势信息, 我们把一批内页的流量放在一个页面上面展示, 这样子就只做这一个页面的排名就可以了. 我们发现我们之前每个页面上面都有一些共同点(真人 cs 项目的名称, 玩法, 推荐指数)另外还缺少一些知识介绍, 我们发现我们网站其他的页面有介绍的另外知识点如(真人 cs 的价格, 真人 cs 介绍), 我们就在想能不能整合成一个网页, 这个网页上面包含了(真人 cs 简介, 价格, 游戏玩法等关于真人 cs 非常相关的信息)这时候我们就创建了一个组合页面. 这个组合页面就是 SEO 频道, 也可以叫做专题页面. c) SEO 频道的功能和如何制作 增加网站的收录量 获取更多的排名和流量 (如何制作 SEO 专题页面我们在第 4 阶段给大家详细讲.) 4.4. 外链4.4.1. 外链的历史外链的由来: a) 每个连到你网页的链接都是对其质量表示肯定的一张”选票”, 自然搜索引擎在判断哪个网页对其搜索结果来说具有最高质量时, 会计算这些”选票”. b) 为了更多地获得在搜索结果当中的排名或者为了在排名当中能够有一个不错的位置, 外链成为了一个网站站外优化的唯一途径. 外链的发展: a) 得到更多的链接 每条链接获得的权重都是差不多的, 这是外链最初的阶段, 链接越多越好. 短期内确实取得了很好的效果, 但是只是短期, 因为搜索引擎发现很多非优秀的网页比一些优秀网页的排名还要好, 原因就是他们获得了很多的垃圾外链(小站的链接). b) 从最大的站点得到链接 于是搜索引擎开始重视外链的来源网站, 站点越大, 链接所获得的权重越好, 于是这个时候, 一些大型网站的目录, 和一些小的目录开始受到追捧. 但是, 一直在发展的搜索引擎发现这些大站的分类目录好像原意链接到几乎所有的站点, 并不关心在自己网站上加外链的站点质量, 甚至不相关也无所谓. 更重要的是搜索引擎还发现这些链接以首页的链接为主, 对于信息型搜索词和交易型搜索词好像根本没有照顾到, 于是为了重视这些内页, 搜索引擎做了调整: 那些只有首页被链接的站点对于信息型搜索词和交易型搜索词的请求不再能得到高的排名. c) 深度链接是重要的 这次调整之后, 搜索营销人员发现锚文本的价值被提升, 且”深度链接”是他们对此的应对措施, 意思是”如果你链接我的网页, 我会链接你的”, (就是国内我们常见的友情链接), 效果极佳. 但是过了一段时间后忽然那些采用了此类手段的网站排名开始不稳定了, 甚至有下滑的趋势, 很显然, 你也应该知道了: 搜索引擎又做了调整. d) 单向链接的时代来临: 英勇的搜索营销人员发现拥有单向链接的页面开始得到青睐, “我们需要尽可能多的单向链接”, 这一观点开始泛滥, 博客留言, 跟帖这些链接绝大部分是为了针对搜索引擎设计的, 后来的事, 跟前面一样, 这些靠单向链接获得优秀排名的站点开始被降权, 排名下滑, 因为博客留言这种方式获得的链接实在太没有价值, 并不能挑选出优秀的站点, 搜索引擎再次做了调整. e) 购买知名站点单向链接: 这个口号开始传遍搜索营销人员的耳朵, 因为至少从技术角度是判断不出来这条链接是否是免费的, 是否是自愿加上的. 于是一大批无名小站排名扶摇直上, 但是站点本身又没有什么改进的地方, 只是有很多知名站点给了他们单向链接而已, 而且这个链接给得莫名其妙, 就像新闻联播之前, 经常有一家酒厂给我们报时一样. 向我们之前经历的一样, 搜索引擎于是又做了调整, 这些劣质的但是获得了高质量单向链接的站点开始失去了他们的排名优势. f) 相关的链接开始受到关注: 于是故事开始到这里展示停住了, 至少目前来看, 这些策略(相关链接)一直在被使用, 而且效果极佳. 以后会发生什么事, 我们不知道, 我们这里是当作童话来讲的, 真实的外链策略与搜索引擎的博弈远比这些复杂. 总结: 以上这些方法是外链的一个发展史, 也是营销人员和搜索引擎的博弈历史, 但凡是人为刻意的外链都是一种投机行为, 只要是投机行为, 都有一定的局限性. 注意点: a) 这些过时的手段依然有效: 通过上面的讲解, 你可能会认为以上讲的链接是不是都失去了效果, 或者你认为他们都不再有价值, 那就大错特错了, 以上给大家列出的这些外链行为, 到今天为止, 依然有效, 只不过效果没有以前那么好了而已, 我们讲的是搜索引擎”调整”而不是”彻底放弃” 4.4.2. 外链的价值可以带来流量: 这是外链最基本的价值, 我们要清楚链接的本质, 基于用户的外链才是最稳定的外链. 可以直接增加爬虫的访问概率: 吸引到更多的爬虫爬取, 从而增加了收录, 另外还可以获取相关网页的信任投票从而, 增加了权重, 以及网页排名的稳定性, 外链是站外优化的唯一途径. 外链是确认竞争对手实力的途径: 除了内容之外, 外链是衡量以及研究竞争对手的一个重要参考. 外链是对优质网站的奖赏: 很多优秀的网站持续不断的得到外链, 这才是真正的外链策略: 做好内容, 服务好访客, 外链自己会送过来. 这是网络和纸媒区别最重要的特点: 网络为什么比纸媒有更大影响力, 因为就是网络使用方便, 我们想看另一方面的咨询, 只需要点击下链接就可以, 而不用换本杂志, 或者换张报纸. 4.4.3. 外链的资源分析外链的方式有很多种, 这里给大家列举分析几种常见形式: 1, 博客: a) 新浪, 搜狐, 天涯免费博客, 独立域名博客都是可以的; 2, 论坛: a) 论坛上可以留下链接b) phpwind 或者 discuz 3, 友情链接: 就是网站双方的管理员互相在各自的网页上加上对方的链接: a) 百度b) hao123 4, 博客留言 5, 软文 软文发外链的目的就是引起转载, 前提是文章内容优秀, 当然不排除有些网站去除链接的可能, 真正优秀的网站会给您保留的, 那些不给您保留链接的网页本身就是有风险的, 加多了反倒不好. 6, RSS 网站 a) 这个有点像分析, 只不过分享只是某篇特定的文章, 而 RSS 订阅某网站的内容, 只要有新的文章更新, 订阅平台(比如谷歌阅读器)就会有这些网站的标题和内容; b) http://jandan.net/ 7, 网站目录 a) 百度当中搜索”目录提交”, 要申请或者收费; 8, 问答平台 a) 百度知道 9, 借助百度站长工具 a) 可以获得更多资源, 尤其是竞争对手的外链资源; 4.4.4. 外链操作4.4.4.1. 外链计划外链的重要性: 增加收录, 提升排名. 第一阶段: 收录 新站刚刚上线, 首要解决的就是收录问题. (一个月内)发首页链接 第二阶段: 排名 外链组合成 “SEO 模型”, 提升排名. (一个月后)发多个页面链接 外链相关度: 一定要相关 外链广泛度: 相关网页数量要多 外链流行度: 尽可能多的 URL 获取链接 演示: ZAC-每日一贴 查询工具(百度站长平台-外链查询) 第三阶段: 稳定收录和排名 重复第二阶段, 持续发外部链接, 保证外链接增长速率(更加稳定, 持续) 4.4.4.2. 外链收集外链收集: a) 定义: 收集可以发相关外链的网页b) 工具: Excel 表格c) 操作方法: 填表格法 网址,类型,用户名,密码,邮箱,相关性,留下链接形式 1, 建立表格, 并且设定一些参数 2, 收集符合条件的网页填写到表格 d) 如何找相关网页的链接 1, 查看竞争对手网站外链情况(百度站长工具-外链查询) 2, 通过搜索”关键词” 4.4.4.3. 外链筛选a) 定义: 把收集来的网页筛选出来能发链接的网页.b) 如何做 收集的网页, 有发表评论/主题的地方, 保存到表格里面 没有发评论/主题的地方, 直接删除网页即可 4.4.4.4. 外链执行监控a) 定义: 把外部链接发布到相关网页上.b) 操作: 1, 组织话术 类型 要点 举例 博客留言 组织一句非常通俗的广告语, 放入链接 论坛发帖 组织一篇文章中加入锚文本/末尾放链接/签名回帖 门户投稿 组织一篇软文文章中加入锚文本/末尾放链接 友情链接 谈你很认真的更新文章和发布外链 2, 注册账号 论坛账号, 门户发稿账号, 免费博客账号等 3, 判断能否留上链接 注意: 留链接的时候要确认链接的 URL 唯一化. 一般的是http://www.seojiaoxue.com/, 注意带上”/“和不带是有区别的. 4, 外链发布 c) 外链监控 主要看网站外链的增长趋势即可. 4.4.4.5. 外链实际操作演示a) 准备工作 制作一个 Excel 表格存放发外链资源 注册一个站长工具账号查询外链情况. b) 演示 收集, 筛选, 执行, 监控 4.4.4.6. 发布外链注意事项1, 确保标准化 其实就是 URL 的唯一性: 一个关键词只能对应一个 URL, 一个 URL 可以对应多个关键词. 2, 网站主题类型要尽量相关: a) 链接相关性是我们 SEO 模型当中极其重要的因素, 是我们未来排名的关键;b) 在站外链接的时候我们也要注意, 在 SEO 里面外链和内链没有严格的区别, 我们优化的对象是网页而不是网站, 当网站主题不是特别相关的时候, 我们尽量寻找相关的页面. 3, 要分散在尽可能多的优质网站上 外链之所以被视为对排名有重要影响的因素就是因为, 它代表了该网页的受欢迎程度, 那么如果外链效果要想好的话, 尽量不要集中在极少部分的网站上, 尽可能多的出现在优质的网站上, 在同等条件下, 数量越多获得的信任度越高. 4, 链接尽量呈现多样性 链接的多样性包括两个方面 a) 不要仅仅是发布首页的链接, 信息型搜索词和交易型搜索词才是我们的重点客户, 也就是我们内页链接的广泛度要引起重视和加强; b) 不要是仅仅一种链接形式, 一个优秀的网页往往是各个方面都很优秀, 如果外链当中全部都是一种形式的链接会引起怀疑的; c) 外链当中最好的形式是锚文本, 假如没有锚文本, 在我们的 URL 链接周围也要尽可能地放上我们的关键词. 5, 频率要自然: a) 我们要一步一步地为网站构建链接, 记住: 外链增长越自然越好, 有什么样的”内功”就练什么样的”招式”(外链), 否则会走火入魔(被惩罚); b) 使您的站点成为链接磁铁石, 最好的外链是用来吸引流量(访客)的, 而不是引蜘蛛. 6, 作弊是愚蠢的 常见的作弊手段有很多, 这里给大家举几个例子, 这类作弊已经被搜索引擎注意很多年了, 可能您会暂时取得一些排名, 拿到一些流量, 但是只会是暂时的, 如果您想做一个长久的稳定的网站, 就不要去挑战搜索引擎的智商. a) 链接工厂 一些狡猾的搜索引擎营销人员通过建立几十上百个独立站点, 专门作为某几个网站的外链资源站, 可以迅速的给目标站点添加几千个链接; b) 隐藏链接 这个主要是通过一些页面处理, 使得页面的一些内容用户看不到, 但是蜘蛛可以抓取到, 这类页面是专门给蜘蛛设计的页面. 这样被认为可以在上面添加很多的链接, 指向他们的目标站点; c) 伪造的双向链接 有很多网站站长会给您发出请求, 比如他们会在他们页面上做出超链接指向您的网站, 但是作为回报, 你也要在您的网站上加上指向他们的链接, 这个其实就是互换友情链接. 看似公平的交易, 其实会出现作弊, 虽然在他的网站上有指向您的超链接, 但是搜索引擎蜘蛛并不会给您的网页权重和加分, 也就是得不到认可, 也就是他做了伪造的链接. 过来人给大家的建议: 一定要小心确保自己没有被人愚弄, 更重要的是没有卷入愚弄蜘蛛的项目当中去, 后者比前者更加危险. d) 外链群发 博客群发, 留言板群发, 病毒传播的链接发布在无关页面上, 用在市场上可以购买的群发工具来发外链更是”必死无疑”; e) 黑链 入侵其他人的网站, 篡改别人的网页, 使得别人的网页上出现自己网站的链接, 大家要清楚购买黑链和购买专业外链很多时候性质都一样. 7, 注意点 但凡可以发布的, 不是自然增长的外链原则上都可以叫做作弊, 只要是作弊, 都会受到搜索引擎的惩罚, 只是时间问题. 8, 总结 不自然的外链, 无关的外链, 并不能给访客真正带来价值的外部链接都属于有作弊嫌疑的, 因为外链的本质就是引导和吸引客户, 也就是吸引直接流量, 搜索引擎只是模拟用户给了外链一些权重, 所以不要单纯的为了搜索引擎去设计外链, 那样你会被搜索引擎”看不起”的. 4.4.4.7. 外链策略这里给大家讲的策略更多的是一种思路, 给大家作一个参考, 但是这仅仅是”术”, 想真正做好外链就要把”道”走对了, “道”就是从外链的本质出发: 1, 为了获取直接流量的外链. 2, 把内容做好, 吸引外链. “道”走对了, 获得搜索引擎的信任只是时间问题. 1, 软文: a) 热门事件: 比如私奔帝 “王功权” 属于一个典型的例子, 此事件一出, 刺激了广大网民, 于是各大媒体, 营销文案开始围绕此事大肆炒作, 各类软文也是各显神通, 因为这类热门事件极易引起大家的关注和站长们的转载. 凤凰网: 最适合私奔十大胜地 搜房网: 私奔帝王功权回家了 看全球十大私奔圣地(图) b) 八卦事件: 成功明星背后都有成功的八卦 c) 分析 中国绝大部分网民素质并不算高, 所以他们的关注点也是不一样的, 想想芙蓉姐姐和凤姐的成名史我们就清楚了, 中国人上网的普遍兴趣(至少现在是): 等出事, 看热闹. 所以要想赢得他们的外链, 迎合他们的口味是很多人的选择. 2, 技术 a) 模板制作: 这个比较知名的例子是某个人的独立博客, 他这个博客有一段时间在 SEO 这个词上的百度搜索结果中排在首页, 其原因就是他分享出来了自己的博客模板, 当然模板上带有自己的链接. 大量的人开始使用, 于是产生了大量的外链, 注意: 这带来的仅仅是链接, 里面很多是非 SEO 的网站. 最后的结局是, 该博客排名至今没有起色. 方法是好方法, 依然对于外链有效, 缺点就是不可控. b) 插件 这个也是一个很好的吸引外链的方法, 如果您制作的插件能够给广大站长带来方便的话, 他们推广起来也会很快. 比如 wordpress 后台有很多插件, 这些插件的作者就在插件上留下了他们的链接, 这也不失为一个好方法. 分析: 互联网一个很重要的精神就是分享, 稍微懂点技术的人, 可以考虑下. 请大家明白你有多用心为他人服务你就有多大的回报, 至少跟某些行业比, 互联网对这句话验证的例子要多得多. 3, 活动 a) 可以跟名人, 著名景点发生关系, 比如 SEO 十大牛人评选, 最适合私奔的十大景区评选等, 这类活动往往能够引起本行业网站的关注和转载. b) 根据节日制作的特殊网页, 比如祝福网页, 好玩儿的应景小游戏, 往往也是可以带来很多外链和流量的, 这些东西技术含量往往并不高, 主要应一些活动的景, 节假日就可以认为是全名的一个活动. 4, 其它: a) 购买链接: 这并不是多么见不得人的事, 很多网站比如阿里巴巴都会有专门的预算来购买链接, 尽管阿里巴巴因为外链的问题被谷歌惩罚过, 但是这个毕竟是一种策略, 为了获得流量, 有些风险是值得的, 其实仔细想想, 哪种创新不是冒险呢? 只是看你有没有冒险的资本, 购买链接我们要掌握好一个度. b) 群发 群发同样也不是多么见不得光的行为, 群发掌握的好, 效果还是很不错的, 不过这种群发方式影响面小, 如果用大家都知道的群发工具来做的话, 那你的站必死无疑. c) 黑客: 真正好的黑客, 都是技术高手, 这种技术往往可以做出很好的事情出来, 很多黑客都是值得尊重的, 他们看不惯垄断, 他们讨厌技术壁垒, 他们期待网络更加公平. 但是用黑客技术攻击别人的网站来发外链绝对不是一件值得尊重的事情, 而且我们相信这么做的人如果不知道悔改的话, 也不会有什么值得期待的未来. 4.5. 心态何谓执行力: a) 在 SEO 里面就是我们要沿着正确的优化方向坚持做下去, 禁得住诱惑. b) 比如我们的一个网站按照正规方法完全用自己的原创, 站在用户的角度去优化. 我们要记住我们的目的是要持久的排名, 稳定的流量, 而不是昙花一现. 越是这个时候越要坚持按照正确的方向走下去, 这就是执行力. 送给大家一句话: 好走的路都是下坡路. 为什么要提升执行力: a) 执行力是 SEO 的关键; b) SEO 不像传统行业, 有努力马上得到回报, 比如我们投入一些原材料到生产线上, 马上就能看到原材料变成了产品, 但是 SEO 我们投入精力和努力, 经过 2-3 个月才能慢慢看到效果, 而且如果我们想做到一个调整也不是马上就能看到效果的, 所以这个时候执行力就显得尤为重要, 内容要持续更新, 所以我们可能需要每天做重复的工作, 当大家技术水平差不多的时候拼的就是用心, 拼的就是执行力. c) 今天很残酷, 明天更残酷, 后天很美好, 但是绝大部分人死在了明天晚上, 我们要争取看到后天太阳升起. 执行力的核心: 坚持 成功贵在坚持, 我们可能很久之前就听说过这句话, 但是有多少人能真正做到呢? 5. SEO 系统5.1. 算法5.1.1. 算法历史SEO 元年: a) 世界上第一家搜索引擎公司是雅虎, 当时就是一个目录, 诞生于 1994 年, 随之而来的就是针对该搜索引擎的排名, 其实就是如何在这家网站目录上更好的排名, 1995 年算是 SEO 元年吧. b) 这个时候排名很简单, 比如标题上加 ⭐ 就可以在雅虎目录上有很好的排名. 当然现在也有标题上加 ⭐ 但是更多的是为了醒目, 吸引点击. c) 推荐网站: “互联网档案馆” SEO 的萌芽: a) 搜索引擎排名 1995 年-2003 年国内已经有相关的 SEO 人员开始研究了, 只不过当时不叫搜索引擎优化 SEO, 而是叫做搜索引擎排名, 网络上也有了一些关于排名的资料. b) SEO 行业”野蛮生长” 国内: 以 SP 产业带动起来的高速发展的暴利刺激下, SEO 行业只能用”野蛮生长”来形容, 一个资深 SEO 从业者的原话: “当年我们推广网站不是托在搜索引擎公司上班的熟人, 朋友把排名放上去, 就是搞信息堆砌, 制造反链来作弊, 这些做法尽管一时很见效, 但是随着搜索引擎内控的严格和管理的完善, 很多网站都被淘汰了.” 现在看来其实就是低级的黑帽手法. 国外: 2002 年也是谷歌 SEO 被极大范围滥用的一年. 2003 年(真正 SEO 到来) a) 谷歌的”佛罗里达更新” (Florida update) b) 这是 SEO 历史上最为严厉的针对垃圾网页和不法 SEO 的惩罚, 国内也开始有搜索引擎优化的叫法了, 这一年可以叫做白帽 SEO 元年吧. c) 谷歌的技术更新, 同样意味着其他搜索引擎也相应做了调整. 2005 年(SEO 开始走向稳定) 国外: 以谷歌为代表的搜索引擎开始极为频繁的更新, 而不是之前的定期更新, 这就使得 SEO 从业人员能够在很短的时间内看到自己调整网页后的效果. 国内: 得益于导航网站, 用户体验提升, 市场推广的成功, 百度的市场份额逐渐扩大, 这个时候(2005 年)百度的市场份额是 28.7%, 谷歌中国 16%, 中国雅虎 29.8% 2006-2012 年两件大事: a) SP 产业的政策调整 2006 年 8 月, 随着国务院, 信产部决定将 SP 服务资格证收归移动运营商所有, SP 产业的黄金时代嘎然而止, 以彩页 flash 配诱惑性文字为特征的传统 SEO 推广策略失去了最大的市场. 这之后 SEO 才真正的进入到电子商务领域. b) 谷歌退出中国市场: 当时在国内主流的 SEO 教程里面, 绝大部分内容是欧美人士针对谷歌的研究的成果, 只是套用在了百度上面. c) 百度 SEO 开始成为国内主流: 从这个时候开始, 百度的不稳定, 百度的各种弊病开始成为广大 SEO 从业者常常讲的话题, 原本在谷歌上屡试不爽的策略, 在百度上面迟迟不见效果, 但是在谷歌上必定被惩罚的策略, 在百度排名上成为了一把利器. d) 百度和谷歌原则上是一致的 尽管搜索引擎所处的阶段以及策略不同, 但是他们的大方向是一致的, 从长期来看, 百度和谷歌并没有什么特别大的区别, 重视客户体验, 注重内容的网站往往排名都差不了. SEO 的转型与机遇: a) 自 2006 年底开始, 随着建站技术的普及和竞价排名模式的争议渐起, SEO 的发展迎来了新一轮战略机遇期. 这个阶段慢慢的 SEO 逐渐摆脱了之前”作弊””投机””忽悠””黑客”的帽子, 开始成为了为电商服务的流量先行军; b) SEO 成为了一种热门职业, 在我国电商人才缺口极大, 这些缺口当中 10%都跟 SEO 有关. 在我们很多地方毕业就等于失业市场环境下, 电商企业 SEO 岗位开高薪却无人应聘的情况是有发生; 5.1.2. SEO 原理a) 世界各大搜索引擎发展到现在, 其实技术水平都差不多, 所以了解了百度的工作原理之后, 对其他搜索引擎也是一样的. 频率值: a) 搜索引擎的硬件是有限的, 不可能有太多资源对每一个网页频繁光顾, 简单来理解就是不同的网站, 搜索引擎光顾的频率不一样. 有些网站一天抓取几百上千次, 但是有的一天只有一次, 也可能几天才来一次. b) 影响频率值: 虽然蜘蛛针对不同的网站的网站有不同的频率值, 但是我们可以通过做一些事情影响它的频率值. c) 提升频率值的方法 经常更新的网站, 往往频率值会比较高, 所以尽可能持续更新; 搜索引擎会形成习惯的, 为了更加高效的工作, 它会特别关注那些经常更新的网站. 历史记录: a) 我们网站所有的历史会被搜索引擎记录下来, 搜索引擎的计算过程会参考您的网站在历史中的表现. b) 这里提醒我们: 网站前期不要犯错误, 必须在进行网站建设的时候不要做错误的事情, 一定要谨慎, 比如原创, 网站结构等等. 在后期评估网页质量的时候会参考你前期的工作. c) 三岁看到老, 道理都一样: 搜索引擎执行的是人的意志. 你在”小时候”的行为搜索引擎都会记录在案的. 过度优化: a) 网页中加入隐藏的文字, 隐藏的链接;b) 与网页内容不相关的关键词;c) 具有欺骗性跳转或者有欺骗性的重定向;d) 专门针对搜索引擎的桥页, 即所谓的过度页;e) 针对程序生成的内容: 制造大量的内容, 命中搜索引擎结果;f) 大量重复无价值的内容;g) 充斥着大量恶意广告, 恶意代码的页面;h) 群发链接等等; 过滤: a) 不要欺骗用户; b) 对内容的把握上很多人没有什么概念的;比如采集, 很多人乐此不疲, 其实对收录有很坏的影响 c) 误区: 所谓搜索引擎抓取, 就是被搜索引擎收录了; 事实上: 搜索引擎抓取一个页面, 跟搜索引擎收录一个页面是不同的, 他们之间还有一个环节叫做过滤, 搜索引擎做算法调整更多是对过滤环节的调整 d) 收录的问题往往集中在是否能够通过”过滤”: 蜘蛛来抓我们的页面向来不是问题. 我们没有收录的页面不是因为蜘蛛没来过, 往往是因为在搜索引擎看来对用户没有价值. 被过滤掉就进不了搜索引擎的一个数据库, 也就是没有收录. 索引: 这个提醒我们 keywords 已经不重要了. 输出结果: a) 按照道理到这里搜索引擎的工作就结束了, 事实上搜索引擎的工作才刚刚开始, 它要对搜索结果进行持续关注; b) 比如同一个词的搜索结果, 排名第一的网站, 用户的跳出率极高, 而排名第三的页面用户体验非常好的话, 那么排名的顺序就要再次调整了. 以上是搜索引擎工作最基本的原理. 搜索引擎与 SEO: 我们上节课主要是给大家讲了搜索引擎内部的工作流程, 这个流程到 SEO 里面就是优化的三个阶段: 收录, 排名, 点击. 如表: 搜索引擎内部 抓取 过滤 建立索引 输出结果 收集数据 SEO 工作 蜘蛛访问 收录 无 排名 点击 收录: a) 就像有人问您: 您最喜欢吃的水果是什么? 您脑海里肯定会出现很多选择: 苹果, 梨, 猕猴桃等等, 但是一个您从来没有见过且不知道什么味道的水果不可能出现在您的脑海里; b) 同样的道理, 我们要想在搜索引擎的搜索结果当中有一个不错的排名, 我们第一个要解决的问题就是让我们的网页进入到搜索引擎的脑海里(数据库), 这就是收录 c) 再补充一点, 抓取不等于收录, 就像您在集市上逛, 您看见(抓取了)很多人(网页), 但是不一定都记住(收录), 您记住的都是很特别的人(原创页面). 排名: a) 收录的问题解决之后, 我们下面要解决的就是排名, 如何让网页得到不错的排名呢? 条件 1: 自身优秀 – 相关且权威; 条件 2: 其它相关页面对该页面的信任投票 – 相关反向链接. 点击: a) 排名好, 流量不一定高. 有了排名之后, 另外一个要解决的问题就是点击率, 因为再好的排名没有人点击也是没用的; b) 就像我们在地铁口摆摊儿, 拿到一个离出口最近的位置固然是好事, 但是并不意味着客户就多, 很有可能他们直接绕过去看其它家摊上的东西去了; c) 同样的道理, 任何一个关键词搜索结果当中都会出现最少 10 个相关的网页, 那么如何让我们的客户选择点击我们的页面呢? 这就需要我们在标题和页面内容上下点功夫; d) 搜索引擎搜索结果调出来的除了我们网页标题之外还有网页内容的摘要, 这个网页内容摘要很多时候不是我们描述标签里的内容, 所以除了标题之外内容也很重要; 比如在百度里搜索 “廊坊 SEO 顾问”和”关于廊坊 SEO 网站优化之路的一些内容和观点”搜索出来的同一个页面, 一个调用的是描述标签里的内容, 另一个就是网页的其它相关内容. 总结: 总的来说, SEO 就要解决这三大问题: 收录, 排名, 点击. 影响这些问题的因素我们在其它章节给大家做了详细介绍. 惩罚: 降权: 意思就是搜索引擎对该网站的信任度下降了. 普通降权: a) 就是搜索引擎对某网站已经收录的页面再次进行过滤处理, 导致网站部分已经被收录甚至有排名的网页, 被过滤掉或者搜索引擎对其页面打分降低; b) 主要表现是: 网站整体收录量和整体排名下降; c) 主要原因分析: 1, 网站经常性的打不开;2, 页面用户体验太差, 比如跳出率很高, PV 很小;3, 死链过多;4, 网站改版后, 整体结构以及部分链接发生变化;5, 过度优化;6, 其它影响用户体验的因素. 比如: 在原本干净的页面加上太多弹窗广告, 经常性的更换主题. K 站: 具体表现就是直接从搜索引擎数据库中全部删除某网站, 是最为严厉的降权. 主要原因包括: a) 网站持续打不开: 比如域名没有续费, 解析地址发生改变, 网站搬家(也可能是空间商所为)但是没有重新绑定域名, 网站程序被删除, 网站含有敏感话题被机房管理员临时关闭, 长期遭受攻击导致网站打不开以及其他原因造成用户长时间不能正常访问; b) 对社会造成恶劣影响的网站比如: 反动的, 色情的, 敏感政治话题的等等; c) 页面严重过度优化等. 新站效应: a) 所谓新站效应就是指我们的一个全新的网站, 往往可以在很短时间内取得很好的排名; b) 新站收录排名下降并不是被惩罚: 我们都知道, 搜索引擎提供给我们的页面都是搜索引擎提前下载好的页面, 假如一个小时之前发生的事情, 搜索引擎上面可能就没有, 这就影响了用户体验, 那么正因为如此, 搜索引擎开始对一些网站不过滤或者粗过滤就直接让其进入到了建立索引和输出结果这两个阶段, 所以我们才能及时地在搜索引擎里面看到很多刚刚发生的信息. 我们通常所讲的”新站效应”背后的原因就这个; c) 在这之后搜索引擎还是会对网站再次进行过滤, 重新进行输出结果处理的. 大家要记住它当初只是暂时不过滤或者粗过滤, 即便是已经有排名的网站, 搜索引擎还是会根据自身的数据库情况持续地进行监控和过滤的. 注意点: a) 降权是针对整个网站的; 排名是针对网页的, 但是降权很多时候是针对整个网站的. b) 权重值 在搜索引擎内部都有自己对网页权重判定的一个值, 比如早期的谷歌 PR 值(现在重要性已经不如从前了), 百度和其它搜索引擎也都有各自对页面的判定标准, 只不过没有公布而已. “百度权重值” 百度从来没有承认过. c) 降权的本质就是: 对已经有收录的网页再次进行审核, 对已经造成不好影响的页面进行过滤或者降低打分处理. 5.1.3. 分词技术搜索引擎的资料库: a) 我们在查询任何一个关键词的时候, 搜索引擎不是现查现找, 而是提前准备好了一个数据库, 就等着我们去查询, 简单来讲就是搜索引擎提前讲它认为重要的页面信息尽可能地下载好, 放在了它的数据库当中, 这个供用户查询相关结果的已经下载好了的数据库就是搜索引擎的资料库; b) 不同的搜索引擎他们的数据库也是不一样的, 一般是在几十到 100 亿个网页左右, 我们就先当做 100 亿来计算. 索引库: a) 搜索引擎的本职工作: 我们在搜索一个关键词的时候, 搜索引擎要在浩瀚的网页世界里给我们找到我们需要的网页; b) 搜索引擎为什么那么快? 比如我们在几万字的文档上找一个词用 ctrl+f 都要花一点时间, 但是上百亿的网页当中去寻找只需要几分之一秒, 原因就是搜索引擎已经对这些网页进行了分类处理, 就像在图书馆我们寻找我们要的图书一样, 按照分类就可以节省很多时间; c) 这个经过分类的页面信息资料库就是我们讲的索引库. 索引库的分类和建立: a) 不论是中文还是英文, 网页的总数是不断激增的, 因为相关的新产品新话题也是不断增加的, 但是词语的总数是不变的比如所有的中文词语加起来也就不到 10 万, 英文也就上百个单词; b) 我们来算下: 英文 100 万个单词, 我们按照词来分类, 一个词一类: 100 亿/100 万=1 万; 中文我们就按照 10 万个词来算, 也按照词来分类, 一个词一类: 100 亿/10 万=10 万 这种级别的数据对于搜索引擎的计算机来讲还是很容易处理的; c) 除了计算的方便, 还有另外一个好处就是可以直接命中用户的搜索习惯, 因为用户的习惯也是根据词来搜索的, 通俗来理解, 搜索引擎的索引库就是这样的: 当用户输入关键词”汽车轮胎”搜索时, 搜索引擎就从汽车那行和轮胎那行里拿出同时都有的, 交集的 URL 来即可. 当然这是理想状态, 实际上搜索引擎的工作远比这些复杂, 但是原理是类似的. 以上就是关于搜索引擎索引库建立的相关知识. 分词技术: a) 概念: 通过上节课我们知道, 要想建立索引库, 有一件事必须要去做, 就是把页面上文字内容进行拆分, 分好一个一个词之后放到索引库当中去, 这个就叫做分词, 搜索引擎的这项技术就叫做分词技术. b) 理解: 分词技术就把词分开的意思, 看起来很简单, 但是大家要注意这个不是我们要学习的东西, 这是搜索引擎的一项技能. 我们要做的就是利用搜索引擎的这项技术, 因为搜索引擎的这项技术对于做 SEO 意义很大. 分词技术的流程: 一个页面对于搜索引擎来讲就一个布满关键词的页面而已. 分词技术对于 SEO 的意义 a) 比如我们的页面把”网上如何赚钱”这个词优化到了百度第一, 那么与此同时, 在”如何赚钱” “网赚”这些词上我们也已经有了很好的权重, 只是我们没看到, 后期我们加强一下, 那么很容易排名就上来了; b) 根据分词技术假如我们把”你””我”这些字优化上去的话, 搜索引擎是没有办法在其他词上给我们权重的; c) 所以我们写页面内容尤其是写网页 title 的时候要注意利用搜索引擎的这项技术, 合理布局我们的关键词, 使我们网页能够命中更多的关键词, 从而获得更多关键词排名. 5.1.4. SEO 指南5.1.4.1. 百度优化指南为什么要解读百度优化指南: a) 百度是大陆影响面最大的搜索引擎, 如果我们想在百度上获取一些流量或者稳定地获得一些高质量的流量的话, 百度喜欢什么样的网站不喜欢什么样的网站我们必须要清楚; b) 给出了百度 SEO 最好的方法; c) 给出了我们做百度优化的最高要求和最低标准; d) 我们这里只是对其进行解释和补充, 大家一定要认真看完百度优化指南上的全部内容. 百度优化指南的全称 百度互联网创业俱乐部搜索引擎优化指南 5.1.4.2. 谷歌优化指南为什么要解读谷歌优化指南: a) 谷歌是世界最大的搜索引擎, 虽然已经退出大陆市场(香港和台湾依然照常服务, 退出中国是不准确的), 但是不可否认的是它是公认的世界顶级搜索引擎, 代表了搜索引擎发展的趋势, 所以它的优化指南对我们有巨大的参考价值, 包括中文搜索而不仅仅是外贸. b) 谷歌对 SEO 的建议在所有搜索引擎里是最好的, 也是最专业的. c) 谷歌优化指南给了最好的优化手法. d) 谷歌优化指南指出了 SEO 优化的方向 e) 我们只是针对谷歌优化指南进行解释和补充, 内容还是需要大家认真看的. 谷歌优化指南的全称 名字: &lt;&lt;谷歌搜索引擎优化初学者指南&gt;&gt;, 从名字上就可以看出来, 谷歌跟百度对于 SEO 从业者的策略有很大的不同, 各有利弊. 5.1.5. SEO 最新动态搜索引擎算法更新 a) Google Panda(谷歌熊猫) 打击对象: Content farm(内容农场) content farm: 指的是科技行业指责单纯为了其搜索服务的流量而为用户用户提供低质量, 通常并不可能靠而且在某些情况下甚至是剽窃来的信息. 简单来理解内容农场就是指那些低质量内容的站点, 通过采集, 拼凑起来对访客无价值的页面. b) Google 页面布局算法 2012.1.19 左右开始, 打击对象主要是在网页首屏放置太多广告, 而使得真正对用户有帮助的内容成为了广告的附属品. 尽管在首屏投放广告是一种极为常见的做法, 但是对此谷歌官方回应: 我们希望用户将能够看到内容, 不总是向下滚动. c) Google Penguin (谷歌企鹅) 谷歌于 2012.4.14 开始对于过度优化的网站进行严格审核, 之前坊间流行的谷歌 SEO 手法, 成为这次重点打击的对象: 交换链接(友情链接), 黑链等. d) Google EMD 更新 2012.9.28 左右开始, 主要针对域名中包含关键词的网站进行降权, 因为之前给了过高的权重. 比如在 car 这个词的排名上, 如果您的域名是 carxxx.com 那么之前谷歌会给你一些比其他没有包含 car 的域名更高的权重, 这次更新谷歌把它收回. 5%以上的英文网站受到了影响. 百度: a) 百度反作弊算法更新 1, 百度分别于 6.22 和 6.28 日惩罚了大批低质量的网站, 而且之前没有任何征兆. 2, 由于本次调整范围大, 力度深, 误伤了很多正规网站, 所以从本次开始百度官方对每次调整都发布了公告, 而在这之前很难想象. b) 百度超链接作弊算法更新 1, 本次算法更新与谷歌有遥相呼应的意思, 从 2012.10.23 左右开始.2, 本次对象包括而不仅限于: 买卖链接, 无价值的交叉链轮, 群发链接, 黑链, 无价值的交换链接. SEO 展望: a) SEO 要走保守路线, 注重内容b) 注重品牌和用户积累; 因为流量成本越来越高. c) 用户体验 用作弊手段获取高流量的机会已经不多, 所以要力争提升现有流量的转化率, 提升用户体验, 注重数据研究. d) 关注社会化与分享 搜索引擎已经开始针对社会化媒体和分享算法调整. 5.1.6. 百度站长工具简介百度站长平台: 百度站长平台是百度网页搜索为网站管理员搭建的站长工具和交流平台, 提供 sitemap, 索引量查询, 抓取异常, 页面优化建议, 被黑监测等站长工具, 并提供官方资料区及讨论区, 第一时间发布网页搜索官方动态及知识, 帮助提升网站用户体验. 百度站长工具: 自从 2012 年 6 月份的调整之后, 百度开始变得越来越亲民, 开始着力为站长着想, 开发了很多相关工具, 尤其是开放了外链查询, 因为能提供这项服务的自从雅虎停止之后一直没有权威的数据, 虽然国内也有相关工具, 但是对于中文网页的抓取一直不是很理想. 当然还有很多其它相关工具, 我们来一一给大家介绍下: 数据提交: Sitemap死链提交URL 提交 网站配置: 5.2. 策略5.2.1. 项目分析5.2.1.1. SEO 项目策划和分析a) 明确需求(产品/服务) 营销目标: 品牌推广 公司名称 品牌相关词 市场公关 事件名称, 事件特点相关词 主营业务推广 主营产品/服务/型号相关词 活动促销营销 活动/促销名称, 内容相关词 目标受众,搜索行为 目标受众群体 大学生,工人,白领等 目标受众群体的年龄 20 岁做什么的, 20 岁用什么化妆品 目标受众群体的地域 山东,北京,南京 目标受众群体的搜索行为 导航型搜索, 信息型搜索, 交易型搜索 目标受众群体的购物行为 淘宝化妆品, 京东化妆品 市场环境 竞争对手有哪些 竞争对手品牌词 竞争对手的卖点 竞争对手的产品特点 竞争对手的宣传方式 学习并运用 搜索行为可以查看: 百度数据统计报告(data.baidu.com) b) 项目执行 搭建网站, SEO 设置, 填充内容(发布文章), 网站宣传(发布外链) c) 数据研究 记录网站的运营数据, 根据数据变化, 找到问题源. d) 提升优化 找到问题源去解决问题, 实现专业的 SEO 操作手法 5.2.2. 增加收录5.2.2.1. 影响收录因素*收录 IDC 网站 内容 爬虫抓取量 爬虫收录原理 影响爬虫收录的因素 网站内部因素 网站外部因素 页面质量 内容方面 原创有价值 防止重复 技术方面 URL W3C 完整 head 信息 如果你的网站还没有被收录, 请检查一下爬虫抓取量和页面质量 5.2.2.2. 搜索引擎爬虫爬取方式, 收录原理抓取=&gt; 漫游式(多线程) =&gt; 下载内容|=&gt; 抓取链接=&gt; 待抓取库 =&gt; 分级抓取(优先级) 演示(httrack 网站镜像工具(整站下载器)) http://www.httrack.com 下载–安装(中文版本) b) 收录原理 过程: robots.txt=&gt;首页=&gt;栏目页=&gt;css/js=&gt;内容页 5.2.2.3. 影响爬虫爬取的内部因素1, 网站速度影响爬虫访问 机房=&gt; DNS 服务器 =&gt; 出口带宽 =&gt; 硬件 =&gt; 操作系统 = &gt; 程序 2, nofollw 标签的使用控制爬虫爬取 nofollow 是指不追踪此链接 nofollow 掉每个页面重复出现的链接和对 SEO 无价值页面, 减少爬虫重复抓取每个页面内的链接, 提高爬虫抓取效率, 增强对重要页面的抓取. 3, 其他影响爬虫抓取的因素 防火墙规则, 防攻击设置, 防止采集设置规则: 一个网站访问 n 次后, 自动断开, 爬虫被拒. 分割硬盘: 在服务器上安装多个虚拟机, 硬盘转速慢, 爬虫访问不到网页 多个返回码: 一个链接返回多个返回码搜索引擎是不会抓取的 5.2.2.4. 影响爬虫爬取的外部因素影响爬虫抓取的外部因素 a) 外部链接 外链的作用有两个, 一个是吸引爬虫来抓取, 另外一个是提升排名. 相关性, 流行性, 广泛性(给每个网页加外链, 不要全部指向首页) b) 文章 文章的原创性, 更新频率, 独特性. 原创文章一定收录, 只是时间问题. c) 权重 权重是指搜索引擎对网站的信任程度, 权重高网站爬虫数量多, 抓取及时. 权重高的网站有爬虫长期”隐居”. d) 网站地图 网站地图促进爬虫爬取, 增进收录重要因素. e) PR 值 PR 值是谷歌对于网站质量的衡量标准, 但是 PR 对 SEO 的作用非常小, 有些参考意义, 但是意义并不是很大了. 5.2.2.5. 技术对收录的影响爬虫抓取网页过程中是可以看到网页 url, html 代码和 head 信息. a) URL 规范化 1, 静态化 唯一化 http://www.seojiaoxue.com/?p=9http://www.seojiaoxue.com/archives/9.html 网站中同一个网页, 只对应一个 url. 如果网站上多种 url 都能访问同样的内容, 会有如下危险: 1, 搜索引擎会选一种 url 为标准, 可能会和正版不同2, 用户可能为同一个网页的不同 url 做推荐, 多种 url 形式分散了该网页的权重 如果你的网站上已经存在多种 url 形式, 建议按以下方式处理: 1, 在系统中只使用正常形式 url, 不让用户接触到非正常的 url2, 不把 session id, 统计代码等不必要的内容放在 url 中3, 不同形式的 url, 301 永久跳转到正常形式4, 防止用户输错而启用的备用域名, 301 永久跳转到主域名5, 使用 robots.txt 禁止 Baiduspider 抓取您不想向用户展现的形式 2, url 中带关键词: 英文/拼音 在排名上有一定的优势 b) W3C 标准 HTML 代码要符合标准 结构层, 表现层, 行为层标签完整性. c) head 信息正确性(服务器) 抓包工具 httpwatch(安装, 下载, 使用) Accept 指示能够接受的返回数据的范围, */*表示所有 Accept-Language zh-cn 表示能够接受的返回数据的语言 Accept-Encoding gzip, deflate Accept-Encoding 表明浏览器可接受的除了纯文本之外的内容编码的类型, 比如 gzip 压缩还是 deflate 压缩内容. Last-Modified Fri, 04 Jan 2008 01:01:01 GMT 指定背请求资源上次修改的日期和时间节省带宽, 减少重复抓取 Server Apache 一种表明 Web 服务器软件及其版本号的头标 content-length 内容长度 通过文字长度判断是否更新过, 但是不准, 如果文字一样, 就无法判断. 5.2.2.6. 内容对收录的影响a) 原创性 原创文章一定会被收录, 但是只是时间问题. 原创性是影响网站权重的很重要的一个因素, 其他因素没有它重要. 原创影响权重, 权重影响收录, 收录影响排名, 排名影响流量. 搜索引擎有很多判断原创性的方法(演示) b) 重复性 转载或者采集的页面内容和之前页面都一样, url 不统一也是重复, 网页相似度很好就算重复页面. 页面重复是 SEO 负面因素. 重复页面与总页面比例要低于 30%, 网站大量重复会被惩罚. 避免重复的方法: 在网站的正文部分多调用随机调用增加文章内容. url 唯一化等, 解决重复性最高境界是原创. 5.2.3. 提高排名5.2.3.1. SEO 排名模型Q: 真有排名秘籍码? 有多少人知道搜索引擎的算法 答案: 没有秘籍. 没人知道全部的算法, 工程师, SE 给客户最好的搜索结果, 给用户最好的价值, 搜索引擎会给我们排名, 流量是搜索引擎给我们的, 数据和 SEO 经验, 总结出了 SEO 排名模型. a) 定义 基于对搜索引擎的排名特征和算法已经 SEO 经验分析得出一个排名的原理, 这个原理就是 SEO 模型 b) 原理 c) 操作 1, 网站结构符合: 内容页的相关性推荐板块2, 内链和外链3, 其他: SEO 频道, 锚文本等 d) 注意点 1, 网页都是相关的(信任投票), 注意质量2, 相关网页数量很多 5.2.3.2. 网站 SEO 排名内部因素提高排名内部因素 1, 标题, 关键词位置 标题带有关键词(关键词多命中长尾) 关键词位置非常重要(参考报纸写法) 2, 内部链接 锚文本的使用, 全站链接, 导航链接 3, 页面关键词相关性 页面内容和关键词相关程度 4, 关键词在页面, 域名中使用 位置 域名中最好有关键词拼音或英文 5, nofollow 的使用 屏蔽无用和没价值页面 6, 板块设置 相关推荐, 最新文章板块 7, 其他(密度, 字数, 图片优化) 密度 2%-8%不要太刻意了. 字数控制 1000 字左右 图片采用 alt 属性优化关键词 5.2.3.3. 网站 SEO 排名外部因素提高排名的外部因素(外链) a) 外链相关度, 广泛度, 流行度 相关度: 在相关的网页上面发外部链接, 越相关越好 流行度: 相关的外部链接数量要多. 广泛度: 网站多个页面需要发布外部链接(不要仅仅指向首页, 要获取多个页面的排名) b) 锚文本使用 锚文本作用非常的重要, 告诉搜索引擎你的网页内容是什么. 可以仅仅靠外链把排名坐上去(国际站, 点石互动) 锚文本使用: 全站链接, alt 属性描述, url 四周旁边的文字 c) 外链主题性, 外链产生速率 外链主题相关性是指发外链的网页一定要和你发的内容相关. 5.2.3.4. 单一页面排名和多个页面排名Q: 获取排名的基本单位是网页还是网站? 答案是: 网页 a) 单一页面的排名 内部因素 + 外部因素 + 其他因素(权重) b) 多个页面的排名 批量做单一页面的排名形成多个页面排名. 另外大规模网站需要其他的一些策略(SEO 频道) c) 演示案例站点 弓箭工艺品两个企业站对比. A: &lt;www.xugongfang.com&gt; b: &lt;www.liuyicheng.com&gt; 5.2.3.5. SEO 频道a) SEO 频道由来 1, 很大大型网站的页面太多, 不能被爬虫充分抓取, 影响了收录.2, 搜索引擎抓取层数有限 1 层=50 页面2 层=50*50 页面=25003 层=50*50\\*50页面=125000 搜索引擎一般抓取 2 层 注意: 这里抓取不是你网站目录, 而是根据链接层次.http://www.abc.com/1/2/1.html b) SEO 频道的建立 根据网站内容上一些维度, 比如某些共同特征等, 组合成一批网页, 这些网页上面都是某一个主题非常相关的内容, 这样的网页就是 SEO 频道, 平常也叫专题 c) 频道模板 新闻类, 商城类 不同的网站模板类型是不一样的. d) SEO 频道如何涨流量 网页是原创的, 内容高度集中/相关, 排名形成 SEO 频道, 大量命中长尾词 e) SEO 频道的注意点 1, 做百度 SEO 频道不能有站内搜索的特征2, 控制页面数量, 防止造成大量重复, 防止网站降权 5.2.4. 提升点击率a) 点击率概述 关键词排名前十位位置获取的流量不一样, 点击网站的次数也不一样. b) 计算方式 点击率=点击次数/展现次数 c) 影响因素 网页的标题和描述 d) 如何优化 1, 标题和描述写清楚(注意写要点)2, 放些醒目的符号吸引点击比如: “★” 5.2.5. 日志分析5.2.5.1. 日志分析解读a) 为什么要做日志分析? 1, 日志是记录数据最准的, 而且是最全的(用户数据, 爬虫数据, 服务器错误日志) 2, 查询是否收录以及收录数量分析. 查询某一栏目下收录量等 b) 怎么做日志分析 获取日志–使用工具–确立目标–分析日志–总结数据(长期)–得出结论 5.2.5.2. 日志分析工具和使用a) 日志下载 window iis, linux apache 按照网站生成, 在根目录下的 log 文件 b) 日志分析工具 光年日志分析工具 c) 工具介绍 国平老师, 10 年 SEO 经验, 前阿里巴巴 SEO 人员, 管理世界级网站的 SEO 工作. SEM 一家之言www.semyj.com 功能: 常规数据(抓取时间, 抓取量, 次数)拆分功能(万能) d) 工具下载 http://www.semyj.com/archives/1539 (或者百度搜索) e) 工具使用和简单日志分析 5.2.5.3. 日志分析案例和注意事项1, 常规数据的统计 抓取量, 抓取次数, 爬行时间, 不重复抓取量, 单个爬虫平均抓取量, 单个爬虫平均抓取时间, 404 页面数量 制作一个 Excel 表格来统计这些数据 2, 拆分有用数据 目录抓取量 某搜索引擎蜘蛛抓取量 某 ip 的抓取信息 b) 日志分析注意事项 判断真假蜘蛛 5.2.6. 词库5.2.6.1. 需求分析需求分析的重要性: a) 搜索引擎的任务是帮助用户找到答案, 我们的目的是让搜索引擎选择我们的答案 b) 应该准备什么样的答案就显得尤为重要. 我们不是客户: a) 客户在想什么, 不是我们拍拍脑门儿就知道的, 我们要通过数据说话. b) 举例: 针对推广”妇炎洁”这款产品, 我们做个一个调查, 下面三个关键词, 您认为哪个关键词搜索量比较大? A 妇炎洁价格 B 妇炎洁哪里买 C 男人可以用妇炎洁吗? 绝大多数人选择 A 或者 B, 但是数据告诉我们 C 的搜索量大于前面两个 c) 不要问为什么, 要相信数据 因为这是数据告诉我们的, 不可能每一个人都成为心理学家(如果没有数据支持的话, 心理学家也很难得出正确答案), 所以了解需求, 先从数据开始. 学会用数据说话: a) 我们在准备一个行业的关键词词库之前, 必须对整个行业的数据有个最基本的了解. b) 行业数据无关指数, 无关转化, 但是关乎趋势, 方向, 选择大于努力, 方向大于执行. 5.2.6.2. 思路太热门的关键词不要 a) 错误的理论 我们经常听到一种理论或者我们自己经常也有这样的错觉: 如果我要想获得这个行业的足够多的流量的话, 就必须以最热门的关键词作为目标, 诸如手机, 汽车, 电脑等词. b) 举例 1, 太热门的词属于大品牌 比如大家一提到电脑, 就想到了联想, 可能也有惠普, 华硕, 但是大多数人会想到联想, 您要确定您的公司是否在整个行业以产品而知名, 如果您确实是为联想服务, 那么像笔记本, 电脑, 台式机此类的关键词特别适合您, 您可以为了您的企业把关于电脑的所有种类的词语全部拿下, 像宝洁公司的产品占领超市货架一样, 您的企业在网络上也可以做到. 为什么不呢? 2, 小众市场也大有可为 如果您不是为联想工作, 而只是一家小型的笔记本生产企业, 那电脑带来的流量真的不适合您, 因为转化率太低, 而且更重要的是成本过大, 因为带来的大多数不是定向客户. 您应该知道您的优势, 您也有很多客户觉得您的笔记本比联想的好, 不是吗? 他们在想什么, 他们的需求是什么, 这才是您的定向客户. 您到底适合小众还是大众取决于您的产品影响力. 无关优劣, 对于 SEO 来讲, 定向客户是唯一的目标. 放弃太冷门的关键词 a) 错误的观点 竞争太小的关键词应该成为我们的首选, 我们要”农村包围城市”, 这种理论听起来确实不错, 但是有些太偏远的”山村”我们还是放弃吧, 因为确实也带不来什么流量, 或者抓化率太低. b) 举例 1, 如果用地方俚语作为关键词来优化, 效果就不是很好, 因为任何一个人在线下和线上他们的行为是不一样的, 就比如一个村里人, 在村里说土话, 但是到了城市里就讲普通话. 2, 同样的我们到了网络上之后会使用大家通用的语言去交流, 而不是坚持”地方特色”, 因为我们为此碰壁很多次了, 客户也一样, 不是吗? 常规思路: a) 思路分析 类型 解释 举例 品牌关键词 公司名称, 简介, 俗称, 独有资源, 英文简称, 名人等 华为技术有限公司, 华为, 任正非(不要奇怪, 任正非也是华为的代名词) 产品关键词 产品/服务的简称, 俗称, 英文名称, 英文缩写等 SEO 培训, 信息与通信解决方案, 奥迪 A6 价格, 北京别墅出租 组合关键词 地域+产品, 地域+服务, 性别+服务, 年龄段+产品/服务等 北京 SEO 培训, 北京保洁, 女鞋, 老人手机, 老人陪护等 问答关键词 这是常见的关键词 如何开淘宝店, 哪家湘菜馆最正宗 相关关键词 这类词语是网民没有直接表明对产品或者服务的需求, 但是这类词所提供的信息表明网民对产品/服务有极大的需求 秦皇岛驾校, 学习日语从哪里开始下手, 小孩儿老是尿床怎么办 错误关键词 随着各种输入法的泛滥, 把名字打错的情况越来越多 taobao, 孩儿空调, 海心空调 5.2.6.3. 拓展和整理市场公关关键词 a) 树立品牌形象专用关键词 这类关键词一般没有什么指数, 但是与品牌密切相关, 如果说之前我们的策略是为了获取流量的话, 那么这里的策略就可以称之为创造流量. b) 比如长城汽车曾经进行了”SUV 心”的关键词策略, 尽管这个词没有什么指数, 但是企业用它来进行市场推广, 相当于塑造了一个”附属品牌”, 占领了消费者的心智. 对企业的 SUV 产品的推广有很大帮助. c) 这是一种非常有效的市场公关工作, 让一个没有指数的词深入人心, 成本低廉, 效果极好, 推荐大家看一本书叫做&lt;&lt;定位&gt;&gt;, 长城汽车就是书中的中国公司的客户. d) 在网络上我们可以用关键词排名给我们的公司和产品进行定位, 定位很重要. 活动促销关键词 a) 节假日, 新电影, 热门事件, 最新新闻, 我们的产品都可以想办法和这些联系起来, 进行相关关键词的优化, 进行产品的促销, 会带来意想不到的收获. b) 小技巧: 比如在某大导演的电影开始筹拍的时候开始优化电影名字, 这个时候它的指数小, 竞争很不激烈, 但是当它开始上映后, 指数会升得很高. 研究竞争对手的关键词: a) 我们通过调查分析, 了解我们竞争对手的关键词很重要. b) 了解竞争对手有哪些关键词策略, 他们的宣传渠道, 尽可能获取他们最全的关键词词库. c) 尽量做到竞争对手有的关键词我们全有, 对手没有的我们也有, 人无我有, 人有我优. 现在关键词的监控与整理 a) 已经取得的成绩要及时总结经验 我们网站现在所有的流量来源都要做到精确统计, 务必搞清楚我们之前的工作哪些是有效的, 哪些是无效的. 不过可以肯定的是, 有些流量是我们意想不到的, 而其对应的关键词是我们接下来重点研究的对象. b) 根据监控成果调整我们的词库 1, 传统广告界的营销部门都知道一句话: 我知道有一半广告费都浪费了, 但我不知道浪费在哪里. 2, SEO 推广的优势就在于我们有多种数据来验证我们的优化成果. 我们做的每一次努力, 我们都要清楚它的效果. 3, 去除效率低下的关键词, 增添我们意外收获的关键词, 并重点研究. c) 根据经验放大我们的成绩 务必根据我们已经取得的成绩进行优化, 尝试根据成功经验把我们的流量成绩放大, 这是效率很高的事情, 至少可以避免少犯错误. 头脑风暴 a) 一个人的力量, 视野, 阅历都是有限的, 我们可以通过头脑风暴的方式和我们的同事, 朋友来进行讨论和拓展关键词词源. b) 比如对于普通的智能手机, 我们搜索相关信息的时候, 习惯性地在搜索框输入”智能手机出厂参数” “智能手机评测” 但是并不能找到相关信息, 我们用”手机出厂测试” “手机出厂标准”, 反倒是能找到有用的信息. c) 原因很简单: 在制定手机标准的部门和商家眼里不存在”智能手机”这个概念, 他们眼里只有手机, 只是不同的功能, 不同的配置而已. 在一些技术部门眼里, “智能手机”是营销部门炒出来的概念. 这个我们光靠自己是很难想到的, 但是有一个在手机厂工作的朋友可能就会省很多的力气. 建立词库分类列表 这是我们所有工作的成果整理, 按照不同的网站, 构建不一样的词库 a) 关键词类别分组法 1, 一级分类: 品牌词, 产品词, 通用词, 行业词, 活动词, 人群词 2, 二级分类: 主词, 官网, 功能, 价格, 问句, 口碑, 促销 3, 举例: 品牌主词: 京东商城/联想 品牌官网: 京东官网, 联想官网 品牌活动: 京东光棍节促销, 联想笔记本促销 品牌口碑(问句): 京东怎么样, 联想笔记本到底怎么样 产品功能: 智能手机 产品价格: 联想 K860i 价格 b) 核心词分组法 1, 在我们拓展关键词的时候, 是按照核心词发散思维, 那么我们只需要将包含相同核心词的关键词找出来, 按照相似句式或者词性的类别划分就可以了. 2, 比如下面这些关键词 英语在线课堂, 美语词汇培训, 英文词汇班, 北京英语辅导, 英语口语网站, 美语口语班 3, 我们可以根据核心词划分: 英语类: 英语在线课堂, 英文词汇班, 北京英语辅导, 英语口语网站 美语类: 美语词汇培训 美语口语班 c) 语法结构分组法 1, 这是一种利用关键词语法结构分组的方式, 这种分组方式适合一些小型网站2, 比如下面这些关键词: 幼儿英语, 雅思报名, 雅思词汇班, 雅思语法班, 练口语, 少儿英语, 提高口语, 雅思考试报名, 怎样才能学好英语, 儿童英语, 如何提升英语水平, 学口语, 宝宝说英语, 雅思听力班, 小孩子学英语 3, 我们可以按照语法结构来分: A, 业务名词类: 少儿英语, 儿童英语, 幼儿英语, 雅思听力班, 雅思词汇班, 雅思语法班. B, 动词短语类 练口语, 学口语, 提高口语, 雅思报名, 雅思考试报名 C, 疑问句 怎样才能学好英语, 如何提升英语水平 D, 陈述句 宝宝说英语, 小孩子学英语 总结: 无论采取哪种分类方式, 我们要遵循的原则是: 将意义相近, 结构相同的关键词放在一起,这样便于针对关键词组织相应的页面以及针对关键词进行调整. 5.2.7. 方案撰写5.2.7.1. 准备阶段定位: a) 定位网站的方向 品牌宣传, 形象展示, 抑或交易平台. b) 分析网站的类型 比如单页站, 企业站, 商城网站, 博客网站, 论坛等等. c) 准备网站的功能规划 留言系统, SNS 系统, 问答系统, 支付系统, UGC 部分等等. 关键词准备: a) 分析用户需求 1, 潜在客户在搜索什么;2, 他们需要的是什么样的”答案”3, 确定合适的关键词. b) 关键词布局 1, 确定导航型搜索词(主关键词)2, 确定信息型搜索词(较有价值的长尾词)3, 确定交易型搜索词(普通长尾词) 站内规划 a) 导航;b) 内部锚文本c) 页面相关推荐(导出链接) SEO 目标确定 a) 目标定位b) 目标分解(阶段性目标)c) 品牌建设d) 投入产出比 网站流量预估: a) 关键词总指数b) 预计排名;c) 位置点击率;d) 旺淡季对比e) 其它因素. 5.2.7.2. 执行阶段a) 首页 title 标签, description 标签确定;b) 内页 title 标签的确定, description 标签的规划c) SEO 设置(网站地图, 404, URL 处理, 层级规划, nofollow 规划) 内容更新: a) 更新频率b) 内容质量;c) SEO 频道页 小中型网站可以忽略 流量转化数据监控方案: a) 流量 潜在客户的数量 b) 咨询, 注册, 留言 准客户的数据 c) 在线购买 顾客资料的记录. 风险成本监控: a) 直接费用b) 时间成本c) 人才成本d) 成本超支e) 时间(计划)延迟f) 搜索算法变更 SEO 执行策略: a) title;b) description;c) 内页优化d) 外部链接e) 内部链接f) 内容数量g) 内容质量h) 用户体验 5.2.8. 团队建设岗位需求: a) 整体规划;b) 词库建设c) 文档撰写d) 项目跟进 人员配备: a) 小型站点 小型站点从兼职人员开始. b) 大型站点 可以安排两到三个全职人员 c) 人员越少越好 尤其是初期, 不要配备太多的人. 团队所需技能: a) 网站内容的建设能力 文案编辑, HTML 编码, SEO 人员对这两方面的技能越熟悉越好. b) 付费搜索 付费搜索领域往往可以给自然排名优化很多极具参考的建议, 比如百度官方给付费搜索提供的关键词建议服务, 对于 SEO 很有帮助. 作为一个专业的 SEO 人员, 切忌闭门造车, 了解付费搜索也是很有必要的. c) 关键词研究 关键词是 SEO 的核心工作, 关乎 SEO 的成败. 提升技能的方法: a) 不断尝试 搜索引擎的算法是不断更新的, 想要第一时间了解算法的更新, 认真去尝试并且把知识日积月累是我们一直在使用的办法. b) 课堂培训 尽管几乎所有的培训内容, 都不可能涵盖所有的搜索营销的技术, 但是不影响我们通过这类培训掌握 HTML, 营销技术等技能. c) 参加行业会议 很多时候最好的搜索营销信息就来自于行业会议, 参加行业会议是一个不错的交流活动, 会使你快速成长. d) 团队成员轮岗 这个在传统企业很普遍, 轮岗的优点就在于, 一个人通过不同岗位的学习就可以了解整个团队的运行情况, 轮岗是一种真正能够扩展资源的双赢方式. SEO 相关工具使用: a) 很多时候我们发现花了三天时间做的工作, 相应的工具只用两个小时就可以全部完成. b) 如果您的团队对这些 SEO 工具不是特别了解的话, 那是一件非常遗憾的事情. c) 最理想的状态是团队里有人可以写软件出来, 或者可以写需求, 把一些单调的工作用软件来完成. 网站的监控: 监控对象: 网站的流量, 转化率, 内容和技术改动, 以及对网站的评测. 对公司产品和顾客的了解: 如果这一点做到位的话, 那么对公司网站的关键词词库的建设和网站结构的布局会更加准确. 跟其它部门的沟通: a) SEO 涉及到一个网站最核心的工作–流量, 会涉及到一个网站的方方面面; b) 我们要做好 SEO 工作的话, 其它部门的配合对我们来讲也是极为重要的; c) 公司内部的”公关”也是 SEO 团队必备的一项技能. 6. 数据分析6.1. 综述6.2. 流量6.3. 爬虫6.4. 底层6.5. 运营6.6. 竞争对手7. 营销推广7.1. 微博营销7.2. 软文7.3. EDM8. 参考文档SEO 视频教程全集 seo 站长综合查询工具 SEO 内容中心 移动端 SEO：权威指南","link":"/angular/site_seo.html"},{"title":"使用 Astro 快速搭建自己的博客系统","text":"Astro 是一款现代化的前端框架，由开发团队 Snowpack 创建，旨在提供一种简单而强大的方式来构建快速、可靠且易于维护的 Web 应用程序。Astro 支持静态站点生成，这意味着在构建时生成 HTML 文件，从而提高网站的加载速度和性能。 今天我们主要讲述如何使用 Astro 快速搭建自己的博客系统。 1. 环境准备 需要先安装 nodejs v18.17.1 或 v20.3.0 更高版本 文本编辑器——推荐使用带有官方 Astro 扩展的 VS Code。 命令行终端- 通过 Astro 的命令行界面 (CLI) 访问。 2. 创建一个 Astro 项目这里推荐使用 pnpm 作为 node 包管理工具，如果您习惯 npm or yarn 可自行调整命令行指令及参数。 2.1. 使用命令行向导创建项目12345678910111213141516171819202122232425262728293031323334353637383940414243$ pnpm create astro@latest.../191d395dcd8-40343 | +59 ++++++.../191d395dcd8-40343 | Progress: resolved 59, reused 27, downloaded 32, added 59, done astro Launch sequence initiated. dir Where should we create your new project? ./density-dwarf tmpl How would you like to start your new project? Use blog template ts Do you plan to write TypeScript? Yes use How strict should TypeScript be? Strict deps Install dependencies? Yes git Initialize a new git repository? Yes ✔ Project initialized! ■ Template copied ■ TypeScript customized ■ Dependencies installed ■ Git initialized next Liftoff confirmed. Explore your project! Enter your project directory using cd ./density-dwarf Run pnpm dev to start the dev server. CTRL+C to stop. Add frameworks like react or tailwind using astro add. Stuck? Join us at https://astro.build/chat╭─────╮ Houston:│ ◠ ◡ ◠ Good luck out there, astronaut! 🚀╰─────╯ 2.2. 使用模板创建项目官方 templates 可以在这里找到 astro examples 123456789# 使用官方模板创建项目pnpm create astro@latest --template &lt;example-name&gt;# 使用第三方模板创建项目pnpm create astro@latest --template &lt;github-username&gt;/&lt;github-repo&gt;# 或者git clone https://github.com/&lt;github-username&gt;/&lt;github-repo&gt; myProjectName 示例 123456789101112131415161718192021222324252627282930313233343536373839$pnpm create astro@latest --template surjithctly/astroship astro Launch sequence initiated. dir Where should we create your new project? ./purple-plasma ◼ tmpl Using surjithctly/astroship as project template ts Do you plan to write TypeScript? Yes use How strict should TypeScript be? Strict deps Install dependencies? Yes git Initialize a new git repository? Yes ✔ Project initialized! ■ Template copied ■ TypeScript customized ■ Dependencies installed ■ Git initialized next Liftoff confirmed. Explore your project! Enter your project directory using cd ./purple-plasma Run pnpm dev to start the dev server. CTRL+C to stop. Add frameworks like react or tailwind using astro add. Stuck? Join us at https://astro.build/chat╭─────╮ Houston:│ ◠ ◡ ◠ Good luck out there, astronaut! 🚀╰─────╯ 3. 开发环境启动 AstroAstro 带有内置开发服务器，其中包含项目开发所需的一切。astro dev命令将启动本地开发服务器，以便您首次看到新网站的运行情况。 每个入门模板都附带一个可astro dev为您运行的预配置脚本。导航到您的项目目录后，使用您最喜欢的包管理器运行此命令并启动 Astro 开发服务器。 123456789101112$ pnpm dev&gt; purple-plasma@2.2.0 dev /path-to-astro-project&gt; astro dev astro v4.8.7 ready in 395 ms┃ Local http://localhost:4321/┃ Network use --host to expose 然后浏览器打开http://localhost:4321/ 4. 项目结构1234567891011121314151617181920/├── public/│ └── ...├── src/│ ├── components/│ │ └── ...│ ├── layouts/│ │ └── ...│ └── pages/│ └── ...│ ├── content│ │ ├── blog│ │ │ ├── example-page-a.md│ │ ├── config.ts│ │ └── team│ │ ├── example-page-b.md│ │ ├── example-page-c.mdx└── package.json Astro 会在在 src/pages/ 目录中查找 .astro 或 .md 文件， 在编译期间将其渲染称 html 页面。每个页面都根据其文件名显示为一个路由。 任何静态文件（如图像）都可以放在 public/ 目录中。 5. 创建第一篇博文通常情况下在 src/content 下有一些预设的目录，如果将 markdown 格式的博客文章，放置在预设的目录下， 并配置好合适的 front-matter， 在开发模式下使用， 例如https://localhost:4321/blog/example-page-a就能访问。 5.1. create a new content Collection如果你想在 src/content 添加新的目录结构用于分门别类的放置自己的博客文章， 此时需要创建新的content collection，此时就需要修改配置 config.ts，然后在 src/pages 下创建新的页面。 例如我想在 src/content 在创建一个 ansible 的目录用于存放 ansible 相关的文章。 首先我需要在 src/content 下创建 ansible 目录;然后我需要修改 config.ts，添加 ansible 相关的配置; 123456789101112131415161718192021222324const ansibleCollection = defineCollection({ //创建一个新的ansibleCollection schema: z.object({ draft: z.boolean(), title: z.string(), snippet: z.string(), image: z.object({ src: z.string(), alt: z.string(), }), publishDate: z.string().transform((str) =&gt; new Date(str)), author: z.string().default(&quot;Astroship&quot;), category: z.string(), tags: z.array(z.string()), }),});// 3. Export a single `collections` object to register your collection(s)// This key should match your collection directory name in &quot;src/content&quot;export const collections = { blog: blogCollection, team: teamCollection, ansible: ansibleCollection, // export ansibleCollection}; 然后要创建 ansible 的主页面 src/pages/ansible.astro，这样当用户访问https://localhost:4321/ansible就不会是空白页面或者出现 404 页面找不到的问题 内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374---import { getCollection } from &quot;astro:content&quot;;import { Picture } from &quot;astro:assets&quot;;import Layout from &quot;@layouts/Layout.astro&quot;;import Container from &quot;@components/container.astro&quot;;import Sectionhead from &quot;@components/sectionhead.astro&quot;;// Filter ansible entries with 'draft: false' &amp; date before current dateconst publishedAnsibleEntries = await getCollection(&quot;ansible&quot;, ({ data }) =&gt; { return !data.draft &amp;&amp; data.publishDate &lt; new Date();});// Sort content entries by publication datepublishedAnsibleEntries.sort(function (a, b) { return b.data.publishDate.valueOf() - a.data.publishDate.valueOf();});---&lt;Layout title=&quot;Ansible&quot;&gt; &lt;Container&gt; &lt;Sectionhead&gt; &lt;Fragment slot=&quot;title&quot;&gt;Ansible&lt;/Fragment&gt; &lt;Fragment slot=&quot;desc&quot;&gt; We write about building startups and thoughts going on our mind. &lt;/Fragment&gt; &lt;/Sectionhead&gt; &lt;main class=&quot;mt-16&quot;&gt; &lt;ul class=&quot;grid gap-16 max-w-4xl mx-auto&quot;&gt; { publishedAnsibleEntries.map((ansiblePostEntry, index) =&gt; ( &lt;li&gt; &lt;a href={`/ansible/${ansiblePostEntry.slug}`}&gt; &lt;div class=&quot;grid md:grid-cols-2 gap-5 md:gap-10 items-center&quot;&gt; &lt;Picture src={ansiblePostEntry.data.image.src} alt={ansiblePostEntry.data.image.alt} sizes=&quot;(max-width: 800px) 100vw, 800px&quot; width={800} height={600} loading={index &lt;= 2 ? &quot;eager&quot; : &quot;lazy&quot;} decoding={index &lt;= 2 ? &quot;sync&quot; : &quot;async&quot;} class=&quot;w-full rounded-md object-cover object-center bg-white&quot; /&gt; &lt;div&gt; &lt;span class=&quot;text-blue-400 uppercase tracking-wider text-sm font-medium&quot;&gt; {ansiblePostEntry.data.category} &lt;/span&gt; &lt;h2 class=&quot;text-3xl font-semibold leading-snug tracking-tight mt-1 &quot;&gt; {ansiblePostEntry.data.title} &lt;/h2&gt; &lt;div class=&quot;flex gap-2 mt-3&quot;&gt; &lt;span class=&quot;text-gray-400&quot;&gt; {ansiblePostEntry.data.author} &lt;/span&gt; &lt;span class=&quot;text-gray-400&quot;&gt;• &lt;/span&gt; &lt;time class=&quot;text-gray-400&quot; datetime={ansiblePostEntry.data.publishDate.toISOString()}&gt; {ansiblePostEntry.data.publishDate.toDateString()} &lt;/time&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; )) } &lt;/ul&gt; &lt;/main&gt; &lt;/Container&gt;&lt;/Layout&gt; 最后要创建一个博客文章的渲染页面例如： src/pages/ansible/[slug].astro 内容可以参考下面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263---import { getCollection } from &quot;astro:content&quot;;import Layout from &quot;@layouts/Layout.astro&quot;;import Container from &quot;@components/container.astro&quot;;// Generate a new path for every collection entryexport async function getStaticPaths() { const ansibleEntries = await getCollection(&quot;ansible&quot;); return ansibleEntries.map((entry) =&gt; ({ params: { slug: entry.slug }, props: { entry }, }));}// Get the entry directly from the prop on renderconst { entry } = Astro.props;const { Content } = await entry.render();---&lt;Layout title={entry.data.title}&gt; &lt;Container&gt; &lt;div class=&quot;mx-auto max-w-3xl mt-14&quot;&gt; &lt;span class=&quot;text-blue-400 uppercase tracking-wider text-sm font-medium&quot;&gt; {entry.data.category} &lt;/span&gt; &lt;h1 class=&quot;text-4xl lg:text-5xl font-bold lg:tracking-tight mt-1 lg:leading-tight&quot;&gt; {entry.data.title} &lt;/h1&gt; &lt;div class=&quot;flex gap-2 mt-3 items-center flex-wrap md:flex-nowrap&quot;&gt; &lt;span class=&quot;text-gray-400&quot;&gt; {entry.data.author} &lt;/span&gt; &lt;span class=&quot;text-gray-400&quot;&gt;•&lt;/span&gt; &lt;time class=&quot;text-gray-400&quot; datetime={entry.data.publishDate.toISOString()}&gt; {entry.data.publishDate.toDateString()} &lt;/time&gt; &lt;span class=&quot;text-gray-400 hidden md:block&quot;&gt;•&lt;/span&gt; &lt;div class=&quot;w-full md:w-auto flex flex-wrap gap-3&quot;&gt; { entry.data.tags.map((tag) =&gt; ( &lt;span class=&quot;text-sm text-gray-500&quot;&gt;#{tag}&lt;/span&gt; )) } &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mx-auto prose prose-lg mt-6 max-w-3xl&quot;&gt; &lt;Content /&gt; &lt;/div&gt; &lt;div class=&quot;text-center mt-8&quot;&gt; &lt;a href=&quot;/ansible&quot; class=&quot;bg-gray-100 px-5 py-3 rounded-md hover:bg-gray-200 transition&quot; &gt;← Back to ansible&lt;/a &gt; &lt;/div&gt; &lt;/Container&gt;&lt;/Layout&gt; 最终，我们放置一篇文章在 src/content/ansible 下面，内容如下，当我们打开https://localhost:4321/ansible/first-page 就可以正常访问了。 vi src/content/ansible/first-page.md 12345678910111213141516171819202122232425262728---title: 运维自动化之Ansiblesnippet: &quot;Ornare cum cursus laoreet sagittis nunc fusce posuere per euismod dis vehicula a, semper fames lacus maecenas dictumst pulvinar neque enim non potenti. Torquent hac sociosqu eleifend potenti.&quot;draft: falsetoc: truename: &quot;Robert Palmer&quot;avatar: { src: &quot;https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?&amp;fit=crop&amp;w=280&quot;, alt: &quot;Robert Palmer&quot;, }image: { src: &quot;https://images.unsplash.com/photo-1593720213428-28a5b9e94613?&amp;fit=crop&amp;w=430&amp;h=240&quot;, alt: &quot;full stack web development&quot;, }publishDate: &quot;2022-11-08 11:39&quot;category: &quot;Tutorials&quot;tags: - linux - Ansiblecategories: - devops - ansiblereward: true---我的第一篇博客 6. 如何发布博客astro 支持的发布平台有很多，例如：Netlify, Vercel, Github pages, gitlab pages, Cloudflare pages, Heroku, AWS, Google cloud 等等。 今天我们以 github pages 为例，讲解如何将自己的博客发布到 github pages。 6.1. 配置站点修改配置 astro.config.mjs 123456// https://astro.build/configexport default defineConfig({ site: &quot;https://your_website_domain&quot;, base: 'your-repo',}); site: 站点的值必须为以下值之一： 以下 URL 基于您的用户名：https://.github.io为 GitHub 组织的私人页面自动生成的随机 URL：https://.pages.GitHub.io/ base:可能需要一个 base 值，以便 Astro 将您的存储库名称（例如/your-repo）视为您网站的 base。 设置自定义域 您可以通过添加以下内容来设置自定义域/将 public/CNAME 文件添加到您的项目： public/CNAMEsub.mydomain.com 这将在您的自定义域而不是 user.github.io 部署您的网站。别忘了为您的域提供商配置 DNS。 6.2. 发布站点发布之前，先编译 123pnpm build 编译后将在 dist 目录生成网站所有静态资源文件。然后将其发布到 github 上。 12345678910git initgit add .git commit -m &quot;initial commit&quot;# 添加 repogit remote add origin &lt;https://github.com/&gt;&lt;username&gt;/&lt;repository&gt;.git# 这里借助angular的ghpage cli将生成的内容发布到githubnpx angular-cli-ghpages --dir=dist/ 7. 配置 Astro 编辑器对于 vscode 编辑器， 可以安装插件 astro-build.astro-vscode 123code --install-extension astro-build.astro-vscode 其他编辑器，可以参考： Astro Editor Setup 7.1. 自动格式化 astro 文档首先安装 prettier 和 prettier astro 插件 12pnpm i --save-dev prettier prettier-plugin-astro 修改 vscode settings.json 123&quot;[astro]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, 修改配置 .prettierrc 覆盖 prettier 默认的 parser 为 astro 12345678910111213{ &quot;plugins&quot;: [&quot;prettier-plugin-astro&quot;], &quot;overrides&quot;: [ { &quot;files&quot;: &quot;*.astro&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;astro&quot; } } ], ....} 参考How to automatically format Astro files in VS Code using Prettier 8. 参考文档Start a new Astro project Astro deploy Astro Editor Setup Astro Introduction","link":"/astro/astro_install_and_configure.html"},{"title":"运维自动化之Ansible","text":"1. 介绍1.1. Ansible 发展和起源Ansible 是一款开源的 IT 配置管理工具，常被 IT 界的小伙伴们用于服务部署、配置管理等工作。配置文件采用最常见的 yaml 格式，学习起来也是比较容易，并且不像 SaltStack，Ansible 并不需要也没有 agent，只有一个控制端。该工具使用简单但功能非常强大，可以解决众多工作中繁琐的服务安装、配置等问题。 Ansible 的第一个版本是 0.0.1，发布于 2012 年 3 月 9 日，其作者兼创始人是 Michael DeHaan。迄今为止已经发展到了 2.9 版本。并且它的关注度、Star 数以及 Fork 的次数都位居榜首。就连强大的 SaltStack 也只能排到第二。 Michael DeHaan 在配置管理和架构设计方面有丰富的经验，曾就职于 RedHat 公司，在 RedHat 任职期间主要开发了 Cobble。在他尝试了各种自动化工具 Puppet、Chef 之后，决定自己打造一款能够结合众多优点的自动化工具。由此，便有了 Ansible 这款易理解、易上手、受众人喜爱的自动化工具。 1.2. 为什么需要 Ansible前面说过，ansible 通常用于自动化的场景，多用在服务部署、配置管理方面。随着时间推移和公司发展，项目越来越多，团队日益壮大，各种公司内部开发的应用、第三方开源的中间件等服务越来越多，那么管理起来就相对比较困难，人肉操作已经完全满足不了传统的运维工作，需要消耗相当多的时间来进行变更，进而阻碍了开发人员的速度，极大的降低了工作效率。显然可考又高效的部署和管理成为了公司的一大难点与挑战。那么一款高效且可靠的服务部署和管理工具就显得尤为重要。而在很长一段时间里，Docker 容器与 kubernetes 容器编排系统没有被广泛的普及之前，有很大一部分人在使用 Jenkins + Ansible 进行 CICD。 1.3. Ansible 的主要功能批量执行远程命令：可以对任意多台主机同时进行命令的执行。 批量配置软件服务：可以进行自动化的方式部署、配置及管理服务。 编排高级的 IT 任务：Ansible 可以使用 yaml 来编写一套完整的 Playbook，用来部署维护一套完全的基础架构。 1.4. Ansible 的相关特性Ansible 是基于每个模块进行工作，自身并没有批量部署的能力，ansible 自身只是提供了一种框架。 Ansible 由 Python 语言开发，没有 agent，不需要在被管理节点安装任何客户端； 模块化：基于模块工作，秩序调用特定的模块来完成特定工作； 基于 SSH 协议； 三大关键组成模块：Paramiko， PyYAML， Jinja2； 幂等性：一个任务执行 1 遍和执行 n 遍效果一样，不因重复执行带来意外情况； 可以使用命令行 ad-hoc 方式来执行批量任务，也可以使用 yaml 格式的文件来定制 Playbook 剧本实现批量任务； 可以使用 Role 组织批量任务 1.5. Ansible 的优点容易学习且轻量：无需在被控制节点安装 agent，做批量操作时只需要在操作机操作即可(前提：需要配置好免密登录)； 操作灵活：具有众多的模块，可使用命令行 ad-hoc 方式或者 Playbook 剧本的方式来实现批量任务执行； 可移植性高：可以基于 yaml 文件编写一套 Playbook，只要做好逻辑判断，就可以在多种操作系统上拿来即用； 幂等性：一个任务执行 1 遍和执行 n 遍效果一样，不因重复执行带来意外情况； 支持普通用户 sudo 提权。 但是任何事物都具有两面性。SSH 虽好，但如果被管理的机器数量众多的话，执行的速度就会比较慢，就需要进行一定的优化和分批任务来缓解速度问题。 1.6. Ansible 的架构Ansible 由以下几个核心工具组成： INVENTORY：Ansible 管理主机的清单/etc/anaible/hosts； MODULES：Ansible 执行命令的功能模块，多数为内置核心模块，也可自定义； PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等； APl：供第三方程序调用的应用程序编程接口。 在日常工作中，我们大多数用到的且使用比较频繁的主要是：Inventory 和 Modules。通常我们会根据项目的需求来定制化我们的 Inventory，不会将它放在默认的/etc/anaible/hosts 文件中。 2. 运维自动化和 Ansible 架构介绍2.1. 运维自动化发展历程及技术应用2.1.1. 云计算运维工程师核心职能 平台架构组建负责参与并审核架构设计的合理性和可运维性, 搭建运维平台技术架构, 通过开源解决方案,以确保在产品发布之后能高效稳定的运行,保障并不断提升服务的可用性, 确保用户数据安全, 提升用户体验. 日常运营保障负责用运维技术或者运维平台确保产品可以高效的发布上线, 负责保障产品 7*24H 稳定运行, 在此期间对出现的各种问题可以快速的定位并解决; 在日常工作中不断优化系统架构和部署的合理性, 以提升系统服务的稳定性. 性能, 效率优化用自动化的工具/平台提升软件在研发声明周期中的工作效率. 优化资源利用率支持产品的不断迭代, 需要不断的进行架构优化调整, 以确保整个产品能够在功能不断丰富和复杂的条件下, 同时保持高可用性. 2.1.2. 软件开发阶段计划=&gt;编码=&gt;打包=&gt;测试=&gt;发布=&gt;部署=&gt;运维=&gt;监控 2.1.2.1. 相关工具 代码管理(SCM): GitHub, GitLab, BitBucket, SubVersion 构建工具: maven, Ant, Gradle 自动化部署: Capistrano, CodeDeploy 持续集成(CI): jenkins, Travis 配置管理: Ansible, SaltStack, Chef, Puppet 容器: Docker, Podman, LXC, 第三方厂商如 AWS 编排: Kubernetes, Cor, Apache Mesos 服务注册与发现: Zookeeper, etcd, Consul 脚本语言: python, ruby, shell 日志管理: ELK, Logentries 系统监控: Prometheus, Zabbix, Datadog, Graphite, Ganglia, Nagios 性能监控: AppDynamics, New Relic, Splunk 压力测试: JMeter, Blaze meter, loader.io 应用服务器: Tomcat, jBoss, IIS Web 服务器: Apache, Nginx 数据库: MySQL, Oracel, PostgreSQL 等关系型数据库; mongoDB, Redis 等 NoSQL 数据库. 项目管理(PM): Jira, Asana, Taiga, Trello, Basecamp, Pivotal Tracker 2.1.3. 运维工程师的发展路线基础运维=&gt;监控运维=&gt;系统运维=&gt;应用运维=&gt;自动化运维=&gt;架构师=&gt;总监或 CTO 2.1.3.1. 运维的未来是什么? 一切皆自动化“运维的未来是, 让开发人员借助工具, 自动化和流程, 并且让他们能够在运维干预极少的情况下部署和运维服务, 从而实现自助服务, 每一个角色都应该努力使工作实现自动化.” — &lt;&lt;运维的未来&gt;&gt; 2.1.3.2. 企业实际应用场景2.1.3.2.1. Dev 开发环境使用者: 程序员功能: 程序员个人的办公电脑或项目的开发测试环境, 部署开发软件, 测试个人或项目整体的 BUG 的环境管理者: 程序员 2.1.3.2.2. 测试环境使用者: QA 测试工程师功能: 测试经过 Dev 环境测试通过的软件的功能和性能, 判断是否达到项目的预期目标, 生成测试报告.管理者: 运维说明: 测试环境往往有多套, 测试环境满足测试功能即可, 不易过多 测试人员希望测试环境多套, 公司的产品多产品线并发, 即多个版本, 意味着多个版本同步测试. 通常测试环境有多套和产品线数量保持一样 2.1.3.2.3. 预发布环境使用者: 运维功能: 使用和生产环境一样的数据库, 缓存服务等配置, 测试是否正常 2.1.3.2.4. 发布环境包括代码发布机, 有些公司为堡垒机(安全屏障) 使用者: 运维功能: 发布代码至生产环境管理者: 运维发布机: 往往需要有 2 台(主备) 2.1.3.2.5. 生产环境使用者: 运维, 少数情况开放权限给核心开发人员, 极少数公司将权限完全开放给开发人员并维护功能: 对用户提供公司产品的服务 2.1.3.2.6. 灰度环境属于生产环境的一部分使用者: 运维功能: 在全量发布代码前将代码的功能面向少量精准用户发布的环境, 可基于主机或用户执行灰度发布案例: 供 100 台生产服务器, 先发布其中 10 台服务器, 这 10 台服务器就是灰度服务器管理者: 运维灰度环境: 往往该版本功能变更较大, 为了保险起见特意先让一部分用户优化体验该功能, 待这部分用户使用没有重大问题的时候, 再全量发布至所有服务器 2.1.3.3. 程序发布程序发布要求: 不能导致系统故障或造成系统完全不可用不能影响用户体验 预发布验证: 新版本的代码发布到服务器(跟线上环境配置完全相同, 只是未接入到调度器) 灰度发布: 基于主机, 用户, 业务 正式发布 发布过程: 在调度器上下线一批主机标记为 mainttenance 状态 关闭服务 部署新版本的应用程序 启动服务 在调度器上启用这一批服务器 自动化灰度发布: 脚本发布平台 2.1.3.3.1. 自动化运维应用场景文件传输应用部署配置管理任务流编排 2.1.3.4. 常用自动化运维工具 Ansible: python, Agentless, 中小型应用环境 Saltstack: python, 一般需要部署 Agent, 执行效率更高 Puppet: Ruby, 功能强大, 配置复杂, 重型, 适合大型环境 Fabric: python, agentless Chef: ruby, 国内应用少 Cfengine func 2.1.4. Ansible 介绍和架构2.1.4.1. Ansible 发展史作者: Michael DeHaan(Cobbler 与 Func 作者)ansible 的名字来自&lt;&lt;安德的游戏&gt;&gt;中跨越时空的即时通信工具2012-03-09, 发布 0.0.1 版, 2015-10-17, Red Hat 宣布 1.5 亿美金收购 官网: http://www.ansible.com/官方文档: https://docs.ansible.com/ 2.1.4.2. Ansible 特性 模块化: 调用特定的模块, 完成特定任务 Paramiko(python 对 ssh 的实现), PyYAML, jinja2(模板语言) 三个关键模块 支持自定义模块, 可使用任何编程语言写模块 基于 Python 语言实现 部署简单, 基于 python 和 SSH(默认已安装), agentless, 无需代理不依赖 PKI(无需 ssl) 安全, 基于 OpenSSH 幂等性: 一个任务执行 1 遍和 n 遍效果一样, 不因重复执行带来意外情况 支持 playbook 编排任务, YAML 格式, 支持丰富的数据结构 较强的多层解决方案 role 2.1.4.3. Ansible 架构2.1.4.3.1. Ansible 组成Inventory, API, Modules, Plugin 的绿框, 可以理解为是 Ansible 命令工具,其为核心执行工具. Inventory: Ansible 管理主机的清单/etc/ansible/hosts Modules: Ansible 执行命令的功能模块, 多数为内置核心模块, 也可自定义 Plugins: 模块功能的补充, 如连接类型插件, 循环插件, 变量插件, 过滤插件等, 该功能不常用 API: 供第三方程序调用的应用程序接口 2.1.4.3.2. Ansible 命令执行来源 User 普通用户, 即 System Administrator Playbooks: 任务剧本(任务集), 编排定义 Ansible 任务集的配置文件, 由 Ansible 顺序依次执行, 通常是 Json 格式的 YML 文件 CMDB(配置管理数据库) API 调用 PUBLIC/PRIVATE Cloud API 调用 User =&gt; Ansible Playbook =&gt; Ansible 2.1.4.3.3. 注意事项 执行 ansible 的主机一般称为主控端, 中控, master 或堡垒机 主控端 Python 版本需要 2.6 或以上 被控端 Python 版本小于 2.4 需要安装 python-simplejson 被控端如开启 SELinux 需要安装 libselinux-python Windows 不能作为主控端 3. Ansible 的安装和使用3.1. Ansbile 安装ansible 的安装方法有多种 3.1.1. EPEL yum 源安装1yum install ansible 3.1.2. 编译安装12345678yum -y install python-jinja2 PyYAML python-paramiko python-babel \\ python-crypto tar xf ansible-1.5.4.tar.gzcd ansible-1.5.4python setup.py buildpython setup.py installmkdir /etc/ansiblecp -r examples/* /etc/ansible 3.1.3. Git 方式12345git clone git://github.com/ansible/ansible.git --recursivecd ./ansiblesource ./hacking/env-setup 3.1.4. pip 安装pip 是安装 Python 包的管理器, 类似 yum 123456yum install python-pip python-develyum install gcc glibc-devel zibl-devel rpm-build openssl-develpip install --upgrade pippip install ansible --upgrade 3.1.5. 确认安装1ansible --version 3.1.6. Ansible 相关文件3.1.6.1. 配置文件/etc/ansible/ansible.cfg 主配置文件, 配置 Ansible 工作特性/etc/ansible/hosts 主机清单/etc/ansible/roles/ 存放角色的目录 3.1.6.2. Ansbile 主配置文件Ansible 的配置文件/etc/ansible/ansbile.cfg 其中大部分的配置内容无需进行修改 1234567891011121314[defaults]# inventory = /etc/ansbile/hosts # 主机列表配置文件# libaray = /usr/share/my_modules # 库文件存放位置# remote_tmp = $HOME/.ansbile/tmp # 临时py命令文件存放在远程主机目录# local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录# forks = 5 # 默认并发数# sudo_user = root # 默认sudo用户# ask_sudo_pass = True # 每次执行ansible命令是否询问ssh密码# ssk_pass = True# remote_port = 22# host_key_checking = False # 检查对应服务器的host_key, 建议取消注释# log_path=/var/log/ansible.log # 日志文件, 建议启用# module_name = command # 默认模块, 可以修改为shell模块 3.1.6.3. ansible.cfg 文件的优先级顺序ansible 获取 ansible.cfg 文件的优先级顺序 ansible 运行时会先检查 ansible 命令的目录中是否有 ansible.cfg 文件，如果不存在该文件，则检查用户的主目录（~/）中是否有 ansible.cfg 文件，在找不到其他配置文件时，使用全局/etc/ansible/ansible.cfg 文件，如果都不存在，ansible 包含它使用的默认值。 使用 ANSIBLE_CONFIG 环境变量指定配置文件位置，而此时指定的任何文件将覆盖所有其他配置文件 3.1.6.4. Inventory 主机清单ansible 的主要功用在于批量主机操作, 为了便捷地使用其中的部分主机, 可以在 inventory file 中将其分组命名默认的 inventory file 为/etc/ansible/hostsinventory file 可以有多个, 且也可以通过 Dynamic Inventory 来动态生成 3.1.6.4.1. 主机清单文件格式inventory 文件遵循 INI 文件风格, 中括号中的字符为组名, 可以将同一个主机同时归并到多个不同的组中,此外, 当如若目标主机使用了非默认的 SSH 端口, 还可以在主机名称之后使用冒号加端口号来标明如果主机名称遵循相似的命名模式, 还可以使用列表的方式标识各主机 123456789101112131415161718192021222324252627282930# Ex 1: ungrouped hosts, specify before any group headers## green.example.com## bluce.example.com## 192.168.100.1## 192.168.100.10# Ex 2: A collection of hosts belonging to the 'webservers' group## [webservers]## alpha.example.org## beta.example.org## 192.168.1.100## 192.168.1.110# If you have multiple hosts following a pattern you can specify# them lik this:[dbservers]## db-[99:101]-node.example.com## db-[a:f].example.com[appservers]10.0.0.[1:100]# 如何主机没有使用默认的22端口作为ssh的监听端口# 定义host时可以指定其端口号www.example.com:2222 3.1.6.5. Ansible 相关工具/usr/bin/ansible 主程序, 临时命令执行工具/usr/bin/ansible-doc 查看配置文档, 模块功能查看工具/usr/bin/ansible-galaxy 下载/上传优秀代码或 Roles 模块的官网平台/usr/bin/ansible-playbook 定制自动化任务, 编排剧本工具/usr/bin/ansible-pull 远程执行命令的工具/usr/bin/ansible-vault 文件加密工具/usr/bin/ansible-console 基于 Console 界面与用户交互的执行工具 3.1.6.6. 利用 ansible 实现管理的主要方式Ad-Hoc 即利用 Ansible 命令, 主要用于临时命令使用场景Ansible-playbook 主要用于长期规划好的, 大型项目的场景, 需要有前期的规划过程 3.1.6.7. ansible-doc此工具用来显示模块帮助格式 123ansible-doc [options] [module...]-l, --list # 列出可用模块-s, --snippet # 显示指定模块的playbook片段 范例: 123456# 列出所有模块ansible-doc -l# 查看指定模块帮助用法ansible-doc ping# 查看指定模块帮助用法ansible-doc -s ping 3.1.6.8. ansible 命令此工具通过 ssh 协议, 实现对远程主机的配置管理, 应用部署, 任务执行等功能建议: 使用此工具前, 先配置 ansible 主控端能基于密钥认证的方式联系各个被管理节点 范例: 利用 sshpass 批量实现基于 key 验证 123456ssh-keygen -f /root/.ssh/id_rsa -P ''NET=192.168.100export SSHPASS=testfor IP in (1..200); do sshpass -e ssh-copy-id $NET.$IPdone 格式: 123ansible &lt;host-pattern&gt; [-m module_name] [-a args] 选项说明 12345678910111213--version # 显示版本号-m module # 指定模块, 默认为command-v # 详细过程 -vv -vvv更详细--list-hosts # 显示主机列表, 可简写 --list-k, --ask-pass # 提升输入ssh连接密码, 默认是key验证-C, --check # 检查, 并不执行-T --timeout=TIMEOUT #执行命令的超时时间, 默认10s-u --user=REMOT_USER # 执行远程执行的用户-b, --become # 代替旧版的sudo切换--become-user=USERNAME #指定sudo的runas用户, 默认root-K, --ask-become-pass # 提示输入sudo时的口令 3.1.6.9. ansible-pull此工具会推送 ansible 的命令至远程, 效率无限提升, 对运维要求较高. 3.1.6.10. ansible-playbook此工具用于执行编写好的 playbook 任务 范例: 1234567891011ansible-playbook hello.ymlcat hello.yml---#hello world from yml file- hosts: websrvs remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world 3.1.6.11. ansible-valt此工具可用于加密解密 yml 文件 格式: 1ansible-vault [create|decrypt|edit|encrypt|rekey|view] 范例 12345678ansible-vault encrypt hello.yml # 加密ansible-vault decrypt hello.yml # 解密ansible-vault view hello.ymlansible-vault edit hello.ymlansible-vault rekey hello.ymlansible-vault create hello.yml 3.1.6.12. ansible-console此工具是可交互执行命令, 支持 tab, ansible 2.0+新增 提示符格式: 执行用户@当前操作的主机组(当前的主机数量)[f:并发数]$ 常用子命令: 设置并发数: forks n 例如: forks 10切换组: cd 主机组 例如: cd web列出当前组主机列表: list列出所有的内置命令: ?或 help 范例: 12345678root@all (2)[f:5]$ listroot@all (2)[f:5]$ cd appsrvsroot@all (2)[f:5]$ listroot@all (2)[f:5]$ yum name=httpd state=presentroot@all (2)[f:5]$ service name=httpd state=startedroot@all (2)[f:5]$ forks 10 3.1.7. Ansible 常用模块2015 年底 270 多个模块, 2016 年达到 540 个, 2018 年 01 月 12 日 1378 个模块, 2018 年 07 月 15 日 1852 个模块, 2019 年 5 月 25 日(ansible 2.7.10)时 2080 个, 2020 年 0302 日有 3387 个模块 虽然模块众多, 但常用的模块也就 2,30 个而已, 针对特定业务只有 10 几个模块 常用模块帮助文档参考: https://docs.ansible.com/ansible/latest/modules/modules_by_category.html 3.1.7.1. Command 模块功能: 在远程主机执行命令, 此为默认模块, 可忽略-m 选项注意: 此命令不支持 $VARNAME &lt;&gt; | ; &amp; 等, 用 shell 模块实现 范例: 12345678ansible srvs -m command -a 'service vsftpd start'ansible srvs -m command -a 'echo hello world | passwd -stdin user_name'# 查看操作系统版本ansible srvs -m command -a 'cat /etc/centos-release'ansible srvs -m command -a 'chdir=/etc cat centos-release' 3.1.7.2. shell 模块功能: 和 command 相似, 用 shell 执行命令范例: 123ansible srv -m shell -a 'echo test | passwd -stdin wang' 注意: 调用 bash 执行命令, 类似 cat /tmp/test/md | awk -F ‘|’ ‘{print 1,2}’ &amp;&gt; /tmp/example.txt 这些复杂命令, 即使使用 shell 也可能会失效, 解决办法: 写到脚本时, copy 到远程, 执行, 再把需要的结果拉回执行命令的机器 范例: 将 shell 模块代替 command, 设为默认模块 123vim /etc/ansible/ansible.cfg#修改下面一行module_name = shell 3.1.7.3. script 模块功能: 再远程主机上运行 ansible 服务器上的脚本 范例: 1ansible websrvs -m script -a /data/test.sh 3.1.7.4. copy 模块功能: 从 ansible 服务器主控端复制文件到远程主机 123456789# 如目标存在, 默认覆盖, 此处指定先备份ansible srv -m copy -a &quot;src=/root/test1.sh dest=/tmp/test2.sh owner=test mode=600 backup=yes&quot;# 指定内容, 直接生成目标文件ansible srv -m copy -a &quot;content='test content\\n' dest=/tmp/test.txt&quot;# 复制/etc/下的文件, 不包括/etc/目录本身ansible srv -m copy -a &quot;src=/etc/ dest=/backup&quot; 3.1.7.5. fetch 模块功能: 从远程主机拷贝文件到 ansible 的主控端, 与 copy 相反, 目前不支持目录 范例: 1ansible srv -m fetch -a &quot;src=/root/test.sh dest=/data/scripts&quot; 3.1.7.6. File 模块功能: 设置文件属性 范例: 1234567891011# 创建空文件ansible srv -m file -a 'path=/data/test.txt state=touch'ansible srv -m file -a 'path=/data/test.txt state=absent'ansible srv -m file -a 'path=/data/test.txt owner=wang mode=755'# 创建目录ansible srv -m file -a 'path=/data/mysql state=directory owner=mysql group=mysql'# 创建软连接ansible srv -m file -a 'src=/data/testfile dest=/data/testfile-link state=link' 3.1.7.7. unarchieve 模块功能: 解包解压缩 实现有两种用法: 将 ansible 主机上的压缩包传到远程主机后解压缩至特定目录, 设置 copy=yes 将远程主机上的某个压缩包解压缩到指定路径下, 设置 copy=no 常见参数: copy: 默认为 yes, 当 copy=yes, 拷贝的文件是从 ansible 主机复制到远程主机上, 如果没有设置为 copy=no, 会在主机上寻找 src 源文件remote_src: 和 copy 功能一样且互斥, yes 表示在远程主机, 不在 ansible 主机, no 表示文件在 ansible 主机上src: 源路径, 可以是 ansible 主机上的路径, 也可以是远程主机上的路径, 如果是远程主机上的路径, 则需要设置 copy=no 范例: 1ansible srv -m unarchive -a &quot;&quot; 3.1.7.8. archive 模块功能: 打包压缩 范例: 123ansible websrvs -m archive -a &quot;path=/var/log/ dest=/data/log.tar.bz2 format=bz2 owner=wang mode=0600&quot; 3.1.7.9. Hostname 模块功能: 管理主机名 范例: 1234ansible node1 -m hostname -a &quot;name=websrv&quot;ansible 192.168.100.18 -m hostname -a 'name=node18' 3.1.7.10. Cron 模块功能: 计划任务支持时间: minute, hour, day, month, weekday 范例: 123456789101112131415# 备份数据库脚本#cat mysql_backup.shmysqldump -A -F --single-transaction --master-data=2 -q -uroot | gzip &gt;mysql_`date +%F_%T`.sql.gz# 创建任务ansible dbsrv -m cron -a 'hour=2 minute=30 weekday=1-5 name=&quot;backup mysql&quot; job=/root/mysql_backup.sh'ansible srv -m cron -a 'minute=/5 job=/usr/sbin/ntupdate 172.20.0.1 &amp;&gt;/dev/null name=Synctime'# 禁用计划任务ansible srv -m cron -a 'minute=/5 job=/usr/sbin/ntupdate 172.20.0.1 &amp;&gt;/dev/null name=Synctime disabled=yes'# 启用计划任务ansible srv -m cron -a 'minute=/5 job=/usr/sbin/ntupdate 172.20.0.1 &amp;&gt;/dev/null name=Synctime disabled=no'# 删除计划任务ansible srv -m cron -a 'name=Synctime state=absent'ansible srv -m cron -a 'name=&quot;backup mysql&quot; state=absent' 3.1.7.11. Yum 模块功能: 管理软件包 范例: 1234ansible srv -m yum -a 'name=httpd state=present' # 安装ansible srv -m yum -a 'name=httpd state=absent' # 删除 3.1.7.12. Service 模块功能: 管理服务 范例: 12345ansible srv -m service -a 'name=httpd state=started enable=yes'ansible srv -m service -a 'name=httpd state=stopped'ansible srv -m service -a 'name=httpd state=reloaded'ansible srv -m shell -a &quot;sed -i 's/^Listen 80/Listen 8080/' /etc/httpd/conf/httpd.conf&quot;ansible srv -m service -a 'name=httpd state=restarted' 3.1.7.13. User 模块功能: 管理用户范例: 12345678# 创建用户ansible srv -m user -a 'name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root'ansible srv -m user -a 'name=nginx comment=nginx uid=88 group=&quot;root, deamon&quot; shell=/sbin/nologin system=yes create_home=no home=/data/nginx non_unique=yes'# 删除用户及家目录等数据ansible srv -m user -a 'name=nginx state=absent remove=yes' 3.1.7.14. Group 模块功能: 管理组 范例: 12345# 创建组ansible websrvs -m group -a 'name=nginx gid=88 system=yes'# 删除组ansible websrvs -a group -a 'name=nginx state=absent' 3.1.7.15. Lineinfile 模块ansible 在使用 sed 进行替换时, 经常会遇到需要转义的问题, 而且 ansible 在遇到特殊符号进行替换时, 存在问题, 无法正常进行替换, 其实在 ansible 自身提供了两个模块: lineinfile 模块和 replace 模块, 可以方便地进行替换 功能: 相当于 sed, 可以修改文件内容 范例: 12ansible all -m lineinfile -a &quot;path=/etc/selinux/config regexp='^SELINUX=' line='SELINUX=enforcing'&quot;ansible all -m lineinfile -a 'dest=/etc/fstab state=absent regexp=&quot;^#&quot;' 3.1.7.16. Replace 模块该模块有点类似于 sed 命令, 主要也是基于正则进行匹配和替换 范例: 123456# 将以UUID开头的行注释掉, \\1表示正则表达式匹配的内容ansible all -m replace -a &quot;path=/etc/fstab regexp='^(UUID.*)' replace='#\\1'&quot;# 恢复以上操作ansible all -m replace -a &quot;path=/etc/fstab regexp='^#(UUID.*)' replace='\\1'&quot; 3.1.7.17. Setup 模块功能: setup 模块来收集主机的系统信息, 这些 facts 信息可以直接以变量的形式使用, 但是如果主机较多, 会影响执行速度, 可以使用 gather_facts: no 来禁止收集 facts 信息 范例: 1234567891011121314151617ansible srv -m setupansible srv -m setup -a &quot;filter=ansible_nodename&quot;ansible srv -m setup -a &quot;filter=ansible_hostname&quot;ansible srv -m setup -a &quot;filter=ansible_domain&quot;ansible srv -m setup -a &quot;filter=ansible_memtotal_mb&quot;ansible srv -m setup -a &quot;filter=ansible_memory_mb&quot;ansible srv -m setup -a &quot;filter=ansible_memfree_mb&quot;ansible srv -m setup -a &quot;filter=ansible_os_family&quot;ansible srv -m setup -a &quot;filter=ansible_distribution_major_version&quot;ansible srv -m setup -a &quot;filter=ansible_distribution_version&quot;ansible srv -m setup -a &quot;filter=ansible_processor_vcpus&quot;ansible srv -m setup -a &quot;filter=ansible_all_ipv4_addresses&quot;# 使用通配符ansible srv -m setup -a &quot;filter=ansible_processor_*&quot; 4. Playbook4.1. playbook 介绍playbook 剧本是由一个或多个 play 组成的列表 play 的主要功能在于将预定义的一组主机, 装扮成事先通过 ansible 中的 task 定义好的角色. Task 实际是用 ansible 的一个 module, 将多个 play 组织在一个 playbook 中, 即可以让它们联合起来, 按事先编排的机制执行预定义的动作 playbook 文件是采用 YAML 语言编写的 4.2. YAML 语言4.2.1. YAML 语言介绍YAML 是一个可读性高的用来表达资料序列的格式. YAML 参考了其他多种语言,包括: XML, C 语言, Python, Perl 以及电子邮件格式 RFC2822 等. Clark Evans 在 2001 年首次发表了这种语言, 另外 Ingy dot net 与 Oren Ben-kiki 是这种语言的共同设计者, 目前很多软件中采用此格式的文件, 如 ubuntu, ansible, docker, k8s 等.YAML: YAML aint markup language, 即 YAML 不是标记语言, 不过, 在开发这种语言时, YAML 的意思其实是: “Yet Another Markup Language” (仍是一种标记语言) YAML 官方网站: http://www.yaml.org 4.2.2. YAML 语言特性YAML 的可读性好YAML 和脚本语言的交互性好YAML 使用实现语言的数据类型YAML 有一个一致的信息模型YAML 易于实现YAML 可以基于流来处理YAML 表达能力强, 扩展性好 4.2.3. YAML 语法简介在单一文件第一行, 用连续三个连字号”-“开始, 还有选择性的连续三个点号(…)用来表示文件的结束次行开始正常写 playbook 的内容, 一般建议写明该 playbook 的功能使用#号注释代码缩进必须是统一的, 不能空格和 tab 混合使用缩进的级别也必须是一致的, 同样的缩进代表同样的级别, 程序判别配置的级别是通过缩进结合换行来实现的, YAML 文件内容是区分大小写的, key/value 的值均需要大小写敏感多个 k/v 可同行写也可换行写, 同行使用,分割v 可是个字符串, 也可是另一个列表一个完整的代码块功能需最少元素需包括 name 和 task一个 name 只能包括一个 taskYAML 文件扩展名通常为 yml 或 yaml YAML 的语法和其他高阶语言类似, 并且可以简单表达清单, 散列表, 标量等数据结构, 其结构(structure)通过空格来展示, 序列(sequence)里的项用”-“来代表, Map 里的键值对用”:”分割, 下面介绍常用的数据结构. 4.2.3.1. List 列表列表由多个元素组成, 且所有元素前均使用”-“打头 范例: 12345678# A list of tasty fruits- Apple- Orange- Strawberry- Mango[Apply, Orange, Strawberry, Mango] 4.2.3.2. Dictionary 字典字典通常由多个 key 与 value 构成 范例: 123456789# An example recordname: Example Developerjob: Developerskill: Elite# 也可以将key:value置于{}中进行表示, 用,分割多个key:value# An example record{name: &quot;Example developer&quot;, job: &quot;developer&quot;, skill: &quot;Elite&quot;} 4.3. Playbook 核心元素Hosts 执行的远程主机列表Tasks 任务集Variable 内置变量或自定义变量在 playbook 中调用Templates 模板, 可替换模板文件中的变量并实现一些简单逻辑的文件Handler 和 Notify 结合使用, 由特定条件触发的操作, 满足条件方才执行, 否则不执行tags 标签, 指定某条任务执行, 用于选择运行 playbook 中的部分代码, ansible 具有幂等性, 因此会自动跳过没有变化的部分, 即便如此, 有些代码为测试其确实没有发生变化的时间依然会非常地长, 此时如果确信没有变化, 就可以通过 tags 跳过此些代码片段 4.3.1. hosts 组件Hosts: playbook 中的每一个 play 的目的都是为了让特定主机以某个指定的用户身份执行任务. hosts 用于指定要执行指定任务的主机, 须事先定义在主机清单中 案例 1- hosts: websrvs:appsrvs 4.3.2. remote_user 组件remote_user: 可用于 host 和 task 中, 也可以通过指定其通过 sudo 的方式在远程主机上执行任务, 其可用于 play 全局或某个任务; 此外, 甚至可以在 sudo 时使用 sudo_user 指定 sudo 时切换的用户 123456789- hosts: websrvs remote_user: root tasks: - name: test connection ping: remote_user: test_user sudo: yes # 默认sudo为root sudo_user: wang # sudo为wang 4.3.3. task 列表和 action 组件play 的主体部分是 task list, task list 中有一个或多个 task, 各个 task 按次序逐个在 hosts 中指定的所有主机上执行, 即在所有主机上完成第一个 task 后, 再开始第二个 task.task 的目的是使用指定的参数执行模块, 而再模块参数中可以使用变量. 模块执行是幂等的, 这意味着多次执行是安全的, 因为其结果均一致.每个 task 都应该有其 name, 用于 playbook 的执行结果输出, 建议其内容能清晰地描述任务执行步骤. 如果未提供 name, 则 action 的结果将用于输出 task 两种格式 (1) action: moudule arguments(2) module: arguments 建议使用 注意: shell 和 command 模块后面跟命令, 而非 key=value 范例: 12345678---- hosts: websrvs remote_user: root tasks: - name: install httpd yum: name=httpd - name: start httpd service: name=httpd start=started enabled=yes 4.3.4. 其它组件某任务的状态在运行后为 changed 时, 可以通过 notify 通知给相应的 handlers 任务可以通过 tags 打标签, 可在 ansible-playbook 命令上使用-t 指定进行调用 4.3.5. ShellScript VS Playbook 案例12345678910# SHELL脚本实现#!/bin/bash# 安装apacheyum install --quiet -y httpd# 复制配置文件cp /tmp/httpd.conf /etc/httpd/conf/httpd.confcp /tmp/vhosts.conf /etc/httpd/conf.d/systemctl enable --now httpd playbook 实现 123456789101112---- hosts: websrvs remote_user: root tasks: - name: &quot;安装Apache&quot; yum: name=httpd - name: &quot;复制配置文件&quot; copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/ - name: &quot;复制配置文件&quot; copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/ - name: &quot;启动Apache, 并设置开机启动&quot; service: name=httpd state=started enabled=yes 4.4. playbook 命令格式 1ansible-playbook &lt;filename.yml&gt; ... [options] 常见选项: 12345678--check -C # 只检查可能发生的改变, 但不真正执行操作--list-hosts # 列出运行任务的主机--list-tags # 列出tag--list-tasks # 列出task--limit 主机列表 # 只针对列表中的主机执行-v -vv -vvv # 显示过程 范例 12345ansible-playbook file.yml --check #只检测ansible-playbook file.ymlansible-playbook file.yml --limit websrvs 4.5. Playbook 初步4.5.1. 利用 playbook 创建 mysql 用户范例: mysql_user.yml 1234567- hosts: dbsrvs remote_user: root gather_facts: no # 不收集主机信息 tasks: - { name: create group, group: name=mysql system=yes gid=306 } - name: create user user: name=mysql shell=/sbin/nologin system=yes group=mysql uid=306 home=/data/mysql create_home=no 4.5.2. 利用 playbook 安装 nginx范例: install_nginx.yml 123456789101112131415# install nginx- hosts: websrvs remote_user: root gater_facts: no tasks: - name: add group nginx group: name=nginx state=present - name: add user nginx user: name=nginx state=present - name: install Nginx yum: name=nginx state=present - name: html page copy: src=files/index.html dest=/usr/share/nginx/html/index.html - name: start nginx service: name=nginx state=started enabled=yes 4.5.3. 利用 playbook 安装和卸载 httpd范例: install_httpd.yml 12345678910111213---# install httpd- hosts: websrvs remote_user: root gather_facts: no tasks: - name: install httpd yum: name=httpd state=present - name: install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ - name: start service service: name=httpd state=started enabled=yes 范例: remove_httpd.yml 12345678910---- hosts: websrvs remote_user: root tasks: - name: remove httpd package yum: name=httpd state=absent - name: remove apache user user: name=apache state=absent - name: remove data file file: name=/etc/httpd state=absent 4.5.4. 利用 playbook 安装 mysql范例: 安装 mysql-5.6.46-linux-glibc2.12 123456789101112131415161718192021222324252627282930- hosts: websrvs remote_user: root tasks: - name: install packages yum: name=libaio,perl-Data-Dumper,per-Getopt-Long - name: create mysql group group: name=mysql gid=306 - name: create mysql user user: name=mysql uid=306 group=mysql shell=/sbin/nologin system=yes create_home=no home=/data/mysql - name: copy tar to remote host and file mode unarchive: src=/data/ansible/files/mysql-5.6.46-linux-glibc2.12-x86_64.tar.gz dest=/usr/local/ owner=root group=root - name: crate link /usr/local/mysql file: src=/usr/local/mysql-5.6.46-linux-glibc2.12-x86_64 dest=/usr/local/mysql state=link - name: data dir shell: chdir=/usr/local/mysql/ ./script/mysql_install_db --datadir=/data/mysql -- user=mysql tags: data - name: config my.conf copy: src=/data/ansible/files/my.conf dest=/etc/my.cnf - name: service script shell: /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld - name: enable service shell: /etc/init.d/mysqld start: chkconfig --add mysqld; chkconfig mysql on tags: service - name: PATH variable copy: content='PATH=/usr/local/mysql/bin:$PATH' dest=/etc/profile.d/mysql.sh - name: secure script script: /data/ansible/files/secure_mysql.sh tags: script 4.6. Playbook 中使用 handlers 和 notifyHandlers 本质是 task list, 类似于 mysql 中的触发器触发行为, 其中的 task 与前述的 task 并没有本质上的不同, 主要用于当关注的资源发生变化时, 才会采取一定的操作, 而 Notify 对应的 action 可用于在每个 play 的最后触发, 这样可以避免多次有改变发生时每次都执行指定的操作, 尽在所有的变化发生完成后一次性地执行指定操作. 在 notify 中列出的操作称为 handler, 也即 notify 中调用 handler 中定义的操作 案例: 12345678910111213---- hosts: websrvs remote_user: root tasks: - name: install httpd yum: name=httpd state=present - name: install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf notify: restart httpd handlers: - name: restart httpd service: name=httpd state=restarted 4.7. playbook 中使用 tags 组件在 playbook 文件中, 可以利用 tags 组件, 为特定 task 指定标签, 当在执行 playbook 时, 可以只执行特定 tags 的 task, 而非整个 playbook 文件 案例:httpd.yml 1234567891011121314---# tags example- hosts: websrvs remote_user: root gater_facts: no tasks: - name: install httpd yum: name=httpd state=present - name: install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ tags: conf - name: start httpd service tags: service service: name=httpd state=started enabled=yes 执行指定的 tags 123ansible-playbook -t conf,service httpd.yml 4.8. playbook 中使用变量变量名: 仅能由字母, 数字和下划线, 且只能以字母开头 变量定义 123key=value 范例: 1http_port=80 变量调用方式: 通过 调用变量, 且变量名前后建议加空格, 有时用”“ 才生效 变量来源: ansible 的 setup facts 远程主机的所有变量都可直接调用 通过命令行指定变量, 优先级最高 4.8.1. 在 playbook 文件中定义变量范例: var2.yml 123456789101112---- host: websrvs remote_user: root vars: - username: user1 - groupname: group1 tasks: - name: create group group: name= {{groupname}} state=present - name: create user user: name= {{ username }} state=present 4.8.2. 在 playbook 文件中定义变量范例: 12345678910- hosts: websrvs remote_user: root vars: - username: user1 - groupname: group1 tasks: - name: create group group: name={{groupname}} state=present - name: create user user: name={{username}} group={{ groupname }} state=present 123ansible-playbook -e &quot;username=user2 groupname=group2&quot; var3.yml 4.8.3. 使用变量文件可以在一个独立的 playbook 文件中定义变量, 在另一个 playbook 文件中引用变量文件中的变量,比 playbook 中定义的变量优先级更高 vars.yml 12package_name: vsfpdservice_name: vsfpd install_app.yml 123456789# install app and configure- hosts: appsrvs remote_user: root var_files: - vars.yml tasks: - name: install package yum: name={{package_name}} tags: install 4.8.4. 主机清单中定义变量主机变量 在 inventory 主机清单文件中为指定的主机定义变量以便于在 playbook 中使用 范例: 12345[websrvs]www1.example.com http_port=80 maxRequestPerChild=808www2.example.com http_port=8080 maxRequestPerChild=909 组(公共)变量 在 inventory 主机清单文件中赋予给指定组内所有主机上的在 playbook 中可用的变量 范例: 1234567[websrvs]www1.example.comwww2.example.com[websrvs:vars]domain=example.com 4.9. template 模板模板是一个文本文件, 可以作为生成文件的模板, 并且模板文件中可以嵌套 jinja2 语法 4.9.1. jinja2 语法jinja2 语言使用字面量, 有下面形式 字符串: 使用单引号或双引号 数字: 整数, 浮点数列表: [item1, item2, …]元组: (item1, item2, …)字典: {key1:value1, key2:value2}布尔型: true/false算术运算: +,-,*,/,//,%,**比较操作: ==, != &gt;, &gt;=, &lt;,&gt;=逻辑运算: and, or, not流表达式: For, IF, When 字面量: 表达式最简单的形式是字面量, 字面量表示诸如字符串和数值的 python 对象, 如”hello world”, 双引号或单引号中间的一切都是字符串. 无论何时你需要在模板中使用一个字符串(比如函数调用,过滤器或只是包含或继承一个模板的参数), 如 42, 42.23数值可以为整数和浮点数, 如果有小数点, 则为浮点数, 否则为整数, 在 python 里, 42 和 42.0 是一样的 jinja 语法详细语法可参考https://doc.yonyoucloud.com/doc/jinja2-docs-cn/index.html 4.9.2. templatetemplate 功能: 可以根据和参考模块文件, 动态生成相似的配置文件template 文件必须存放于 template 目录下, 且命名为.j2 结尾yaml/yml 文件需和 template 目录平级, 目录结构如下: ./|—temnginx.yml|—templates|___nginx.conf.j2 范例: 利用 template 同步 nginx 配置文件 123456789准备templates/nginx.conf.j2文件vim temnginx.yam---- hosts: websrvs remote_user: root tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf template 模块只能在 playbook 中使用，不能在 ansible 命令中单独使用template 的作用根据模板生成文件并拷贝到目标位置 执行: 1ansible-playbook temnginx.yml template 变更替换 范例: 修改文件 nginx.conf.j2 1234vim templates/nginx.conf.j2worker_processes {{ ansible_processor_vcpus }} 变量来源： setup 模块的变量(系统变量) 主机清单中的变量 变量文件中的变量 yaml 文件中定义的变量 ansible-playbook 中使用-e 选项传递的变量 角色中定义的变量 vim temnginx2.yml 1234567891011121314---- hosts: websrvs remote_user: root tasks: - name: install nginx yum: name=nginx - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart nginx - name: start service service: name=nginx state=started enabled=yeshandlers: - name: restart nginx service: name=nginx state=restarted 1ansible-playbook temnginx2.yml 4.10. playbook 使用 whenwhen 语句，可以实现条件测试，如果需要根据变量，facts 或此前任务的执行结果来作为某 task 执行与否的前提时， 要用到条件测试，通过在 task 后添加 when 子局即可使用条件测试，jinja2 的语法格式 范例： 1234567---- hosts: websrvs remote_user: root tasks: - name: &quot;shutdown RedHat flavored systems&quot; command: /sbin/shutdown -h now when: ansible_os_family == &quot;RedHat&quot; 范例： 1234567891011121314---- hosts: websrvs remote_user: root tasks: - name: add group nginx tags: user user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: Install nginx yum: name=nginx state=present - name: restart Nginx service: name=nginx state=restarted when: ansible_distribution_major_version == &quot;6&quot; 4.11. playbook 使用迭代 with_items迭代：当有需要重复性执行的任务时，可以使用迭代机制对迭代项的引用，固定变量名为”item”要在 task 中使用 with items 给定要迭代的元素列表 列表元素格式： 字符串 字典 范例： 12345678910---- hosts: websrvs remote_user: root tasks: - name: add serveral users user: name={{ item }} state=present group=wheel with_items: - testuser1 - testuser2 范例： 1234567891011121314151617---- hosts: websrvs remote_user: root tasks: - name: add some groups group: name={{ item }} state=present with_items: - nginx - mysql - apache - name: add some users user: name={{ item.name }} group={{ item.group }} state=present with_items: - { name: &quot;nginx&quot;, group: &quot;nginx&quot; } - { name: &quot;mysql&quot;, group: &quot;mysql&quot; } - { name: &quot;apache&quot;, group: &quot;apache&quot; } 5. Roles 角色角色是 Ansible 自 1.2 版本引入的新特性, 用于层次性, 结构化地组织 playbook, roles 能够根据层次型结构自动装载变量文件, tasks 以及 handlers 等, 要使用 roles 只需要在 playbook 中使用 include 指令即可, 简单来讲, roles 就是通过分别将变量, 文件, 任务, 模板以及处理器放置于单独的目录中, 并可以便捷地 include 它们的一种机制, 角色一般用于基于主机构建服务的场景中, 但也可以用于构建守护进程等场景中 运维复杂的场景: 建议使用 roles, 代码复用度高 roles: 多个角色的集合, 可以将多个的 role, 分别放至 roles 目录下的独立目录中 roles/mysql/httpd/nginx/redis/ 5.1. Ansible Roles 目录编排Roles 目录结构如下所示 roles/project/: 项目名称, 有以下子目录 files/: 存放由 copy 或 script 模块等调用的文件templates/: template 模块查找所需要模板文件的目录tasks/: 定义 task, role 的基本元素, 至少应该包含一个名为 main.yml 的文件; 其它的文件需要在此文件中通过 include 进行包含handlers/: 至少应该包含一个名为 main.yml 的文件; 其它的文件需要在此文件中通过 include 进行包含vars/: 定义变量, 至少应该包含一个名为 main.yml 的文件; 其它的文件需要在此文件中通过 include 进行包含meta/: 定义当前角色的特殊设定及其依赖关系, 至少应该包含一个名为 main.yml 的文件, 其它文件需要在此文件中通过 include 进行包含default/: 设定默认变量时使用此目录中的 main.yml 文件, 比 vars 的优先级低 5.2. 创建 role创建 role 的步骤 (1) 创建以 role 命名的目录(2) 在 roles 目录中分别创建以各角色名称命名的目录, 如 webservers 等(3) 在每个角色命名的目录中分别创建 files, handlers, met, tasks, templates 和 vars 目录; 用不到的目录可以创建为空目录, 也可以不创建(4) 在 playbook 文件中, 调用各角色 针对大型项目使用 Roles 进行编排范例: roles 的目录结构 12345678910111213nginx-role.ymlroles/|----nginx |----files | |--main.yml |----tasks | |--groupadd.yml | |--install.yml | |--main.yml | |--restart.yml | |--useradd.yml |----vars |--main.yml 5.3. playbook 调用角色调用角色方法 1: 1234567---- hosts: websrvs remote_user: root roles: - mysql - memcached - nginx 调用角色方法 2: 键 role 用于指定角色名称, 后续的 k/v 用于传递变量给角色 1234567---- hosts: all remote_user: root roles: - mysql - (role: nginx, username: nginx) 调用角色方法 3: 123456---- hosts: all remote_user: root roles: - (role: nginx, username: nginx, when: ansible_distribution_major_version == '7') 5.4. roles 中的 tags 使用1234567891011- hosts: websrvs remote_user: root roles: - { role: nginx, tags: [&quot;nginx&quot;, &quot;web&quot;], when: ansible_distribution_major_version == '6', } - { role: httpd, tags: [&quot;httpd&quot;, &quot;web&quot;] } - { role: mysql, tags: [&quot;mysql&quot;, &quot;db&quot;] } - { role: mariadb, tags: [&quot;mariadb&quot;, &quot;db&quot;] } 123# ansible-playbook可以挑标签执行ansible-playbook --tags=&quot;nginx,httpd,mysql&quot; nginx-role.yml 5.5. 实战案例5.5.1. 案例 1： 实现 httpd 角色123456789101112131415161718192021222324252627282930313233343536# 创建角色相关的目录mkdir -pv /data/ansible/roles/httpd/{tasks, files, handlers}# 创建角色相关的文件cd /data/ansible/roles/httpd/vim tasks/main.yml- include: install.yml- include: config.yml- include: index.yml- include: service.ymlvim tasks/install.yml- name: install httpd package yum: name=httpdvim tasks/config.yml- name: config file copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes notify: restartvim tasks/index.yml- name: index.html copy: src=index.html dest=/var/www/html/vim tasks/service.yml- name: start service service: name=httpd state=started enabled=yesvim handlers/main.yml- name: restart service: name=httpd state=restarted# 在files目录下创建两个文件httpd.conf index.html 在 playbook 中调用 httpd 角色 vim /data/ansible/role_httpd.yml 123456---# httpd role- hosts: all remote_user: root roles: - httpd 5.5.2. 案例 2：实现 nginx 角色1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 创建角色相关的目录mkdir -pv /data/ansible/roles/nginx/{tasks, files, templates, handlers, vars}# 创建角色相关的文件cd /data/ansible/roles/nginx/vim tasks/main.yml- include: install.yml- include: config.yml- include: index.yml- include: service.ymlvim tasks/install.yml- name: install nginx package yum: name=nginxvim tasks/config.yml- name: config file for centos7 copy: src=nginx7.conf.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version==&quot;7&quot; notify: restart- name: config file for centos8 copy: src=nginx8.conf.j2 dest=/etc/nginx/nginx.conf when: ansible_distribution_major_version==&quot;8&quot; notify: restartvim tasks/index.yml- name: index.html# 跨角色调用文件 copy: src=roles/httpd/files/index.yml dest=/usr/share/nginx/html/vim tasks/service.yml- name: start service service: name=nginx state=started enabled=yesvim handlers/main.yml- name: restart service: name=nginx state=restartedvim vars/main.ymluser: daemonvim templates/nginx7.conf.j2......user: {{ user }}.......vim templates/nginx8.conf.j2......user: {{ user }}....... 在 playbook 中调用 nginx 角色 vim /data/ansible/role_nginx.yml 123456---# httpd role- hosts: all remote_user: root roles: - role_nginx 5.5.3. 案例 3：实现 mysql 角色40”51’ 123456789101112131415161718cat /data/ansible/roles/mysql/files/my.conf[mysqld]socket=/tmp/mysql.sockuser=mysqlsymbolic-links=0datadir=/data/mysqlinnodb_file_per_table=1log-binpid-file=/data/mysql/mysqld.pid[client]port=3306socket=/tmp/mysqld.log[mysqld_safe]log-error=/var/log/mysqld.log 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667cat /data/ansible/roles/mysql/files/secure_mysql.sh#!/bin/bash/usr/local/mysql/bin/mysql_secure_installation &lt;&lt;EOFyphiloenglishphiloenglishyyyyEOFls /data/ansible/roles/mysql/files/my.conf mysql-5.6.46-linux-glibc2.12-x86_64.tar.gz secure_mysql.shcat /data/ansible/roles/mysql/tasks/main.yml- include: install.yml- include: group.yml- include: user.yml- include: unarchive.yml- include: link.yml- include: data.yml- include: config.yml- include: service.yml- include: path.yml- include: secure.ymlcat /data/ansible/roles/mysql/tasks/install.yml- name: install packages yum: name=libaio, perl-Data-Dumper, perl-Getopt-Long cat /data/ansible/roles/mysql/tasks/group.yml- name: create mysql group group: name=mysql gid=306 cat /data/ansible/roles/mysql/tasks/user.yml- name: create mysql user user: name=mysql uid=306 group=mysql shell=/sbin/nologin system=yes create_home=no home=/data/mysql cat /data/ansible/roles/mysql/tasks/unarchive.yml- name: copy tar to remote host and file mode unarchive: src=mysql-5.6.46-linux-glibc2.12-x86_64.tar.gz dest=/usr/local owner=root group=root cat /data/ansible/roles/mysql/tasks/link.yml- name: mkdir /usr/local/mysql file: src=/usr/local/mysql-5.6.46-linux-glibc2.12-x86_64.tar.gz dest=/usr/local/mysql state=link cat /data/ansible/roles/mysql/tasks/data.yml- name: data dir shell: chdir=/usr/local/mysql ./scripts/mysql_install_db --datadir=/data/mysql --user=mysql cat /data/ansible/roles/mysql/tasks/conf.yml- name: conf my.cnf copy: src=my.cnf dest=/etc/my.cnfcat /data/ansible/roles/mysql/tasks/service.yml- name: service script shell: /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld;/etc/init.d/mysqld;/etc/init.d/mysqld start; chkconfig mysqld oncat /data/ansible/roles/mysql/tasks/path.yml- name: PATH variable copy: content='PATH=/usr/local/mysql/bin:$PATH' dest=/etc/profile.d/mysql.sh cat /data/ansible/roles/mysql/tasks/secure.yml- name: secure script script: secure_mysql.sh 6. 参考教程ansible 入门到精通及企业实战 Ansible 中文权威指南 Ansible 介绍 Ansible指南","link":"/ansible/ansible.html"},{"title":"安装ansible","text":"Ansible是一种基于Python开发的开源配置和自动化工具，专为类Unix系统设计。它使用SSH协议与节点进行通信，无需在节点上安装任何客户端。 Ansible具有以下特点： 无需代理：Ansible不需要在远程主机上安装客户端或代理，这使得部署和配置变得非常简单。跨平台支持：Ansible支持Linux、Windows、Unix和网络设备等多种操作系统。自动化运维：Ansible可以实现批量系统配置、批量程序部署、批量运行命令等功能，极大地提高了运维效率。简单易学：Ansible上手容易，学习曲线平缓，是每位运维工程师必须掌握的技能之一。功能强大：Ansible具有丰富的模块和插件，可以完成各种复杂的运维任务。Ansible的组成包括核心程序、模块、插件、剧本和主机清单等部分。其中，核心程序是Ansible的核心部分，负责与远程主机进行通信；模块是用于执行各种任务的插件，包括命令执行、文件操作、配置管理等；插件则是用于完成特定功能的插件，包括连接插件、邮件插件等；剧本是用于定义Ansible多任务配置文件的脚本文件，由Ansible自动执行；主机清单是用于定义Ansible管理的主机清单的文件。 本文主要介绍如何在Windows上以及Linux上安装Ansible。 1. Windows上安装Ansible在Windows上安装Ansible 2. Linux上安装AnsibleLinux上安装ansible 有多种方式 2.1. 方式一： EPEL yum 源安装12345678# 备份epel yum源mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backupmv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup# 更新EPELyum源，注意这里是RHEL 7系列， 根据具体的操作系统进行调整wget -O /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repoyum install ansible 2.2. 方式二： 编译安装12345678910111213# 安装依赖包yum -y install python-jinja2 PyYAML python-paramiko python-babel python-crypto wget https://releases.ansible.com/ansible/ansible-2.9.27.tar.gz# 解压源码包tar xf ansible-2.9.27.tar.gzcd ansible-2.9.27python setup.py buildpython setup.py installmkdir /etc/ansiblecp -r examples/* /etc/ansible 2.3. 方式三： Git 方式12345git clone git://github.com/ansible/ansible.git --recursivecd ./ansiblesource ./hacking/env-setup 2.4. 方式四：pip 安装pip 是安装 Python 包的管理器, 类似 yum 123456yum install python-pip python-develyum install gcc glibc-devel zibl-devel rpm-build openssl-develpip install --upgrade pippip install ansible --upgrade 2.5. 验证是否安装成功1ansible --version","link":"/ansible/ansible_install.html"},{"title":"使用ansible安装golang","text":"本文主要讲述如何使用Ansible在Redhat Linux系列上安装golang 19。 关于Ansible的基本概念可以参考运维自动化之Ansible 1. 安装Ansible安装Ansible参考安装ansible | 鹏叔的技术博客 2. 编写Ansible Playbook如果远程主机非root用户，需要准备一个ansible.cfg文件用于覆盖ansible默认配置，也可以直接修改/etc/ansible/ansible.cfg 1234567891011# vi ansible.cfg[defaults]# replace the user with actual user on controlled noderemote_user = user_name_on_managed_host[privilege_escalation]become = Truebecome_method = sudobecome_user = rootbecome_ask_pass = False vi install_golang.yaml 1234567891011121314151617181920212223242526---- name: Install golang hosts: all become: yes vars: - golang_download_url: https://studygolang.com/dl/golang/go1.19.3.linux-amd64.tar.gz env_file: /etc/profile tasks: - name: Unzip the downloaded file unarchive: src: &quot;{{ golang_download_url }}&quot; dest: /usr/local remote_src: yes - name: Set Golang environment variables lineinfile: dest={{ env_file }} insertafter={{ item.position }} line={{ item.value }} state=present with_items: - {position: EOF, value: &quot;export GOPROXY=https://goproxy.cn,direct&quot;} - {position: EOF, value: &quot;export PATH=$PATH:/usr/local/go/bin&quot;} notify: Reload profile handlers: - name: Reload profile shell: source {{ env_file }} 3. 执行Ansible Playbook1ansible-playbook install_golang.yaml 4. 参考文档分享Ansible批量安装golang环境 Linux System Roles","link":"/ansible/ansible_install_golang.html"},{"title":"使用ansible安装java","text":"本文主要讲述如何使用Ansible在Redhat Linux系列上安装java 17。 关于Ansible的基本概念可以参考运维自动化之Ansible 1. 安装Ansible安装Ansible参考安装ansible | 鹏叔的技术博客 2. 编写Ansible Playbook如果远程主机非root用户，需要准备一个ansible.cfg文件用于覆盖ansible默认配置，也可以直接修改/etc/ansible/ansible.cfg 1234567891011# vi ansible.cfg[defaults]# replace the user with actual user nameremote_user = user_name_on_managed_host[privilege_escalation]become = Truebecome_method = sudobecome_user = rootbecome_ask_pass = False vi install_java.yaml 12345678910111213141516171819202122232425---- name: Install Java hosts: all become: yes vars: - jdk_package_name: java-17-openjdk-devel jdk_version: 17.0.9.0.9 env_file: /etc/profile tasks: - name: Install OpenJDK yum: name={{ jdk_package_name }}-{{ jdk_version }} state=present - name: Set Java environment variables lineinfile: dest={{ env_file }} insertafter={{ item.position }} line={{ item.value }} state=present with_items: - {position: EOF,value: &quot;export JAVA_HOME=/usr/lib/jvm/{{ jdk_package_name }}-{{ jdk_version }}.el8.x86_64&quot;} - {position: EOF,value: &quot;export PATH=$JAVA_HOME/bin/:$PATH&quot;} - {position: EOF,value: &quot;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&quot;} notify: Reload profile handlers: - name: Reload profile shell: source {{ env_file }} 3. 执行Ansible Playbook1ansible-playbook install_java.yaml 4. 参考文档使用ansible 安装java Ansible 学习总结（6）—— Ansible 19个常用模块使用示例 Linux System Roles","link":"/ansible/ansible_install_java.html"},{"title":"记一次关于 Shared connection to remotehost 的 Ansible问题排查","text":"今天花了几乎一天的时间排查一个Ansible连接异常断开的问题。翻遍了几乎所有的帖子都没有找到正确的答案，经过不断的尝试，终于把这个问题搞懂了，特此记录下来，以便能帮助到同样正在被这个问题折磨的人。 问题描述今天在网上花了3.9美金购买了一个1U1G vps, 印象中1U1G的vps跑linux是没有问题的，所以就果断下单了。 由于vps是暴露在公网的，于是写了一个Ansible playbook用于加固vps的安全性，其中有一段是检查firwalld package有没有安装，内容如下： 123456- name: Ensure firewall package is installed ansible.builtin.dnf: name: firewalld state: present 执行这一段的时候，死后就是报错，而且无论我如何折腾，都非常稳定地输出如下错误。 1234TASK [security : Ensure firewall package is installed] *************************************************************fatal: [remote_host]: FAILED! =&gt; {&quot;changed&quot;: false, &quot;module_stderr&quot;: &quot;Shared connection to remote_host closed.\\r\\n&quot;, &quot;module_stdout&quot;: &quot;&quot;, &quot;msg&quot;: &quot;MODULE FAILURE\\nSee stdout/stderr for the exact error&quot;, &quot;rc&quot;: 137} 初看起来，非常像SSH连接超时，因此把整个SSH的工作原理，如何在服务器端，客户端，系统配置中调整ssh的参数研究了一遍。 而且试验了各种参数组合，都能正常ssh登陆远程主机，长时间不超时。但是当我运行Ansible脚本的时候依然如故。 借鉴他人的解决方案同时我也查找了网上类似的问题，以下这些文章是总结比较好的 How to Fix Shared connection to x.x.xx closed Ansible Error?。 How to Fix “Shared connection to x.x.xx closed” Ansible Error 这篇是Ansible官网的相关issue. ansible排错,ansible_ts 这篇也遇到类似的问题, 只是类似， 根本原因(root cause)不一样，但是至今没有解答, 而且也走在错误的方向上，仍然考虑的是连接超时方向。 Ansible: “msg”: “MODULE FAILURE\\nSee stdout/stderr for the exact error” 由于“Shared connection to remote_host closed.”是一个非常general的error。受管机中的各种错误都可以导致Ansible管理机器抛出这个错误。 导致这个错误的原因，这里总结一下。 网络问题可以导致以上问题，解决办法是用ssh远程主机，查看具体错误，并针对性解决网络问题。 防火墙设置改变后，重新加载配置，可能导致连接中断。 受管机Python的python版本过低，可能导致连接中断。 受管机没有安装必要的软件可能导致连接中断。 实际情况远比以上总结复杂。 误打误撞发现root cause尝试使用vvvv选项，看是否能获得有用信息。却又被引入了另外一个误区。 123ansible-playbook -vvvv -i hosts.ini security-enhancement.yml 123456789fatal: [remote_host]: FAILED! =&gt; { &quot;changed&quot;: false, &quot;module_stderr&quot;: &quot;OpenSSH_9.6p1, OpenSSL 3.2.1 30 Jan 2024\\r\\ndebug1: Reading configuration data /home/eagle/.ssh/config\\r\\ndebug1: Reading configuration data /etc/ssh/ssh_config\\r\\ndebug3: /etc/ssh/ssh_config line 55: Including file /etc/ssh/ssh_config.d/50-redhat.conf depth 0\\r\\ndebug1: Reading configuration data /etc/ssh/ssh_config.d/50-redhat.conf\\r\\ndebug2: checking match for 'final all' host remote_host originally remote_host\\r\\ndebug3: /etc/ssh/ssh_config.d/50-redhat.conf line 3: not matched 'final'\\r\\ndebug2: match not found\\r\\ndebug3: /etc/ssh/ssh_config.d/50-redhat.conf line 5: Including file /etc/crypto-policies/back-ends/openssh.config depth 1 (parse only)\\r\\ndebug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.config\\r\\ndebug3: gss kex names ok: [gss-curve25519-sha256-,gss-nistp256-sha256-,gss-group14-sha256-,gss-group16-sha512-]\\r\\ndebug3: kex names ok: [curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512]\\r\\ndebug1: configuration requests final Match pass\\r\\ndebug2: resolve_canonicalize: hostname remote_host is address\\r\\ndebug1: re-parsing configuration\\r\\ndebug1: Reading configuration data /home/eagle/.ssh/config\\r\\ndebug2: add_identity_file: ignoring duplicate key ~/.ssh/id_rsa\\r\\ndebug1: Reading configuration data /etc/ssh/ssh_config\\r\\ndebug3: /etc/ssh/ssh_config line 55: Including file /etc/ssh/ssh_config.d/50-redhat.conf depth 0\\r\\ndebug1: Reading configuration data /etc/ssh/ssh_config.d/50-redhat.conf\\r\\ndebug2: checking match for 'final all' host remote_host originally remote_host\\r\\ndebug3: /etc/ssh/ssh_config.d/50-redhat.conf line 3: matched 'final'\\r\\ndebug2: match found\\r\\ndebug3: /etc/ssh/ssh_config.d/50-redhat.conf line 5: Including file /etc/crypto-policies/back-ends/openssh.config depth 1\\r\\ndebug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.config\\r\\ndebug3: gss kex names ok: [gss-curve25519-sha256-,gss-nistp256-sha256-,gss-group14-sha256-,gss-group16-sha512-]\\r\\ndebug3: kex names ok: [curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512]\\r\\ndebug3: expanded UserKnownHostsFile '~/.ssh/known_hosts' -&gt; '/home/eagle/.ssh/known_hosts'\\r\\ndebug3: expanded UserKnownHostsFile '~/.ssh/known_hosts2' -&gt; '/home/eagle/.ssh/known_hosts2'\\r\\ndebug1: auto-mux: Trying existing master at '/home/eagle/.ansible/cp/2389f72688'\\r\\ndebug2: fd 3 setting O_NONBLOCK\\r\\ndebug2: mux_client_hello_exchange: master version 4\\r\\ndebug3: mux_client_forwards: request forwardings: 0 local, 0 remote\\r\\ndebug3: mux_client_request_session: entering\\r\\ndebug3: mux_client_request_alive: entering\\r\\ndebug3: mux_client_request_alive: done pid = 14400\\r\\ndebug3: mux_client_request_session: session request sent\\r\\ndebug1: mux_client_request_session: master session id: 2\\r\\ndebug3: mux_client_read_packet_timeout: read header failed: Broken pipe\\r\\ndebug2: Received exit status from master 137\\r\\nShared connection to remote_host closed.\\r\\n&quot;, &quot;module_stdout&quot;: &quot;&quot;, &quot;msg&quot;: &quot;MODULE FAILURE\\nSee stdout/stderr for the exact error&quot;, &quot;rc&quot;: 137} 从详细日志里面，看到以下一行，非常可疑，但是却是一个误区, 通过查找mux_client_read_packet_timeout相关的资料，发现是只是一个debug level的信息。 123mux_client_request_session: master session id: 2\\r\\ndebug3: mux_client_read_packet_timeout: read header failed: Broken pipe 最后将重点放在了&quot;rc&quot;: 137 ，这行小字才是root cause, 因为它是受管理机器上返回的唯一错误编号。其实中间我将重心放在超时问题时就注意到这行小字，由于这个数字太过抽象，实在没有引起重视。我也注意到很多相识问题，但是这个数字都不一样。 于是立马搜索了一下这个137代表什么样的错误。有相关问题提到137代表内存溢出，我起初以为是ssh内存溢出，即使137代表内存溢出，我也没想到是那里内存溢出。 因为中间有太多环节有可能内存溢出，有Ansible本身，有ssh的过程，有python解释器。后来我将dnf替换成yum, 依然是一样的错误。 为了找到到底是哪个环节发生内存溢出。我在那里漫无目的的尝试，于是我登陆到远程主机，尝试yum命令，dnf命令，这些命令只是打印出Killed消息，也没有与内存溢出产生连续。于是尝试在远程主机上使用不同版本的sshd服务，不同版本的操作系统。错误依然如故。心情异常沮丧。已经在考虑使用其他替代方案，手动写脚本来做安全增强了，但是手写脚本也得dnf或yum其中之一可用才可以呀。于是继续尝试。 不知道怎么想的，忽然在出现killed消息后执行了一下这条命令 echo $? 结果打印出了 137 这个错误代码，一下子思路豁然开朗了。 123456789101112user@VM-6QOC7BH3 ~ $ dnf search PythonAlmaLinux 9 - AppStream 17 MB/s | 14 MB 00:00 AlmaLinux 9 - BaseOS 18 MB/s | 15 MB 00:00 AlmaLinux 9 - Extras 26 kB/s | 20 kB 00:00 Extra Packages for Enterprise Linux 9 - x86_64 19 MB/s | 23 MB 00:01 Killeduser@VM-6QOC7BH3 ~ $ yum search PythonKilleduser@VM-6QOC7BH3 ~ $ echo $?137 原来是受管机上的dnf和yum本身存在错误。137 是内存溢出。 但是查询了一下剩余内存，又还剩500+M, 起初有些怀疑。 12345678user@VM-6QOC7BH3 ~ $ free -h total used free shared buff/cache availableMem: 769Mi 212Mi 500Mi 3.0Mi 172Mi 556MiSwap: 0B 0B 0Buser@VM-6QOC7BH3 ~ $ sudo dnf updateKilled 但是无论如何新买的机器dnf和yum都不能用，肯定得找管理员啊。于是提工单给vps管理说明情况，管理员立即给出回复。 1234567HelloThis is because your process was killed due to insufficient memory. Please add swap or upgrade your package.Best Regards,xxx 不信，于是把上面的可用内存发给他看，他又回了一句 1234567HelloWe recommend that you add swap and then test again.Best Regards,xxx 于是给1U1G的vps添加swap分区，添加swap分区的过程可以参考Linux 上添加swap分区 再次运行安全加固脚本，问题解决了。整个过程非常折磨人，在搜索解决方案的时候，也发现了很多人被这个问题折磨。 123ansible-playbook -vvvv -i hosts.ini security-enhancement.yml 总结这是由于Ansible报错不够清晰的原因导致的，中间多次被误导，被引入误区，虽然整个学习的过程受益匪浅，但是这种被折磨的感觉非常不爽。 所以一个清晰的报错信息，对软件的可用性非常重要，出现错误不可怕，可怕的是这种过于精简的报错信息。当然这不能全怪Ansible，因为它拿到的错误代码就是这样。根本原因还在于Linux, 或Linux的理念，很多编程语言错误返回就是一个代码，无论python, shell, c, C++，一旦出处，排查问题折磨死人。 另外，Linux的许多发行版本越来越臃肿了，对内存的要求都越来越高了，尤其是一个dnf和yum程序居然需要500+M的内存，确实是没有意识到的。我记得以前手里有一台非常老旧的笔记本，大概是零几年的还能跑ubuntu, 一台树莓派还能跑manjaro， 这种时代正在逐渐过去了。 就Ansible 错误信息 “Shared connection to x.x.xx closed” 本身，需要第一时间将ansible-playbook -vvvv打印出的实际运行脚本拿到受管机上去执行一下，尽快找到与&quot;rc&quot;: xxx对应的错误原因。只要找到原因，后续解决就比较有的放矢了。","link":"/ansible/ansible_trouble_shooting.html"},{"title":"在Windows上安装Ansible","text":"1. 前言Ansible是一种无代理自动化工具，可安装在单个主机（称为控制节点）上。从控制节点，Ansible可以通过SSH、Powershell远程处理和许多其他传输远程管理整个机器和其他设备（称为托管节点），所有这些都是通过一个简单的命令行界面实现的，不需要数据库或守护程序。 本教程是安装环境为Windows, 在windows上要运行Ansible还需要安装Msys2, 主要用于运行 GNU 软件的开发和运行环境。同时它也是一个在Cygwin （POSIX 兼容性层） 和 MinGW-w64（从”MinGW-生成”）基础上产生的，追求更好的互操作性的 Windows 软件. 2. 安装MSys2安装MSys2可以参考我的教程MSys2安装教程 安装好MSys2后即可执行以下命令安装ansible 1pacman -S ansible 3. 控制节点要求对于您的控制节点（运行Ansible的机器），您可以使用几乎任何安装了Python 3.9或更新版本的类UNIX的机器。这包括Red Hat、Debian、Ubuntu、macOS、BSD和Windows Subsystem for Linux（WSL）发行版下的Windows。没有WSL的Windows本机不支持作为控制节点；有关更多信息，请参阅Matt Davis的博客文章 4. 受管节点要求受管节点（Ansible正在管理的机器）不需要安装Ansible，但需要Python 2.7或Python 3.5-3.11来运行Ansible库代码。被管理节点还需要一个用户帐户，该帐户可以通过SSH连接到节点。 注意: 网络模块是一个例外，并且在受管设备上不需要Python。请参阅网络模块 5. 节点需求汇总下表列出了控制节点和受管节点上所需的Python的当前版本和历史版本。 ansible-core Version Control node Python Managed node Python 2.11 Python 2.7, Python 3.5 - 3.9 [†] Python 2.6 - 2.7, Python 3.5 - 3.9 2.12 Python 3.8 - 3.10 Python 2.6 - 2.7, Python 3.5 - 3.10 2.13 Python 3.8 - 3.10 Python 2.7, Python 3.5 - 3.10 2.14 Python 3.9 - 3.11 Python 2.7, Python 3.5 - 3.11 6. 选择要安装的Ansible软件包和版本Ansible社区包以两种方式分发：一种是名为Ansible-core的极简语言和运行时包，另一种是更大的名为anssible的包，它添加了社区策划的Ansible集合，用于自动化各种设备。选择适合您需求的包装；以下是ansible的安装步骤，但如果您想要安装ansible core，并且只单独安装所需的ansible集合，则可以将安装步骤中的ansible替换为ansible-core。在您的操作系统包管理器中可能会提供ansible或ansible-core，您可以使用自己喜欢的方法免费安装这些包。这些安装说明仅涵盖官方支持的使用pip安装python包的方法。 6.1. 定位Python找到并记住要用于运行Ansible的Python路径。以下安装说明将此python称为python3。例如，如果您已经确定希望/usr/bin/python3.9中的Python安装Ansible, 请指定Python3.9而不是python3。 6.2. 确保pip已经安装要验证是否已经为您首选的Python安装了pip，请执行以下操作： 1python3 -m pip -V 如果一切顺利，您应该看到以下内容： 12python3 -m pip -Vpip 21.0.1 from /usr/lib/python3.9/site-packages/pip (python 3.9) 如果看到的是如上输出，那么说明pip是可用的，您可以继续下一步。如果您看到类似No module named pip这样的错误，那么在继续操作之前，您需要需要先安装pip。这可能意味着安装额外的操作系统包（例如，python3-pip），或者通过运行以下命令直接从Python Packaging Authority安装最新的pip： 1234curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython3 get-pip.py --user 您可能需要执行一些额外的配置，然后才能运行Ansible。有关更多信息，请参阅有关安装到用户站点的Python文档 7. 安装Ansible在您选择的Python中使用pip为当前用户安装您选择的Ansible包： 1python3 -m pip install --user ansible 或者，您可以在此Python环境中安装特定版本的ansible-core： 1python3 -m pip install --user ansible-core==2.14.2 8. 升级Ansible要将此Python环境中现有的Ansible安装升级到最新发布的版本，只需在上面的命令中添加–upgrade： 123python3 -m pip install --upgrade --user ansible 9. 验证是否安装成功您可以通过检查版本来测试Ansible是否已正确安装： 1ansible --version 此命令显示的版本适用于已安装的相关ansible-core包。 要检查已安装的ansible软件包的版本，请执行以下操作： 1python3 -m pip show ansible 安装成功后, 可以看到如下输出 123456789101112131415161718192021222324$ansible --versionansible [core 2.14.2] config file = /etc/ansible/ansible.cfg configured module search path = ['/home/your_name/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python3.11/site-packages/ansible ansible collection location = /home/your_name/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3.11.2 (main, Feb 14 2023, 18:12:17) [GCC 11.3.0] (/usr/bin/python.exe) jinja version = 3.1.2 libyaml = True$python3 -m pip show ansibleName: ansibleVersion: 7.2.0Summary: Radically simple IT automationHome-page: https://ansible.com/Author: Ansible, Inc.Author-email: info@ansible.comLicense: GPLv3+Location: /usr/lib/python3.11/site-packagesRequires: ansible-coreRequired-by: 10. 参考文档Ansible installation guide Ansible 7 Porting Guide","link":"/ansible/install_ansible_on_windows.html"},{"title":"Chrome插件开发","text":"1. 前言chrome extensions官方文档 2. 初识Chrome插件2.1. 什么是Chrome插件, 他能干什么?Chrome插件是为chrome浏览器添加功能的小程序, chrome插件可以获取网页内容并可以操作网页内容, 如爬取网页数据(网络爬虫), 自动点击(定时点击或刷新), 修改网页内容(如更改网页文字或图片)等. 2.2. 为什么是Chrome插件而不是其它浏览器插件?首先Chrome是使用最多的浏览器, 其次国内许多浏览器是基于Chrome内核开发的, Chrome插件可以用于许多其它浏览器上, 如360, 百度浏览器上. 2.3. 学习Chrome插件开发需要哪些知识储备?只需要html, css和javascript的基础知识即可. 我们还可以选择使用jQuery之类的JavaScript库, 让开发变得更简单. 2.4. 本课程的主要内容本教程将教你如何开发, 调试和部署Chrome插件. 学习中将边开发边学习概念而不是先对所有概念进行介绍. Hello World Browser Action Page Action 非Browser Action类型的插件或Page Action类型的插件的其它知识 调试 部署 3. Chrome插件的文件结构在我们正式开始开发插件前, 我们先来了解一下一个Chrome插件的构成, 通常一个chrome插件包含以下几个部分: cssimgjsmanifest.jsonpopup.html manifest.json必须, 是插件的配置文件, 包含插件名称, 版本号, 图标, 权限等信息. *.html: 用于向用户展示信息并与用户交互的界面, 如插件的设置界面等. js/*.js: 用于实现插件的逻辑功能, 并不要求必须放在js文件夹下. service worker 处理和侦听浏览器事件。有很多类型的事件，例如导航到新页面、删除书签或关闭选项卡。它可以使用所有Chrome API，但不能直接与网页内容交互；这属于内容脚本的工作。 img/*.png: 插件需要的图片, 如插件图标等, 文件类型不必是png, 文件夹非必须. css/*.css: 插件中用到的css, 如对网页样式进行修改时用到的css文件. 文件夹非必须. 4. 第一个chrome插件helloworld现在, 我们来创建我们的第一个Chrome插件HelloWorld. 本课程我们使用vs code作为编辑器, 您也可以使用其它编辑器. 主要目录结构如下. 4.1. 创建helloworld12345HelloWorld|-- img |-- logo.png |-- manifest.json|-- popup.html 1, 新建插件文件夹HelloWorld2, 编写manifest.json文件 manifest.json文件内容, 更多关于manifest.json文档字段说明, 请查看manifest文件说明文档也可以查看官方的helloworld示例,完整代码可在github上下载 - tutorial.hello-world 123456789101112131415{ &quot;manifest_version&quot;: 3, &quot;name&quot;: &quot;helloWorld&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;description&quot;: &quot;hello world 插件&quot;, &quot;icons&quot;: { &quot;128&quot;: &quot;img/logo.png&quot;, &quot;48&quot;: &quot;img/logo.png&quot;, &quot;16&quot;: &quot;img/logo.png&quot; }, &quot;action&quot;: { &quot;default_popup&quot;: &quot;popup.html&quot;, &quot;default_icon&quot;: &quot;img/logo.png&quot; }} 注意如果chrome版本较旧, 比如Chrome 88之前的版本, 则需要将不支持manifest v3, 需要按照manifest v2的格式配置manifest.json文件. popup.html 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt; Hello world &lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=&quot;message&quot;&gt; 你好 &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 注意: 最好指定编码, 否则可能出现乱码的情况. 这样一个helloword插件的代码部分就完成了, 下面我们讲解如何将其加载进Chrome. 4.2. 使用HelloWorld插件点击Chrome右上角用户偏好设置=&gt;扩展程序=&gt;管理扩展程序, 进入插件管理界面. 或者直接在浏览器地址栏输入chrome://extensions/进入插件管理界面. 要安装自己编写的浏览器插件, 首先将右上角的开发者模式开启. 开启开发者模式后, 界面上方会出现”加载已解压的扩展程序”按钮. 点击该按钮, 选择我们helloword插件所在目录进行加载. 加载完成后在扩展, 点击右上角”扩展程序按钮”就可以看到helloworld插件了, 点击helloworld插件就能看到”你好”信息了. 如果插件加载过程中存在任何问题, 在扩展程序管理页面对应的plugin上会有”错误”按钮, 点击”错误”可以看到即可看到错误的详细信息. 获得错误详情后即可进行除错处理. 前提是要打开开发者模式. 5. Javascript的基本用法首先引入javascript, 修改后的popup.html文件如下所示. popup.html 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt; Hello world &lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;js/jquery.js&quot; /&gt; &lt;script src=&quot;js/popup.js&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=&quot;message&quot;&gt; 你好 &lt;/h1&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot;&gt; &lt;/input&gt; &lt;/body&gt;&lt;/html&gt; popup.js的内容如下 123456789$(function(){ $('#input1').keyup( function(){ $('#message').text('你好, '+ $('#input1').val()); } )}) 这样当我们在输入框输入信息的时候, message标题栏就会跟随输入发生变化. 可以参考上节内容加载该插件并测试. 6. 数据存储6.1. 获取存储权限首先, 如果我们要使用本地存储, 则需要在manifest.json中添加storage权限 12345&quot;permissions&quot;: [ &quot;storage&quot;] 6.2. 从存储读取数据123456789101112131415161718192021222324252627$(function(){ chrome.storage.sync.get('total', function(bugget){ var totalAmount = 0; if(bugget.total) { totalAmount = parseFloat(bugget.total); } $(&quot;#total&quot;).text(totalAmount); } $('addBtn').click(function (){ chrome.storage.sync.get('total', function(bugget){ var totalAmount = 0; if(bugget.total) { totalAmount = parseFloat(bugget.total); } var amount = $('#amount').val(); if(amount) { totalAmount += parseFloat(amount); chrome.storage.sync.set('total':totalAmount) } $(&quot;#total&quot;).text(totalAmount); $(&quot;#amount&quot;).val(&quot;&quot;) }); })}) 从上面的例子可以看到通过chrome.storage即可获取本地存储, 通过storage提供的一些方法, 我们即可操纵数据. 7. Options Page的用法Options Page用于提供user interface给使用插件的用户设置必要的参数. 首先在manifest.json文件中指定Options page 123456{ &quot;name&quot;: &quot;My extension&quot;, ... &quot;options_page&quot;: &quot;options.html&quot;, ...} options.html 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt; Budget manager options &lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;js/jquery.js&quot; /&gt; &lt;script src=&quot;js/options.js&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 预算管理选项 &lt;/h1&gt; &lt;h2&gt; 预算限制: &lt;input type=&quot;text&quot; id=&quot;limit&quot;&gt;&lt;/h2&gt; &lt;input type=&quot;submit&quot; id=&quot;setlimit&quot; value=&quot;保存限制&quot;&gt; &lt;input type=&quot;submit&quot; id=&quot;resetTotal&quot; value=&quot;清楚总金额&quot;&gt; &lt;/body&gt;&lt;/html&gt; 详细示例可以参考官方文档Give users options 8. 添加右键菜单通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里. 首先需要获取访问右键菜单的权限, 修改manifest.json, 添加如下内容. 12345&quot;permissions&quot;: [ &quot;contextMenus&quot; ] 另外我们需要定义一个service_worker, service worker能获得更多操纵浏览器行为的权限, 其中包括管理右键菜单. 定义service_worker的方式如下, 在manifest.json中定义service_worker的入口脚本. 12345&quot;background&quot;: { &quot;service_worker&quot;: &quot;js/service-worker.js&quot;}, 在js/service-worker.js即可调用chrome的API创建右键菜单项, 代码如下. 参考Chrome extensions api examples contextMenus 12345678910111213chrome.contextMenus.create( { id: &quot;10086&quot;, type: &quot;normal&quot;, title: &quot;test menu item&quot;, contexts: [&quot;page&quot;, &quot;selection&quot;] }, function(){ console.log(&quot;what can I help you?&quot;) }) 说明: 只有获取到contextMenus权限, 才可调用chrome.contextMenus.create, 如果未获取到权限chrome.contextMenus将返回undefined菜单的id必须是唯一的, 否则会与其它子菜单冲突.contextMenu type有四种类型, 分别为: nomal, checkbox, radio, separatorcontextMenu contexts有多种类型, 用于控制子菜单在何种情况显现, 具体类型参考文档type-ContextType必须传入回调函数, 否则会报错API的详细说明, 请参考Extensions - API reference - chrome.contextMenus 9. 如何与页面交互前面我们讲了popup page, options page以及service_worker, 这些都需要用户的操作才能与网页进行交互, 如果要在用户打开的网页自动注入事件或改变网页行为, 我们需要插入content_scripts. 要引入content_scripts, 我们需要修改manifest.json, 添加对应的content_scripts. 以下就是一个content_scripts配置示例 123456789&quot;content_scripts&quot;: [ { &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], &quot;js&quot;: [&quot;js/jquery.js&quot;, &quot;js/content_script.js&quot;], &quot;css&quot;: [&quot;css/style.css&quot;], &quot;run_at&quot;: &quot;document_end&quot;, &quot;all_frames&quot;: false } 说明: 一段我们配置了content_scripts,并且我们的插件被成功加载到浏览器中, 浏览器在打开任何页面时都会检查, 是否要注入入(Inject)插件的content_scripts的部分到网页;浏览器通过matches属性判断是否注入, 通过run_at属性控制何时注入, 通过js,css属性控制注入哪些内容;通过all_frames控制是在匹配页面的所有frame中运行还是只在最上层的frame中运行。缺省是false，也就是只在最上层frame中运行;对于js属性, 其是一个数组, 脚本在数组中的位置决定了脚本的加载顺序, 所有被依赖的脚本需要放在靠前的位置.关于run_at的详细说明: 控制content script注入的时机。可以是document_start， document_end或者document_idle。缺省时是document_idle。如果是document_start, 文件将在所有CSS加载完毕，但是没有创建DOM并且没有运行任何脚本的时候注入。如果是document_end，则文件将在创建完DOM之后，但还没有加载类似于图片或frame等的子资源前立刻注入。如果是document_idle，浏览器会在document_end和发出window.onload事件之间的某个时机注入。具体的时机取决与文档加载的复杂度，为加快页面加载而优化。注意： 在document_idle的情况下，content script不一定会接收到window.onload事件，因为它有可能在事件发出之后才加载。在大多数情况下， 在content script中监听onload事件是不必要的，因为浏览器会确保在DOM创建完成后才执行它。 如果一定要在window.onload的时候运行，可以通过document.readyState属性来检查onload事件是否已经发出。 10. 页面之间的通信 以上是chrome插件的结构简图, 从图中我们可以看出, chrome插件主要由三部分组成: Background script (service worker), Content script, Popup. 其中service worker是在后台运行的, 通常一个插件只会有一个service_worker的实例在运行. 而content script会有多个实例同时在运行, 这取决与用户打开了多少个与插件相匹配的页面. 而popup会在用户点击插件时打开, 关闭时退出, 或者在被service_worker或content script触发时进行创建. 10.1. Background script (service worker)service worker是插件的事件处理程序；它包含对插件很重要的浏览器事件的侦听器。它处于休眠状态，直到事件被触发，然后执行所指示的逻辑；通过配置可以实现它只在需要时加载，在空闲时卸载以节省内存, 通过配置也可以实现常驻内存。service worker可以访问所有Chrome API，只要它在manifest.json中声明了所需的权限。 10.2. Content scriptContent script是在网页上下文中运行的脚本。通过使用标准的文档对象模型（DOM），他们能够读取浏览器访问的网页的详细信息，对其进行更改，并将信息传递给插件的其它部件。 10.3. Popup当用户单击工具栏中扩展的操作按钮时，将显示操作的弹出窗口。弹出窗口可以包含您喜欢的任何HTML内容，并将自动调整大小以适应其内容。 10.4. 页面间通信插件中的不同组件可以使用消息传递进行通信。任何一方都可以监听从另一端发送的消息，并在同一频道上进行响应。 在本教程中，我们将重点关注Content script和service worker如何进行通信。 10.5. Content script和service worker之间通信content script发送消息给service worker并通过Promise的Then方法处理返回结果. 123456789101112chrome.runtime .sendMessage({ searchingWord: searchingKeyWord, }) .then((wordInfo) =&gt; { document.write( 'word: ' + wordInfo.word + '&lt;br&gt;' + 'translation: ' + wordInfo.translation ); } service worker 在onMessage通道上, 一旦接收到消除, 就会调用处理函数进行处理, 处理玩的结果通过sendResponse发送给消息发送方. 注意通过fetch返回的对象是Response类型, 这种类型不是标准的json对象, 所以必须将其转换为json对象才能正确的传递给content script.即以下示例中的.then((response) =&gt; response.json())部分, 即是将Response对象转换为json object. 12345678910111213141516171819202122232425chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { fetchData( &quot;https://api.example.com/&quot; + request.searchingWord ) .then((response) =&gt; response.json()) .then((res) =&gt; { sendResponse(res); }); return true;});function fetchData(url) { return fetch(url, { method: &quot;GET&quot;, cache: &quot;default&quot;, credentials: &quot;include&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot;, }, redirect: &quot;follow&quot;, referrerPolicy: &quot;no-referrer-when-downgrade&quot;, });} 11. 发布插件到谷歌市场11.1. 注册google开发者账号点击链接进入谷歌市场注册页面 11.2. 提交Chrome插件文件包注册开发者身份成功后，我们就可以将CRX文件打包提交了。在开发者信息中心，选择添加新项。首次发布项目之前，您必须支付 US5.00的一次性开发者注册费。谷歌收取此费用的目的是对开发者帐户进行验证，并为用户提供更好的保护，以防他们受到欺骗性活动的侵害。支付注册费后，您最多可以发布 20 项内容。谷歌使用 Google 电子钱包来处理US5.00的一次性开发者注册费。谷歌收取此费用的目的是对开发者帐户进行验证，并为用户提供更好的保护，以防他们受到欺骗性活动的侵害。支付注册费后，您最多可以发布20项内容。谷歌使用Google电子钱包来处理US5.00付款。如果您之前未使用过 Google 电子钱包，会被要求您提供结算信息。 11.3. 编辑Chrome插件信息我们在访问谷歌应用商店的插件chrome扩展程序上有一些文字的介绍信息，我们开发人员在上传成功后，需要在开发者信息中心中编辑插件的基本信息。填写完信息，点击提交审核即可。 12. 相关阅读chrome插件开发中Chrome storage API使用详解 13. 参考文档谷歌插件开发-Chrome-exts-cli 【干货】Chrome插件(扩展)开发全攻略 最新版 V3 chrome 插件开发~ demo + 坑","link":"/chrome/chrome_plugin_development.html"},{"title":"chrome插件开发中Chrome storage API使用详解","text":"1. 前言Storage API 是 Google Chrome 提供的一个内置 API，用于在插件中存储和访问数据。它提供了四种存储方式：本地存储（Local Storage）,同步存储（Sync Storage）,会话存储(storage.session), 受管存储(storage.managed)。本地存储用于在本地计算机上存储数据，而同步存储则将数据存储在用户的 Google 账号中，并在不同设备间同步。这使得插件能够在不同环境中保持一致的数据状态，为用户提供更好的体验。 Chrome storage API 提供了一种特定于插件的方法来保存用户数据和状态。它类似于 Web 平台的存储 API（IndexedDB和Storage），但旨在满足扩展的存储需求。以下是一些主要功能： 所有插件contexts（包括扩展service worker和content scripts ）都可以访问存储 API。 存储数据的格式需要符合要求,存储的数据必须是 JSON 格式的对象或字符串，否则将会触发错误。 存储数据的读写是异步的：由于存储数据的读写操作是异步的，因此需要使用回调函数或 Promise 来处理返回值。 存储数据可以执行批量读写操作。 即使用户清除缓存和浏览历史记录，数据仍然存在。 即使用户使用隐身模式，存储的设置也会保留。 受管存储区域提供只读模式, 专用于企业浏览器策略。 2. 储存区结束Chrome storage被分割为四块存储区域, 分别为: 本地存储(storage.local) 同步存储(storage.sync) 存储会话(storage.session) 受管存储区域(storage.managed) 2.1. 本地存储(storage.local)数据存储在本地，当插件被删除时，数据将被清除。配额限制约为 10 MB，但可以通过请求权限来增加”unlimitedStorage”。考虑使用它来存储大量数据。使用它可以让插件在多个页面之间共享数据，而且这些数据在用户关闭浏览器后也不会丢失。 在 Chrome 114 之前，本地配额约为 5 MB。 在实际开发场景中我们通常使用它来存储以下类型的数据： 用户配置数据：比如用户选择的语言、主题、字体等。 用户历史记录：比如用户最近访问的网站、搜索记录等。 扩展程序状态：比如用户是否登录、扩展程序是否启用等。 2.1.1. local Storage API 清单 API 描述 chrome.storage.local.get() 用于获取存储在本地的数据 chrome.storage.local.set() 用于存储数据到本地存储空间中 chrome.storage.local.remove() 用于删除本地存储空间中的数据 chrome.storage.local.clear() 用于删除本地存储空间中所有items chrome.storage.local.getBytesInUse() 用于获取已存储数据的大小 2.1.2. 本地存储使用方法下面是一个简单的 chrome.storage.local 的使用示例： 12345678910// 存储数据chrome.storage.local.set({language: 'zh-CN'}, function() { console.log('Data saved.');});// 读取数据chrome.storage.local.get('language', function(result) { console.log('Language is ' + result.language);}); 在上面的代码中，我们首先使用 chrome.storage.local.set 方法存储了一个名为”language”的键值对，表示用户选择的语言为中文。回调函数中打印了一条日志表示数据已经存储成功。接着，我们使用 chrome.storage.local.get 方法读取了名为”language”的键值对，并打印出来。如果之前已经存储了这个键值对，那么会输出”Language is zh-CN”。需要注意的是，存储数据是异步的，因此在读取数据时需要在回调函数中处理。而且存储的数据必须是JSON格式的，因此需要将数据用对象的形式传递给 chrome.storage.local.set 方法。 另外 localStorage 是基于域名的。而 content_scripts 是注入到用户当前浏览页面中的，如果 content_scripts 直接读取 localStorage，所读取到的数据是用户当前浏览页面所在域中的。 所以通常的解决办法是 content_scripts 通过 runtime.sendMessage 和 service worker 通信，由 service worker 读写扩展所在域（通常是 chrome-extension://extension-id/）的 localStorage，然后再传递给 content_scripts。这样就可以实现跨页面共享数据. 另外storage local 支持批量读写操纵, 当我们需要一组数据时不必逐个的去读取或写入. 123456789101112131415161718192021var user1 = {'name': 'diego', 'age': 18}var user2 = {'name': 'eagle', 'age': 20} // 往存储中写入数据chrome.storage.local.set({'user1': user1}, function() { console.log('保存成功');chrome.storage.local.set({'user2': user2}, function() { console.log('保存成功');// 从存储中批量读取数据chrome.storage.local.get(['user1', 'user2'], function(result) { document.write( 'name: ' + result['user1'].name + '&lt;br&gt;' + 'age: ' + result['user1'].age + '&lt;hr&gt;' + 'name: ' + result['user2'].name + '&lt;br&gt;' + 'age: ' + result['user2'].age );}); 2.2. 同步存储(storage.sync)如果同步存储被启用，数据将同步到用户登录的任何 Chrome 浏览器。如果禁用，其行为类似于storage.local. 当浏览器离线时，Chrome 会在本地存储数据，并在浏览器重新上线时恢复同步。整体配额约为 100 KB，单条记录限额为 8 KB。可以使用它来跨浏览器同步用户设置。 本地和同步存储区域不应存储机密用户数据，因为它们未加密。处理敏感数据时，请考虑使用session存储区域将值保存在内存中，直到浏览器关闭。 在实际开发场景中通常用于存储需要在多个设备之间同步的数据，例如： 用户偏好设置：如主题、语言、字体大小等。 书签和浏览历史：使用户在不同设备上能够访问相同的书签和浏览历史记录。 扩展程序状态和配置：确保用户在不同设备上使用相同的扩展程序设置。 2.2.1. sync Storage API 清单 API 描述 chrome.storage.sync.get() 用于获取存储在同步存储的数据 chrome.storage.sync.set() 用于存储数据到同步存储空间中 chrome.storage.sync.remove() 用于删除同步存储空间中的数据 chrome.storage.sync.clear() 用于删除同步存储空间中所有items chrome.storage.sync.getBytesInUse() 用于获取已使用的同步存储数据的大小 chrome.storage.sync 的API包含以上几个参数，与 chrome.storage.local 基本一致。它们属于StorageArea的基本方法. 以下是一个chrome.storage.sync 的使用示例： 12345678910// 存储数据chrome.storage.sync.set({theme: 'dark'}, function() { console.log('Data saved.');});// 读取数据chrome.storage.sync.get('theme', function(result) { console.log('Theme is ' + result.theme);}); 2.3. 会话存储(storage.session)在浏览器会话期间将数据保存在内存中。默认情况下，它不会暴露给content scripts，但可以通过设置更改此行为chrome.storage.session.setAccessLevel()。配额限制约为 10 MB。考虑使用它来存储跨service worker运行的全局变量。 在 Chrome 112 之前，配额约为 1 MB。 2.4. 受管存储区域(storage.managed)用于存储和管理由管理员在企业环境中配置的扩展程序设置，它的主要作用是在企业环境中统一管理和配置扩展程序的设置。企业管理员可以通过集中管理的方式，向员工的Chrome浏览器中推送扩展程序的特定设置，确保各个用户使用相同的配置。 管理员可以使用JSON Schema和企业策略在托管环境中配置支持扩展的设置。该存储区域是只读的。 2.4.1. managed Storage API 清单 API 描述 chrome.storage.managed.get() 用于获取存储在 Chrome 管理的环境中的数据 chrome.storage.managed.set() 用于存储数据到 Chrome 管理的环境中，但只能由管理员或管理控制台授权的组织进行写操作 chrome.storage.managed.remove() 用于删除 Chrome 受管存储中的数据，但只能由管理员或管理控制台授权的组织进行写操作 chrome.storage.managed.clear() 用于删除受管存储空间中所有items, 但只能由管理员或管理控制台授权的组织进行写操作 chrome.storage.managed.getBytesInUse() 用于获取受管存储空间已使用的存储数据的大小 需要注意的是，chrome.storage.managed 主要用于企业或教育机构的管理控制台，而不是一般的插件开发。该 API 用于管理者对用户浏览器环境中的存储数据进行控制和配置。 以下是一个简单的示例： 123456chrome.storage.managed.get(['theme', 'language'], function(result) { console.log('Theme is ' + result.theme); console.log('Language is ' + result.language);}); 3. 如何查看local storage 和 sync storage可能是出于数据安全考虑, Devtools中没有提供直接查看这两块存储区域的图形化工具, 网上提供的图形化工具插件Storage Area Explorer也被禁用了, 但是通过一些方法可以安装并启用这个插件, 具体参考is-there-a-way-to-view-chrome-storage-local-in-developer-tools. 另一种方法是使用命令行, 当断点停在content script上或service worker脚本上时, 打开console, 输入chrome.storage.sync.get()或chrome.storage.sync.get() 在打印出的对象上, 展开节点Promise=&gt;PromiseResult可以看到所有数据. 第三种方法: 打开chrome://sync-internals/ 在Sync Node Browser界面展开Extension settings节点可以看到Sync strage的存储状况. 4. 相关阅读Chrome插件开发 5. 参考文档谷歌插件开发：Storage API 详解（手把手带你从零探索开发谷歌插件 Chrome storage存储 API使用详解 Chrome extension API - chrome.storage","link":"/chrome/chrome_storage_api.html"},{"title":"命令行打包Chrome插件","text":"本文介绍了如何打包、托管和更新通用 Web 服务器中的 crx 文件。 1. 制作.crx 扩展程序安装包1.1. 手动制作.crx在 Chrome 浏览器输入框中输入 chrome://extensions/打开扩展程序管理界面，或点击 Chrome 菜单，将光标悬停在“更多工具”上，然后选择“扩展程序”。 在“扩展程序管理”页面上，点击开发者模式旁边的切换开关来启用开发者模式。然后选择打包扩展程序按钮。 在“扩展程序根目录”字段中指定扩展程序文件夹的路径，然后点击打包扩展程序按钮。对于首次打包扩展程序，请忽略 Private key 字段。 Chrome 将创建两个文件：一个 .crx 文件和一个包含扩展程序私钥的 .pem 文件。 切勿丢失私钥！请将 .pem 文件保存在安全可靠的地方；更新扩展程序时需要用到此文件。 1.1.1. 更新.crx 扩展程序安装包通过增加 manifest.json 中的版本号来更新扩展程序的 .crx 文件。 12345678{ ... &quot;version&quot;: &quot;1.5&quot;, ... }} 返回扩展程序管理界面，然后点击打包扩展程序按钮。指定扩展程序目录的路径以及私钥的位置。 点击打包扩展程序按钮生产新的.crx 文件。 1.2. 通过命令行打包通过调用 chrome.exe 在命令行中打包扩展程序。使用 –pack-extension 标志可指定扩展程序的文件夹位置，使用 –pack-extension-key 标志可指定扩展程序私钥文件的位置。 12345678# For windowschrome.exe --pack-extension=C:\\myext --pack-extension-key=C:\\myext.pem# For fedoragoogle-chrome --pack-extension=path_to_your_chrome_plugin_source -pack-extension-key=path_to_your_chrome_extension_key# 例如google-chrome --pack-extension=~/sourceRepo/chrome_plugin -pack-extension-key=~/sourceRepo/chrome_plugin.pem 2. 托管托管 .crx 文件的服务器必须使用适当的 HTTP 标头，以便用户通过点击链接来安装扩展程序。 如果满足以下任一条件，Google Chrome 就会将文件视为可安装： 该文件的内容类型为 application/x-chrome-extension 文件后缀为 .crx，并且满足以下两个条件： 文件不会使用 HTTP 标头 X-Content-Type-Options: nosniff 提供 文件包含以下内容之一： 空字符串 “text/plain” “application/octet-stream” “unknown/unknown” “application/unknown” “/“ 无法识别可安装文件的最常见原因是服务器发送了标头 X-Content-Type-Options: nosniff。第二个最常见的原因是服务器发送的内容类型未知，即不在上一个列表中。如需解决 HTTP 标头问题，请更改服务器的配置或尝试在其他服务器上托管 .crx 文件。 2.1. 更新浏览器每隔几小时就会检查已安装的扩展程序，看是否有更新网址。对于每个扩展程序，它会向更新网址发出请求，以查找更新清单 XML 文件。 更新检查返回的内容是一个 XML 格式的更新清单，其中列出了相应扩展程序的最新版本。 如果更新清单中的版本高于安装的版本，浏览器就会下载并安装新版本。 新版本的.crx 扩展程序必须使用与当前已安装的版本相同的私钥签名。 注意：为了保护用户隐私，Google Chrome 不会在自动更新清单请求中发送任何 Cookie 标头，并且会忽略对这些请求的响应中的所有 Set-Cookie 标头。 2.1.1. 更新网址在 Chrome 应用商店以外的服务器上托管的扩展程序必须在其 manifest.json 文件中包含 update_url 字段。 Linux 是唯一一个可供 Chrome 用户安装非 Chrome 应用商店托管的扩展程序的平台。 12345678{ &quot;name&quot;: &quot;My extension&quot;, ... &quot;update_url&quot;: &quot;https://myhost.com/mytestextension/updates.xml&quot;, ...} 2.1.2. 更新清单服务器返回的更新清单应为 XML 文档。 123456&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;gupdate xmlns='http://www.google.com/update2/response' protocol='2.0'&gt; &lt;app appid='aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'&gt; &lt;updatecheck codebase='https://myhost.com/mytestextension/mte_v2.crx' version='2.0' /&gt; &lt;/app&gt;&lt;/gupdate&gt; 该 XML 格式借鉴了 Google 的更新基础架构 Omaha 所使用的格式。扩展程序系统会为更新清单的 &lt;app&gt; 和 &lt;updatecheck&gt; 元素使用以下属性： appid: 扩展程序 ID 根据公钥的哈希值生成，如打包中所述。扩展程序的 ID 会显示在“扩展程序管理”页面上 代码库: 指向 .crx 文件的 HTTPS 网址。 版本: 由客户端用于确定是否应下载 codebase 指定的 .crx 文件。它应与 .crx 文件的 manifest.json 文件中“version”的值一致。 更新清单可能会通过添加多个元素来包含有关多个扩展程序的信息。 3. troubleshooting问题 1: 当点击.crx 文件下载按钮时，报错”程序包无效：CRX_REQUIRED_PROOF_MISSING“ https://support.google.com/chrome/thread/7757612/what-does-crx-required-proof-missing-mean-when-trying-to-install-a-chrome-extension?hl=en 4. 参考文档在只有命令行界面的服务器上打包 Chrome 扩展 在 Linux 上安装扩展程序 crx is a utility to package Google Chrome extensions via a Node API Webpack Plugin for a chrome extension build","link":"/chrome/cli_build_chrome_extension.html"},{"title":"自己动手写一个Mysql到PostgreSQL数据库迁移工具","text":"1. 前言这段时间在进行 Mysql 到 PostgreSQL 数据库迁移工作. 主要包含三部分工作, 其一是构建数据库对象, 包括表, 视图, 存储过程的构建, 这部分由于我在项目早期就引入了 liquibase, 所以迁移工作很简单, 所以没有总结文章. 其二是代码修改, 让代码适配新的数据库, 这部分已经总结发布到了鹏叔的技术博客 - 从 Mariadb 迁移到 postgresql. 其三是数据迁移, 数据迁移也有一些现成的工具, 但是配置起来比较麻烦, 工具比想象中的复杂太多, 用起来也不是太顺手, 与其花时间在熟悉一次性的工具上, 不如自己写一个迁移工具. 于是就有了这篇文章. 2. 目标写一个通用的工具, 尽量是一键式完成数据迁移. 用户不需要提高太多信息, 最多提共源和目标数据库的信息, 确认需要迁移的表后自动完成数据迁移工作. 3. 思路 首先需要连接两个异构数据库. 然后从源数据库批量读出数据. 最后将其写入目标数据库. 尽量通过查询数据库的元数据创建查询和更新工作. 4. 实现4.1. 创建 gradle 项目使用 gradle 创建 java 或 springboot 项目结构, 如何创建 springboot 或 java 工程可以到我的博客空间查找. 这里只是列出简单的命令. 1gradle init 4.2. 引入依赖12runtimeOnly 'mysql:mysql-connector-java:5.1.37'runtimeOnly 'org.postgresql:postgresql:42.5.1' 4.3. 创建数据源这里使用 spring boot 管理. Config.java 1234567891011121314151617181920212223242526import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;@Configurationpublic class Config { @Bean @ConfigurationProperties(prefix = &quot;spring.target-db&quot;) public DataSource targetDatasource() { return DataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = &quot;spring.source-db&quot;) @Primary public DataSource sourceDataSource() { return DataSourceBuilder.create().build(); }} application.properties 12345678910111213#target dbspring.target-db.jdbcUrl=jdbc:postgresql://localhost:5432/testspring.target-db.username=postgresspring.target-db.password=passwordspring.target-db.driverClassName=org.postgresql.Driver#source dbspring.source-db.jdbcUrl=jdbc:mysql://localhost:3306/testspring.source-db.username=rootspring.source-db.password=passwordspring.source-db.driverClassName=com.mysql.jdbc.Driver 4.4. 抽象出迁移步骤首选获取表数据总数, 然后分批查询源数据库, 批量写入目标数据库. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.List;import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;abstract public class CommonMigration { private static Logger LOG = LoggerFactory.getLogger(CommonMigration.class); public void migrate() throws Exception { int totalRecords = getTotalRecords(); int stepLength = getStepLength(); LOG.info(&quot;start to migrate data from source db to target db&quot;); for (int offset = getInitialOffset(); offset &lt; totalRecords; offset = offset + stepLength) { List&lt;Map&lt;String, Object&gt;&gt; rows = queryForList(getQuerySql(), offset, stepLength); batchInsert(rows); LOG.info(&quot;moved {} records&quot;, offset); } } abstract protected List&lt;Map&lt;String, Object&gt;&gt; queryForList(String querySql, int offset, int stepLength); abstract protected String getQuerySql(); abstract protected void batchInsert(List&lt;Map&lt;String, Object&gt;&gt; collocMaps) throws Exception; protected int getStepLength() { return 100; } protected int getInitialOffset() { return 0; } abstract protected int getTotalRecords();} 4.5. 具体实现细节DataTableMigration.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.sql.SQLException;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.stream.Collectors;import java.util.stream.IntStream;import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.util.Assert;public class DataTableMigration extends CommonMigration { private final JdbcTemplate targetJdbc; private final JdbcTemplate sourceJdbc; private final String tableName; private final String primaryKey; private final String[] columnNamesInSourceDB; private final String[] columnNamesInTargetDB; private final Map&lt;String, String&gt; columnMappings; public DataTableMigration(DataSource sourceDataSource, String tableName, DataSource targetDataSource) throws SQLException { this(sourceDataSource, targetDataSource, tableName, new HashMap&lt;&gt;()); } public DataTableMigration(DataSource sourceDataSource, DataSource targetDataSource, String tableName, Map&lt;String, String&gt; columnMappings) throws SQLException { this.tableName = tableName.toLowerCase(); this.sourceJdbc = new JdbcTemplate(sourceDataSource); this.targetJdbc = new JdbcTemplate(targetDataSource); this.primaryKey = MigrationUtils.getPrimaryKeyByTableName(sourceDataSource.getConnection(), this.tableName); this.columnNamesInSourceDB = MigrationUtils.getColumnsByTableName(sourceDataSource.getConnection(), this.tableName); Assert.isTrue(this.columnNamesInSourceDB != null &amp;&amp; this.columnNamesInSourceDB.length &gt; 0, &quot;can't find column infor from source db for the table &quot; + this.tableName); this.columnNamesInTargetDB = MigrationUtils.getColumnsByTableName(targetDataSource.getConnection(), this.tableName); Assert.isTrue(this.columnNamesInTargetDB != null &amp;&amp; this.columnNamesInTargetDB.length &gt; 0, &quot;can't find column infor from target db for the table &quot; + this.tableName); this.columnMappings = columnMappings; } protected JdbcTemplate getSourceJdbc() { return this.sourceJdbc; } protected JdbcTemplate getTargetJdbc() { return this.targetJdbc; } @Override protected List&lt;Map&lt;String, Object&gt;&gt; queryForList(String querySql, int offset, int stepLength) { return getSourceJdbc().queryForList(querySql, offset, stepLength); } @Override protected void batchInsert(List&lt;Map&lt;String, Object&gt;&gt; rows) throws SQLException { getTargetJdbc().batchUpdate(getInsertSQL(), rows.stream().map(this::rowToParam) .collect(Collectors.toList())); } private Object[] rowToParam(Map&lt;String, Object&gt; row) { return Arrays.stream(columnNamesInTargetDB) .map(colInSource -&gt; columnMappings.getOrDefault(colInSource, colInSource)) .map(row::get) .toArray(); } protected String getInsertSQL() { return String.format(&quot;insert into %s (%s) values(%s)&quot;, this.tableName, String.join(&quot;,&quot;, columnNamesInTargetDB), IntStream.range(0, columnNamesInTargetDB.length) .mapToObj(n -&gt; &quot;?&quot;) .collect(Collectors.joining(&quot;,&quot;))); } @Override protected String getQuerySql() { return String.format(&quot;select %s&quot; + &quot; from %s&quot; + &quot; order by %s asc &quot; + &quot; limit ?, ?&quot;, String.join(&quot;,&quot;, columnNamesInSourceDB), this.tableName, this.primaryKey); } @Override protected int getStepLength() { return 100; } @Override protected int getTotalRecords() { int count = getSourceJdbc().queryForObject( &quot;select count(1) from &quot; + tableName, Integer.class); return count; }} 所使用的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;public class MigrationUtils { public static String getPrimaryKeyByTableName(Connection conn, String tableNamePattern) throws SQLException { DatabaseMetaData dbMetaData = conn.getMetaData(); ResultSet tabs = dbMetaData.getTables(null, null, tableNamePattern, new String[] { &quot;TABLE&quot; }); List&lt;String&gt; pkColList = new ArrayList&lt;&gt;(); while (tabs.next()) { ResultSet resultSet = dbMetaData.getPrimaryKeys(null, tabs.getString(&quot;TABLE_SCHEM&quot;), tabs.getString(&quot;TABLE_NAME&quot;)); while (resultSet.next()) { pkColList.add(resultSet.getString(&quot;COLUMN_NAME&quot;)); } } return pkColList.stream().collect(Collectors.joining(&quot;,&quot;)); } public static String[] getColumnsByTableName(Connection conn, String tableNamePattern) throws SQLException { DatabaseMetaData dbMetaData = conn.getMetaData(); ResultSet tabs = dbMetaData.getTables(null, null, tableNamePattern, new String[] { &quot;TABLE&quot; }); List&lt;String&gt; columnList = new ArrayList&lt;&gt;(); while (tabs.next()) { ResultSet resultSet = dbMetaData.getColumns(null, tabs.getString(&quot;TABLE_SCHEM&quot;), tabs.getString(&quot;TABLE_NAME&quot;), null); while (resultSet.next()) { columnList.add(resultSet.getString(&quot;COLUMN_NAME&quot;)); } } return columnList.toArray(new String[columnList.size()]); }} main 方法, 这里的数据库表, 可以通过 DatabaseMetaData 全部获取, 但是数据迁移项目需求各不相同, 可以加以改进适配到自己的项目中. 程序运行有两个前提,一目标数据库表是空的, 否则会有主键冲突的状况.二,数据库表各字段的名和类型需要一致程序在 mysql 和 postgreSQL 之间进行了有限测试, 代码拿走不谢, 但是测试需要自己完成, 有问题欢迎反馈. 123456789public static void main(String[] args) { new DataTableMigration(sourceDataSource, &quot;TABLE1&quot;, targetDataSource).migrate(); new DataTableMigration(sourceDataSource, &quot;TABLE2&quot;, targetDataSource).migrate(); new DataTableMigration(sourceDataSource, &quot;TABLE3&quot;, targetDataSource).migrate(); new DataTableMigration(sourceDataSource, &quot;TABLE4&quot;, targetDataSource).migrate(); new DataTableMigration(sourceDataSource, &quot;TABLE5&quot;, targetDataSource).migrate(); } 5. 后记写完这部分数据迁移工具后, 发现数据库结构的迁移也是可用通过通用代码来完成的, 目前忙于赶项目进度. 如果忙完手头的工作, 再来补充数据库表结构的迁移工作. 6. 参考文档Java DatabaseMetaData getPrimaryKeys()方法与示例 liquibase 的 changelog 详解","link":"/database/db_migrations.html"},{"title":"Centos7上安装MariaDB","text":"1. 安装1.1. 检查是否已安装 mariadb1yum list installed | grep mariadb 1.2. 安装MariaDB如果未安装，执行以下命令安装命令 1yum -y install mariadb mariadb-server 1.3. 安装完成MariaDB，首先启动MariaDB1systemctl start mariadb 1.4. 设置开机启动1systemctl enable mariadb 2. 配置2.1. 修改配置授权远程访问1234vi /etc/my.cnfbind-address = &lt;some ip-address&gt; 2.2. 创建远程访问用户，并授予访问权限1234567CREATE USER 'user1'@'internet_ip' IDENTIFIED BY 'the_password';GRANT ALL ON *.* TO 'user1'@'internet_ip';--or reset password if user existsSET PASSWORD FOR 'user1'@'localhost' = PASSWORD('the_password'); 2.3. 设置中文字符集12345678910111213141516171819202122vi /etc/my.cnf.d/mariadb-server.cnf在[mysqld]标签下添加#characterinit_connect='SET collation_connection = utf8mb4_unicode_ci'init_connect='SET NAMES utf8mb4'character-set-server=utf8mb4collation-server=utf8mb4_unicode_ciskip-character-set-client-handshakevi /etc/my.cnf.d/client.cnf在[client]下添加#characterdefault-character-set=utf8mb4vi /etc/my.cnf.d/mysql-clients.cnf在[mysql]中添加#characterdefault-character-set=utf8mb4 2.4. 重启mariadb服务，使配置生效1systemctl restart mariadb 2.5. 查看版本123456789101112131415161718192021MariaDB [(none)]&gt; \\s--------------mysql Ver 15.1 Distrib 5.5.68-MariaDB, for Linux (x86_64) using readline 5.1Connection id: 3Current database:Current user: root@localhostSSL: Not in useCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server: MariaDBServer version: 5.5.68-MariaDB MariaDB ServerProtocol version: 10Connection: Localhost via UNIX socketServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8mb4Conn. characterset: utf8mb4UNIX socket: /var/lib/mysql/mysql.sockUptime: 1 day 20 hours 48 min 13 sec 2.6. 查看字符集是否生效123456789101112131415161718mysql&gt; show variables like 'character%'; MariaDB [(none)]&gt; show variables like 'character%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+log for trouble shooting/var/log/mariadb/mariadb.log 2.7. 设置数据库对大小写不敏感进入 /etc/my.cnf.d ，编辑server.cnf 123vi /etc/my.cnf.d/server.cnf在[mysqld]下添加lower_case_table_names = 1 3. 参考文档https://www.cnblogs.com/zhanzhan/p/7729981.html https://blog.csdn.net/qq_35440040/article/details/86084909","link":"/database/install_mariadb_on_centos7.html"},{"title":"在Linux（AlmaLinux 9）上安装MariaDB","text":"当 MariaDB Server 的前身 MySQL 于 2009 年被 Oracle 收购时，MySQL 创始人 Michael “Monty” Widenius 出于对 Oracle 管理权的担忧而分叉了该项目，并将新项目命名为 MariaDB。 MySQL 以他的第一个女儿 My 命名，而 MariaDB 则以他的第二个女儿 Maria 命名。 在 MariaDB 5.5 之前，MariaDB Server 遵循 MySQL 版本编号模式，旨在与 MySQL 的同一主要版本兼容。 2012 年，为了反映 MySQL 中不可用的功能越来越多，MariaDB Server 的版本编号出现了分歧，MariaDB 发布了 10.0，而 MySQL 发布了 5.6。 当前的长期支持版本是 MariaDB 10.6，而最新的稳定短期支持版本是 MariaDB 10.9。 MariaDB Server 仍然保持与 MySQL 的高度兼容性，并且大多数使用 MySQL 的流行应用程序将与 MariaDB 无缝协作。 MariaDB Server 非常强调不破坏其用户的向后兼容性。 就地升级支持从旧的 MySQL 版本升级到最新的 MariaDB 版本。 MariaDB Server 提供了一种 Oracle 语法兼容模式，无需更改即可运行 Oracle 数据库应用程序。 1. 安装1.1. 检查是否已安装 mariadb1dnf list installed | grep -i mariadb 2. 更新 DNF 存储库缓存1sudo dnf update 2.1. 安装 MariaDB如果未安装，执行以下命令安装命令 1sudo dnf -y install mariadb mariadb-server 说明： 这里的 -y 表示 yes, 它会自动接受所有默认选项，减少与用户交互，这在自动化脚本中非常有用。 Maria 是 mysql 的一个分支，它在 mysql 的基础上进行了改进和增强，以提供更好的性能、安全性和可靠性。mariadb-server 是 MariaDB 的服务器软件包，它包含了 MariaDB 数据库服务器及其相关的工具、库和配置文件。在安装 MariaDB 时，通常需要安装 mariadb-server 软件包，这样才能启动 MariaDB 服务器，并且使用 MariaDB 数据库。因此，mariadb-server 是 MariaDB 的一个重要组成部分。 安装前可以使用 dnf search mariadb 和 dnf info mariabd 查看 rpm repo list 是否包含了 maridb 以及确认版本是否是合适 2.2. 启动 MariaDB 并设置为开机启动1sudo systemctl enable --now mariadb 3. 配置3.1. 修改配置授权远程访问1234sudo vi /etc/my.cnf.d/mariadb-server.cnfbind-address = &lt;some ip-address&gt; 3.2. 增强 MariaDB的安全性默认情况下，新安装的 mariadb 的密码为空，在shell终端直接输入 mysql 就能登陆数据库。 如果是刚安装第一次使用，请使用 mysql_secure_installation 命令初始化 MariaDB 安装默认不安全。安装数据库软件后，运行以下命令来保护您的 MariaDB 服务器。此命令将启动一系列安全配置，以增强对 MariaDB 安装的保护： 为root用户设置密码 删除匿名（anonymous）用户 设置不允许远程root用户登陆 删除测试用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263$ sudo mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we'll need the currentpassword for the root user. If you've just installed MariaDB, andhaven't set the root password yet, you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password or using the unix_socket ensures that nobodycan log into the MariaDB root user without the proper authorisation.You already have your root account protected, so you can safely answer 'n'.Switch to unix_socket authentication [Y/n] n ... skipping.You already have your root account protected, so you can safely answer 'n'.Change the root password? [Y/n] n ... skipping.By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y ... Success!Normally, root should only be allowed to connect from 'localhost'. Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y ... Success!By default, MariaDB comes with a database named 'test' that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y ... Success!Cleaning up...All done! If you've completed all of the above steps, your MariaDBinstallation should now be secure.Thanks for using MariaDB! 3.3. 创建远程访问用户，并授予访问权限123sudo mysql 12345678CREATE USER 'user1'@'internet_ip' IDENTIFIED BY 'the_password';GRANT ALL ON *.* TO 'user1'@'internet_ip'; -- e.g. GRANT ALL ON *.* TO 'user1'@'localhost'; --or reset password if user existsSET PASSWORD FOR 'user1'@'localhost' = PASSWORD('the_password'); 3.4. 设置中文字符集12345678910111213141516171819202122vi /etc/my.cnf.d/mariadb-server.cnf在[mysqld]标签下添加#characterinit_connect='SET collation_connection = utf8mb4_unicode_ci'init_connect='SET NAMES utf8mb4'character-set-server=utf8mb4collation-server=utf8mb4_unicode_ciskip-character-set-client-handshakevi /etc/my.cnf.d/client.cnf在[client]下添加#characterdefault-character-set=utf8mb4vi /etc/my.cnf.d/mysql-clients.cnf在[mysql]中添加#characterdefault-character-set=utf8mb4 3.5. 重启 mariadb 服务，使配置生效1sudo systemctl restart mariadb 3.6. 查看版本1sudo mysql 12345678910111213141516171819202122232425MariaDB [(none)]&gt; \\s--------------mysql Ver 15.1 Distrib 10.5.22-MariaDB, for Linux (x86_64) using EditLine wrapperConnection id: 8Current database:Current user: root@localhostSSL: Not in useCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server: MariaDBServer version: 10.5.22-MariaDB MariaDB ServerProtocol version: 10Connection: Localhost via UNIX socketServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8mb4Conn. characterset: utf8mb4UNIX socket: /var/lib/mysql/mysql.sockUptime: 7 min 27 secThreads: 1 Questions: 13 Slow queries: 0 Opens: 17 Open tables: 10 Queries per second avg: 0.029-------------- 3.7. 查看字符集是否生效1234567891011121314151617mysql&gt; show variables like 'character%';MariaDB [(none)]&gt; show variables like 'character%';+--------------------------+------------------------------+| Variable_name | Value |+--------------------------+------------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | /usr/share/mariadb/charsets/ |+--------------------------+------------------------------+8 rows in set (0.001 sec) 3.8. 设置数据库对大小写不敏感进入 /etc/my.cnf.d ，编辑 mariadb-server.cnf 123sudo vi /etc/my.cnf.d/mariadb-server.cnf在[mysqld]下添加lower_case_table_names=1 重启让配置生效 1sudo systemctl restart mariadb 4. 参考文档Centos7上安装MariaDB","link":"/database/install_mariadb_on_linux.html"},{"title":"Linux上安裝pgadmin","text":"本文讲述在Fedora或Redhat系列操作系统上如何安装pgadmin。 要安装前，请首先卸载您可能已经安装的任何pgAdmin repo软件包， 以保持一个干净的环境 12345# for fedorasudo rpm -e pgadmin4-fedora-repo# 或者 # for Rocky, Redhat or CentOSsudo rpm -e pgadmin4-redhat-repo 1. 设置软件仓库on Fedora run: 123sudo rpm -i https://ftp.postgresql.org/pub/pgadmin/pgadmin4/yum/pgadmin4-fedora-repo-2-1.noarch.rpm or on Rocky, Redhat or CentOS, run: 1sudo rpm -i https://ftp.postgresql.org/pub/pgadmin/pgadmin4/yum/pgadmin4-redhat-repo-2-1.noarch.rpm 2. 安装pgadmin4要安装pgAdmin，请运行以下命令之一： 12345678# Install for both desktop and web modes.sudo dnf install -y pgadmin4# Install for desktop mode only.sudo dnf install -y pgadmin4-desktop# Install for web mode only.sudo dnf install -y pgadmin4-web 3. 配置pgadmin4最后，如果您已经安装了pgadmin4或pgadmin4web，请运行web设置脚本，将系统配置为在web模式下运行: 123sudo /usr/pgadmin4/bin/setup-web.sh 系统会提示您创建pgadmin管理员帐号并询问是否要启动pgadmin server, 选择是，系统会自动启动pgadmin server. 4. 使用如何使用pgadmin web？ 在浏览器打开http://127.0.0.1/pgadmin4/ 即可。输入上一歩创建的用户名和密码即可访问。 如何使用pgadmin desktop? 在应用程序列表中找到pgadmin单击打开即可。 5. troubleshooting下载安装包速度非常慢， 考虑切换成国内的yum mirror 例如在Fedora 下 使用阿里云镜像 12345678910# 备份sudo mv /etc/yum.repos.d/fedora.repo /etc/yum.repos.d/fedora.repo.backupsudo mv /etc/yum.repos.d/fedora-updates.repo /etc/yum.repos.d/fedora-updates.repo.backup## 下载新的 fedora.repo 和 fedora-updates.repo 到 /etc/yum.repos.d/sudo wget -O /etc/yum.repos.d/fedora.repo http://mirrors.aliyun.com/repo/fedora.reposudo wget -O /etc/yum.repos.d/fedora-updates.repo http://mirrors.aliyun.com/repo/fedora-updates.repo## 运行sudo yum makecache生成缓存sudo yum makecache 6. 参考文档pgAdmin 4 (RPM) fedora镜像","link":"/database/install_pgadmin_on_fedora.html"},{"title":"Linux上安装PostgreSQL","text":"1. 前言本文以PostgreSQL 15 为例讲解如何在linux上安装PostgreSQL。 1.1. 本文主要内容 PostgreSQL 15 安装(yum) PostgreSQL 15 基础配置 PostgreSQL 15 远程访问配置 PostgreSQL 基础管理 1.2. 本文环境信息与适用范围适用范围 OS: Centos 7 or Fedora 39PostgreSQl 15 2. PostgreSQL安装2.1. 导入yum源123456# Install the repository RPM:sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm# fedora 39sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/F-39-x86_64/pgdg-fedora-repo-latest.noarch.rpm# fedora 40sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/F-40-x86_64/pgdg-fedora-repo-latest.noarch.rpm 2.2. 安装PostgreSQL服务12# Install PostgreSQL:sudo dnf install -y postgresql15-server 2.3. 初始化数据库12# Optionally initialize the database:sudo /usr/pgsql-15/bin/postgresql-15-setup initdb 2.4. 启动PostgreSQL服务12345# 设置PostgreSQL服务为开机启动, 并立即启动postgresql服务sudo systemctl enable --now postgresql-15# 查看postgresql的状态systemctl status postgresql-15 3. 修改postgres账号密码PostgreSQL安装成功之后，会默认创建一个名为postgres的Linux用户，初始化数据库后，会有名为postgres的数据库，来存储数据库的基础信息，例如用户信息等等，相当于MySQL中默认的名为mysql数据库。 postgres数据库中会初始化一名超级用户postgres 为了方便我们使用postgres账号进行管理，我们可以修改该账号的密码 3.1. 如何修改postgres账号密码进入PostgreSQL命令行 通过su命令切换linux用户为postgres会自动进入命令行 12sudo bashsu - postgres 启动SQL Shell 1psql 修改密码 1ALTER USER postgres WITH PASSWORD 'NewPassword'; 4. 配置远程访问4.1. 开放端口12345678910# 检查防火墙是否开启sudo firewall-cmd --state# 显示默认区域的所有规则sudo firewall-cmd --list-all# 如果开启, 需放行5432端口sudo firewall-cmd --add-port=5432/tcp --permanentsudo firewall-cmd --reload 4.2. 修改IP绑定123456#修改配置文件sudo vi /var/lib/pgsql/15/data/postgresql.conf#将监听地址修改为*#默认listen_addresses配置是注释掉的，所以可以直接在配置文件开头加入该行listen_addresses='*' 4.3. 允许所有IP访问12345678#修改配置文件sudo vi /var/lib/pgsql/15/data/pg_hba.conf#在问号尾部加入host all all 0.0.0.0/0 md5# 或者只允许局域网内的用户访问host all all 192.168.1.0/24 md5 配置环境变量1234sudo vi /etc/profile.d/postgresql.sh# 修改pathexport PATH=$PATH:/usr/pgsql-15/bin/ 4.4. 重启PostgreSQL服务12#重启PostgreSQL服务sudo systemctl restart postgresql-15 配置完成后即可使用客户端进行连接 5. PostgreSQL 基础管理启动SQL shell： 12su postgrespsql 数据库相关语法示例 1234567891011121314#创建数据库CREATE DATABASE mydb;#查看所有数据库\\l#切换当前数据库\\c mydb#创建表CREATE TABLE test(id int,body varchar(100));#查看当前数据库下所有表\\d 用户与访问授权语法示例 12345678910#新建用户CREATE USER test WITH PASSWORD 'test';#赋予指定账户指定数据库所有权限GRANT ALL PRIVILEGES ON DATABASE mydb TO test;#移除指定账户指定数据库所有权限REVOKE ALL PRIVILEGES ON DATABASE mydb TO test 权限代码：SELECT、INSERT、UPDATE、DELETE、TRUNCATE、REFERENCES、TRIGGER、CREATE、CONNECT、TEMPORARY、EXECUTE、USAGE 6. 如何卸载postgreSQL123456789101112131415## 停止服务sudo systemctl stop postgresql-15## 删除服务sudo systemctl disable postgresql-15## 卸载软件sudo dnf remove postgresql15-server postgresql15-libs; sudo dnf autoremove ; sudo dnf clean packages## 清除数据sudo rm -rf /usr/pgsql-15/sudo rm -rf /var/lib/pgsql/15 如果要再次重装postgresql,需要将/var/lib/pgsql下的数据备份，然后删除/var/lib/pgsql目录 7. 问题排查 日志文件的位置postgresql-15在REHL系列服务器的位置为/var/lib/pgsql/15/data/log 查看服务状态 1systemctl status postgresql-15 查看系统日志 1journalctl -u postgresql-15 8. 参考文档在CentOS 7上安装&amp;配置PostgreSQL 12 Linux downloads (Red Hat family)","link":"/database/install_postgresql_on_linux.html"},{"title":"Windows上安装PostgreSQL 14","text":"本文主要讲述如何在Windows上安装PostgreSQL 14。 安装步骤 双击打开安装向导,点击下一步 修改Installation directory或者使用默认安装位置 选择需要安装的组件, 默认全选, 初学者可以使用默认配置, 有经验的用户可以根据自己的需求选择要安装的组件 Postgresql Server pgAdmin: Postgresql 客户端工具 Stack builder Command line Tools: 命令行工具 选择数据存储目录 设置超级管理员密码 设置端口, 可使用默认端口5432 选择locale, 可以使用默认locale 安装程序将会提示安装信息 1234567891011Installation Directory: C:\\Program Files\\PostgreSQL\\14Server Installation Directory: C:\\Program Files\\PostgreSQL\\14Data Directory: C:\\Program Files\\PostgreSQL\\14\\dataDatabase Port: 5432Database Superuser: postgresOperating System Account: NT AUTHORITY\\NetworkServiceDatabase Service: postgresql-x64-14Command Line Tools Installation Directory: C:\\Program Files\\PostgreSQL\\14pgAdmin4 Installation Directory: C:\\Program Files\\PostgreSQL\\14\\pgAdmin 4Stack Builder Installation Directory: C:\\Program Files\\PostgreSQL\\14Installation Log: C:\\Users\\xxxx\\AppData\\Local\\Temp\\install-postgresql.log 点击下一步, 直到安装完成 开启或关闭postgreSQL服务可以在windows服务管理界面, 将PostgreSQL服务设置为手动启动, 自动启动, 或关闭.","link":"/database/install_postgresql_on_windows.html"},{"title":"从Mariadb迁移到postgresql","text":"1. 前言本文主要实验所用的环境, 后端是golang, gin web框架. mysql driver: 1github.com/go-sql-driver/mysql v1.4.1 迁移后PostgreSQL driver: 1github.com/jackc/pgx/v5 v5.1.1 迁移前服务器版本为:mariadb 版本为5.5.68-MariaDB 123mysql Ver 15.1 Distrib 5.5.68-MariaDB, for Linux (x86_64) using readline 5.1 2. 两者之间的差异 连接字符串不一样 mariadb: 12# dataSourceNameusername:******@TCP(localhost:3306)/test?charset=utf8mb4 打开mysql连接: 1sql.Open(&quot;mysql&quot;, dataSourceName) postgresql: 12# dataSourceNamepostgres://eagle:****@localhost:5432/test 打开PostgreSQL连接: 1sql.Open(&quot;pgx&quot;, dataSourceName) sql参数语法不一样 mysql的sql参数占位符是? 而PostgreSQL的sql参数占位符是$1,$2,$3..... 一些函数不一样 函数 MySQL 等价的PostgreSQL函数 随机函数 Rand() Random() 当前日期 curdate() current_date 当前时间without timezone CURTIME() LOCALTIMESTAMP 日期的加减 curdate() + INTERVAL 1 DAY current_date + INTERVAL ‘1 DAY’ 空值替换 IFNULL() COALESCE() 日期格式化 DATE_FORMAT(MEMO_DATE,”%Y%m%d”) TO_CHAR(CURRENT_DATE, ‘yyyyMMDD’) 对bool值的处理不同 PostgreSQL对数值处理更加严谨 mysql 可以将整数0 作为bool值false插入数据库, 而postgresql不行, 必须为bool值FALSE 或FALSE才能被作为bool值. 处理Blob类型数据的方式不一样 PostgreSQL有两种Blob类型, 一种是OID(Object identifiers), 一种是bytea, 而Bytea类型更接近Mysql数据库中的BLOB. OID字段 只保存了对象的4位的identifier(an unsigned four-byte integer), 具体内容存储在Postgresql的Large_object内部表中, 用户只能通过Postgresql提供的函数或者驱动提供的API才能读取, 通过identifier获取具体的内容. 当然这样的设计有它的好处, 即不用在查询表时将大块的数据加载到内存, 而是在实际需要时再通过identifier去取回数据. 既能保证数据的完整性, 又能获得将数据保存在数据库外部同样的优势,同时能获得数据库提供的操纵binary data的函数, 无疑是一种比较先进的理念. 比较无奈database/sql也就是标准库, 对这种模式支持不够好, 目前没有提供标准的操作类似于PostgreSQL OID的接口, 要使用OID类型的数据, 还必须依赖与具体的驱动程序. insert 语句 Mysql 支持“insert into” 和 “insert”, 而postgreSQL只支持”insert into”， 例如以下语句在postgreSQl会报语法错误， 而mysql不会。 12345678-- postgreSQl会报语法错误insert book_items(USER_ID, BOOK_ID, WORD_ID)values(1, 2, 100 )-- postgreSQl 中正确胡写法是insert into book_items(USER_ID, BOOK_ID, WORD_ID)values(1, 2, 100 ) postgresql 字段名和表名大小写 PostgreSQL对表名、字段名都是区分大小写的。但是，PostgreSQL在SQL语句中对大小写是不敏感的，在不加双引号的情况下，创建时无论使用大写还是小写，表中都会统一转为小写显示的，因此查询时也会将语句中的字段名统一改成小写，因此，此时使用大小写查询均可。 用SQL语句的时候需要加双引号，或者转义符号。如果要创建名称为大写字母的字段名，需加双引号，此时表中的字段名不含双引号，但是查询时需加上双引号，执行时语句中的双引号将被抹去，因此能查出对应字段。 查询执行时，只会发生字段”双引号被抹去”和“大写转小写”中其中一个，优先发生”双引号被抹去”。 postgreSQL limit 语法 postgreSQL 不支持 limit 10, 20 这种语法, 需要替换为 limit 20 offset 10","link":"/database/migrate_to_postgressql_from_mariadb.html"},{"title":"PostgreSQL高级篇","text":"1. PG简介PostgreSQL是一个免费的对象-关系型数据库服务器(ORDBMS), 在灵活的BSD许可证下发行.PostgreSQL开发者把它念作post-gress-Q-L.PostgreSQL的Slogan是世界上最先进的开源关系型数据库.开源界的Oracle, 去O首选 PostgreSQL官网https://www.postgresssql.org/ PostgreSQL中文社区https://www.postgres.cn/v2/home 中国数据库流行度排行https://www.modb.pro/dbRank 全球数据库流行度趋势https://db-engines.com/en/ranking 1.1. PG的历史PostgreSQl最初设想于1986年, 当时被叫做Barkley Postgre Project. 该项目一直到1994年都处于演讲和修改中, 直到开发人员Andrew Yu和Jolly Chen在Postgres中添加了一个SQL(Structured Query Language, 结构化查询语言)翻译程序, 该版本叫做Postgre95, 在开放源代码社区发放. 开始以社区的形式运作. 1996年, 再次对Postgre95做了较大的改动, 并将其作为PostgreSQL6.0版本发布. 该版本的Postgre提高了后端的速度, 包括增强型SQL92标准以及重要的后端特性(包括子选择, 默认值, 约束和触发器) 2005年, 发布8.0版本, 开始支持Windows系统环境 PostgreSQL 9.0: 支持64位Windows系统, 异步流数据复制, Hot Standby; PostgreSQL 9.1: 支持数据同步复制, unlogged tables, serializable snapshot isolation, FDW外部表. 此版本后, PostgreSQL开始得到中国多个行业用户的关注, 开始有应用于电信, 保险, 制造业等边缘系统. 目前生产环境主流的版本是PostgreSQL 12 2021-09-30, PostgreSQL全球开发组宣布, 功能更为强大的开源数据库, PostgreSQL 14版本正式发布! 1.2. PG的社区PG为什么没有被商业公司控制? 纯社区 Sponsor 占比: 服务| Daas提供商: 29% 最终用户: 37% 数据库厂商: 21% 云厂商 最终用户深度参与, 使得PG社区像滚雪球越滚越大. AWS -&gt; bigsqlMS -&gt; citusIBM -&gt; redhat sponsors: Pivotal, 2ndQuadrant, Rackspace, NTTGroup, VMWare, Zalando,Crunchy Data, DALIBO, meetme, CONOVA, EDB, Google, data egret,PGX, Postgres, Yandex, IBM, Fujitsu, Redpill, Amazone. 他们为什么要贡献核心代码? 最终用户 希望社区长久, 期望可以享受免费, 可持续发展的, 开源的, 不被任何商业公司, 不被任何国家控制的企业级数据库. 去O, 去DB2, 去Sybase; 不靠数据库赚钱; PG用到的人越多, 越多人背书, 使用越靠谱(事实也是如此); 抛砖引玉, 企业投入两个研发持续贡献(一年可能一两百万), 实际上整个PG社区有数千人在共享, 对最终用户来说, 简直是赚到了. 使用商业数据库, 除了License等成本, 依旧需要投管理, 研发, 外包资源, 一年数千万甚至上亿, 公司越大, 越有动力去贡献社区. 从趋势来看, 给PG贡献代码的大客户只会越来越多; 云厂商 开源数据库与厂商发生利益冲突, 纷纷改协议; 数据库市场巨大; 自研是最佳选择, 但是自研有一些问题: 譬如需要培养生态, 需要市场背书, 需要大量研发资源, 可能需要重复造轮子; BASE PG的好处: 免去自己培养生态, 避免重复造轮子, PG的代码基础非常不错(开源界的Oracle) 防止其他厂商控制PG失去市场主导能力(AWS, Google, IBM, 微软都已经成为PG社区的赞助商) 数据库厂商 推一款新的商业数据库, 通常都需要背书, 小厂产品, 谁为你背书? 有技术的厂商, 很难挑战已有的数据库市场格局 有渠道的厂商, 需要抓住窗口期, 快速占领市场, 避免重复造轮子. 需要一款可以无法律风险, 二次分发的开源数据库, 唯有PG. 可以贡献核心代码, 社区所有的用户都可以为之背书. 数据库服务|Daas服务提高商 开源产品的服务提供商, 能力如何体现? 当然是你的架构能力, 优化能力, 管理能力, FIX BUG的能力 最好能贡献核心代码, 有PG为你背书 主要贡献者列表: https://www.postgresql.org/community/contributors 全球赞助商 https://www.postgresql.org/about/sponsors PostgreSQL中文BBS https://bbs.pgsqldb.com/client/index.php PosgreSQL用户 https://www.postgresql.org/about/users 1.3. PostgreSQL许可证1.4. PostgreSQL与MySQL的比较PostgreSQL相对于MySQL的优势 在SQL的标准实现上要比MySQL完善, 而且功能实现比较严谨. 对表连接支持较完整, 优化器的功能完善, 支持的索引类型很多, 复杂查询能力较强. PG主表采用堆表存放, MySQL采用索引组织表, 能够支持比MySQL更大的数据量. PG的主设备复制属于物理复制, 相对于MySQL基于binlog的逻辑复制, 数据的一致性更加可靠, 复制性能更高, 对主机性能的影响也更小. PostgreSQL支持JSON和其他NoSQL功能, 如本机XML支持和使用HSTORE的键值对. 它还支持索引JSON数据以加快访问速度, 特别是10版本JSONB更是强大. PostgreSQL完全免费, 而且是BSD协议, 如果你把PostgreSQL改一改, 然后再拿去卖钱, 也没有人管你, 这一点很重要, 这表明了PostgreSQL数据库不会被其它公司控制. 相反, MySQL现在主要是被Oracle公司控制. MySQL相对于PG的优势 innodb的基于回滚段实现的MVCC机制, 相对PG新老数据一起存放的基于XID的MVCC机制, 是占优势的. 新老数据一起存放, 需要定时触发VACUUM, 会带来多余的IO和数据库对象加锁开销, 引起数据库整体的并发能力下降. 而且VACUUM清理不及时, 还可能引发数据膨胀. MySQL采用索引组织表, 这种存储方式非常适合基于主键匹配的查询, 删改操作, 但是对表结构设计存在约束. MySQL的优化器比较简单, 系统表, 运算符, 数据类型的实现很精简, 非常适合简单的查询操作. MySQL相对于PG在国内的流行度更高, PG在国内显得就有些落寞了. MySQL的存储引擎插件化机制, 使得它的应用场景更加广泛, 比如除了innodb适合事务处理场景外, myisam适合静态数据的查询场景. 总结: 从应用场景来看, PG更加适合严格的企业应用场景(比如金融, 电信, ERP, CRM), 但不仅仅限制于此, PostgreSQL的json, jsonb, hstore等数据格式, 特别适用于一些大数据格式的分析; 而MySQL更适合业务逻辑相对简单, 数据可靠性要求较低的互联网场景(比如facebook, google, alibaba), 当然现在MySQL引擎的大力发展, 功能表现良好. 2. 安装PostgreSQLWindows安装教程可参考: https://pengtech.net/database/install_postgresql_on_windows.htmlLinux安装教程可参考: Centos7上安装PostgreSQL 14 3. PostgreSQL的基本使用3.1. 登录12345678910# psql -h 服务器 -U 用户名 -d 数据库 -p 端口地址 psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432$ psql (连接数据库, 默认用户和数据库都是postgres)# 相对于系统用户postgres以同名数据库用户的身份, 登录数据库, 这是不用输入密码的.# 如果一切正常, 系统提示符会变成&quot;postgres=#&quot;. 表示这时已经进入数据库控制台. 3.2. 创建数据库创建一个叫exampleDB的数据库 123createdb -h localhost -p 5432 -U postgres exampleDB 4. 参考文章数据库流行度排名","link":"/database/postgresql_advanced.html"},{"title":"PostgreSQL备份与恢复","text":"1. 前言数据库的备份有多种分类方式。 按照备份后的文件类型，可以分为物理备份（文件系统级别的备份）和逻辑备份（备份后的文件是sql文件或特定格式的导出文件）； 按照备份过程中是否停止数据库服务，可分为冷备份（备份过程中停止数据库服务）和热备份（备份过程中数据库服务开启并可供用户访问）； 按照备份是否是完整的数据库，可分为全量备份(备份是完整的数据库)和增量备份（备份是上一次全量备份后数据库改变的内容）。 Postgresql的常见备份方式有以下三种：文件系统级别的冷备份, SQL转储, 连续归档. 2. Postgresql的常见备份方式Postgresql常见的备份方式主要有三种: 1. 文件系统级别的冷备份, 2. SQL转储 3. 连续归档 2.1. 文件系统级别的冷备份这种备份方式需要关闭数据库，然后拷贝数据文件的完整目录。恢复数据库时，只需将数据目录复制到原来的位置。该方式实际工作中很少使用。 2.2. SQL转储这里我们用到的工具是pg_dump和pg_dumpall。 这种方式可以在数据库正在使用的时候进行完整一致的备份，并不阻塞其它用户对数据库的访问。它会产生一个脚本文件，里面包含备份开始时，已创建的各种数据库对象的SQL语句和每个表中的数据。可以使用数据库提供的工具pg_dumpall和pg_dump来进行备份。pg_dump只备份数据库集群中的某个数据库的数据，它不会导出角色和表空间相关的信息，因为这些信息是整个数据库集群共用的，不属于某个单独的数据库。pg_dumpall，对集簇中的每个数据库调用pg_dump来完成该工作,还会还转储对所有数据库公用的全局对象（pg_dump不保存这些对象）。 目前这包括适数据库用户和组、表空间以及适合所有数据库的访问权限等属性。 例如，在我的计算机上，可使用如下命令对名为dbname的数据库进行备份： 12345678910111213141516171819202122232425262728pg_dump -h 127.0.0.1 -p 5432 -U postgres -d dbname -c -C -f dbname_`date &quot;+%Y%m%d%H%M%S&quot;`.sql-c--clean 输出在创建数据库创建命令之前先清理（删除）该数据库对象的命令。 这个选项只是对纯文本格式有意义。对于归档格式，你可以在调用 pg_restore 的时候声明选项。-C--create 以一条创建该数据库本身并且与这个数据库联接等命令开头进行输出。（如果是这种形式的脚本，那么你在运行脚本之前和哪个数据库联接就不重要了。） 这个选项只对纯文本格式有意义。对于归档格式，你可以在调用 pg_restore 的时候声明该选项。-f file--file=file 把输出发往指定的文件。如果忽略这些，则使用标准输出。联接参数-h host--host=host 声明运行服务器的机器的主机名。如果数值以斜杠开头，则它被用做到 Unix 域套接字 的路径。缺省是从 PGHOST 环境变量中取得的，如果设置了这个环境变量的话，否则，尝试 一个 Unix 域套接字连接。-p port--port=port 声明服务器正在侦听并等待联接的 TCP 端口或本地 Unix 主控套接字文件句柄。缺省时使用环境变量 PGPORT 的值（如果存在），或者是编译时的缺省值。-U username 以给出用户身分联接 使用如下命令可对全部pg数据库进行备份。 123 pg_dumpall -h 127.0.0.1 -p 5432 -U postgres -c -C -f db_bak_`date &quot;+%Y%m%d%H%M%S&quot;`.sql 需要连续多次输入密码， 等待备份完成，等等时间取决于数据量。 恢复方式很简单。执行恢复命令即可： 12# 普通用户权限即可 psql -h 127.0.0.1 -p 5432 -U postgres -f db_bak.sql 提示：备份后建议压缩数据以减少占用空间gzip db_bak_YYYYMMDDHHMISS.sql并转存到不同设备，保存多份备份rsync -avz --progress user_name@remote_host:/path_to_backup/db__bak_YYYYMMDDHHMISS.sql.gz /path_to_restore 2.3. 连续归档这种方式的策略是把一个文件系统级别的全量备份和WAL(预写式日志)级别的增量备份结合起来。当需要恢复时，我们先恢复文件系统级别的备份，然后重放备份的WAL文件，把系统恢复到之前的某个状态。这种备份有显著的优点： 不需要一个完美的一致的文件系统备份作为开始点。备份中的任何内部不一致性将通过日志重放来修正。可以结合一个无穷长的WAL文件序列用于重放，可以通过简单地归档WAL文件来达到连续备份。不需要重放WAL项一直到最后。可以在任何点停止重放，并使数据库恢复到当时的一致状态。可以连续地将一系列WAL文件输送给另一台已经载入了相同基础备份文件的机器，得到一个实时的热备份系统。 2.3.1. 如何进行连续归档呢？实验环境:OS: Centos 7.9Postgresql: 14.6 2.3.1.1. 配置postgresql.conf首先需要配置/etc/sysconfig/pgsql/postgresql.conf 如果/etc/sysconfig/pgsql目录下没有该配置文件, 可以基于 /usr/pgsql-14/share/postgresql.conf.sample创建一个 12345678archive_mode = onwal_level = replicaarchive_mode = onarchive_command = 'cp /var/lib/pgsql/14/data/%p /var/lib/pgsql/14/backups/walback/%f' archive_command执行时，%p会被要被归档的文件路径所替代，而%f只会被文件名所替代。 一些注意事项:/var/lib/pgsql/14/backups/walback替换为归档日志的存放路径。wal_level只能在服务器启动时修改。但是，archive_command可以通过重载配置文件来修改。要确保归档的目录是存在的walback文件夹的用户组和所有者应该是postgres, 否则会备份失败如果你需要在参数archive_command中嵌入一个真正的%字符，可以使用%% 之后需要重启数据库使配置生效。 2.3.1.2. 制作一个基础备份接下来需要制作一个非排他的基础备份。Postgresql提供了排他备份和非排他备份两种备份方式，推荐使用非排他的备份方式。 以一个具有运行pg_start_backup权利的用户连接到服务器（不在乎是哪个数据库）并且发出以下命令： 12Select pg_start_backup('backup_label', false, false); 对数据库进行一次文件系统级别的备份。即将postgresql的安装目录下的data目录及其内容复制到其他位置。 在同一个连接中，发出命令： 123select * from pg_stop_backup(false); 这个命令代表结束一次非排他的备份。 3. 参考文档Postgresql的三种备份方式 26.3. 连续归档和时间点恢复（PITR","link":"/database/postgresql_backup_restore.html"},{"title":"PostgreSQL基础","text":"1. 数据库基础知识1.1. 什么是数据库数据库(Database, DB)是一个长期存储在计算机内的, 有组织的, 有共享的, 统一管理的数据集合. 保管数据的”仓库” 数据管理的方法和技术 1.2. 数据表数据库表: 是一系列二维数组的集合 横向的行(记录, 行) 纵向的列(字段, 属性, 列) 1.3. 数据类型常用的数据类型有: 整数数据类型 浮点数数据类型 日期/时间数据类型 字符串数据类型 二进制数据类型 1.4. 数据库系统构成数据库系统有 3 个主要的组成部分: 数据库 数据库管理系统 数据库应用程序 1.5. SQL 语言sql 是对数据库进行查询和修改操作语言.SQL 语言包括 4 个部分DDL: DROP, CREATE, ALTER 等语句.DML: INSERT, UPDATE, DELETE 语句.DQL: SELECT 语句.DCL: GRANT, REVOKE, COMMIT, ROLLBACK 等语句. 1.6. 常用的数据库访问技术目前流行的数据库访问技术如下: ODBC: Open Database Connectivity(开放数据库连接) JDBC: Java Database Connectivity(Java 数据库连接) ADO.NET: .NET 框架中用于和数据库交互的类库 PDO: PHP Data Object(PHP 语言访问数据库技术) 2. PostgreSQL 数据库介绍2.1. PostgreSQL 数据库发展历程 1973年，美国国防部与加州大学伯克利分校合作开发了一个研究项目，叫Ingres。 1985年，研究项目终止，随后开源，并且命名叫Postgre 1986 年: 加州大学伯克利分校开发了一个叫 Postgre 的关系数据库服务器 1994 年: 增加了 SQL 语言解析器, 命名为 Postgres95 1996 年: 更名为 PostgreSQL, 版本号从 6.0 开始 2005 年: 发布 8.0 版本, 开始支持 Windows 系统环境 2011 年: 发布 9.1 版本, 增加了很多创新性功能, 具备强大的可扩展性 目前: 已经发布到 9.4 版本, 增加对于 NoSQL 的支持 2.2. PostgreSQL 数据库特点PostgreSQL 数据库的主要特点如下: 免费 速度快 平台可移植性 丰富的接口 面向对象特性 安全性 配合的开源软件很多 3. PostgreSQL 数据库环境搭建3.1. PostgreSQL 数据库软件下载PostgreSQL 官网: https://www.postgresql.org 下载地址: https://www.postgresql.org/download/ 3.2. 在 Windows 平台搭建 PostgreSQL 环境3.2.1. 前置条件要使用图形安装向导执行安装，您必须具有超级用户或管理员权限。以下部分将指导您在 Windows 主机上安装 PostgreSQL。要启动安装向导，请具有足够的权限并双击安装程序图标；如果出现提示，请提供密码。注意，在某些版本的 Windows 中，要使用管理员权限调用安装程序，需要右键单击安装程序图标并从上下文菜单中选择以管理员身份运行。 3.2.2. 下载安装包访问地址: https://www.postgresql.org/download/windows/, 点击”Download the installer”超链接进入 postgreSQL 安装包下载页面.或者直接打开 https://www.enterprisedb.com/downloads/postgres-postgresql-downloads 进入下载页面 当前教程使用的版本:postgresql-14.6-1-windows-x64 3.2.3. 安装步骤 双击打开安装向导,点击下一步 修改 Installation directory 或者使用默认安装位置 选择需要安装的组件, 默认全选, 初学者可以使用默认配置, 有经验的用户可以根据自己的需求选择要安装的组件 Postgresql Server pgAdmin: Postgresql 客户端工具 Stack builder Command line Tools: 命令行工具 选择数据存储目录 设置超级管理员密码 设置端口, 可使用默认端口 5432 选择 locale, 可以使用默认 locale 安装程序将会提示安装信息 1234567891011Installation Directory: C:\\Program Files\\PostgreSQL\\14Server Installation Directory: C:\\Program Files\\PostgreSQL\\14Data Directory: C:\\Program Files\\PostgreSQL\\14\\dataDatabase Port: 5432Database Superuser: postgresOperating System Account: NT AUTHORITY\\NetworkServiceDatabase Service: postgresql-x64-14Command Line Tools Installation Directory: C:\\Program Files\\PostgreSQL\\14pgAdmin4 Installation Directory: C:\\Program Files\\PostgreSQL\\14\\pgAdmin 4Stack Builder Installation Directory: C:\\Program Files\\PostgreSQL\\14Installation Log: C:\\Users\\{user}\\AppData\\Local\\Temp\\install-postgresql.log 点击下一步, 直到安装完成 3.2.4. 开启或关闭 postgreSQL 服务可以在 windows 服务管理界面, 将 PostgreSQL 服务设置为手动启动, 自动启动, 或关闭. 3.3. 在 Linux 平台搭建 PostgreSQL 环境查看 PostgreSQL 版本 123postgres --version 3.4. 在 Mac 平台搭建 PostgreSQL 环境4. pgAdmin 客户端工具使用4.1. 使用 pgAdmin 工具连接 PostgreSQL 数据库一些检测检查 检查 postgresql.conf 配置文件 连接远程数据库服务需要注意如下一些问题: 关闭服务器机器防火墙 修改服务器端连接监听(postgresq.conf 配置文件) 修改连接认证方式(pg_hba.conf 配置文件) 4.2. pgAdmin 工具常用功能介绍 query tools: sql 查询工具 5. PostgreSQL 数据库, 数据表, 数据类型和运算符介绍5.1. 使用 pgadmin 工具操作数据库对象如何创建数据库 点击右侧导航树, 选择数据库 node, 右击弹出菜单, 在菜单中选择新建数据库 填充数据库名, 选择所有者 点击创建 如何修改数据库 点击右侧导航树,选中要修改的数据库, 右击弹出菜单, 在菜单中选择新建数据库 在弹出的界面中, 修改数据库属性 点击应用 如何删除数据库 点击右侧导航树,选中要修改的数据库, 右击弹出菜单, 点击删除 5.2. 使用 SQL 语言操作数据库对象如何创建数据库 123create database test_database; 创建数据库时指定参数 123create database test_database with owner= postgre encoding = 'utf-8'; 如何修改数据库 1alter database test_database rename to dev_database; 如何修改数据库参数 1alter database dev_database connection limit 20; 如何删除数据库 1drop database dev_database; 5.3. 使用 pgAdmin 工具操作数据表对象如何创建数据表 选择 数据库&gt;模式&gt;public&gt; 数据表, 右击菜单, 选择新建数据表 在弹出的对话框中数据数据库表名称, 所有者, 模式, 添加字段 点击确定. 如何修改数据表 在数据库导航栏中, 选择修改数据表, 按图像界面指引操作. 如何删除数据表 选择数据包, 右击菜单, 选择删除 5.4. 使用 SQL 语言操作数据表对象如何创建数据表 123456create table student ( id int, name varchar(30), birthday data, score numeric(5,2)) 如何修改数据表 123456789101112131415161718192021-- 修改表名称alter table student rename to student1;-- 修改数据表中字段名称alter table student rename id to bh;-- 修改数据表中字段类型alter table student alter column name type varchar(40);-- 修改数据表中的字段alter table student drop column birthday;-- 在数据表中添加字段alter table student add column address varchar(200); 如何删除数据表 123456789-- 如何删除数据表drop table student-- 删除表前检查表是否存在, 从而避免sql错误信息drop table if exists student 5.5. PostgreSQL 常用数据类型介绍5.5.1. 数值类型数值类型由 2 字节、4 字节或 8 字节的整数以及 4 字节或 8 字节的浮点数和可选精度的十进制数组成。 下表列出了可用的数值类型。 名字 存储长度 描述 范围 smallint 2 字节(16bit) 小范围整数 -32768 到 +32767 INT(INTEGER) 4 字节(16bit) 常用的整数 -2147483648 到 +2147483647 bigint 8 字节(16bit) 大范围整数 -9223372036854775808 到 +9223372036854775807 decimal 可变长 用户指定的精度，精确 小数点前 131072 位；小数点后 16383 位 NUMERIC(m, n) 可变长 用户指定的精度，精确, 任意精度类型 小数点前 131072 位；小数点后 16383 位 real 4 字节(32bit) 可变精度，不精确 6 位十进制数字精度 double precision 8 字节(64bit) 可变精度，不精确 15 位十进制数字精度 smallserial 2 字节(16bit) 自增的小范围整数 1 到 32767 serial 4 字节(32bit) 自增整数 1 到 2147483647 bigserial 8 字节(64bit) 自增的大范围整数 1 到 9223372036854775807 5.5.2. 布尔类型PostgreSQL 支持标准的 boolean 数据类型。 boolean 有”true”(真)或”false”(假)两个状态， 第三种”unknown”(未知)状态，用 NULL 表示。 名称 存储格式 描述 boolean 1 字节 true/false 5.5.3. 日期与时间类型下表列出了 PostgreSQL 支持的日期和时间类型。 名字 存储空间 描述 最低值 最高值 分辨率 timestamp [ (p) ] [ without time zone ] 8 字节 日期和时间(无时区) 4713 BC 294276 AD 1 毫秒 / 14 位 timestamp [ (p) ] with time zone 8 字节 日期和时间，有时区 4713 BC 294276 AD 1 毫秒 / 14 位 date 4 字节 只用于日期 4713 BC 5874897 AD 1 天 time [ (p) ] [ without time zone ] 8 字节 只用于一日内时间 00:00:00 24:00:00 1 毫秒 / 14 位 time [ (p) ] with time zone 12 字节 只用于一日内时间，带时区 00:00:00+1459 24:00:00-1459 1 毫秒 / 14 位 interval [ fields ] [ (p) ] 12 字节 时间间隔 -178000000 年 178000000 年 1 毫秒 / 14 位 5.5.4. 字符串类型CHAR/CHARACTER(N) //固定长度字符串, 不足补空格VARCHAR(n)/ CHARACTER VARING(n) // 变长字符串, 有长度限制TEXT //变长字符串, 无长度限制 5.5.5. 货币类型money 类型存储带有固定小数精度的货币金额。 numeric、int 和 bigint 类型的值可以转换为 money，不建议使用浮点数来处理处理货币类型，因为存在舍入错误的可能性 名字 存储容量 描述 范围 money 8 字节 货币金额 -92233720368547758.08 到 +92233720368547758.07 5.5.6. 选择正确的数据类型主要目的: 优化存储, 提高数据库性能 正确使用整数类型和浮点数类型 日期与时间类型 CHAR 和 VARCHAR 之间的特点和选择 5.6. PostgreSQL 运算符介绍5.6.1. 运算符概述5.6.2. 算术运算符算术运算符包含内容: 加 (+) 减 (-) 乘 (*) 除 (/) 求余 (模运算, %) 5.6.3. 比较运算符比较运算符常常用于比较大小 运算符 作用 = 等于 &lt;&gt;(!=) 不等于 &lt;= 小于等于 &gt;= 大于等于 &gt; 大于 &lt; 小于 LEAST 在有两个或者多个参数时, 返回最小值 GREATEST 在有两个或者多个参数时, 返回最大值 BETWEEN AND 判断一个值是否落在两个值之间 IN 判断一个值是否是列表中的任意一个值 LIKE 通配符匹配 示例: 1234567891011select 1=0, '2', 1&lt;&gt;2, 4!=4, 2&gt;=1;select 2 between 1 and 3;select 2 in (2, 3, 4), 2 in (4,5)select 'abc' like 'a%', 'abc' like '_b_', 'abc' not like '%d'select least(6,2, 3), greatest(6,2, 3) 5.6.4. 逻辑运算符逻辑运算符包含内容: NOT (逻辑非) AND (逻辑与) OR (逻辑或) 示例 123456789-- 一般在Postgresql中, 1作为真来处理, 0作为假来处理-- n作为真来处理, y作为假来处理select not '1', not 'y', not '0', not 'n';select '1' and 'y', '1' and '0', '0' and 'n';select '1' or 'y', '1' or '0', '0' or 'n'; 5.6.5. 运算符优先级 优先级 运算符 最低 = (赋值运算符) OR AND NOT BETWEEN, CASE, WHEN, THEN, ELSE =(比较运算符), &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, IN -(减号), + *, /, % - (负号) 最高 ! 6. PostgreSQL 函数, 索引和视图6.1. PostgreSQl 常用函数介绍6.1.1. 常用的数值函数 函数名称 函数作用 AVG() 返回某列的平均值 COUNT() 返回某列行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列的值之和 6.1.2. 常用的字符串函数 函数名称 函数作用 LENGTH(S) 计算字符串长度 CONCAT(S) 字符串合并函数 LTRIM(s)/RTRIM(s)/TRIM(s) 删除字符串空格函数 REPLACE(s, s1, s2) 字符串替换函数 SUBSTRING(s,n, len) 获取子串函数 6.1.3. 常用的日期和时间函数 函数名称 函数作用 EXTRACT(type FROM D) 获取日期指定值函数 CURRENT_DATE 获取当前日期函数 CURRENT_TIME 获取当前时间函数 NOW() 获取当前日期时间函数 示例: 12345select current_date, current_time, now();select extract(year from birthDate), extract(month from birthDate), extract(day from birthDate) from employee; 6.1.4. 自定义函数语法基本语法格式: 12345678CREATE FUNCTION //声明创建函数 add(integer, integer) //定义函数名称, 参数类型RETURNS integer //定义函数返回值AS 'select $1 + $2;' //定义函数体LANGUAGE SQL //用以实现函数的语言RETURN NULL ON NULL INPUT; //定义参数为NULL时处理情况 示例 123456789-- 定义函数create or replace function concat_string(integer, varchar, data)return varchar as'SELECT $1 || $2 || $3'language sqlreturns null on null input-- 调用函数select e_no, e_name, e_hiredate, concat_string(e_no, e_name, e_hiredate)from employee; 6.2. PostgreSQL 数据库索引介绍6.2.1. 什么是索引？索引（Index）是帮助PostgreSQL高效获取数据的数据结构，就好比书的目录，加快数据库的查询速度。 6.2.2. 索引的作用在数据库系统中建立索引主要有以下作用： 1.快速读取数据 2.保证数据记录的唯一性 3.实现表与表之间的参照完整性 4.在使用orderby ，group by子句进行检索时，索引可以减少排序和分组的时间。 6.2.3. 索引的分类6.2.3.1. 按存储结构分类 索引名称 使用场景 B-tree 索引 适合处理那些能够按顺序存储数据 Hash 索引 只能处理简单的等于比较 GiST 索引 一种索引架构 GIN 索引 反转索引, 处理包含多个值的键 6.2.3.2. 按数据的存储方式（物理结构）分类 聚集索引：聚簇索引的顺序就是数据的物理存储顺序，索引与数据存放在同一个文件中。 非聚集索引：非聚簇索引的顺序与数据的物理存储顺序不同，索引与数据存放在不同的文件。 6.2.3.3. 按应用层次分类 普通索引 最基本的索引，它没有任何限制，用于加速查询 唯一索引 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。 组合索引 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。 fulltext索引配合match against操作使用，而不是一般的where语句加like。 它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。 6.2.4. 什么情况下该创建索引？ 频繁作为查询条件的字段应该创建索引； 查询中与其他表有关联的字段，例如外键关系； 在经常需要排序(order by),分组(group by)和的distinct 列上加索引，可以加快排序查询的时间, 6.2.5. 什么情况下不创建索引？ 查询中很少使用到的字段 不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求. 值重复率高的字段不适合建索引（比如性别、百万级数据时比如26个字母）数据很少的字段也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率 定义为text和image和bit数据类型的列不应该增加索引, 当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系 6.2.6. 索引的创建和删除示例: 1234567--创建索引, 默认是B-tree索引create index emp_name_index on employee(e_name);--删除索引drop index emp_name_index;--创建索引create index emp_name_index on employee(e_name); 6.2.7. 使用索引的优点和缺点优点: 提高数据的查询速度 加速与表之间的连接 在分组和排序字句进行数据检索,可以减少查询时间中分组和排序时所消耗的时间 缺点: 创建和维护索引需要消费时间 需要占用磁盘空间 不合适的索引或索引过多，会降低增删改的效率 一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快) 6.3. PostgreSQL 数据库视图介绍6.3.1. 视图的含义视图是从一个或几个基本表（或视图）组成的虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 6.3.2. 视图的创建示例: 12345678910--创建视图create view v_emp_dev asselect e_no, e_name, e_salary, e_hireDatefrom employeewhere dept_no = 10 order by e_salary desc;-- 使用视图select * from v_emp_dev; 6.3.3. 视图的删除1drop view v_emp_dev 6.3.4. 视图的作用视图的作用: 简单化 安全性 逻辑数据独立性 7. PostgreSQL 数据操作和数据表约束介绍7.1. 简单数据插入操作7.1.1. 向单表中插入数据示例 1insert into student values(1, '张三', '1990-01-01', 3.85) 7.1.2. 向数据表中指定字段插入数据示例: 1insert into student (id, name, birthday) values (2, '李四', '1990=01-02'); 7.2. 批量数据插入操作使用 INSERT 语句批量向数据表中插入数据 123456insert into student(id, name, birthday) values(3, '张三1', '1990-01-01'),(4, '张三2', '1990-01-02'),(5, '张三3', '1990-01-03'); 使用 SELECT 语句向数据表中插入数据 12345678-- 不字段特定字段insert into student_newselect * from student-- 指定字段insert into student_new(id, name, birthday)select id, name, birthday from student 7.3. 数据更新操作7.3.1. 指定条件更新数据1update student set name='李四' where id = 2; 7.3.2. 批量更新数据1update student set score = 0; 7.3.3. 将指定结果更新到对应字段1update student set score = 1.1+2.3 where id = 1; 7.4. 数据删除操作7.4.1. 数据删除操作示例: 123456789delete from student where id = 4;delete from student where birthday between '1990-01-01' and '1990-02-01'-- 清空数据表delete from student_new 7.4.2. TRUNCATE 数据清空操作1truncate table student_new; 7.4.3. DELETE 与 TRUNCATE 操作区别 DELETE TRUNCATE 执行速度 慢 快 可指定条件 可以 不可以 语句分类 DML DDL 可以回滚事务 可以 不可以 删除操作记录日志 记录 不记录 7.5. PostgreSQL 数据表主键和外键介绍7.5.1. 如何定义主键约束1234567891011121314create table emp( id int primary key, name varchar(30), salary numeric(9,2))-- 或者create table emp( id int, name varchar(30), salary numeric(9,2), constraint pk_emp primary key(id)) 7.5.2. 如何定义外键约束示例: 12345678910111213create table dept ( id int primary key, name varchar(40))create table employee( id int primary key, name varchar(30), salary numeric(9,2), deptId int, constraint fk_emp_dept foreign key(deptId) references dept(id)) 7.5.3. 主键约束和外键约束的作用主键约束作用: 唯一标识一条记录 提高数据的检索效率 外键约束作用: 保证数据的完整性 提高数据的检索效率 7.6. PostgreSQL 数据表非空约束, 唯一约束和默认值约束介绍7.6.1. 如何定义非空约束12345create table emp4 ( id int primary key, name varchar(30) not null, salary numeric(9,2)) 7.6.2. 如何定义唯一约束123456create table emp4 ( id int primary key, name varchar(30) not null, phone varchar(30) unique, salary numeric(9,2)) 7.6.3. 如何定义默认值约束12345create table emp4 ( id int primary key, name varchar(30) not null, salary numeric(9,2) default 0.0) 7.6.4. 非空约束, 唯一约束和默认值约束的作用约束作用: 维护数据的完整性 在业务层面保证数据正确性 8. PostgreSQL 数据查询操作8.1. 简单数据查询操作8.1.1. 查询语句语法基本语法格式 123456789SELECT {*|&lt;字段列表&gt;} //查询结果字段内容FROM &lt;表1&gt;,&lt;表2&gt;... // 查询数据表 [WHERE &lt;表达式&gt;] // where 查询条件表达式 [GROUP BY &lt;group by definition&gt;] //group by 数据分组 [HAVING &lt;expression&gt; [{&lt;operator&gt;&lt;expression&gt;}]] [ORDER BY &lt;order by definition&gt;] //查询结果排序 [LIMIT [&lt;offset&gt;,] &lt;row count&gt;] //限制结果显示数量 准备数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 创建演示数据表结构-- 创建dept表CREATE TABLE dept ( d_no INT PRIMARY KEY, -- 部门编号 d_name VARCHAR(30), --部门名称 d_location VARCHAR(300) -- 部门所在地址)-- dept 表初始化数据INSERT INTO dept VALUES(10, '开发部', '北京市海淀区');INSERT INTO dept VALUES(20, '测试部', '北京市东城区');INSERT INTO dept VALUES(30, '销售部', '上海市');INSERT INTO dept VALUES(40, '财务部', '广州市');INSERT INTO dept VALUES(50, '运维部', '武汉市');INSERT INTO dept VALUES(60, '集成部', '南京市');-- 创建employee表CREATE TABLE employee ( e_no INT PRIMARY KEY, e_name VARCHAR(30) NOT NULL, e_gender CHAR(2) NOT NULL, dept_no INT, e_job VARCHAR(50) NOT NULL, e_salary NUMERIC(9, 2), e_hireDate Date, constraint fk_emp_deptno FOREIGN KEY (dept_no) REFERENCES dept(d_no))-- 初始化employee表INSERT INTO employee VALUES(100, '赵志军', 'f', 10, '开发工程师', 5000, '2010-01-01');INSERT INTO employee VALUES(101, '张铭雨', 'f', 10, '开发工程师', 6000, '2012-04-04');INSERT INTO employee VALUES(102, '许峰', 'f', 10, '开发经理', 6000, '2012-04-04');INSERT INTO employee VALUES(103, '王嘉琪', 'm', 20, '测试工程师', 4500, '2012-04-04');INSERT INTO employee VALUES(104, '李江新', 'f', 20, '测试工程师', 5000, '2012-04-04');INSERT INTO employee VALUES(105, '张海影', 'f', 20, '测试经理', 5000, '2012-04-04');INSERT INTO employee VALUES(106, '马恩波', 'f', 30, '销售人员', 3000, '2012-04-04');INSERT INTO employee VALUES(107, '李惠敏', 'm', 30, '销售人员', 5000, '2012-04-04');INSERT INTO employee VALUES(108, '马爽爽', 'm', 30, '销售经理', 9000, '2012-04-04');INSERT INTO employee VALUES(109, '史晓云', 'm', 30, '销售高级经理', 12000, '2012-04-04');INSERT INTO employee VALUES(110, '刘燕凤', 'm', 40, '财务人员', 3000, '2012-04-04');INSERT INTO employee VALUES(111, '王科', 'f', 40, '财务人员', 3500, '2012-04-04');INSERT INTO employee VALUES(112, '李林英', 'f', 40, '财务经理', 5000, '2012-04-04');INSERT INTO employee VALUES(113, '李杨', 'f', 10, '实习工程师', NULL, '2012-04-04');INSERT INTO employee VALUES(114, '李刚', 'f', NULL, '实习工程师', NULL, '2012-04-04');INSERT INTO employee VALUES(115, '王林', 'f', NULL, '实习工程师', NULL, '2012-04-04'); 8.2. 简单查询操作12345678910111213-- 查询employee中所有字段内容select * from employee;-- 查询指定字段数据select e_no, e_name,dept_no, e_job from employee;-- 为表和字段指定别名select e_no, e.e_name as name,dept_no, e_job from employee as e; 8.3. 单表指定条件查询操作12345678910111213141516-- 工资少于5000的雇员select e_no, e.e_name as name,dept_no, e_job from employee as e where e_salary &lt;5000 ;-- 女性雇员信息select e_no, e.e_name as name,dept_no, e_job from employee as e where gender = 'F';-- 雇员测试和销售部门的select e_no, e.e_name as name,dept_no, e_job from employee as e where dept_no in (20,30);-- 查找姓李的select e_no, e.e_name as name,dept_no, e_job from employee as e where e_name like '李%';-- 查找入职日期在2012-04-01到2012-04-30的雇员select e_no, e.e_name as name,dept_no, e_job from employee as e where e_hireDate between '2012-04-01' and '2012-04-30'; 8.4. 单表指定条件复杂查询操作8.4.1. 查询空值内容123select e_no, e.e_name as name,dept_no, e_job from employee as e where e_salary is null ;select e_no, e.e_name as name,dept_no, e_job from employee as e where e_salary is not null ; 8.4.2. AND, OR 多条件查询12345678select e_no, e.e_name as name,dept_no, e_job from employee as ewhere e_gender = 'f' and dept_no = 10;select e_no, e.e_name as name,dept_no, e_job from employee as ewhere e_gender = 'f' and dept_no in (10, 20);select e_no, e.e_name as name,dept_no, e_job from employee as ewhere e_gender = 'f' and (dept_no =10 or dept_no =20); 8.4.3. 查询结果集排序123456789101112131415161718192021select e_no, e.e_name as name,dept_no, e_job from employee as eorder by e_salary; -- 默认是升序(asc)排序select e_no, e.e_name as name,dept_no, e_job from employee as eorder by e_salary desc;select e_no, e.e_name as name,dept_no, e_job from employee as eorder by e_salary asc, e_hireDate desc;-- 空值显示在最前面select e_no, e.e_name as name,dept_no, e_job from employee as eorder by e_salary asc nulls first;-- 空值显示在最后面select e_no, e.e_name as name,dept_no, e_job from employee as eorder by e_salary asc nulls last; 8.4.4. LIMIT 关键字查询123456789-- 显示前5条数据select e_no, e.e_name as name,dept_no, e_job from employee as elimit 5-- 从第5条后的5条数据select e_no, e.e_name as name,dept_no, e_job from employee as elimit 5 offset 5 8.5. 多表连接查询操作8.5.1. INNER JOIN 连接查询操作1234567-- 隐式内连接select e_no, e.e_name as name,dept_no, d.name, e_job from employee as e, dept as dwhere dept_no = d_no;-- 显式内连接select e_no, e.e_name as name,dept_no, d.d_name, e_job from employee as e inner join dept as d on dept_no = d_no 8.5.2. LEFT JOIN 连接查询操作123456-- 左连接(left join)select e_no, e.e_name as name,dept_no, d.d_name, e_job from employee as e left join dept as d on dept_no = d_no-- 左连接(left outer join)select e_no, e.e_name as name,dept_no, d.d_name, e_job from employee as e left outer join dept as d on dept_no = d_no 8.5.3. RIGHT JOIN 连接查询操作1234567-- 右连接(right join)select e_no, e.e_name as name,dept_no, d.d_name, e_job from employee as e right join dept as d on dept_no = d_no-- 右连接(right outer join)select e_no, e.e_name as name,dept_no, d.d_name, e_job from employee as e right outer join dept as d on dept_no = d_no 8.6. 子查询操作8.6.1. EXISTS 关键字子查询操作123456789-- existsselect * from employee as e where exists(select d_no from dept where d_no = e.dept_no and d_name='开发部')-- not existsselect * from employee as e where not exists(select d_no from dept where d_no = e.dept_no and d_name='开发部') 8.6.2. IN 关键字子查询操作1234select * from employee as e where dept_no in(select d_no from dept where d_name='开发部') 8.6.3. 标量子查询操作标量子查询是圆括号中的常规 SELECT 查询，仅返回一个值：带有一个列的一行。 执行此查询，返回值将在外部查询中使用。如果子查询返回零行，则子查询表达式的值为 null。如果它返回多行，将返回错误. 子查询可引用父查询中的变量，这将在子查询的任何一次调用中充当常量。 您可在需要表达式的大部分语句中使用标量子查询。标量子查询在下列情况下是无效表达式： 作为表达式的默认值 在 GROUP BY 和 HAVING 子句中 123select e_no, e_name, (select d_name || ' ' || d_location from dept where dept_no= d_no) from employee as e 8.7. 查询结果集合合并操作8.7.1. 使用 UNION ALL 对查询结果进行合并123select e_no, e_name, dept_no, e_salary from employee where dept_no in (10, 20)union allselect e_no, e_name, dept_no, e_salary from employee where e_salary &gt; 5000 8.7.2. 使用 UNION 对查询结果进行合并123select e_no, e_name, dept_no, e_salary from employee where dept_no in (10, 20)unionselect e_no, e_name, dept_no, e_salary from employee where e_salary &gt; 5000 union 会去掉重复的记录 8.7.3. 使用 UNION ALL 和 UNION 之间的区别union 会去掉重复的记录 而 union all 只是简单的合并结果集union 合并操作效率更高 UNION UNION ALL 去除重复记录 可以 不可以 执行速度 慢 快","link":"/database/postgresql_basics.html"},{"title":"PostgreSQL 数据库版本升级实战","text":"PostgreSQL 版本发布规则，一年一个大版本，一个季度一个小版本；PG 遇到的 BUG 问题，社区会很快进行修复，并在下一个版本中发布，因此有必要进行对数据库版本升级，避免触发已知的 BUG 带来业务系统的不稳定。本文主要分享一下，PG 小版本升级、跨版本升级和借助逻辑复制进行数据库升级。 1. PG 小版本升级PG 小版本的迭代不会改变内部的存储格式，因此升级小版本只需要安装最新版本后，使用新版本重新启动数据库即可。 停止数据库实例 对数据目录进行备份 安装最新版本数据库 使用新版本启动数据库 调整环境变量，PGHOME/LD_LIRARAY_PATH 等 注意：在安装新版本数据库时，要保证数据库块大小一致。 2. PG 跨版本升级大版本的升级方法主要有如下三种： 使用 pg_dumpall / pg_restore 进行升级 使用 pg_upgrade 进行升级 使用逻辑复制进行升级 2.1. 使用 pg_dumpall 和 pg_dump 进行逻辑转储恢复升级此方案的原理是使用 pg_dumpall 命令将旧数据库的全部 dump 成 sql 文件，然后使用 psql 命令还原至高版本的实例中。借助于管道，可以实现在线升级。配合脚本的话，切换至高版本几乎零宕机。由于 dump+restore 总体相对耗时较长，因此不适用于大数据量的数据库，或是写入比较频繁的场景使用。 2.1.1. 备份数据库123pg_dump -h 127.0.0.1 -p 5432 -U postgres -d dbname -c -C -f dbname_bak_`date &quot;+%Y%m%d%H%M%S&quot;`.sql 压缩备份文件 123gzip dbname_bak_xxxxxx.sql 2.1.2. 删除数据库12345678910111213141516## 停止服务sudo systemctl stop postgresql-14## 删除服务sudo systemctl disable postgresql-14## 卸载软件sudo dnf remove postgresql14-server postgresql14-libs; sudo dnf autoremove ; sudo dnf clean packages## 清除数据sudo rm -rf /usr/pgsql-14/sudo rm -rf /var/lib/pgsql/14 2.1.3. 安装高版本数据库123sudo dnf install -y postgresql15-server 2.1.4. 配置数据库1234sudo /usr/pgsql-15/bin/postgresql-15-setup initdb 2.1.5. 启动 PostgreSQL 服务12345# 设置PostgreSQL服务为开机启动, 并立即启动postgresql服务sudo systemctl enable --now postgresql-15# 查看postgresql的状态systemctl status postgresql-15 2.1.6. 修改 postgres 账号密码进入 PostgreSQL 命令行 通过 su 命令切换 linux 用户为 postgres 会自动进入命令行 12sudo bashsu - postgres 启动 SQL Shell 1psql 修改密码 1ALTER USER postgres WITH PASSWORD 'NewPassword'; 2.1.7. 修改 IP 绑定123456#修改配置文件sudo vi /var/lib/pgsql/15/data/postgresql.conf#将监听地址修改为*#默认listen_addresses配置是注释掉的，所以可以直接在配置文件开头加入该行listen_addresses='*' 2.1.8. 允许所有 IP 访问12345678#修改配置文件sudo vi /var/lib/pgsql/15/data/pg_hba.conf#在问号尾部加入host all all 0.0.0.0/0 md5# 或者只允许局域网内的用户访问host all all 192.168.1.0/24 md5 2.1.9. 重启 PostgreSQL 服务12#重启PostgreSQL服务sudo systemctl restart postgresql-15 2.1.10. 恢复数据恢复方式很简单，执行恢复命令即可： 12# 普通用户权限即可psql -h 127.0.0.1 -p 5432 -U postgres -f db_bak.sql 2.2. 使用 pg_upgrade 进行升级pg_upgrade 是官方提供的版本升级工具，有普通模式和 Link 模式两种升级模式。在普通模式下，会把旧版本的数据拷贝到新版本中，需要确保有足够的磁盘空间存储新旧两份数据；Link 模式下，只是在新版本的数据目录中建立了旧版本数据文件的硬连接，可以有效减少磁盘占用的空间。 在升级之前建议使用pg_upgrade --check参数检查新旧版本的兼容性，把每一项不兼容的问题解决后才可以顺利升级，-c 参数只会检查新旧版本兼容性，不会运行真正的升级程序，不会修改数据文件，在运行结束后，会输出兼容性结果。 2.2.1. 首先安装新版本数据库1sudo dnf install -y postgresql15-server 2.2.2. 初始化新数据库1234567/usr/pgsql-15/bin/initdb --version/usr/pgsql-15/bin/initdb --data-checksums -D /var/lib/pgsql/15sudo /usr/pgsql-15/bin/postgresql-15-setup initdb 2.2.3. 然后检查新旧版本兼容性12345678910su - postgresexport PGBINOLD=/usr/pgsql-14/binexport PGBINNEW=/usr/pgsql-15/binexport PGDATAOLD=/var/lib/pgsql/14export PGDATANEW=/var/lib/pgsql/15/usr/pgsql-15/bin/pg_upgrade --check 运行以上命令会生成在两个 Postgres 集群之间发现的任何不兼容性的详细报告。我们希望在底部看到以下消息： *Clusters are compatible* 1234567891011121314151617postgres@fedora:~$ /usr/pgsql-15/bin/pg_upgrade -cPerforming Consistency Checks-----------------------------Checking cluster versions 成功Checking database user is the install user 成功Checking database connection settings 成功Checking for prepared transactions 成功Checking for system-defined composite types in user tables 成功Checking for reg* data types in user tables 成功Checking for contrib/isn with bigint-passing mismatch 成功Checking for incompatible &quot;aclitem&quot; data type in user tables 成功Checking for presence of required libraries 成功Checking database user is the install user 成功Checking for prepared transactions 成功Checking for new cluster tablespace directories 成功*Clusters are compatible* 2.2.4. 备份数据如果您使用 streaming replication，这些 replication 也需要升级。坏消息是我们无法在副本服务器上运行 pg_upgrade。好消息是升级它们的过程很棘手，但速度很快。它们的升级发生在主服务器之后，但这是准备工作的绝佳时机。对于每个副本，您需要安装新的 Postgres 软件，就像我们上面所做的那样，但不要运行 initdb。将每个副本上数据目录中存在的所有配置文件复制到该目录之外的安全位置。 123pg_dumpall -h 127.0.0.1 -p 5432 -U postgres -c -C -f dbname_`date &quot;+%Y%m%d%H%M%S&quot;`.sql 2.2.5. 正式开始升级pg_upgrade –check 完成后，我们就可以进行实际升级了。确保使用–linkpg_upgrade 的参数非常重要。这样做可以避免将所有实际数据文件从旧集群复制到新集群。相反，它会在旧数据文件和新数据文件之间创建硬链接（而不是更常见的符号链接）。这样做会告诉操作系统每个数据文件都有两个完全有效的路径来访问该文件。而且，与复制文件内容相比，它的速度非常快。命令如下所示： 1234## This assumes the ENVs from above were exported/usr/pgsql-15/bin/pg_upgrade --link pg_upgrade 命令的输出将类似于以下内容： 123456789Upgrade Complete----------------Optimizer statistics are not transferred by pg_upgrade.Once you start the new server, consider running: /home/greg/pg/15/bin/vacuumdb --all --analyze-in-stagesRunning this script will delete the old cluster's data files: ./delete_old_cluster.sh 2.2.6. 复制并调整配置文件现在新的集群已经到位，在我们将应用程序连接到它之前还需要几个步骤。 新集群将具有默认的 postgresql.conf、pg_hba.conf 和 pg_ident.conf 文件，这不是您想要的。从旧集群复制 pg_hba.conf 和 pg_ident.conf 文件。它们很可能无需任何修改即可工作，因为这些文件的格式很少改变。接下来，您需要将旧的 postgresql.conf 文件与新文件合并。如果您习惯在 postgresql.conf 文件底部进行更改，则可以轻松地复制并粘贴它们。无论哪种方式，您都应该仔细检查并确保所有设置仍然适用于新集群。不要忘记 postgresql.auto.conf 或“include*”选项引用的任何 conf 文件。 2.2.7. 启用校验和如果您的新集群未启用页面级校验和，那么现在是启用它们的好时机。Postgres 附带一个程序，用于将您的集群更改为使用页面级校验和，名为 pg_checksums。它将与我们上面使用的 initdb 位于同一目录中，用法如下： 1/usr/pgsql-15/bin/pg_checksums -D $PGDATANEW --enable --verbose 2.2.8. 同步您的副本对于这一部分，我将向您推荐官方文档的 step 11 []”Upgrade streaming replication and log-shipping standby servers”](https://www.postgresql.org/docs/current/pgupgrade.html) 。严格按照 rsync 配方操作。将来可能会有更好的方法，所以我宁愿在这里留下一个链接，也不愿复制那个大 rsync 命令并在这里打印出来。:) rsync 进程非常快，因为它只复制已更改的文件。它会比较主服务器上的新旧目录，然后与副本进行比较。与以前一样，此进程的速度取决于文件数量。您可以同时升级副本。 2.2.9. 启动并生成统计数据现在副本已准备就绪，您可以启动主服务器。如果您没有使用 pg_ctl，而是使用 systemd 之类的东西，则可能需要调整一些配置文件或脚本以指向新的数据目录。如果集群启动时没有错误，那么恭喜您！您几乎拥有一个正常工作的集群。但是，如果没有关于表的良好统计数据，Postgres 就无法生成良好的查询计划。截至撰写本文时，Postgres 不会将数据库统计数据从旧集群复制到新集群。这种情况会在某个时候改变，但在此之前，您需要自己生成统计数据。正如我们上面看到的 pg_upgrade 输出所述，您可以分阶段执行此操作以尽可能快地生成统计数据： 123/usr/pgsql-15/bin/vacuumdb --all --analyze-in-stages 如果您不需要分阶段进行，您可以简单地运行： 123/usr/pgsql-15/bin/vacuumdb --all --analyze-only 2.2.10. 升级扩展Postgres 扩展有版本，可能需要自行升级。升级方式是登录新数据库并发出： 1ALTER EXTENSION foobar UPDATE; 如果 pg_upgrade 能够检测到扩展，您将看到如下消息： 12345Your installation contains extensions that should be updatedwith the ALTER EXTENSION command. The file update_extensions.sqlwhen executed by psql by the database superuser will updatethese extensions. 该文件应包含命令，但您也可以通过运行以下命令生成可能需要升级的扩展列表： 1SELECT * FROM pg_available_extensions WHERE default_version &lt;&gt; installed_version; 成功升级将不会返回任何消息，而不需要的升级将会有提示消息： 123456alter extension hstore update;ALTER EXTENSIONalter extension hstore update;NOTICE: version &quot;1.8&quot; of extension &quot;hstore&quot; is already installedALTER EXTENSION 2.2.11. 升级监控和工具不要忘记更新与数据库交互的所有内容，并告诉它您使用的是新的主要版本。您可能还会有一个新的数据目录，某些工具需要知道它。请记住，主要升级意味着新的集群、新的系统标识符以及新的统计数据。 2.2.12. 再次备份现在是运行另一次备份的好时机，这次是针对新版本。 1pgbackrest backup --stanza=mystanza --type=full 2.2.13. 删除旧集群一切运行良好一段时间后，您可以删除旧集群。在运行结束时，pg_upgrade 会创建一个小型 shell 脚本来帮助完成此操作。此脚本非常简单，并且执行“rm -fr $OLDDATADIR”。最好运行该脚本，无论它看起来多么简单，而不是冒着手滑并删除错误的数据目录的风险！ 2.2.14. 为下一次升级做好准备最后一项任务 - 为下一次升级做好准备！Postgres 每年都会发布一个新的主要版本。因此，每年或每隔一年升级一次主要版本是一个好的解决方案。大约每三个月就会发布一个新的次要版本。您希望立即安装这些版本，因为它们只包含关键的错误修复，并且比上述过程更容易安装！ 3. 参考文档Linux 上安装 PostgreSQL PostgreSQL 备份与恢复 PostgreSQL 数据库版本升级 pgupgrade Examining Postgres Upgrades with pg_upgrade","link":"/database/postgresql_upgrade.html"},{"title":"安装并配置docker-compose","text":"Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。 本文主要讲述如何在 centos 7.9上安装docker compose, 当然此安装步骤也适用于 debian &amp; readhat 系列的其他 linux 发行版. 由于读者的操作系统版本，硬件架构可能会与我的环境不一样，或者随着时间的推移，安装过程可能会发生变化，请自行调整，详细信息如下： 12$ uname -aLinux localhost.localdomain 3.10.0-1160.el7.x86_64 \\#1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 1. 准备阶段确定需要安装的版本 访问 docker-compose 的 release page, 了解当前的最新版本，读一读个版本的 release notes 确定自己要安装的版本 当前最新版本为 2.23.0 2. docker-compose 和 Docker 兼容性Compose 文件格式有多个版本：1、2、2.x、和 3.x。下面的表格是 Compose 文件所支持的指定的 docker 发行版： Compose file format Docker Engine release Compose specification 19.03.0+ 3.8 19.03.0+ 3.7 18.06.0+ 3.6 18.02.0+ 3.5 17.12.0+ 3.4 17.09.0+ 3.3 17.06.0+ 3.2 17.04.0+ 3.1 1.13.1+ 3.0 1.13.0+ 2.4 17.12.0+ 2.3 17.06.0+ 2.2 1.13.0+ 2.1 1.12.0+ 2.0 1.10.0+ 详情请参考：Compose file versions and upgrading 3. 开始安装安装过程很简单，只需要替换要安装的版本 12345sudo curl -L https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 4. 验证查询docker-compose版本 1docker-compose version 输出如下 1Docker Compose version v2.27.0 5. 参考文档docker compose release","link":"/docker/docker_compose_install.html"},{"title":"安装并配置docker","text":"1. 什么是Docker容器？Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。 本文主要讲述如何在Centos 7.9操作系统上安装Docker, 当然本教程也适合RHEL系列的其他Linux发型版本. 2. 为什么需要Docker容器？虚拟机（Virtual Machine，简称VM）的发展，减轻了企业对硬件资源的依赖，它将一台物理设备虚拟为多个逻辑设备，每个逻辑设备可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高设备的工作效率。然而，传统VM需要安装操作系统才能执行应用程序，占用系统资源过多。多数情况下，用户只需要运行简单的应用程序，采用VM技术操作繁琐且造成资源浪费。倘若需要迁移应用服务程序，则需迁移整个VM，因此企业迫切需要轻量级的虚拟化技术。 容器，就是一种轻量级的虚拟化技术，目的和虚拟机一样，都是为了创造“隔离环境”。但是它不像VM采用操作系统级的资源隔离，容器采用的是进程级的系统隔离。Docker作为创建容器的主流工具，近年来迅速发展，它的优势在于可以让开发者将企业需要的各种应用及应用依赖文件封装在Docker镜像文件中，然后在任何物理设备（Linux设备或Window设备等）上安装运行实现虚拟化，让应用程序彻底脱离底层设备，可以在物理机之间灵活迁移部署，使运维工程师摆脱了繁琐的环境部署，极大的提高了工作效率，同时减少了部署过程中的潜在风险。 Docker容器具有以下三大特点： 轻量化：一台主机上运行的多个Docker容器可以共享主机操作系统内核；启动迅速，只需占用很少的计算和内存资源。标准开放：Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。安全可靠：Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台主机。 3. 如何安装Docker3.1. 配置 docker-ce yum 源12345678910111213141516171819# 使用阿里云yum源sudo curl https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo# 或者华为云yum源，两者选其一# for centossudo curl https://repo.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo# for Fedora sudo curl https://repo.huaweicloud.com/docker-ce/linux/fedora/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo# for Alma linuxdnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo# 将download.docker.com替换为华为软件仓库sudo sed -i 's+download.docker.com+repo.huaweicloud.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo# 更新yum源缓存sudo dnf makecache 3.2. 安装docker12345678#选择合适的版本dnf list docker-ce --showduplicates | sort -r#安装指定版本sudo dnf install -y docker-ce-3:24.0.7-1.el7.x86_64# 或者 安装最新版本sudo dnf install -y docker-ce 3.3. 配置 docker3.3.1. 配置镜像加速由于 dockerhub 镜像仓库在国外，访问速度较慢，下载镜像的过程中，多数情况下会因为超时而失败，所以强烈建议配置镜像加速。另外在整个安装过程中主要需要与 internet 上三个镜像仓库打交道 DockerHub, gcr.io 这个几乎不能访问，后面会介绍到如何获得其上相应的镜像 quay.io , 主要是一些网络组件相关的镜像 123456$sudo vi /etc/docker/daemon.json{ &quot;registry-mirrors&quot;: [&quot;https://&lt;你的ID&gt;.mirror.aliyuncs.com&quot;], &quot;live-restore&quot;: true, &quot;debug&quot;: true} 镜像加速列表 提供者 镜像地址 科大镜像 https://docker.mirrors.ustc.edu.cn/ 网易 https://hub-mirror.c.163.com/ 阿里云 &lt;https://&lt;你的ID&gt;.mirror.aliyuncs.com&gt; 七牛云加速器 https://reg-mirror.qiniu.com daocloud 加速器 &lt;http://&lt;你的ID&gt;.m.daocloud.io/&gt; 阿里云获取镜像加速器地址 其他还有华为云镜像加速，显然是为华为云用户准备的，请参考这篇文章进行配置镜像加速 3.3.2. docker iptables FORWARD 策略docker 自 1.13 版起会自动设置 iptables 的 FORWARD 默认策略为 DROP，这可能会影响 kubernetes 集群依赖的报文转发功能，因此，需要在 docker 服务启动后，重新将 FORWARD 链的默认策略设置为 ACCEPT，方式是修改/usr/lib/systemd/system/docker.service 文件，在 “ExecStart=/usr/bin/dockerd” 一行之后新增加一行内容如下： 1ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT 3.4. 启动docker重载完成后即可启动 docker 服务： 1234# 重新加载docker服务设置sudo systemctl daemon-reload# 重启docker服务sudo systemctl start docker 设置为开机自启动 1systemctl enable docker 3.5. 测试docker查看docker版本 12$ docker --versionDocker version 24.0.7, build afdd53b 运行hello-world镜像, 能看到hello world消息, 说明docker镜像配置没有问题 123sudo docker run hello-world 4. 如何卸载Docker?4.1. 删除docker服务1234systemctl stop dockersystemctl disable docker 4.2. 查询已安装的docker安装包首先搜索已安装的docker安装包 12345yum list installed|grep docker# 或者rpm -qa|grep docker 输出 123456containerd.io.x86_64 1.6.24-3.1.el7 @docker-ce-stabledocker-buildx-plugin.x86_64 0.11.2-1.el7 @docker-ce-stabledocker-ce.x86_64 3:24.0.7-1.el7 @docker-ce-stabledocker-ce-cli.x86_64 1:24.0.7-1.el7 @docker-ce-stabledocker-ce-rootless-extras.x86_64 24.0.7-1.el7 @docker-ce-stabledocker-compose-plugin.x86_64 2.21.0-1.el7 @docker-ce-stable 4.3. 删除安装包12yum remove docker-buildx-plugin.x86_64 containerd.io.x86_64 docker-ce-cli.x86_64 docker-ce.x86_64 docker-ce-rootless-extras.x86_64 docker-compose-plugin.x86_64 4.4. 删除docker 镜像123rm -rf /var/lib/docker 5. 相关阅读安装并配置docker-compose","link":"/docker/docker_install.html"},{"title":"Centos7上源码安装git2.x","text":"1. 背景介绍由于运行gitlab pipeline job遇到如下错误 12fatal: git fetch-pack: expected shallow listERROR: Job failed: exit status 1 网上搜索原因, 是因为git的版本过低, 经查询确认, 确实很低还是1.x的git版本. 想通过yum源升级, 发现yum源上的最新版也才1.8.3.1到目前2021-12-14为止要在centos7上安装2.x的 git还是要通过源码安装, 以下是源码安装git的全过程. 2. 博客更新安装完成后发现这里有第三方提供的rpm包 可以下载, 所以现在可以有另一种安装方式可供选择了 即rpm包安装https://pkgs.org/download/git 3. 下载git源码12cd /optwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.22.0.tar.gz 这里我下载的是2.22.0版本的，如果要下载其他版本，把URL后面的版本号修改即可.如果提示cannot verify mirrors.edge.kernel.org’s certificate, 参考 troubleshooting章节. 4. 解压、编译、安装gIt解压源码包 1tar -xvf git-2.22.0.tar.gz 编译进入解压后的源码包, 编译源码编译前需要安装依赖包 1yum -y install openssl-devel curl-devel expat-devel 编译安装 123./configure ./configure --prefix=/usr/localmake prefix=/usr/local allmake prefix=/usr/local install 注意: 这里需要指定prefix, 如果不制定默认会安装到${HOME} 目录下. 如果你知道如何使用checkinstall, 可以尝试使用checkinstall进行安装, 可以参考这篇文章永远不要通过运行将任何东西安装到系统中 make install！如今，大多数makefile都不支持“卸载”目标，因为它们习惯于安装到专用的暂存位置进行测试或制作软件包（.rpm，.deb等），然后软件包管理器负责清理。如果需要安装某些软件，请尝试找到一个官方软件包，或者尝试从较新版本的操作系统中向后移植另一个官方软件包（如果有）。作为最后的选择，请尝试使用checkinstall尝试在运行时创建二进制包的工具make install。这很烂，但仍然比光秃秃的要好make install。 5. 如何卸载很多教程都只讲述了如何安装, 但是知道如何安全,彻底的卸载也很重要. 比如我在安装时,使用了默认的安装目录, git被安装到了/root/git/bin下面, 不是很理想,我希望git 被安装到/usr/local目录下. 所以需要卸载, 重新安装. 此时了解卸载对安装过程,以及安装过程中具体做了些什么很有好处. 以下就是卸载过程. 5.1. 卸载git这是从Makefile截取的一段代码, 从这段代码大致可以看出,git相关的文件路径二进制文件应该都在 $(prefix)/bin, 由于我没有指定prefix,应该使用的是默认prefix 比如我之前没有指定prefix所以默认prefix应为$(HOME) 即/root 1234567891011121314prefix = $(HOME) #/root bindir = $(prefix)/bin #/root/bin mandir = $(prefix)/share/man #/root/share/man infodir = $(prefix)/share/info #/root/share/info gitexecdir = libexec/git-core mergetoolsdir = $(gitexecdir)/mergetools # /root/libexec/git-core/mergetools sharedir = $(prefix)/share # /root/share gitwebdir = $(sharedir)/gitweb # /root/share/gitweb perllibdir = $(sharedir)/perl5 # /root/share/perl5 localedir = $(sharedir)/locale # /root/share/locale template_dir = share/git-core/templates htmldir = $(prefix)/share/doc/git-doc # /root/share/doc/git-doc ETC_GITCONFIG = $(sysconfdir)/gitconfig # /etc/gitconfig ETC_GITATTRIBUTES = $(sysconfdir)/gitattributes # /etc/gitattributes 所以大致可以确定设计到的目录和文件有以下几个, 如果你没有使用源码方式安装过其他软件, 基本上这些目录下都是git相关的文件, 如果你以源码方式安装过其他软件, 请小心卸载, 以免影响其他程序.通过grep Makefile得到gitexec_instdir = $(prefix)/$(gitexecdir) 实际值为/root/libexec/git-core$(sysconfdir)应该等于/etc所以在没有源码安装其他软件的前提下,再次强调是没有没有源码安装其他软件的前提下, 如果有其它软件干扰请谨慎移除.应该移除以下目录和文件为:/root/bin 目录 123456789$tree /root/bin/root/bin├── git├── git-cvsserver├── gitk├── git-receive-pack├── git-shell├── git-upload-archive└── git-upload-pack /root/share 目录 1234567/root/share├── git-core├── git-gui├── gitk├── gitweb├── locale└── perl5 /root/libexec 目录 12/root/libexec/└── git-core /etc/gitconfig 文件/etc/gitattributes 文件 6. 问题排查12345--2021-12-14 21:38:58-- https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.22.0.tar.gzResolving mirrors.edge.kernel.org (mirrors.edge.kernel.org)... 147.75.95.133, 2604:1380:3000:1500::1Connecting to mirrors.edge.kernel.org (mirrors.edge.kernel.org)|147.75.95.133|:443... connected.ERROR: cannot verify mirrors.edge.kernel.org's certificate, issued by ‘/C=US/O=Let's Encrypt/CN=R3’: Issued certificate has expired. 错误：无法验证Gcc.GNU.org的证书，由’/C= U/O＝=让我们加密/CN=让加密权限X3’：无法在本地验证发行者的权限。 为了安全地连接到GC.GNU.ORG，请使用“无检查证书”。此时使用以下命令即可[root@gaojingbo yum.repos.d]# yum install -y ca-certificates 7. 参考文章Centos7安装Git2.x + Apache 搭建Git Http Server Centos 7.2安装git和卸载git","link":"/git/centos7_install_git_via_sourcecode.html"},{"title":"如何配置git push","text":"1. 背景介绍有时我们在push代码时候，需要写很长一段命令，尤其在branch的名字非常长的时候，而且在团队合作的环境中，分支名都是自解释型的，名称通常都很长。当然在理解git原理的前提下，可以自己写shell脚本去读取当前分支名，将很长的一串命令缩短，配置一个简短的别名去调用脚本，也是可以的。这里介绍一种简单的通过配置git configuration方式达到使用git push将change推送到远程同名分支的方式。 2. git push介绍git push默认行为是将本地所有与远程同名的分支推送到远程，这种默认行为往往不是我们期望的。为了能让用户这种行为，git为我们提供了push.default选项。这个选项有如下几个值：nothing - 不要推任何东西.matching - 推送所有匹配的分支。两端具有相同名称的所有分支都被认为是匹配的。这是默认设置。.upstream - 将当前分支推送到其上游分支.tracking - 已不推荐使用，是upstream的同义词.current - 将当前分支推送到同名分支.simple -（Git 1.7.11 新增，自 Git 2.0 起默认）类似于上游，但如果上游分支的名称与本地分支名称不同，则拒绝推送。 如果您想查询当前设置，可以执行以下操作。默认情况下，它将返回matching。 12$ git config --global push.defaultmatching 如果我们要将其更改为仅推送当前分支，可以执行继续说： 1git config --global push.default simple 说明: 省略 –global 标志只会为当前存储库更改它。由于很难记住哪个项目哪个项目使用哪种默认行为方式，因此建议使用 –global选项将起设置为全局配置。 无论您使用哪个选项，手动执行长命令 git push origin my-branch 以明确仅推送您当前的分支还是有效的，不会受到任何影响。 警告: 对于我们大多数人来说，current是最安全的推动行为。但是，它有一个小的副作用：当远程上不存在具有你本地名称的分支时，它会自动在远程上创建它。虽然这通常是您想要的，但它不会在您的本地和远程分支之间设置跟踪。这意味着 git pull 将不起作用，并且当您的本地和远程分支不同时，Git pull得到任何提示信息。要在远程和设置跟踪上创建具有相同名称的分支，请使用 -u 选项： 1git push -u 如果您不小心创建了远程分支，但忘记设置跟踪，您也可以再次运行 git push -u 。如果您当前无法推送，请使用 123git branch --set-upstream-to=origin/$(git rev-parse --abbrev-ref HEAD)#或者：for git 2.22 or abovegit branch --set-upstream-to=origin/$(git branch -show-current) 3. 参考文档github docs Git: How to configure git to push only your current branch","link":"/git/how_to_configure_git_push.html"},{"title":"Centos7上搭建git服务器","text":"1. 说明Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。虽然git不必依赖一个中心化的仓库来工作, 但是中心化的仓库也能带来很多好处, 比如方便团队写作, 本文主要讲述, 如何配置git服务器, 让多人通过ssh协议的方式访问服务器端的代码仓库. 2. 第一步: 在Centos7上安装git1yum install git 3. 第二步: 配置git用户3.1. 添加git用户12345adduser git#建立账户adduser git# 打开配置文件vi /etc/passwd 修改git用户的login shell.为什么要修改login shell呢? 其一是出于安全考虑, 当你将对方用户的public key添加到authorized_key文件后, 如果git用户的登录shell依然是/bin/bash, 理论上其他用户是可以以git用户登录到服务器的, 这样会很不安全. 我能允许其他用户做的仅仅是clone, push, pull等操作. 其二 如果不改为git-shell其他用户也不能正常使用git 下面是git用户设置修改前和修改的比较 1234原始值 git:x:1000:1000::/home/git:/bin/bash 修改后值git:x:1000:1000::/home/git:/usr/bin/git-shell 4. 第三步 配置sshd服务我们知道git客户端可以使用ssh协议 或者https协议与服务器通信. 这里我们在服务器端配置的是ssh协议 4.1. 首先, 开启 SSH RSA 验证12# 打开sshd配置文件 vi /etc/ssh/sshd_config 修改一下一些配置 123原始值 修改后值#RSAAuthentication yes RSAAuthentication yes#PubkeyAuthentication yes PubkeyAuthentication yes 修改连接超时时间 123456789原始值 #ClientAliveInterval 0 #ClientAliveCountMax 3 修改后值ClientAliveInterval 0 #修改保持连接时间，ClientAliveCountMax 3 #修改保持连接次数。 设置ssh超时断连 1vim /etc/profile 在HOSTNAMEHISTIZE后追加timeout超时时间TMOUT=600；600表示超过300秒无操作即断开连接。并确保 “AuthorizedKeysFile” 的值为 “.ssh/authorized_keys”。重启 SSH 服务。 1systemctl restart sshd.service 5. 第四步 创建首个仓库123456789# 进入目录 cd /home/git# 创建 Git 仓库 [name] 为仓库名 git init --bare [name].git# 修改仓库的owner为 git 用户chown -R git.git [name].gitchown -R git.git /home/git/.ssh/ 6. 第五步 授权用户访问123456# 创建目录mkdir /home/git/.ssh# 进入目录 cd /home/git/.ssh#创建文件 touch /home/git/.ssh/authorized_keys 注意: 客户端使用ssh-keygen生成公钥私钥对, 如果已经有公钥, 可直接将公钥添加到服务器端的授权访问文件/home/git/.ssh/authorized_keys 7. 第五步 客户端克隆项目客户端 12# 拷贝仓库 [server ip] 为服务端 IPgit clone git@[server ip]:/home/git/[name].git 如果能成功克隆项目, 表示服务器端安装和配置成功. 如果不能, 检查网络连接, 检查防火墙等等. 8. 关联阅读Centos7上源码安装git2.x gitlab安装升级及迁移 gitlab-runner安装与配置 如何配置git push","link":"/git/install_setup_git_server.html"},{"title":"Windows上安装git2.x","text":"1. Windows上安装git2.x 转到Git download page并根据您的机器配置下载安装程序。 执行安装程序。 如果要在任何备用位置上安装节点，请选择安装路径。 我建议使用默认选项。 验证是否已使用此命令安装了节点。 12$ git --versiongit version 2.17.1.windows.2 另外，运行以下命令来设置您的git身份, 这些信息会写入每次commit中, 以标明代码作者的身份, 以及联系方式. 1234#Use your git email id$ git config --global user.email &quot;you@example.com&quot;# Use your git name$ git config --global user.name &quot;Your Name&quot; 2. 配置ssh key1234567891011121314151617181920212223242526$ ssh-keygen -oGenerating public/private rsa key pair.Enter file in which to save the key (/home/schacon/.ssh/id_rsa):Created directory '/home/schacon/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/schacon/.ssh/id_rsa.Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.The key fingerprint is:d0:82:24:8e:d7:f1:bb:9b:33:53:90:09:49:da:9b:e3 schacon@mylaptop.local``` 首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。 然而，如果你使用了密码，那么请确保添加了 -o 选项，它会以比默认格式更能抗暴力破解的格式保存私钥。 你也可以用 ssh-agent 工具来避免每次都要输入密码。```bash$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local 关于在多种操作系统中生成 SSH 密钥的更深入教程，请参阅 GitHub 的 SSH 密钥指南。","link":"/git/windows_install_git.html"},{"title":"命令行打包Firefox插件","text":"在开发过程中，您的扩展将由一个目录组成，其中包含一个manifest.json文件和扩展所需的其他文件（脚本、图标、HTML 文档等）。您需要将它们压缩到一个文件中才能上传到 AMO。 Firefox 中的打包扩展称为“XPI 文件”，它们是具有不同扩展名的 ZIP 文件。上传到 AMO 时不必使用 XPI 扩展。 打包扩展最方便的方法是使用web-ext build. 该工具会自动排除包中通常不需要的文件，例如.git文件。否则，请按照以下适合您的操作系统的说明进行操作。 web-ext build详情请参考web-ext-build 和 web ext github repo 提示： ZIP 文件必须是扩展程序文件本身的 ZIP，而不是包含这些文件的目录的 ZIP。 提示：验证 ZIP 文件的格式是否正确，例如通过在 Firefox 中加载文件about:debugging。 1. windows上打包firefox插件 打开包含扩展文件的目录。 选择实现扩展所需的文件和目录，排除运行扩展不需要的那些文件，例如.git、图形源和类似文件。 打开快捷菜单，然后单击“发送到压缩文件夹” 。 2. macOS（图形界面）上打包firefox插件 打开包含扩展文件的目录。 选择实现扩展所需的文件和目录，排除运行扩展不需要的那些文件，例如.git、图形源和类似文件。 打开快捷菜单并单击“压缩 n 项”。 3. Linux / macOS 终端中打包firefox插件 打开终端。 使用命令打开包含扩展文件的目录 cd path/to/my-extension/。 使用zip命令压缩目录的内容 - 请记住排除运行扩展不需要的那些文件，例如.git、图形源和类似文件。 123zip -r -FS ../my-extension.zip * --exclude '*.git*' 4. 参考文档Package your extension Firefox 中的附加组件签名 Signing and distributing your add-on","link":"/firefox/cli_build_firefox_extension.html"},{"title":"gitlab CICD基础","text":"1. Gitlab CI/CD 基础课程主要内容 为什么要做CI/CD? GitLab CI/CD GitLabCI vs JenkinsCI 1.1. 为什么要做CI/CD?1.1.1. 传统应用发布署模式 开发团队 在开发环境中完成软件开发，单元测试，测试通过，提交到代码版本管理库 运维团队 把应用部署到测试环境，供QA团队测试，测试通过后部署生产环境． QA团队 进行测试，测试通过后通知部署人员发布到生产环境． 1.1.2. 传统应用发布署模式面临的挑战 错误发现不及时 很多错误在项目的早期就存在，到最后集成的时候才发现问题 容易发生人工低级错误 产品和服务交付中的关键活动全部需要手动操作 团队工作效率低 需要等待他人的工作完成后才能进行自己的工作 开发运维对立 开发人员想要快速更新，运维人员追求稳定，各自的针对的方向不同 1.1.3. CI/CD 持续集成(CI) 持续集成的目的： 尽快发现错误或问题，减少集成问题，避免复杂问题 合并开发人员正在开发编写的所有代码的一种做法 通常一天内进行多次合并和提交代码． 从存储库或生产环境中进行构建和自动化测试，以确保没有集成问题并及早发现任何问题． 连续交付(CD) 持续交付的目标：每次更改都可发布，降低每次发布风险，更加频繁地交付价值，快速频繁客户反馈 通常可以通过将更改自动推送到发布系统来随时将软件发布到生产环境中 持续布署会更进一步，并自动将更改推送到生产中． 1.1.4. 代码版本管理 - GITLAB 代码审核 问题追踪 动态订阅 易于扩展 项目wiki 多角色项目管理 项目代码在线预览 CI工具集成 2. GitLab CI/CD 特性2.1. GitLab内置持续集成持续集成(CI) 集成团队中每个开发人员提交的代码到代码库存储中． 开发人员merge或者pull请求中合并拉取新代码． 在提交或者合并更改到代码存储库之前，会触发构建，测试和新代码验证的管道． CI可帮助您在开发周期的早期发现并减少错误持续交付(CD) 可通过结构化的部署管道确保将经过CI验证的代码交付给您的应用程序． CD可以将经过验证的代码更快地移至您的应用程序． CI/CD一起可以加快团队为客户和利益相关者交付成果的速度．CI和CD必须无缝协作，以使得您的团队快速有效地进行构建， 并且对于确保完全优化的开发实践至关重要． 2.2. Gitlab CI/CD 优势 开源： CI/CD是开源Gitlab社区和专有Gitlab企业版的一部分． 易于学习：具有详细的入门文档 无缝集成：Gitlab CI/CD是Gitlab的一部分，支持从计划到部署，具有出色的用户体验． 可扩展: 测试可以在单独的计算机上分布式运行，可以根据需要添加任意数量的计算机． 更快的结果: 每个构建可以拆分为多个作业，这些作业可以在多台计算机上并行运行． 针对交付进行了优化: 多个阶段，手动部署，环境和变量 2.3. Gitlab CI/CD 特点 多平台：Unix, Windows, macOS和任何其他支持Go的平台上执行构建． 多语言：构建脚本是命令行驱动的，并且可以与java, PHP, Ruby, C和任何其他语言一起使用． 稳定构建：构建在与gitlab不同的机器上运行． 并行构建：Gitlab CI/CD在多台机器上拆分构建，以实现快速执行． 实时日志记录：合并请求中的链接将您带到动态更新的当前构建日志． 灵活的管道：您可以在每个阶段定义多个并行作业，并且可以触发其他构建． 版本管道: 一个.gitlab-ci.yml文件包含你的测试，整个过程的步骤，使每个人都能贡献更改，并确保分支获得所需的管道． 自动缩放：您可以自动缩放构建机器，以确保立即处理您的构建并将成本降至最低． 构建工件： 您可以将二进制文件和其他构建工件上载到gitlab并浏览和下载它们． Docker支持：可以使用自定义Docker镜像，作为测试的一部分启动服务， 构建新的Docker映像，甚至可以Kubernets上运行． 容器注册表: 内置的容器注册表，用于存储，共享和使用容器映像 受保护的变量： 在部署期间使用受每个环境保护的变量安全的存储和使用机密． 环境: 定义多个环境． 2.4. GitLab CI/CD工作原理 将代码托管到Git存储库． 在项目根目录创建CI文件.gitlab-ci.yml, 在文件中指定构建，测试，和部署脚本． Gitlab将检测到它并使用名为Gitlab Runner的工具运行脚本． 脚本被分组为作业，它们共同组成了一个管道． 3. Gitlab CI与Jenkins对比Jenkins 是一个广泛用于持续集成的可视化web自动化工具，Jenkins可以很好的支持各种语言的项目构建，也完全兼容ant, maven, gradle 等多种第三方构建工具，同时跟svn, git能无缝集成， 也支持直接与知名源代码托管网站，比如github, bitbucket直接集成， 并且插件众多，在这么多年的技术积累之后，在国内大部分公司都有使用jenkins. gitlab-CI是gitlab8.0之后自带的一个持续集成系统，中心思想是当每一次push到gitlab的时候，都会触发一次脚本执行，然后脚本的内容包括了测试，编译，部署等一系列自定义的内容．gitlab-Ci的脚本执行，需要自定义安装对应gitlab-runner来执行，代码push之后，webhook检测到代码变化，就会触发gitlab-CI, 分配到各个Runner来运行相应的脚本script. 这些脚本有的测试项目用的，有的是部署用的． 3.1. 对比点1- 分支可配置性分支的可配置性 使用Gitlab Ci, 新创建的分支无需任何进一步配置即可立即使用CI管道中的已定义作业． Jenkins 2 基于gitlab的多分支流水线可以实现，相对配置来说gitlab更加方便一些． 3.2. 对比点2- 定时执行构建有时，根据时间触发作业或整个管道会有所帮助，例如， 常规的夜间定时构建． 使用Jenkins 2可以立即使用， 可以在应执行作业或管道的那一刻以cron 式语法定义． Gitlab CI 没有此功能．但是, 可以通过一种变通办法来使用WebAPI使用同一台或另一台服务器上的Cronjob触发作业和管道．尽管使用gitlab CI无法做到这一点，其实如果配置了提交代码即触发流水线，那么最后一次提交触发什么时候没有什么不同，反而减少未提交代码的定时构建资源浪费． 3.3. 对比点3- 拉取请求支持拉取请求支持如果很好地集成了存储库管理器和CI/CD平台，您可以看到请求的当前构建状态．使用这种功能，可以避免将代码合并到不起作用或无法正确构建的主分支中． Jenkins没有与代码管理系统进一步集成，需要管理员自行写代码或插件实现． Gitlab与CI平台紧密集成，可以方便查看每一个打开和关闭拉动请求的运行和完成管道． 3.4. 对比点４- 权限管理权限管理从存储管理器继承的权限管理对于不想为每个服务分别设置每个用户权限的大型开发人员或组织团队很有用．大多数情况下，两种情况下的权限都是相同的，因此默认情况下应该将它们配置在一个位置．由于Gitlab与GitlabCi的深度整合， 权限可以统一管理．由于Jenkins 2没有内置的存储库管理器， 因此它无法直接在存储库管理器和CI/CD平台之间合并权限． 3.5. 对比点５- 存储库交互 gitlab CI是git存储库管理器的固定组件， 因此在CI/CD流程和存储库功能之间提供良好的交互． Jenkins 2与存储库管理器都是松散耦合的，因此在选择版本控制系统时它非常灵活． 此外，就像其前身一样，Jenkins2强调了对插件的支持，以进一步扩展或改善软件的现有功能． 3.6. 对比点6 - 插件管理 扩展Jenkins的本机功能是通过插件完成的．插件的维护，保护和升级成本很高． Gitlab是开放式的，任何人都可以直接向代码库贡献更改，一旦合并，它将自动测试并维护每一个更改． 3.7. 总结gitlab CI 轻量级，不需要复杂的安装手段． 配置简单， 与gitlab可直接适配． 实时日志十分清晰UI交互体验很好． 使用YAML进行配置，任何人都可以很方便的使用． 没有统一的管理界面，无法统筹管理所有项目 配置依赖于代码仓库，耦合度没有Jenkins低 Jenkins 编译服务和代码仓库分离，耦合度低; 插件丰富，支持语言众多． 有统一的web管理界面． 插件以及自身安装较为复杂． 体量较大，不是很适合小型团队． GitLabCI有助于DevOps人员，例如敏捷开发中，开发与运维是同一个人，最便捷的开发方式．JenkinsCI适合在多角色团队中，职责分明，配置和代码分离，插件丰富． 4. 安装部署Gitlabgitlab 三种按照方式 yum 安装 docker镜像安装 k8s安装 5. Gitlab Runner5.1. Gitlab runner简介 Gitlab Runner是一个开源项目， 用于运行作业并将结果发送回gitlab. 与GitlabCI结合使用，GitlabCI是Gitlab随附的用于协调作业的开源持续集成服务． Gitlab Runner是用Go编写的，可以在Linux, macOS和Windows操作系统上运行 容器部署需要使用最新Docker版本，GitLab Runner需要至少Docker v1.13.0 GitLab Runner版本应与Gitlab版本同步(避免版本不一致导致不兼容) 可以根据需要配置任意数量的Runner GitLabRunner类似于Jenkins的agent, 执行CI持续集成，构建的脚本任务． 5.2. Gitlab runner特点 作业运行控制：同时执行多个作业 作业运行环境： 在本地，使用docker容器，使用Docker容器并通过SSH执行作业． 使用Docker容器在不同的云和虚拟化管理程序上自动缩放． 连接到远程SSH服务器． 支持bash, Windows batch和Windows PowerShell 允许自定义作业运行环境 自动重新加载配置，无需重启． 易于安装，可作为Linux, macOS和Windows的服务 5.3. Gitlab runner类型与状态 类型 shared 共享类型，运行整个平台项目的作业(gitlab) group 项目组类型，运行特点group下的所有项目的作业(group) specific 项目类型，运行指定的项目作业(project) 状态 locked：锁定状态，无法运行项目作业 paused：暂停状态，暂时不会接受新的作业 5.4. Gitlab Runner安装5.4.1. Gitlab Runner安装环境 系统环境：可以在Linux, macOS, FreeBSD和Windows上安装和使用Gitlab Runner 部署方式: 二进制文件，rpm/deb软件包，Docker, Kubernetes 5.5. Gitlab Runner注册5.5.1. timeout 超时作业级别的超时可以超过项目级别超时, 但不能超过Runner特定的超时.runner 超时时间在runner的配置里面设置项目的超时在项目的配置中设置job的超时时间在yaml配置文件中定义example 1234567build: script: build.sh timeout: 3 hours 30 munutestest: script: repec timeout: 3h 30m 示例1: runner超时大于项目超时runner超时设置为24小时, 项目的CI/CD超时设置为2小时.该job将在2小时后超时 示例2: 未配置runner超时runner不设置超时时间, 项目的CI/CD超时设置为2小时该job将在2小时后超时. 示例3: runner超时小于项目超时runner超时时间设置为30分钟, 项目的CI/CD超时设置为2小时该job将在30分钟后超时. runner超时如果小于项目定义的超时时间将具有优先权. 此功能可用于通过设置大超时(例如一个星期)来防止Shared Runner被项目占用. 未配置时, Runner超时设置将不会覆盖项目超时. 5.5.2. parallel 并行作业配置要并行运行的作业实例数, 此值必须大于或等于2并且小于或等于50.这将创建N个并行运行的同一作业实例. 它们从job_name 1/N 到job_name N/N依次命名. 12345678910codescan: stage: codescan tags: - build only: - master script: - echo &quot;codescan&quot; - sleep: 5 parallel: 5 5.5.3. only &amp; excpet 限制分支标签 only和except用分支策略来限制jobs构建: only定义哪些分支和标签的git项目将会执行该job except定义哪些分支和标签的git项目将不会执行该job 1234567job: # use regexp only: - /^issue-.*$ # use special keyword except: - branches 5.5.4. rules 构建规则 rules允许按顺序评估单个规则, 直到匹配并为作业动态提供属性. rules不能与only/except组合使用. 可用的规则:if (如果条件匹配)changs (指定文件发生变化)exists (指定文件存在) 5.5.4.1. rules - if (如果条件匹配)例子:如果domain的值匹配对应的if条件, 则执行对应的运行方式默认为on_success条件判断从上到下, 匹配即停止多条件匹配可以使用&amp;&amp; || 1234567891011121314151617variables: DOMAIN: example.comcodescan: stage: codescan tags: - build script: - echo &quot;codescan&quot; - sleep 5 rules: - if: '$DOMAIN == &quot;example.com&quot;' when: manual - if: '$DOMAIN == &quot;xyz.com&quot;' when: delayed start_in: '5' - when : on_success 5.5.4.2. rules - changs (指定文件发生变化)接受文件路径数组.如果提交中Dockerfile文件发生变化则为true 123456789101112131415161718variables: DOMAIN: example.comcodescan: stage: codescan tags: - build script: - echo &quot;codescan&quot; - sleep 5 rules: - changes: - Dockerfile when: manual - if: '$DOMAIN == &quot;xyz.com&quot;' when: delayed start_in: '5' - when : on_success 5.5.5. rules - allow_failure使用allow_failure: truerules: 在不停止管道本身的情况下允许作业失败或手动作业等待操作. 123456job: script: echo &quot;hello, rules&quot; rules: - if: &quot;$CI_MERGE_REQUEST_TARGET_BRANCH_NAME&quot; == &quot;master&quot; when: manual allow_failure: true 在此示例中, 如果第一个规则匹配, 则作业将具有以下when: manual和allow_failure: true 5.5.6. workflow 结合rules 进行管道创建 顶级workflow关键字适用于整个管道, 并将确定是否创建管道. when: 可以设置为always或never, 如果未提供, 则默认值always. 12345678variables: DOMAIN: example.comworkflow: rules: - if: '$DOMAIN == &quot;example.ocm&quot;' when: always - when: never 5.5.7. cache 缓存存储编译项目所需的运行时依赖项, 指定项目工作空间中需要在job之间缓存的文件或目录.全局cache定义在job之外, 针对所有job生效, job中的cache优先于全局.job 12345build: script: test cache: paths: - target/*.jar 由于缓存是在job之间共享的, 如果不同的job使用不同的路径就出现了缓存覆盖的问题.如何让不同的job缓存不同的cache呢?设置不同的cache: key可以防止缓存覆盖 123456789cache: paths: - my/filesbuild: script: echo &quot;hello&quot; cache: key: build paths: - target/ 5.5.7.1. cache: key 缓存标记为缓存做个标记, 可以配置job, 分支key来实现分支,作业特定的缓存.为不同job定义了不同的cache:key时, 会为每个job分配一个独立的cache.cache:key变量可以使用任何预定义变量,默认为default从gitlab9.0开始, 默认情况下所有内容都在管道和作业之间共享. 按分支设置缓存 cache: key: ${CI_COMMIT_REF_SLUG} 5.5.7.2. cache: key: files 文件变化自动创建缓存files: 文件发生变化自动重新生成缓存files最多指定两个文件, 提交的时候检查指定的文件.根据指定的文件生成密钥计算SHA校验和, 如果文件未改变值为default. 12345678cache: key: files: - Gemfile.clock - package.json paths: - vendor/ruby - node_modules prefix: 允许给定prefix的值与指定文件生成的密钥组合.在这里定义了全局的cache, 如果文件发生变化则值为rspec-xxx111122222, 未变化为rspec-default 12345678910111213cache: key: files: - Gemfile.lock prefix: ${CI_JOB_NAME} paths: - vendor/rubyrespec: script: - bundle exec rspec 5.5.7.3. cache: policy - 缓存策略默认: 在执行开始时下载文件, 并在结束时重新上传文件.policy: pull跳过下载步骤, policy: push跳过上传步骤. 123cache: policy: pull # 不下载缓存 5.5.8. Git Strategy（git策略）你可以通过在全局变量设置位置或者job局部变量设置位置来设置GIT_STRATEGY用以获取应用最近更新的代码。如果没有指定，默认的项目设置将会被使用。 该选项有三个可能的值：clone,fetch和none clone clone是最慢的选项，如果设置该值，每个job将会都克隆一遍仓库，确保项目工作空间总是原始的正确的。 1234variables: GIT_STRATEGY: clone fetch fetch是更快的操作选项，因为他重用了项目的工作空间（如果没有的话，会去clone. 12variables: GIT_STRATEGY: fetch none none也同样重用了项目空间（但是他会跳过所有git操作，包括如果存在的gitlab runner的预克隆脚本）。其主要用于只是为了操作artifacts的job上（例如depoly部署行为）。此时Git仓库的数据可能是存在的，但它一定不是最新的。所以在设置了none的job里你应该依赖从cache或者artifacts来的数据，而不是仓库数据。 1234variables: GIT_STRATEGY: none 6. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner 7. 参考文档黑马程序员-Gitlab CICD gitlab-ci配置详解(二)","link":"/gitlab/gitlab-cicd-basic.html"},{"title":"gitlab-runner常用命令","text":"本文主要讲述如何使用 gitlab-runner cli 命令。 1. 注册 gitlab-runner123456## 无人值守模式gitlab-runner register --name my-runner --url http://gitlab.example.com --registration-token my-registration-token## 交互式gitlab-runner register 2. 注销1234567891011# 取消注册所有附加的注册者gitlab-runner unregister --all-runners# 要取消注册特定的runner，首先通过执行gitlab-runner list获取注册者的详细信息gitlab-runner list# 再根据信息注销，按注册令牌gitlab-runner unregister --url http://gitlab.example.com/ --token t0k3n# 按名字gitlab-runner unregister --name hj_project 3. 参考文档gitlab-runner 常用命令 GitLab Runner 命令","link":"/gitlab/gitlab-runner_cli.html"},{"title":"破解Gitlab ee 15 企业版","text":"1. 前言 2. 安装gitlab-ee企业版 3. 环境说明 4. 安装必要软件 4.1. 安装ruby 4.2. 安装gitlab-license 5. 破解方法 6. 关联阅读 7. 参考文档 1. 前言在破解之前, 我们要确保我们安装了合适版本的gitlab, 本文适用于gitlab 13, 14, 15等多个版本, 因为我是一路从gitlab13升级到15的, 对这些版本我都有亲自测试过, 此方法有效. 对于gitlab 16由于没有亲测过, 适用性未知, 希望试验过的朋友留言告知我, 在此提前表示感谢. 使用此教程的前提: 需要安装gitlab-ee 企业版 需要安装Ruby环境 2. 安装gitlab-ee企业版关于如何安装配置gitlab-ee可以参考我的文章 鹏叔的技术博客 - gitlab安装升级及迁移 3. 环境说明当前我的gitlab版本及环境如下: 操作系统版本: Centos 7.9 gitlab-ee版本为: 15.8.1-ee 12345678910111213141516171819202122232425262728293031$gitlab-rake gitlab:env:infooutput:System informationSystem:Proxy: noCurrent User: gitUsing RVM: noRuby Version: 2.7.7p221Gem Version: 3.1.6Bundler Version:2.3.15Rake Version: 13.0.6Redis Version: 6.2.8Sidekiq Version:6.5.7Go Version: unknownGitLab informationVersion: 15.8.1-eeRevision: c49deff6e37DB Adapter: PostgreSQLDB Version: 13.8URL: http://gitlab.example.comHTTP Clone URL: http://gitlab.example.com/some-group/some-project.gitSSH Clone URL: git@gitlab.example.com:some-group/some-project.gitElasticsearch: noGeo: noUsing LDAP: noUsing Omniauth: yesOmniauth Providers: 4. 安装必要软件4.1. 安装ruby 安装ruby： 12# 查看ruby版本yum list ruby --showduplicates | sort -r 在Centos7.9中，通过yum安装ruby的版本是2.0.0，但是本破解过程需要2.5或以上版本的ruby环境所以需要先添加ruby25 yum源再安装ruby 12345678910111213141516yum install centos-release-scl-rh # 会在/etc/yum.repos.d/目录下多出一个CentOS-SCLo-scl-rh.repo源yum install -y rh-ruby25 # 直接yum安装即可 scl enable rh-ruby25 bash # 必要的一步# 如果遇到ruby找不到的情况, 修改以下两个环境变量export PATH=$PATH:/opt/rh/rh-ruby25/root/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/rh/rh-ruby25/root/lib64ruby -v //查看安装版本# ruby 2.5.9p229 (2021-04-05 revision 67939) [x86_64-linux]gem -v //查看gem安装版本2.7.6.3 4.2. 安装gitlab-license1gem install gitlab-license 5. 破解方法 创建一个rb文件 12cd /var/opt/gitlab/backupscat &gt; license.rb 将如下内容拷贝到license.rb 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071require &quot;openssl&quot;require &quot;gitlab/license&quot;key_pair = OpenSSL::PKey::RSA.generate(2048)File.open(&quot;license_key&quot;, &quot;w&quot;) { |f| f.write(key_pair.to_pem) }public_key = key_pair.public_keyFile.open(&quot;license_key.pub&quot;, &quot;w&quot;) { |f| f.write(public_key.to_pem) }private_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key&quot;)Gitlab::License.encryption_key = private_keylicense = Gitlab::License.newlicense.licensee = {&quot;Name&quot; =&gt; &quot;none&quot;,&quot;Company&quot; =&gt; &quot;none&quot;,&quot;Email&quot; =&gt; &quot;example@test.com&quot;,}license.starts_at = Date.new(2021, 1, 1) # 开始时间license.expires_at = Date.new(2050, 1, 1) # 结束时间license.notify_admins_at = Date.new(2049, 12, 1)license.notify_users_at = Date.new(2049, 12, 1)license.block_changes_at = Date.new(2050, 1, 1)license.restrictions = {active_user_count: 10000,}puts &quot;License:&quot;puts licensedata = license.exportputs &quot;Exported license:&quot;puts dataFile.open(&quot;GitLabBV.gitlab-license&quot;, &quot;w&quot;) { |f| f.write(data) }public_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key.pub&quot;)Gitlab::License.encryption_key = public_keydata = File.read(&quot;GitLabBV.gitlab-license&quot;)$license = Gitlab::License.import(data)puts &quot;Imported license:&quot;puts $licenseunless $licenseraise &quot;The license is invalid.&quot;endif $license.restricted?(:active_user_count)active_user_count = 10000if active_user_count &gt; $license.restrictions[:active_user_count] raise &quot;The active user count exceeds the allowed amount!&quot;endendif $license.notify_admins?puts &quot;The license is due to expire on #{$license.expires_at}.&quot;endif $license.notify_users?puts &quot;The license is due to expire on #{$license.expires_at}.&quot;endmodule Gitlabclass GitAccess def check(cmd, changes = nil) if $license.block_changes? return build_status_object(false, &quot;License expired&quot;) end endendendputs &quot;This instance of GitLab Enterprise Edition is licensed to:&quot;$license.licensee.each do |key, value|puts &quot;#{key}: #{value}&quot;endif $license.expired?puts &quot;The license expired on #{$license.expires_at}&quot;elsif $license.will_expire?puts &quot;The license will expire on #{$license.expires_at}&quot;elseputs &quot;The license will never expire.&quot;end 生成 GitLabBV.gitlab-license license_key license_key.pub 这三个文件。 使用以下命令生成 GitLabBV.gitlab-license license_key license_key.pub 这三个文件 12cd /var/opt/gitlab/backupsruby license.rb license_key.pub 这个是颁布的公钥license_key 这个是私钥, 理论上拥有这个这个私钥就可以给更多gitlab instance颁发的公钥.GitLabBV.gitlab-license 这个文件是许可文件. 使用许可证 首先备份 /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub 1cp /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub.backup 用 license_key.pub 文件替换 /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub文件 1cp /var/opt/gitlab/backups/license_key.pub /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub 修改等级 将登记从STARTER_PLAN修改为ULTIMATE_PLAN 1234567891011--- /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb+++ /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb@@ -367,7 +367,7 @@enddef plan- restricted_attr(:plan).presence || STARTER_PLAN+ restricted_attr(:plan).presence || ULTIMATE_PLANenddef edition 重启gitlab 1gitlab-ctl restart 刚刚ruby license.rb执行后生成的三个文件其中 GitLabBV.gitlab-license 即是许可证，浏览器打开gitlab管理页面 http://${your_gitlab_server_address}/admin/application_settings/general 例如:http://localhost:8080/admin/application_settings/general 展开 add license 勾选Enter license key, 填入license, 勾选terms of service 点击add license按钮, 当看到这段话, 表示成功。The license was successfully uploaded and is now active. You can see the details below. 6. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 7. 参考文档破解Gitlab EE docker安装gitlab-ee并破解","link":"/gitlab/gitlab_ee_crack.html"},{"title":"gitlab安装升级及迁移","text":"1. gitlab简介 2. 安装环境介绍 3. gitlab 安装 4. 系统要求 4.1. 安装准备工作 4.2. 开始安装gitlab 5. gitlab升级 5.1. 升级前备份 5.2. 开启yum缓存 5.3. 开始升级 6. gitlab迁移 6.1. 备份数据 6.2. 在新服务器上安装gitlab 6.3. 还原备份 7. 如何彻底卸载gitlab? 7.1. 卸载前备份 7.2. 执行卸载 8. 问题排查 9. 关联阅读 1. gitlab简介GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。GitLab是由GitLabInc.开发，使用MIT许可证的基于网络的Git仓库管理工具，且具有wiki和issue跟踪功能。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。GitLab由乌克兰程序员DmitriyZaporozhets和ValerySizov开发，它使用Ruby语言写成。后来，一些部分用Go语言重写。截止2018年5月，该公司约有290名团队成员，以及2000多名开源贡献者。GitLab被IBM，Sony，JülichResearchCenter，NASA，Alibaba，Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX等组织使用。 2. 安装环境介绍服务器的操作系统为CentOS Linux release 7.9.2009包管理工具yum.这里安装的是gitlab企业版，本教程可以作为社区版安装的参考资料，社区版安装稍有不同，在了解社区版的差异后，安装步骤稍作调整． 3. gitlab 安装gitlab的安装方式有很多种，比如docker镜像安装，Helm charts安装，源代码安装，GET(GitLab Environment Toolkit)安装, 本文主要讲述使用ceontos或redhat系列中通过yum安装使用rpm包安装．安装前需要对yum和rpm命令有一定的了解． 4. 系统要求空闲硬盘空间： 2.5G+CPU: 4core+ (4核最多支持500用户，8核最多支持1000用户)内存：4GB+ 4.1. 安装准备工作 更新yum源这里采用南京大学镜像(主要处于下载速度考虑)，如果你访问外网的速度够快, 可以考虑使用官方镜像．将下面一段代码拷贝到/etc/yum.repos.d, 命名为gitlab_gitlab-ee.repo, 当然你也可以根据自己的喜好命名，只要文件后缀为.repo即可，符合yum源文件命名规范即可 12345[gitlab_gitlab-ee] name=Gitlab EE Repository baseurl=https://mirrors.nju.edu.cn/gitlab-ee/yum/el$releasever/ gpgcheck=0 enabled=1 更新yum缓存，以便快速查询，确保缓存中有最新安装包信息 1yum makecache 4.2. 开始安装gitlab 开始安装前可以使用yum命令查看有哪些可用的版本，以及当前最新版本是哪个． 1yum list gitlab-ee --showduplicates | sort -r 通过以上命令，确定当前列表中包含最新版本，如果列表中最新版本不是最新的，可能需要执行yum makecache 更新缓存，或者yum源本身就不包含最新版本，那么要考虑更换yum源．如果要安装指定版本，需要确保需要安装的版本包含在列表中． 安装最新版本的方法 1yum install -y gitlab-ee 安装特定版本的方法以centos7为例, 后面的版本号x.y.z-ee.0.el7根据实际情况进行替换． 1yum install -y gitlab-ee-x.y.z-ee.0.el7 配置gitlab安装完成后执行以下命令gitlab将会自动帮我们完成一些必要的配置，切记如果你手动完成一些配置后不要重复执行以下命令，否则手动配置的参数会被清除，严重时会导致用户访问时出现http 500错误． 修改external_url编辑文件/etc/gitlab/gitlab.rb 123#replace gitlab.example.com with your domain or your ip# for instance external_url 'http://192.168.1.100'external_url 'your_domain' 1gitlab-ctl reconfigure 启动gitlab gitlab默认运行在80端口需要检查防火墙状态, 如何防火墙已开启, 需要放行80端口 123456# 检查防火墙是否开启sudo firewall-cmd --state# 如果开启, 需放行80端口sudo firewall-cmd --add-port=80/tcp --permanentsudo firewall-cmd --reload 如果一切顺利，我们就可以启动gitlab了，启动命令为 1gitlab-ctl start 启动成功后, 可以使用浏览器访问gitlab web页面，默认端口是80, 所以可以打开http://your_server_address访问． 如果没有设置密码，系统将为root用户生成一个随机密码，该随机密码可以在/etc/gitlab/initial_root_password文件中找到．建议修改该随机密码，方式为 1gitlab-rake &quot;gitlab:password:reset[root]&quot; 参数说明: 命令中的root即为root用户，该命令也可以用来为其他用户设置密码． 关于gitlab的高级配置，可以参考gitlab的官网 如果要配置gitlab ci/cd还需要安装gitlab-runner, gitlab-runner的安装和配置可以参考我的博客gitlab-runner安装与配置, 更多关于gitlab的文章请访问gitlab合集 这里补充几点如何启动，关闭，查看gitlab状态的命令，方便troubleshooting关闭gitlab 1gitlab-ctl stop 重启gitlab 1gitlab-ctl restart 查看gitlab状态 1gitlab-ctl status 查看gitlab滚动日志 1gitlab-ctl tail 想了解更多命令，可以查看帮助 1gitlab-ctl --help 命令行查看gitlab版本 1cat /opt/gitlab/embedded/service/gitlab-rails/VERSION 查看日志文件 日志文件位于/var/log/gitlab下, 日志是按照服务分类存放 Gitlab 日志文件位于 /var/log/gitlab/gitlab-rails/production.log 5. gitlab升级Gitlab的更新速度还是挺快的, 每隔一个月就会发布一个release. 如果要使用一些新特性或修补一些安全漏洞, 掌握升级技巧是必不可少的. 这里个人建议收藏文档, 原文在文章末尾有链接地址, 以备升级时使用, 知道系统是如何安装的, 又该如何升级. 原文实时更新, 踩过的坑都会记录下来. 更多关于Gitlab的release政策, 请参考gitlab官方文档GitLab release and maintenance policy 5.1. 升级前备份 备份数据 1gitlab-rake gitlab:backup:create 备份敏感数据 手动备份两个具有敏感数据的文件 1234cp /etc/gitlab/gitlab.rb /var/opt/gitlab/backups# andcp /etc/gitlab/gitlab-secrets.json /var/opt/gitlab/backups 说明： 备份被保存在/var/opt/gitlab/backups目录下 备份文件名格式如下: 例如1665044212_2022_10_06_14.4.1-ee_gitlab_backup.tar, 命名规则为:备份编号+日期+gitlab版本号+后缀 备份恢复的原则是对应版本的备份文件只能使用对应版本的gitlab程序进行恢复 跨版本恢复备份文件会出现恢复失败或未知错误 如果要在高版本中使用低版本的备份文件 方法一: 在另一台机中 安装低版本gitlab 将低版本的备份程序采用低版本的gitlab恢复后再将低版本的gitlab升级到高版本, 再使用高版本的gitlab制作备份文件 5.2. 开启yum缓存 gitlab的每个安装包都接近1G大小，gitlab升级过程中可能需要反复恢复重试，如果不开启yum缓存，即每次执行yum install无论成功与否，安装包都会被清理掉，下次重试即使是相同的版本也会去服务器上重新下载，会特别慢，而且消耗服务器带宽，如果触发了镜像服务器的限流机制，升级可能会无法进行下去. 强烈建议开启yum缓存，等升级完成后再关闭缓存并手动清理 /var/cache/yum/x86_64/7/gitlab_gitlab-ee下的缓存． 开启yum 缓存步骤如下: 修改/etc/yum.conf, 将keepcache设置为1, 默认为0.这样当再次重试相同版本时就可以使用-C 参数使用缓存(详细使用方法参考”开始升级章节”)，而不必去镜像服务器上重新下载． /etc/yum.conf 1234567891011[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=1 # 开启缓存, 1表示开启缓存, 0表示关闭缓存debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=0 5.3. 开始升级 升级前需要了解升级路径，gitlab不能一次性从低版本升级到最新版，需要升级到必要的中间版本，然后一步步升级到最新版本．主要涉及到版本之间的数据的迁移(data migration)工作，所以必须经过其中关键的版本升级，才能顺利完成数据更新操作．升级路径可以参考官网 - Upgrade paths, 这里简要列举路径如下8.11.Z -&gt; 8.12.0 -&gt; 8.17.7 -&gt; 9.0.13 -&gt; 9.5.10 -&gt; 10.0.7 -&gt; 10.8.7-&gt; 11.0.6 -&gt; 11.11.8 -&gt; 12.0.12 -&gt; 12.1.17 -&gt; 12.10.14 -&gt; 13.0.14 -&gt; 13.1.11 -&gt; 13.8.8 -&gt; 13.12.15 -&gt; 14.0.12 -&gt; 14.3.6 -&gt; 14.9.5 -&gt; 14.10.5 -&gt; 15.0.5 -&gt; 15.1.6 (for GitLab instances with multiple web nodes) -&gt; 15.4.6 -&gt; 15.11.13 -&gt;(only instances with lots of users or large pipeline variables history) &gt; 16.1 (instances with NPM packages in their package registry) &gt; 16.2.x (only instances with large pipeline variables history) &gt; 16.3 &gt; latest 16.Y.Z. 首先确定gitlab版本信息, 然后再选择合适的升级路径 1234567gitlab-rake gitlab:env:info# 例如GitLab informationVersion: 14.4.1-eeRevision: abc23a14bac gitlab-rake中Rake并不是单词Rake的意思, 它实际上是Ruby Make的简写形式, 是ruby种类似make的一种程序. 使用Rake可以做一些通用的管理和运维任务. 升级前关闭gitlab的部分服务 12345 gitlab-ctl stop unicorngitlab-ctl stop sidekiqgitlab-ctl stop nginx 升级命令 升级命令和安装命令是一样的, 将x.y.z-ee.0.el7替换成关键中间版本 1yum update -y -C gitlab-ee-x.y.z-ee.0.el7 -C 参数使用缓存, 详细解释参考”开启yum缓存” 升级完成后，需要重新运行配置,否则启动会失败 1gitlab-ctl reconfigure 如果有手动配置，需要重做一遍． 需要启动gitlab,等待数据迁移任务完成，然后再备份，再次进行下一个版本的升级． 如果遇到严重问题，需要回退到上一个版本，导入备份，解决问题后继续往后升级，所以备份数据很重要． 备份恢复命令如下：其中636041545_2021_11_04_12.10.14为备份文件的名字，不包含文件名后缀． 1gitlab-rake gitlab:backup:restore BACKUP=1636041545_2021_11_04_12.10.14 每个版本升级完成后，要启动gitlab等待数据迁移完成查看数据迁移任务，有两种查看方式，可以通过web界面查看，也可以通过命令行来查看． web界面查看方式查看迁移任务的状态，打开web界面:在页面顶部, 选择 Menu &gt; Admin.在页面左侧边栏，选择Monitoring &gt; Background Migrations. 命令行查看方式 1gitlab-rails runner -e production 'puts Gitlab::BackgroundMigration.remaining' 6. gitlab迁移 有时我们需要将gitlab迁移到新的性能更好的服务器．怎么进行迁移呢？当然方法很多，这里介绍其中的一种方式，即通过先备份，然后在新的服务器上进行还原操作． 说明: gitlab还原有一点需要注意，那就是备份文件只能是在与创建备份的gitlab版本相同的gitlab上才能恢复，备份文件的后八位即是创建该备份的gitlab的版本，该版本只能在这种版本下进行还原． 6.1. 备份数据1gitlab-rake gitlab:backup:create 备份文件默认(如果没有修改默认配置的情况下)保存在/var/opt/gitlab/backups目录下面． 6.2. 在新服务器上安装gitlab 可以参考本文的安装部分进行安装 6.3. 还原备份 将备份文件拷贝到新服务器的/var/opt/gitlab/backups目录下，执行恢复命令．备份文件参数，根据自己的实际情况进行修改． 首先要将旧服务器上的两个文件/etc/gitlab/gitlab.rb,/etc/gitlab/gitlab-secrets.json拷贝到新服务器, 否则后续会发现一些奇怪的问题. 并将/etc/gitlab/gitlab.rb 的external_url设置为正确的url 然后执行gitlab-ctl reconfigure 1gitlab-rake gitlab:backup:restore BACKUP=1636041545_2021_11_04_12.10.14 如果还原失败, 请先参考问题排查章节, 再在到网上查找解决办法. 7. 如何彻底卸载gitlab? 警告: 注意标题上彻底二字，在你不清楚卸载意味着会发生什么的时候，请不要执行以下任何步骤． 7.1. 卸载前备份 卸载前执行一次备份，备份存放位置为/var/opt/gitlab/backups, 因为后续该目录也会被清除，所以请将备份拷贝到一个安全的位置，因为后续动作可能会永久的删除数据，以便后续发生问题或反悔的时候，可以从备份恢复数据． 备份数据 1gitlab-rake gitlab:backup:create 备份敏感数据 手动备份两个具有敏感数据的文件 1234cp /etc/gitlab/gitlab.rb /var/opt/gitlab/backups# andcp /etc/gitlab/gitlab-secrets.json /var/opt/gitlab/backups 7.2. 执行卸载 关闭gitlab 1234#关闭gtilabgitlab-ctl stop#查看gitlab状态，确保已经关闭gitlab-ctl status 卸载应用程序 1rpm -e gitlab-ee 删除数据残留首先确认有哪些数据残留 1find / -name gitlab 如果都是期望被删除的，那么开始执行删除操作，再次提醒将备份拷贝一份到安全位置． 1234# 首先使用find命令查看一下有哪些数据残留find / -name gitlab # 确定以上文件可以删除后使用删除命令进行删除find / -name gitlab | xargs rm -rf 8. 问题排查 问题 1: 从一台机迁移到另外一台机时报如下错错误 123456Restoring PostgreSQL database gitlabhq_production ... ERROR: must be owner of extension pg_trgmERROR: must be owner of extension btree_gistERROR: must be owner of extension btree_gistERROR: must be owner of extension pg_trgm 解决办法: 修改postgresql配置, 能从本地连接到postgresql 123456$ vim /var/opt/gitlab/postgresql/data/postgresql.conflisten_addresses = '*'# 最下面新增两行$ vim /var/opt/gitlab/postgresql/data/pg_hba.conflocal all all trusthost all all 127.0.0.1/32 trust 重启gitlab使得配置生效 123gitlab-ctl restart 修改gitlab账号为超级用户 12345678$ su - gitlab-psql$ /opt/gitlab/embedded/bin/psql -h 127.0.0.1 gitlabhq_productionpsql (9.2.8)Type &quot;help&quot; for help.gitlabhq_production=# ALTER USER gitlab WITH SUPERUSER;ALTER ROLEgitlabhq_production=# \\q 修改完gitlab用户权限后, 记得将postgresql的配置文件改回去 保证安全性, 防止误操作 以免后续安装postgresql数据库是参数端口冲突 参考文档: https://www.jianshu.com/p/09a2b0c25ecd 问题 2: 解决Gitlab迁移后，项目的 CI/ CD页面报500错误 原因是: gitlab默认的备份机制，是不会备份gitlab.rb和gitlab-secrets.json文件的,如果这两文件还存在则将其拷贝到新的服务器, 如果不存在则将secrets 清除重设参考: https://www.jianshu.com/p/c46aa8c8539c 9. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 fedora上安装gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础","link":"/gitlab/gitlab_installation_upgrade.html"},{"title":"使用gitlab issue board的四种方式","text":"1. 前言构建软件和运行项目的方法有很多种。当我们开始在 GitLab 中构建产品组合和项目管理工具时，我们问自己，“您如何构建工具来支持各种工作流程，而不会因为工具本身的复杂性而陷入瘫痪？我们的结论是什么？构建更少但更灵活的工具。GitLab 的内置issue board是一个很好的例子，说明选择构建单个多功能工具可以显著降低工具维护的复杂性，同时不会限制其功能。 管理项目和软件本质上是复杂的，但项目管理工具本身不一定如此复杂。无论您管理多少个项目、人员或产品，获得保持平稳运行所需的可见性应该是一件容易的事。 GitLab issue board是一个使用简化方法解决复杂问题的很好的例子。我们建立在 GitLab 现有的问题跟踪功能之上，并利用 GitLab 问题标签的强大功能，将它们用作看板上的列表。您可以构建不同的问题板视图，同时保持您在问题跟踪器中看到的相同过滤和排序功能。您可以创建多个板来捕获所需可见性，并按里程碑、标签、责任人和权重定义板的范围。 issue board基于其项目的标签结构，因此，它应用相同的描述性标签来定位在板上的位置，从而在整个开发生命周期中保持一致性。而且，您可以直接从开发板中单击某个问题以开始您的工作。 issue board显示您的团队正在处理哪些问题，分配给每个问题的人员以及这些问题在工作流中的哪个位置 2. 使用方式一: 使用 GitLab issue board进行工作流跟踪无论您是试图掌握项目状态的项目经理，还是需要报告进度的产品经理，工作流可视性都至关重要。 要创建工作流issue，只需为工作流的每个阶段创建标签，然后将其作为列表添加到版块上即可。标记问题后，该问题将自动显示在列表中。当问题准备好进入下一阶段时，只需将其拖放到下一个列表中即可。您也可以直接在问题中更新标签，您的更改将自动显示在版块上。 例如，您的工作流可能如下所示： Development Design Review Test Deploy 要在看板上看到这一点，只需为每个阶段创建一个标签即可。创建一个新版块并为每个阶段添加一个列表。您可以拖放列表以按所需顺序放置它们. 3. 使用方式二: 跨职能规划与工作流视图类似，您可以基于类别创建 GitLab 问题板。 在处理特定产品或功能时，您可能希望获得每个团队正在处理的内容的高阶视图。您可以为每个团队创建一个标签和一个列表，或者，您可能希望查看许多项目或产品线中正在处理的内容。 在上面的示例中，我们有三个标签列表：时间跟踪、项目组合管理和描述模板。每个列表代表一个特定的产品区域。因此，通过这一个板子，您将能够看到哪些未解决的问题属于这三个领域。如果您将board进一步限定为特定里程碑，您将能够看到在该里程碑中要处理的问题中有哪些问题。 这只是如何使用issue board来规划工作的一个示例。同样，由于问题板是使用标签创建的，因此您的选择是无限的！ 4. 使用方式三: 团队工作量可见性您可以使用团队成员列表轻松监控分配给团队中个人的内容。团队成员列表显示分配给特定成员的问题，您可以创建一个版块来为团队中的每个人显示列表，以便快速查看谁在做什么。 5. 使用方式四: GitLab 问题和里程碑规划作为我们项目管理能力的一部分，我们建立了里程碑。里程碑用于跟踪与要在特定时间范围内完成的特定目标相关联的问题和合并请求。 与我们的受托人列表类似，您将能够直接从您的issue board快速创建里程碑视图。这对于那些利用敏捷工作流的人来说特别有用。使用里程碑列表，您可以轻松地在不同里程碑（即sprint，迭代）之间移动问题(story)。 6. 后序当然，这只是冰山一角。请继续关注我们关于使用 GitLab 进行项目组合规划和管理的下一篇文章，我们将介绍其他一些最受欢迎的 GitLab 功能，如 Epics、Roadmaps 和 Milestones。 7. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 8. 参考文档4 ways to use GitLab Issue Boards","link":"/gitlab/gitlab_issue_board.html"},{"title":"GitLab集成PlantUML","text":"1. 摘要本文提供了将PlantUML与GitLab集成的逐步指南。它涵盖了从配置PlantUML服务器到在GitLab中启用它的所有内容，并包括代码块以说明必要的命令。通过遵循本指南，您将能够使用PlantUML在GitLab snips、wikis和代码库中创建图表。 2. 前言当在GitLab集成并正确配置PlantUML后，您可以在snip、Wiki和代码库中创建图表。此GitLab.com上PlantUML默认为所有SaaS用户启用，不需要任何额外配置。 要在自管理实例上设置PlantUML，必须： 配置PlantUML服务器。 配置本地PlantUML访问。 配置PlantUML安全性。 启用PlantUML。 3. 配置PlantUML服务器如果你的服务器是debian或ubuntu系列, 可以使用源码安装plantuml server. 如果是其他类型的服务器, 建议使用docker安装plantuml server.本教程主要讲解docker启动plantuml server. 使用下面的命令即可快速启动一个plantuml server容器. 123docker run -d --name plantuml -p 8080:8080 -e PLANTUML_LIMIT_SIZE=8192m -e PLANTUML_FONT_PATH=/usr/share/fonts/truetype/dejavu/ plantuml/plantuml-server:tomcat 确认容器启动没有问题后, 将容器设置为开机自启. 123docker update --restart=always plantuml 如果你的gitlab服务器本身就是使用docker-compose启动的, 那么可以在docker-compose的配置文件中, 可以参考下面配置添加plantuml-server 1234567891011version: &quot;3&quot;services: gitlab: image: 'gitlab/gitlab-ee:12.2.5-ee.0' environment: GITLAB_OMNIBUS_CONFIG: | nginx['custom_gitlab_server_config'] = &quot;location /-/plantuml/ { \\n proxy_cache off; \\n proxy_pass http://plantuml:8080/; \\n}\\n&quot; plantuml: image: 'plantuml/plantuml-server:tomcat' container_name: plantuml 4. 配置本地PlantUML访问PlantUML服务器在您的服务器上运行，因此默认情况下无法从外部访问。您的服务器必须捕获PlantUML调用gitlab请求https://gitlab.example.com/-/plantuml/并将它们重定向到PlantUML服务器。根据您的设置，URL为以下任一项: http://plantuml:8080/http://localhost:8080/ 如果使用安全协议TLS运行GitLab，则必须配置此重定向，因为PlantUML使用不安全的HTTP协议。较新的浏览器（如Google Chrome 86+）不会在通过HTTPS提供的页面上加载不安全的HTTP资源。所以需要添加额外的配置. 要启用此重定向，请执行以下操作：根据您的设置方法，在/etc/gitlab/gitlab.rb中添加以下行： 1234# Docker deploymentnginx['custom_gitlab_server_config'] = &quot;location /-/plantuml/ { \\n proxy_cache off; \\n proxy_pass http://localhost:8080/; \\n}\\n&quot; 要激活更改，请运行以下命令： 123sudo gitlab-ctl reconfigure 重启gitlab 123sudo gitlab-ctl restart 5. 开启 PlantUML启动完成后，需要在 GitLab 上配置开启 PlantUML，管理员登录 -&gt; Admin Area -&gt; Settings，复选框选中 Enable PlantUML，输入 PlantUML URL（就是刚刚启动的 PlantUML Server 服务监听地址）例如:http://your_plantuml_server_host:8080。好了现在可以开始 PlantUML 之旅了。 6. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 7. 参考文档PlantUML and GitLab","link":"/gitlab/gitlab_plantuml_integration.html"},{"title":"gitlab-runner安装与配置","text":"1. 安装前准备工作1.1. 配置yum源网上大部分教程是介绍如何安装gitlab-ci-multi-runner如何安装，我也按这些教程中的一种安装了，最终发现，不能和最新的gitlab兼容，网上也很少有文章介绍gitlab-ci-multi-runner和gitlab-runner的区别, 实际上gitlab-ci-multi-runner是一个被废弃了的项目, 最新版本只到9.5.1, 而gitlab-runner已经到14.4.0了，在其gitliab仓库上已经说明 Project ‘gitlab-org/gitlab-ci-multi-runner’ was moved to ‘gitlab-org/gitlab-runner’. Please update any links and bookmarks that may still have the old path.关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文 创建文件/etc/yum.repos.d/gitlab_gitlab-ee.repo，内容如下 12345[gitlab_gitlab-ee]name=Gitlab EE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el$releasever/gpgcheck=0enabled=1 说明上面使用的是清华镜像，如果访问外网速度够快，可以使用gitlab官方镜像下载，配置方法如下 1curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash 更新yum cache以便获得最新版本的gitlab-runner 1yum makecache fast 查看可安装版本 1yum list gitlab-runner --showduplicates | sort -r 截至目前06/Nov/2021，最新的版本是14.4.0-1 2. 安装runner1sudo yum install -y gitlab-runner 说明:运行此命令, 背后到底做了些什么? 安装了gitlab-runner必要的二进制文件, 配置文件 创建了gitlab-runner用户 将gitlab-runner 注册为服务并设置为开机启动 3. 配置runner3.1. 注册一个shared runner注册shared runner之前要启动gitlab-runner, 如果没有启动, 可用使用这条命令启动gitlab-runner 1systemctl start gitlab-runner 向GitLab-CI注册一个Runner需要两样东西：GitLab-CI的url和注册token。其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token.打开gitlab页面menue &gt; admin &gt; CICD &gt; runner, 在Setup shared runner一节可以找到相应的url和token 注册完成之后，在页面menue &gt; admin &gt; runner就会多出一条Runner记录 1gitlab-runner register 12345678910111213141516$gitlab-runner registerRuntime platform arch=amd64 os=linux pid=29902 revision=4b9e985a version=14.4.0Running in system-mode.Enter the GitLab instance URL (for example, https://gitlab.com/):http://your_gitlab_domainEnter the registration token:your_gitlab_or_project_cicd_tokenEnter a description for the runner:[i-hrf33t1e]: runner_on_dev_serverEnter tags for the runner (comma-separated):centos7, shellRegistering runner... succeeded runner=zSpe6VZiEnter an executor: docker-ssh, parallels, shell, virtualbox, docker+machine, custom, docker, ssh, docker-ssh+machine, kubernetes:shellRunner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 4. 测试Runner在git库项目主目录，中添加.gitlab-ci.yml使用以下配置创建一个最简单的pipeline 1234567891011121314151617181920stages: - test - build - deploytest: stage: test script: echo &quot;Running tests&quot;build: stage: build script: echo &quot;Building the app&quot;deploy_staging: stage: deploy script: - echo &quot;Deploy to staging server&quot; environment: name: staging url: https://staging.example.com 提交代码，到gitlab pipeline界面查看流水线是否创建成功. 5. 常用配置/etc/gitlab-runner/config.toml 配置默认在 /etc/gitlab-runner/config.toml 下，配置文件更改时不需要重启服务，每隔三秒GitLab Runner 会检查配置修改，并重新加载。 配置项 描述 concurrent 限制可以同时运行的作业数量 log_level 日志级别 log_format 日志格式 check_interval 检查新作业的间隔长度，默认为3秒 sentry_dsn 启用Sentry错误跟踪 listen_address http服务监听地址 6. 常用命令6.1. 服务管理123456789gitlab-runner start #该命令启动GitLab Runner服务。gitlab-runner stop #该命令停止GitLab Runner服务。gitlab-runner restart #该命令将停止，然后启动GitLab Runner服务。gitlab-runner status #此命令显示GitLab Runner服务的状态。当服务正在运行时，退出代码为零；而当服务未运行时，退出代码为非零。 7. 注销gitlab-runner很多安装文档, 只告诉如何安装, 很少讲到如何注销和卸载.当安装过程中遇到问题, 或使用过程中遇到问题, 可以使用大招卸载,重新安装来解决问题, 所以这里我列出了注销gitlab-runner和卸载gitlab-runner的详细说明, 以备不时之需. 12345678910111213141516# 取消注册所有runnergitlab-runner unregister --all-runners# 要注销特定的 runner, 首先通过gitlab-runner list获取注册者的详细信息gitlab-runner list# 再根据名字或url注销# 按名字gitlab-runner unregister --name hj_project# 根据url加令牌gitlab-runner unregister --url http://gitlab.example.com --token tok3n# runner健康检查gitlab-runner health-check 8. 卸载gitlab-runner123456789101112131415161718192021!/bin/bash# 卸载gitlab-runner# 停止服务gitlab-runner stop# 取消随机启动systemctl disable gitlab-runner# 卸载服务gitlab-runner uninstall# 清理文件rm -rf /etc/gitlab-runnerrm -rf /usr/local/bin/gitlab-runnerrm -rf /usr/bin/gitlab-runnerrm -rf /etc/sudoers.d/gitlab-runner# 删除用户userdel -r gitlab-runner 9. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 fedora上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 10. 问题排查 This job does not have a trace job页面写作这个段信息经过分析，目前我遇到的情况是由于gitlab和gitlab runner版本不兼容, gitlab 14.4.0 ,而gitlab runner或gitlab-ci-multi-runner是9.5.1．解决办法，卸载gitlab-ci-multi-runner, 安装gitlab-runner 14.4.0保持和gitlab 版本一致． expected shallow list 123Reinitialized existing Git repository in /home/gitlab-runner/builds/zBFPsthA/0/root/xxx-project/.git/fatal: git fetch-pack: expected shallow listfatal: The remote end hung up unexpectedly 一开始使用的自带git版本是1.8.3.1的，就是版本太低的问题，不支持最新的API, 可用参考我的博客升级git Run untagged jobs 新注册的gitlab runner 默认是不pick untagged jobs 要将其打开才能pick untagged jobs 11. 参考文档GitLab Runner的安装与使用gitlab+gitlab-runner实现前端项目自动化构建部署gitlab-runner常用命令","link":"/gitlab/gitlab_runner_installation.html"},{"title":"fedora上安装gitlab-runner安装与配置","text":"1. 前言本文主要讲述如何在fedora上安装gitlab-runner，安装和配置过程同样适用于其他Linux发行版。 本文是gitlab-runner安装和配置姊妹篇中的一篇，主要针对fedora操作系统，其它操作系统可以参考针对特定操作系统的姊妹篇。 gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner 安装gitlab-runner有两种方式: 一种是使用deb/rpm包安装; 一种是使用二进制文件安装. 本文会分别介绍这两种安装方式。 2. 安装前准备工作2.1. 确认git版本与gitlab-runner的版本兼容性git与git-runner的版本兼容性没有明确的文件描述，但是当gitlab-runner不能正常从gitlab 拉取项目时，如果有报错此时需要考虑两者之间的兼容性问题。 原则上如果是新安装gitlab-runner, 保证git是2.2以上版本。 大多情况下操作系统都会自带git。但是存在一些操作系统版本较旧，需要手动安装git的情况。 本人就遇到Centos 7.9上git版本太旧与gitlab-runner存在兼容性问题的情况，需要手动安装。大多数情况都可以找到git repo使用rpm或者debian库，使用安装包安装。 但是依然存在需要通过源码安装的情况。如果要手动安装可以参考我之前的文章Centos7上源码安装git2.x 2.2. 确认gitlab-runner与gitlab的兼容性关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文 在下载gitlab-runner之前, 最好确定一下服务器上gitlab当前的版本, 然后找到与之对应的gitlab-runner进行安装, 避免出现兼容性问题. 首先确定gitlab版本信息, 可以使用如下命令在服务器端查询, 当然也可以在gitlab web界面帮助信息中找到版本号. 1234567gitlab-rake gitlab:env:info# 例如 ... GitLab information Version: 15.8.1-ee Revision: c49deff6e37 3. 下载安装gitlab-runner安装gitlab-runner有两种方式: 一种是使用deb/rpm包安装; 一种是使用二进制文件安装. 3.1. 方式一：使用rpm包安装gitlab-runner 首先配置rpm软件仓库 如果访问外网速度够快，可以使用gitlab官方镜像下载，配置方法如下 1curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash 如果不能访问外网，也没有魔法，则可以手动配置软件仓库。 魔法可以从这里获得 Windows 上安装与配置 v2rayA。 2024 最新 v2rayA 安装与配置教程 for Windows、Macos、Linux、Android。 手动创建文件/etc/yum.repos.d/gitlab_gitlab-ee.repo，内容如下，配置中使用的是清华镜像站。也可以到中科大，上海交大等镜像站找一找。 12345[gitlab_gitlab-ee]name=Gitlab EE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el$releasever/gpgcheck=0enabled=1 手动配置好软件仓库后更新yum cache，以便获得最佳下载速度 1yum makecache fast 查看可安装版本 1yum list gitlab-runner --showduplicates | sort -r 安装runner 1234# x.y.z为版本号 例如gitlab-runner-15.8.3 sudo yum install -y gitlab-runner-x.y.z 说明: 运行此命令, 背后到底做了些什么? 安装了gitlab-runner必要的二进制文件, 配置文件 创建了gitlab-runner用户 将gitlab-runner 注册为服务并设置为开机启动 3.2. 方式二：使用使用二进制文件安装gitlab-runner 下载gitlab-runner，放置到PATH路径下 例如：/usr/local/bin/ 不同的硬件架构对应不同的二进制文件，更多版本参考download-any-other-tagged-release 推荐下载与gitlab server相兼容的gitlab-runner的特定版本.关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文在Bleeding Edge - download any other tagged release页面上找到特定版本的二进制文件连接, 将以上命令中的url替换即可. 1234# Linux x86-64sudo curl -L --output /usr/local/bin/gitlab-runner &quot;https://gitlab-runner-downloads.s3.amazonaws.com/&lt;version&gt;/binaries/gitlab-runner-linux-amd64&quot; 将替换为与gitlab server相兼容的版本 授予gitlab-runner可执行权限 123sudo chmod +x /usr/local/bin/gitlab-runner 创建gitlab-runner用户 123sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash 安装为服务并启动gitlab-runner 1234sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runnersudo gitlab-runner start 4. 注册gitlab-runner 向GitLab-CI注册一个Runner需要两样东西：GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token. 打开gitlab页面menue &gt; admin &gt; Settings &gt; CI/CD &gt; runner registration, 在Setup shared runner一节可以找到相应的url和token 注册完成之后，在页面menue &gt; admin &gt; runner就会多出一条Runner记录 123sudo gitlab-runner register --url your_gitlab_server_url --registration-token your_token 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 5. 参考文档Install GitLab Runner manually on GNU/Linux","link":"/gitlab/gitlab_runner_on_fedora.html"},{"title":"macOS上安装gitlab-runner安装与配置","text":"1. 前言本文主要介绍使用二进制文件方式在macOS上安装并注册gitlab-runner. 2. 下载gitlab-runner根据不同种类的CPU, 下载不同的二进制文件. 对于Intell CPU, 使用如下命令下载. 123sudo curl --output /usr/local/bin/gitlab-runner &quot;https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64&quot; 对于Apple Silicon CPU, 使用如下命令下载. 123sudo curl --output /usr/local/bin/gitlab-runner &quot;https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-arm64&quot; 3. 安装特定版本的gitlab-runner以上方式下载的是最新版gitlab-runner, 也许会与gitlab server存在兼容性问题. 推荐下载与gitlab server相兼容的gitlab-runner的特定版本.在Bleeding Edge - download any other tagged release页面上找到特定版本的二进制文件连接, 将以上命令中的url替换即可. 3.1. 首先确定gitlab服务器版本 首先确定gitlab版本信息, 可以使用如下命令在服务器端查询, 当然也可以在gitlab web界面帮助信息中找到版本号. 1234567gitlab-rake gitlab:env:info# 例如 ... GitLab information Version: 15.8.1-ee Revision: c49deff6e37 知道了gitlab版本, 我们就可以找到gitlab-runner的下载地址, 虽然不是每一个版本的gitlab-runner下载地址都列在了在Bleeding Edge - download any other tagged release页面, 但是一些关键信息, 但是我们还是能从中获取一些关键信息. 关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文 例如对于版本15.8.1-ee的gitlab, 其对应的macOS intel cpu架构的gitlab-runner应该是https://gitlab-runner-downloads.s3.amazonaws.com/v15.8.1/binaries/gitlab-runner-darwin-amd64, 所以下载命令应该如下: 123sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/v15.8.1/binaries/gitlab-runner-darwin-amd64 4. 授予gitlab-runner可执行权限123sudo chmod +x /usr/local/bin/gitlab-runner 5. 安装gitlab-runner并作为服务启动与其它操作系统不同的是, macOS需要运行在当前用户下, 而不像其它操作系统可以为gitlab-runner单独创建一个用户. 打开终端首先切换到当前用户. 123su - &lt;username&gt; 将gitlab-runner安装为一个服务并启动它 123cd ~gitlab-runner installgitlab-runner start 重启计算机. 注意当注册gitlab-runner在 macOS 上构建 iOS 或 macOS 应用程序时，请使用 shell 执行器。pipeline job将直接在主机上以登录用户运行。这些作业不会在容器中运行，这比使用容器执行器安全性较低。有关详细信息，请参阅安全影响文档。 6. 注册gitlab-runner 向GitLab-CI注册一个Runner需要两样东西：GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token. 打开gitlab页面menue &gt; admin &gt; CI/CD &gt; runners, 在Setup shared runner一节可以找到相应的url和token 注册完成之后，在页面menue &gt; admin &gt; runner就会多出一条Runner记录 123gitlab-runner register --url your_gitlab_server_url --registration-token your_token 注册完成后, 会有消息输出告诉配置文件的位置 “/Users//.gitlab-runner/config.toml” 7. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 fedora上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 8. troubleshooting问题i: gitlab-runner注册之后, admin&gt; runner界面去查询, runner的状态是”Never contacted” 问题排查: 执行gitlab-runner health-check, 检测gitlab-runner的健康状况 解决办法: 需要手动执行gitlab-runner verify, 详情请参考这里 问题2: gitlab-runner不主动pick up任务 原因: 未知, 有很多人遇到相同的问题, 参考这里 截至目前2023/08/24还没有得到回复. 临时解决方案: 在macos下主动运行run命令 123gitlab-runner --debug run 9. 参考文档Install GitLab Runner on macOS","link":"/gitlab/gitlab_runner_on_macos.html"},{"title":"ubuntu上安装gitlab-runner安装与配置","text":"1. 前言在ubuntu上安装gitlab-runner有两种方式: 一种是使用deb/rpm包安装; 一种是使用二进制文件安装. 前一种更方便, 后一种使用范围更广泛, 可以适用于Archlinux或其它任何架构的Linux 发行版. 本文主要介绍使用deb/rpm包安装gitlab-runner, 二进制安装方式可以参考官方文档Using binary file install gitlab-runner 2. 下载gitlab-runner2.1. 确定版本号在下载gitlab-runner之前, 最好确定一下服务器上gitlab当前的版本, 然后找到与之对应的gitlab-runner进行安装, 避免出现兼容性问题. 首先确定gitlab版本信息, 可以使用如下命令在服务器端查询, 当然也可以在gitlab web界面帮助信息中找到版本号. 1234567gitlab-rake gitlab:env:info# 例如 ... GitLab information Version: 15.8.1-ee Revision: c49deff6e37 2.2. 下载安装gitlab-runner确定号版本号后即可执行如下命令, 将其中的版本号替换为合适的版本号. 关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文 如何找到对应版本的rpm/deb包, 可以参考gitlab官网-GitLab Runner bleeding edge releases 12345678# Replace ${arch} with any of the supported architectures, e.g. amd64, arm, arm64# replace ${gitlab_version} with the version of gitlab# &quot;https://gitlab-runner-downloads.s3.amazonaws.com/${version}/deb/gitlab-runner_${arch}.deb&quot;# for examplecurl -LJO &quot;https://gitlab-runner-downloads.s3.amazonaws.com/v15.8.1/deb/gitlab-runner_amd64.deb&quot; 3. 安装一旦有了安装包, 安装就比较简单了. 安装包会帮助处理很多事情. 按照以下步骤为您的系统安装软件包。例如，对于Debian或Ubuntu： 123sudo dpkg -i gitlab-runner_&lt;arch&gt;.deb 4. 注册gitlab-runner 向GitLab-CI注册一个Runner需要两样东西：GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token. 打开gitlab页面menue &gt; admin &gt; Settings &gt; CI/CD &gt; runner registration, 在Setup shared runner一节可以找到相应的url和token 注册完成之后，在页面menue &gt; admin &gt; runner就会多出一条Runner记录 123sudo gitlab-runner register --url your_gitlab_server_url --registration-token your_token gitlab-runner 常用命令查看帮助 123gitlab-runner --help 查看子命令帮助文档 123gitlab-runner &lt;command&gt; --help 查看已经注册的gitlab-runner 123gitlab-runner list 向server注册gitlab-runner 1234567# 非交互模式下注册# 交互模式下注册 gitlab-runner register 5. troubleshooting问题1: 当执行sudo dpkg -i gitlab-runner_&lt;arch&gt;.deb 报错’Package git is not installed’. 12345678910Preparing to unpack gitlab-runner_amd64.deb ...Unpacking gitlab-runner (15.8.1) ...dpkg: dependency problems prevent configuration of gitlab-runner: gitlab-runner depends on git; however: Package git is not installed.dpkg: error processing package gitlab-runner (--install): dependency problems - leaving unconfiguredErrors were encountered while processing: gitlab-runner 解决办法: 安装git 1234567sudo apt updatesudo apt install git# 查看是否安装成功git --version 6. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 fedora上安装gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 7. 参考文档Install GitLab Runner manually on GNU/Linux Registering runners gitlab runner命令","link":"/gitlab/gitlab_runner_on_ubuntu.html"},{"title":"windows上安装gitlab-runner","text":"1. 前言因为需要在Windows上打包Tauri程序, 所以需要一个windows gitlab-runner, 于是有了这篇文章. 2. 准备工作要在Windows上安装和运行GitLab Runner，您需要： Git，可以从官方网站安装 如果要在用户帐户而不是内置系统帐户下运行，则为用户帐户提供密码。 3. 安装 在系统中的某个位置创建一个文件夹，例如：D:\\GitLab-Runner。 下载64位或32位的二进制文件，并将其放入您创建的文件夹中。以下假设您已将二进制文件重命名为gitlab-runner.exe（可选）。您可以下载每个可用版本的二进制文件，如Bleeding Edge中所述-下载任何其他版本。 关于gitlab-runner与gitlab的兼容性原则，gitlab和gitlab-runner在主版本和小版本(major.minor)保持同步，具有相同主版本和小版本号的gitlab和gitlab-runner兼容性最好, 较老的runner可能可以兼容比較新的gitlab,反之亦然，但是不能完全保证．详情请参考官网关于兼容性原文 请确保限制GitLab Runner目录和可执行文件的写入权限。如果不设置这些权限，普通用户可以用自己的可执行文件替换可执行文件，并使用提升的权限运行任意代码。 安装gitlab runner并设置为服务将GitLab Runner作为服务安装并启动。您可以使用内置系统帐户（推荐）或使用用户帐户运行该服务。 以管理员运行一个powershell终端, 进入刚刚创建的文件夹, 例如：D:\\GitLab-Runner 12.\\gitlab-runner.exe install.\\gitlab-runner.exe start 注意这样安装和注册的gitlab runner将以”NT AUTHORITY/System” 用户的身份执行job 3.1. 使用用户帐户运行gitlab-runner服务3.1.1. Windows 10/11专业版本配置123cd D:\\GitLab-Runner.\\gitlab-runner.exe install --user &quot;.\\ENTER-YOUR-USERNAME&quot; --password ENTER-YOUR-PASSWORD.\\gitlab-runner.exe start 需要将用户添加到安全组策略.Go to Control Panel &gt; System and Security &gt; Administrative Tools.Open the Local Security Policy tool.Choose the Security Settings &gt; Local Policies &gt; User Rights Assignment on the list on the left.Open the Log on as a service on the list on the right.Click the Add User or Group… button.Add the user (“by hand” or using Advanced… button) and apply the settings. 3.1.2. Windows 10/11家庭版本配置由于家庭版无法配置安全组策略, 所有即使将GitLab-Runner以普通用户身份设置为服务也启动不了, 所以以下是变通的方式. 仍然以用户身份运行一个powershell终端, 进入刚刚创建的文件夹, 例如：D:\\GitLab-Runner可以先注册gitlab runner 1234cd D:\\GitLab-Runner# 注册gitlab runner.\\gitlab-runner.exe register --url your_gitlab_server_url --registration-token your_token 然后创建快捷方式, 快捷方式内容如下, 并命名为gitlab-runner 123D:\\GitLab-Runner\\gitlab-runner.exe run --working-directory D:\\GitLab-Runner --config D:\\GitLab-Runner\\config.toml --service gitlab-runner --syslog 将快捷方式放到开机启动项, 开机项位置位于C:\\Users\\&lt;user_name&gt;\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 3.2. 注册GitLab Runner 向GitLab-CI注册一个Runner需要两样东西：GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token. 打开gitlab页面menue &gt; admin &gt; Settings &gt; CI/CD &gt; runner registration, 在Setup shared runner一节可以找到相应的url和token 注册完成之后，在页面menue &gt; admin &gt; runner就会多出一条Runner记录 123./gitlab-runner.exe register --url your_gitlab_server_url --registration-token your_token 4. trouble shooting当从gitlab pipeline 执行job时, 遇到pwsh找不到的问题 1ERROR: Job failed (system failure): prepare environment: failed to start process: exec: &quot;pwsh&quot;: executable file not found in %PATH%. Check https://docs.gitlab.com/runner/shells/index.html#shell-profile-loading for more information 修改runner的powershell类型, 在runner的配置文件(D:\\GitLab-Runner\\config.toml) 默认配置的是shell = &quot;pwsh&quot; 将其修改为 shell = &quot;powershell&quot; 5. 关联阅读gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 macOS上安装gitlab-runner安装与配置 fedora上安装gitlab-runner安装与配置 ubuntu上安装gitlab-runner安装与配置 windows上安装gitlab-runner gitlab CICD基础 6. 参考文章gitlab-runner安装与配置 windows上安装gitlab-runner提交gitlab自动打包maven包 Install GitLab Runner on Windows","link":"/gitlab/gitlab_runner_on_windows.html"},{"title":"Golang 运算符","text":"1. Golang 运算符1.1. 算术运算符（Arithmetic Operators） 操作符 描述 例子 + 加法 - 相加运算符两侧的值 A + B 等于 30 - 减法 - 左操作数减去右操作数 A – B 等于 -10 * 乘法 - 相乘操作符两侧的值 A * B等于200 / 除法 - 左操作数除以右操作数 B / A等于2 ％ 取余 - 左操作数除以右操作数的余数 B%A等于0 ++ 自增: 操作数的值增加1 B++ 或 ++B 等于 21 – 自减: 操作数的值减少1 B– 或 –B 等于 19 1.2. 比较运算符（Comparison Operators） 运算符 描述 例子 == 检查如果两个操作数的值是否相等，如果相等则条件为真。 （A == B）为假。 != 检查如果两个操作数的值是否相等，如果值不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 （A &gt; B）为假。 &lt; 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。 （A &lt; B）为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 （A &gt;= B）为假。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 （A &lt;= B）为真。 1.3. 逻辑运算符（Logical Operators）1.4. 赋值运算符（Assignment Operators）1.5. 位运算符（Bitwise Operators） 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 | 如果相对应位都是 0，则结果为 0，否则为 1 （A | B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111","link":"/golang/first_post.html"},{"title":"golang gin 使用swagger生成接口文档","text":"有时候一份清晰明了的接口文档能够极大地提高前后端双方的沟通效率和开发效率。本文将介绍如何使用swagger生成接口文档。 swagger介绍Swagger本质上是一种用于描述使用JSON表示的RESTful API的接口描述语言。Swagger与一组开源软件工具一起使用，以设计、构建、记录和使用RESTful Web服务。Swagger包括自动文档，代码生成和测试用例生成。 在前后端分离的项目开发过程中，如果后端同学能够提供一份清晰明了的接口文档，那么就能极大地提高大家的沟通效率和开发效率。可是编写接口文档历来都是令人头痛的，而且后续接口文档的维护也十分耗费精力。 最好是有一种方案能够既满足我们输出文档的需要又能随代码的变更自动更新，而Swagger正是那种能帮我们解决接口文档问题的工具。 这里以gin框架为例，使用gin-swagger库以使用Swagger 2.0自动生成RESTful API文档。 gin-swagger实战想要使用gin-swagger为你的代码自动生成接口文档，一般需要下面三个步骤： 按照swagger要求给接口代码添加声明式注释，具体参照声明式注释格式。 使用swag工具扫描代码自动生成API接口文档数据 使用gin-swagger渲染在线接口文档页面 添加注释在程序入口main函数上以注释的方式写下项目相关介绍信息。 123456789101112131415161718192021222324package main// @title 这里写标题// @version 1.0// @description 这里写描述信息// @termsOfService http://swagger.io/terms/// @contact.name 这里写联系人信息// @contact.url http://www.swagger.io/support// @contact.email support@swagger.io// @license.name Apache 2.0// @license.url http://www.apache.org/licenses/LICENSE-2.0.html// @host 这里写接口服务的host// @BasePath 这里写base pathfunc main() { r := gin.New() // initial code here ... r.Run()} 在你代码中处理请求的接口函数（通常位于controller层）按如下方式写上注释： 123456789101112131415161718192021222324252627282930313233343536// GetPostListHandler2 升级版帖子列表接口// @Summary 升级版帖子列表接口// @Description 可按社区按时间或分数排序查询帖子列表接口// @Tags 帖子相关接口// @Accept application/json// @Produce application/json// @Param Authorization header string false &quot;Bearer 用户令牌&quot;// @Param object query models.ParamPostList false &quot;查询参数&quot;// @Security ApiKeyAuth// @Success 200 {object} _ResponsePostList// @Router /posts2 [get]func GetPostListHandler2(c *gin.Context) { // GET请求参数(query string)：/api/v1/posts2?page=1&amp;size=10&amp;order=time // 初始化结构体时指定初始参数 p := &amp;models.ParamPostList{ Page: 1, Size: 10, Order: models.OrderTime, } if err := c.ShouldBindQuery(p); err != nil { zap.L().Error(&quot;GetPostListHandler2 with invalid params&quot;, zap.Error(err)) ResponseError(c, CodeInvalidParam) return } data, err := logic.GetPostListNew(p) // 获取数据 if err != nil { zap.L().Error(&quot;logic.GetPostList() failed&quot;, zap.Error(err)) ResponseError(c, CodeServerBusy) return } ResponseSuccess(c, data) // 返回响应} 生成接口文档数据编写完注释后，使用以下命令安装swag工具： 1go install github.com/swaggo/swag/cmd/swag@latest 在项目根目录执行以下命令，使用swag工具生成接口文档数据。 1swag init -g main.go 执行完上述命令后，如果你写的注释格式没问题，此时你的项目根目录下会多出一个docs文件夹。 ./docs├── docs.go├── swagger.json└── swagger.yaml 引入gin-swagger渲染文档数据安装依赖包 12go get package &quot;github.com/swaggo/files&quot;go get package &quot;github.com/swaggo/gin-swagger&quot; 然后在项目代码中注册路由的地方按如下方式引入gin-swagger相关内容： 12345678910import ( // liwenzhou.com ... _ &quot;bluebell/docs&quot; // 千万不要忘了导入把你上一步生成的docs gs &quot;github.com/swaggo/gin-swagger&quot; &quot;github.com/swaggo/gin-swagger/swaggerFiles&quot; &quot;github.com/gin-gonic/gin&quot;) 注册swagger api相关路由 123r.GET(&quot;/swagger/*any&quot;, gs.WrapHandler(swaggerFiles.Handler)) 把你的项目程序运行起来，打开浏览器访问http://localhost:8080/swagger/index.html 就能看到Swagger 2.0 Api文档了。 gin-swagger同时还提供了DisablingWrapHandler函数，方便我们通过设置某些环境变量来禁用Swagger。例如： 1r.GET(&quot;/swagger/*any&quot;, gs.DisablingWrapHandler(swaggerFiles.Handler, &quot;NAME_OF_ENV_VARIABLE&quot;)) 此时如果将环境变量NAME_OF_ENV_VARIABLE设置为任意值，则/swagger/*any将返回404响应，就像未指定路由时一样。 这对一些生产环境很有必要，在前后端分离的项目中，大多数api只是给自家客户端使用，不需要公众提供api接口，此时如果包括一份完整的swagger文档，可能会为黑产提供帮助。在此情况下最后在开发，测试环境开发swagger文档，而对生产环境应该禁止swagger文档。此时即可用到这一特性。 访问swagger文档打开浏览器访问https://your_server/swagger/index.html","link":"/golang/gin-swagger.html"},{"title":"Go database&#x2F;sql 教程","text":"1. 简介Go使用SQL与类SQL数据库的惯例是通过标准库database/sql。这是一个对关系型数据库的通用抽象，它提供了标准的、轻量的、面向行的接口。不过database/sql的包文档只讲它做了什么，却对如何使用只字未提。快速指南远比堆砌事实有用，本文讲述了database/sql的使用方法及其注意事项。 2. 顶层抽象在Go中访问数据库需要用到sql.DB接口：它可以创建语句(statement)和事务(transaction)，执行查询，获取结果。 sql.DB并不是数据库连接，也并未在概念上映射到特定的Database)或schema。它只是一个抽象的接口，不同的具体驱动有着不同的实现方式。通常而言，sql.DB会处理一些重要而麻烦的事情，例如操作具体的驱动打开/关闭实际底层数据库的连接，按需管理连接池。 sql.DB这一抽象让用户不必考虑如何管理并发访问底层数据库的问题。当一个连接在执行任务时会被标记为正在使用。用完之后会放回连接池中。不过用户如果用完连接后忘记释放，就会产生大量的连接，极可能导致资源耗尽（建立太多连接，打开太多文件，缺少可用网络端口）。 3. 加载驱动使用数据库时，除了database/sql包本身，还需要引入想使用的特定数据库驱动。 尽管有时候一些数据库特有的功能必需通过驱动的Ad Hoc接口来实现，但通常只要有可能，还是应当尽量只用database/sql中定义的类型。这可以减小用户代码与驱动的耦合，使切换驱动时代码改动最小化，也尽可能地使用户遵循Go的惯用法。本文使用PostgreSQL为例，PostgreSQL的著名的驱动有： github.com/lib/pq github.com/go-pg/pg github.com/jackc/pgx 这里以pgx为例，它性能表现不俗，并对PostgreSQL诸多特性与类型有着良好的支持。既可使用Ad-Hoc API，也提供了标准数据库接口的实现：github.com/jackc/pgx/stdlib。 1234import ( &quot;database/sql&quot; _ &quot;github.com/jackx/pgx/stdlib&quot;) 使用_别名来匿名导入驱动，驱动的导出名字不会出现在当前作用域中。导入时，驱动的初始化函数会调用sql.Register将自己注册在database/sql包的全局变量sql.drivers中，以便以后通过sql.Open访问。 加载驱动包后，需要使用sql.Open()来创建sql.DB： 4. 连接数据加载驱动包后，需要使用sql.Open()来创建sql.DB： 1234567func main() { db, err := sql.Open(&quot;pgx&quot;,&quot;postgres://localhost:5432/postgres&quot;) if err != nil { log.Fatal(err) } defer db.Close()} sql.Open有两个参数： 第一个参数是驱动名称，字符串类型。为避免混淆，一般与包名相同，这里是pgx。 第二个参数也是字符串，内容依赖于特定驱动的语法。通常是URL的形式，例如postgres://localhost:5432。 绝大多数情况下都应当检查database/sql操作所返回的错误。 一般而言，程序需要在退出时通过sql.DB的Close()方法释放数据库连接资源。如果其生命周期不超过函数的范围，则应当使用defer db.Close() 执行sql.Open()并未实际建立起到数据库的连接，也不会验证驱动参数。第一个实际的连接会惰性求值，延迟到第一次需要时建立。用户应该通过db.Ping()来检查数据库是否实际可用。 123if err = db.Ping(); err != nil { // do something about db error} sql.DB对象是为了长连接而设计的，不要频繁Open()和Close()数据库。而应该为每个待访问的数据库创建一个sql.DB实例，并在用完前一直保留它。需要时可将其作为参数传递，或注册为全局对象。 如果没有按照database/sql设计的意图，不把sql.DB当成长期对象来用而频繁开关启停，就可能遭遇各式各样的错误：无法复用和共享连接，耗尽网络资源，由于TCP连接保持在TIME_WAIT状态而间断性的失败等…… 5. 执行SQL有了sql.DB实例之后就可以开始执行查询语句了。 Go将数据库操作分为两类：Query与Exec。两者的区别在于前者会返回结果，而后者不会。 Query表示查询，它会从数据库获取查询结果（一系列行，可能为空）。 Exec表示执行语句，它不会返回行。 此外还有两种常见的数据库操作模式： QueryRow表示只返回一行的查询，作为Query的一个常见特例。 Prepare表示准备一个需要多次使用的语句，供后续执行用。 6. 操作数据7. 参考文档Go database/sql 教程Golang SQL连接池梳理golang sql 包连接池分析Managing golang connection pool - Practical Examples","link":"/golang/go_database_sql.html"},{"title":"Golang单元测试","text":"1. 前言原文: How To Write Unit Tests in Go Author: Tobi Balogun 译者：philoenglish.com团队; 更多资讯可访问philoenglish.com 单元测试是一种软件测试方法, 用于测试代码的最小可测试单元, 通常是函数或方法. 它的目的是确保每个单元都能够按照预期工作, 并且在修改代码时不会破坏现有的功能,它们是Go编程语言的关键部分。在本教程中，您将创建一个小程序，然后使用Go的测试包和Go test命令对代码运行一系列测试。完成教程后，您将拥有一个可工作的单元测试套件，其中包括一个基于表表格的单元测试、一个覆盖率测试、一项基准测试和一个文档化的示例。 2. 先决条件要完成本教程，您需要以下内容：熟悉Golang编程语言。访问我们的教程系列/电子书《如何在Go中编码》，了解该语言的大致介绍。Go 1.11或更高版本安装在您的本地机器上。您可以按照以下说明在Linux、macOS和Windows上安装Go。在macOS上，您也可以使用Homebrew软件包管理器安装Go。 注意：本教程使用Go module，这是Go 1.11版本中引入的包管理系统。Go module旨在取代GOPATH，并从Go 1.13版本开始成为默认选项。要想更全面地了解Go模块和GOPATH之间的差异，请考虑阅读Go核心团队的这篇官方博客文章。本教程使用Go 1.14版本进行了测试 3. 创建单元测试的示例程序在这一步中，您将构建一个将两个整数相加的小程序。在接下来的步骤中，您将使用go test来测试程序。 首先，创建一个名为math的新目录： 切换到新目录中： 1mkdir ./math 这将是程序的根目录，我们将从这里运行所有剩余的命令。 1cd ./math 现在，使用您喜欢的文本编辑器，创建一个名为math.go的新文件并添加如下代码：math.go 1234567891011package math// Add is our function that sums two integersfunc Add(x, y int) (res int) { return x + y}// Subtract subtracts two integersfunc Subtract(x, y int) (res int) { return x - y} 在这里，我们创建了两个名为Add和Subtract的函数。每个函数接受两个整数，并返回它们的和（func Add）或差（func Subtract）。 在这一步中，我们用Go编写了一些代码。在接下来的步骤中，我们将编写一些单元测试，以确保代码正常工作。 4. 创建单元测试在这一步中，我们将用Go编写第一个单元测试。在Go中编写测试需要一个测试文件，该测试文件必须始终以_test.Go结尾。按照惯例，Go测试文件总是位于测试代码所在的同一文件夹或包中。当您运行go build命令时，这些文件不会被编译，所以您不必担心它们最终会被发布到生产环境。与Go中的所有内容一样，Go语言对测试有自己的看法。Go语言提供了一个小而完整的Testing包，开发人员可以将其与Go test命令一起使用。Testing包提供了一些有用的约定，例如覆盖率测试和基准测试，现在我们将对此进行探索. 创建测试类math_test.go如下：./math/math_test.go 123456789101112131415package mathimport &quot;testing&quot;func TestAdd(t *testing.T){ got := Add(4, 6) want := 10 if got != want { t.Errorf(&quot;got %q, wanted %q&quot;, got, want) }} Go中的测试函数包含以下签名：func TestXxxx（t*testing.t）。这意味着所有测试函数都必须以单词test开头，后跟一个后缀，后缀的第一个单词是大写的。Go中的测试函数只接收一个类型为testing.T的指针的参数。这种类型包含很多有用的方法，例如输出结果、将错误打印到屏幕和发出故障信号等等。示例中的TestAdd用于测试add方法, 其中Test必须大写, 该方法有且仅有一个类型为*testing.T的参数, 这是go的测试规范所约定的相应的我们需要引入testing包 在这一步中，您用Go编写了第一个测试。在下一步中，您将开始使用go测试来测试您的代码。 5. 使用go test运行测试在这一步中，我们将测试代码。go test是一个功能强大的子命令，可以帮助我们自动化测试。go test接受不同的标志，这些标志可以配置您希望运行的测试、测试返回的详细程度等等。 从项目的根目录中，运行第一个测试： 1go test 运行测试命令后我们会看到如下输出 1234OutputPASSok ./math 0.988s go test子命令只查找后缀为_test.go的文件。找到测试文件扫描这些文件中的特殊函数，包括func TestXxx和我们将在后面的步骤中介绍的其他几个函数。go test然后生成一个临时的main package，该包以正确的方式调用这些函数，构建并运行它们，报告结果，最后清理所有内容。 对于我们的小程序来说，我们的go测试可能已经足够了，但有时我们会希望看到更多信息例如哪个测试方法被执行, 用了多长时间之类的。此时添加-v选项获得更多信息。使用-v选项运行测试： 1go test -v 运行测试命令后被测试的方法, 耗时多少等等信息 12345Output=== RUN TestAdd--- PASS: TestAdd (0.00s)PASSok ./math 1.410s 在这一步中，我们使用go test子命令运行了一个基本的单元测试。在下一步中，我们将编写一个更复杂的、表格驱动的单元测试。 6. Table-driven的单元测试Table-driven测试类似于基本单元测试，只是它维护一个包含不同值和结果的表。测试套件对这些值进行遍历，并将它们提交给测试代码。使用这种方法，我们可以测试输入的多种组合及其各自的输出。现在，我们将用一个数组来定义测试用例，其字段包括Add函数所需的两个参数（两个整数）和预期结果（它们的和）。 重写./math/math_test.go 12345678910111213141516171819202122232425262728package mathimport &quot;testing&quot;// arg1 means argument 1 and arg2 means argument 2, and the expected stands for the 'result we expect'type addTest struct { arg1, arg2, expected int}var addTests = []addTest{ addTest{2, 3, 5}, addTest{4, 8, 12}, addTest{6, 9, 15}, addTest{3, 10, 13}, }func TestAdd(t *testing.T){ for _, test := range addTests{ if output := Add(test.arg1, test.arg2); output != test.expected { t.Errorf(&quot;Output %q not equal to expected %q&quot;, output, test.expected) } }} 在这里，我们定义了一个数组，填充了一个包含Add函数的参数和预期结果表格，然后编写了一个新的TestAdd函数。在这个新函数中，您对表进行遍历，运行参数，将输出与每个预期结果进行比较，然后在出现任何错误时返回这些错误。现在使用-v标志运行测试： 123go test -v 输出结果如下 1234567Output=== RUN TestAdd--- PASS: TestAdd (0.00s)PASSok ./math 1.712s 在这一步中，我们编写了一个表格驱动的单元测试。在下一步中，您将编写输出一份单元测试覆盖率的report。 7. 测试覆盖率在这一步中，我们将在Go test中输出覆盖率。在编写测试时，了解测试覆盖了多少实际代码通常很重要。这通常被称为测试覆盖率。这也是为什么我们没有为Subtract函数编写测试的原因，这样我们就可以查看不完整的覆盖率测试。运行以下命令来来看空当前单元测试的覆盖率： 123go test -coverprofile=coverage.out 从输出结果我们可以看到测试覆盖率是50% 123456OutputPASScoverage: 50.0% of statementsok ./math 2.073s Go将此覆盖率数据保存在文件coverage.out中。现在您可以在web浏览器中显示结果。运行以下命令： 123go tool cover -html=coverage.out 在这一步中，您测试了表驱动单元测试的覆盖率。在下一步中，您将对您的功能进行基准测试。 8. Go基准测试在这一步中，我们将在Go中编写一个基准测试。基准测试用于衡量功能或程序的性能。方便我们比较和了解修改对性能的影响。使用这些信息，我们可以揭示Go源代码中值得优化的部分。在Go中，采用func BenchmarkXxx（*testing.B）形式的函数被视为基准测试。go test将在您提供-beach选项时时执行这些基准测试。基准测试是按顺序运行的。 让我们在单元测试中添加一个基准测试。 修改./math/math_test.go添加一个为BenchmarkAdd的基准测试 1234567func BenchmarkAdd(b *testing.B){ for i :=0; i &lt; b.N ; i++{ Add(4, 6) }} 基准测试函数将会运行目标代码b.N次，其中N是一个可以调整的整数。在基准测试执行期间，调整b.N，直到基准测试函数持续足够长的时间以可靠地计时。–bench标志以正则表达式的形式接受其参数。 现在，让我们再次使用go test来运行我们的基准测试： 1go test -bench=. 这个.将匹配文件中的每个基准函数。 您还可以显式地指定要运行哪个基准函数, 也可以用正则表达式指定一批基准测试函数： 1go test -bench=Add 运行以上任一命令，您将看到如下输出： 1234567Outputgoos: windowsgoarch: amd64pkg: mathBenchmarkAdd-4 1000000000 1.07 ns/opPASSok ./math 2.074s 这个输出的告诉我们Add方法被执行了1000000000, 每次平均耗时1.07 ns(纳秒) 现在，您已经为正在增长的单元测试添加了一个基准测试。在下一步也是最后一步中，您将在文档中添加示例，go test也将对这些示例进行评估。 9. 为代码写示例在此步骤中，我们将为Go代码创建文档示例，然后测试这些示例。Go非常专注于正确的文档，示例代码为文档和测试增加了另一个维度。示例基于现有方法和函数。您的示例应向用户展示如何使用特定代码。示例函数是 go test 子命令专门处理的第三种类型的测试函数。 这次我们需要把fmt包添加到import列表中，并在文件末尾添加示例函数ExampleAdd： 1234567891011121314151617181920212223242526272829303132333435363738394041package mathimport ( &quot;fmt&quot; &quot;testing&quot;)// arg1 means argument 1 and arg2 means argument 2, and the expected stands for the 'result we expect'type addTest struct { arg1, arg2, expected int}var addTests = []addTest{ addTest{2, 3, 5}, addTest{4, 8, 12}, addTest{6, 9, 15}, addTest{3, 10, 13},}func TestAdd(t *testing.T) { for _, test := range addTests { if output := Add(test.arg1, test.arg2); output != test.expected { t.Errorf(&quot;Output %q not equal to expected %q&quot;, output, test.expected) } }}func BenchmarkAdd(b *testing.B) { for i := 0; i &lt; b.N; i++ { Add(4, 6) }}func ExampleAdd() { fmt.Println(Add(4, 6)) // Output: 10} 现在ExampleAdd不仅是一个测试, 也是一份关于Add方法的文档. 而且任何时候Add方法的行为发生改变, 示例代码也会被相应的修改.这样的好处就是任何时候, 文档都会随着代码行为的改变而更新, 如果不及时更新测试就不会通过, 这也是golang对测试的独特理解. 现在重新运行单元测试： 123go test -v 我们将会看到如下输出 123456789Output=== RUN TestAdd--- PASS: TestAdd (0.00s)=== RUN ExampleAdd--- PASS: ExampleAdd (0.00s)PASSok ./math 0.442s 您的示例现在也经过了测试。此功能改进了您的文档，也使您的单元测试更加健壮。 10. 总结在本教程中，我们创建了一个小程序，然后编写了一个基本的单元测试来检查其功能。然后，您将单元测试重写为基于表的单元测试，然后添加覆盖率测试、基准测试和文档示例。作为一名程序员，花时间编写足够的单元测试对你来说很有用，因为它可以提高你对所编写的代码或程序将继续按预期工作的信心。Go中的测试包为您提供了相当多的单元测试功能。要了解更多信息，请参阅Go的官方文档。如果你想了解更多关于围棋编程的知识，请访问我们的教程系列/免费电子书《How To Code in Go》。 11. 参考文档How To Write Unit Tests in Go","link":"/golang/go_unit_test.html"},{"title":"GoLang调用 google translate API 实现中英互译","text":"本文主要讲述如何使用golang调用google translate API。其中也详细介绍了使用google translate API的前提条件设置google ADC(Application Default Credentials )。 安装 google translate golang client1go get cloud.google.com/go/translate 导入依赖包1import &quot;cloud.google.com/go/translate&quot; 编写translateText函数1234567891011121314151617181920212223242526func translateText(targetLanguage, text string) (string, error) { ctx := context.Background() lang, err := language.Parse(targetLanguage) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;language.Parse: %w&quot;, err) } client, err := translate.NewClient(ctx) if err != nil { return &quot;&quot;, err } defer client.Close() resp, err := client.Translate(ctx, []string{text}, lang, nil) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;translate: %w&quot;, err) } if len(resp) == 0 { return &quot;&quot;, fmt.Errorf(&quot;translate returned empty response to text: %s&quot;, text) } return resp[0].Text, nil} 设置google ADC(Application Default Credentials )Application Default Credentials (ADC) 是身份验证库使用的一种策略，可根据应用环境自动查找凭据。身份验证库会将这些凭据提供给 Cloud 客户端库和 Google API 客户端库。 安装并初始化 gcloud CLI以下是适合 Red Hat Enterprise Linux 7、8 和 9、Fedora 33 和 34 以及 CentOS 7 和 CentOS 8 系统的安装方式。 对于 其他系统可以参考安装 gcloud CLI 123curl --output /tmp/google-cloud-cli-linux-x86_64.tar.gz -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz 安装并配置google cloud cli 12345678910111213# 创建安装目录mkdir ~/google-cloud-sdk# 将安装包解压到安装目录tar -xvzf /tmp/google-cloud-cli-linux-x86_64.tar.gz -C ~# 将 gcloud CLI 添加到路径中。使用以下命令从解压缩到的文件夹的根目录运行安装脚本：cd ~./google-cloud-sdk/install.sh 初始化 gcloud CLI 123./google-cloud-sdk/bin/gcloud init 这一步需要登陆google账号进行设置, 其中有一步是选择或创建project 选择project后记住project id 后面需要用到 登陆google 123gcloud auth application-default login 浏览器访问，并开启Cloud Translation APIhttps://console.developers.google.com/apis/api/translate.googleapis.com/overview?project=your_project_id 测试代码123456result, err := translateText(&quot;ZH-CN&quot;, &quot;Hello&quot;)if err != nil { fmt.Println(err)}fmt.Println(result) 看到“你好”表示能成功调用google translate API了。 参考文档设置应用默认凭据 Go client library 翻译文本（基本版） 安装 gcloud CLI","link":"/golang/golang_google_translate_api.html"},{"title":"Golang 日志库","text":"任何一个系统开发，都离不开完备的日志系统。go 日志不同其他语言，比如 java 由于 commons-logging 日志标准，和不同实现 如log4j,slf4j,logback，但都是统一调用标准接口;python 中标准logging 模块，功能强大，基本上满足各种需求。但是在golang 语言开发中，目前阅读了几个开源代码，都是自己实现了一套日志记录标准，并没有采用go 官方 log 模块。golang’s log 模块主要提供了3类接口。分别是 “Print、Panic、Fatal”，对每一类接口其提供了3中调用方式，分别是 “Xxxx 、 Xxxxln 、Xxxxf”，基本和fmt中的相关函数类似；但功能有限，很难比如按天，按照容量自动输出拆封生成新日志。如果自己开发一套日志，基本上要满足日志等级输出如DEBUG,INFO,WARN,ERROR/FATAL 、支持输出 console 或者滚动式文件、参数格式化输出、自定义格式化模板，当然如果支持更高级别如按照pakcage输出到不同文件，按照日志级别输出到不同地方那就更好了。 下面简要介绍7款golang日志库： 标准库日志 标准库的slog Logrus Zap Zerolog golang glog seelog 1. 标准库日志Go 的标准库包含一个名为 的基本日志记录包log。它提供了一种将消息记录到控制台的简单方法： 1234567891011package mainimport ( &quot;log&quot;)func main() { log.Println(&quot;This is a log message&quot;)} 但是，标准log包非常简单，可能不适合更复杂的日志记录要求，例如日志轮换、日志级别或日志格式。 2. 标准库的slog最近，Go 标准库引入了一个名为 的新日志记录包slog，它将结构化日志记录引入标准库。结构化日志使用键值对，因此可以快速可靠地解析、过滤、搜索和分析它们。 该slog包提供了比 log 包更高级的日志记录功能，建议在生产环境中使用。 slog以下是如何使用该包登录 Go的示例： 123456789101112131415161718192021package mainimport ( &quot;os&quot; &quot;log/slog&quot;)func main() { textHandler := slog.NewTextHandler(os.Stdout) logger := slog.New(textHandler) logger.Info(&quot;Usage Statistics&quot;, slog.Int(&quot;current-memory&quot;, 50), slog.Int(&quot;min-memory&quot;, 20), slog.Int(&quot;max-memory&quot;, 80), slog.Int(&quot;cpu&quot;, 10), slog.String(&quot;app-version&quot;, &quot;v0.0.1-beta&quot;), )} 要使用 Go 中的包记录到文件slog，您可以使用该slog.NewJSONHandler函数创建一个新的处理程序，以 JSON 格式将日志写入文件。这是一个例子： 1234567891011121314151617181920212223package mainimport ( &quot;os&quot; &quot;log/slog&quot;)func main() { file, err := os.OpenFile(&quot;app.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { panic(err) } defer file.Close() jsonHandler := slog.NewJSONHandler(file) logger := slog.New(jsonHandler) logger.Info(&quot;Application started&quot;, slog.String(&quot;app-version&quot;, &quot;v0.0.1-beta&quot;), )} 3. Logrus为了处理更高级的日志记录需求，许多开发人员转向第三方日志记录库。一种流行的选择是“logrus”，它提供了功能更丰富的日志记录体验。您可以使用以下方式安装它： 123go get github.com/sirupsen/logrus 以下是如何使用 Logrus 库的示例： 1234567891011121314151617181920package mainimport ( &quot;github.com/sirupsen/logrus&quot;)func main() { // Create a new logger instance log := logrus.New() // Set the log level (optional) log.SetLevel(logrus.InfoLevel) // Log messages log.WithFields(logrus.Fields{ &quot;animal&quot;: &quot;walrus&quot;, }).Info(&quot;A walrus appears&quot;)} Logrus 提供结构化日志记录、日志级别、自定义格式化程序等功能。 Logrus是一个高度可扩展的日志库，可以与各种监控工具集成。例如，OpenTelemetry Logrus是一个提供与 OpenTelemetry 集成的插件。 4. ZapGo 生态系统中另一个流行的日志库是 Zap。它以其高性能和结构化日志记录功能而闻名。您可以使用以下方式安装它： 1go get go.uber.org/zap 以下是如何使用 Zap 的基本示例： 123456789101112131415package mainimport ( &quot;go.uber.org/zap&quot;)func main() { // Create a logger logger, _ := zap.NewProduction() // Log messages logger.Info(&quot;This is an info message&quot;, zap.String(&quot;key&quot;, &quot;value&quot;))} Zap 允许以最少的分配进行高效的日志记录，并具有丰富的功能。 您可以使用 OpenTelemetry Zap 将 Zap 与 OpenTelemetry集成插件 5. ZerologZerolog 是一个快速且简单的结构化记录器。它专注于减少分配并为结构化日志记录提供干净的 API。它适合基本和高级日志记录需求。 123go get github.com/rs/zerolog 以下是使用 Zerolog 记录消息的基本示例： 123456789101112131415package mainimport ( &quot;os&quot; &quot;github.com/rs/zerolog&quot;)func main() { // Create a new logger instance logger := zerolog.New(os.Stdout).With().Timestamp().Logger() // Log messages logger.Info().Str(&quot;key&quot;, &quot;value&quot;).Msg(&quot;This is an info message&quot;) logger.Error().Err(fmt.Errorf(&quot;An error occurred&quot;)).Msg(&quot;This is an error message&quot;)} 6. golang gloggolang的glog是一个轻量级的日志库，它是著名的Google开源C++日志库glog的的Golang版本。glog具有上手简单、稳定高效的特点，但自定义控制的内容相对较少。 1go get github.com/golang/glog 以下是使用 golang glog 记录消息的基本示例： 12345678910111213141516171819202122232425262728293031323334353637// 导入所需的包 import ( &quot;flag&quot; // 导入flag包以解析命令行参数 &quot;log&quot; // 导入标准库中的log包（这里并未使用，仅作示例） &quot;os&quot; // 导入os包（这里并未使用，仅作示例） &quot;github.com/golang/glog&quot; // 导入glog包，用于记录日志 ) func main() { // 初始化glog，必须先调用flag.Parse()解析命令行参数，glog依赖于命令行参数来设置日志级别等 flag.Parse() // 设置glog的输出级别为INFO，这样INFO及以上级别的日志才会被输出 // V参数代表详细级别，通过命令行-v可以指定输出详细日志的级别 defer glog.SetV(2) // 使用defer确保在main函数结束前设置V级别 // 输出INFO级别的日志，当V级别设置为2或以上时，该消息会被记录 glog.Info(&quot;This is an info log message.&quot;) // 输出WARNING级别的日志，这个级别的日志通常表示一些潜在的问题，但程序可以继续运行 glog.Warning(&quot;This is a warning log message.&quot;) // 输出ERROR级别的日志，这通常表示程序遇到了错误，但不一定需要终止 glog.Error(&quot;This is an error log message.&quot;) // 输出FATAL级别的日志，会导致程序立即终止，通常用于表示无法恢复的错误 glog.Fatal(&quot;This is a fatal log message.&quot;) // 由于glog.Fatal会触发程序终止，因此这行代码不会执行 glog.Info(&quot;This message will not be printed because of the fatal above.&quot;) // 通常不需要显式调用glog.Flush()，因为glog库会在程序终止时自动刷新缓冲区 // 如果需要确保日志被写入文件，可以在程序结束前显式调用glog.Flush() } glog库的详细日志级别是通过glog.SetV(level)来设置的，并且可以通过命令行参数-v来指定输出详细日志的级别。在上面的示例中，glog.SetV(2)表示当使用-v=2或更高值时，详细日志会被输出。而glog的的日志级别（INFO, WARNING, ERROR, FATAL）是固定的，不需要设置。 另外，在真实的应用场景中，glog库通常用于替代标准库的log包，用于更结构化、更灵活的日志记录。如果需要自定义日志格式或输出位置，可能需要结合glog库的其它功能或考虑使用其他日志库。 7. seelogseelog 是一个 Go 语言（golang）的日志库，它提供了灵活且强大的日志记录功能。与标准的 log 库相比，seelog 提供了更多的定制性和更丰富的功能。 以下是一个简单的 seelog 使用示例： 首先，你需要安装 seelog： 123go get github.com/cihub/seelog 然后，你可以通过 XML 配置文件来配置 seelog： 123456789&lt;seelog type=&quot;asynctimer&quot; asyncinterval=&quot;500&quot; minlevel=&quot;info&quot;&gt; &lt;outputs formatid=&quot;main&quot;&gt; &lt;console /&gt; &lt;file path=&quot;logs/app.log&quot; rollonfilesize=&quot;true&quot; rollsize=&quot;10485760&quot; /&gt; &lt;/outputs&gt; &lt;formats&gt; &lt;format id=&quot;main&quot; format=&quot;%Date %Time [%Level] %Msg%n&quot;/&gt; &lt;/formats&gt; &lt;/seelog&gt; 在 Go 代码中，你可以这样加载并使用配置： 12345678910111213141516171819package main import ( &quot;github.com/cihub/seelog&quot; ) func main() { defer seelog.Flush() // 加载配置文件 if err := seelog.LoadConfiguration(&quot;path/to/seelog.xml&quot;); err != nil { panic(err) } // 记录日志 seelog.Infof(&quot;This is an info message.&quot;) seelog.Warnf(&quot;This is a warning message.&quot;) seelog.Errorf(&quot;This is an error message.&quot;) } 在上面的示例中，seelog 会根据配置文件将日志输出到控制台和文件。你可以根据实际需要调整配置文件的内容，以满足不同的日志记录需求。 总的来说，seelog 是一个功能丰富且灵活的日志库，它可以帮助你更好地管理和分析应用程序的日志。 8. 最佳实践有效的日志记录是提供足够的信息来解决问题和避免信息过载之间的平衡。根据应用程序和组织的具体要求和限制调整您的日志记录实践。 结构化日志记录。采用结构化日志记录，它允许您将键值对或结构化数据附加到日志条目。这使得以结构化方式过滤和分析日志变得更加容易。 日志级别。利用日志级别（例如，INFO、DEBUG、WARN、ERROR）对日志消息进行分类。这使您可以控制日志的详细程度，并在调试或故障排除期间关注相关信息。 上下文信息。在日志消息中包含相关的上下文信息。例如，包括请求 ID、用户 ID 和时间戳。这有助于跨组件跟踪问题。 错误换行。记录错误时，使用错误包装来保留原始错误上下文。您可以使用“github.com/pkg/errors”之类的包或内置的“fmt.Errorf”来实现此目的。 监控和警报。为应用程序日志设置监控和警报。使用 Uptrace 或 Grafana 等工具创建仪表板并根据日志模式设置警报。 9. 总结根据应用程序的要求和复杂性选择日志记录方法。大多数项目都建议使用 Logrus 和 Zap 等第三方库，因为它们提供了强大的功能并且社区维护得很好。 最近，Go 标准库引入了一个名为slog的新日志记录包，它将结构化日志记录引入标准库，并建议在生产环境中使用。 请记住，日志记录库的选择可能取决于项目的大小和复杂性。对于较小的项目，一个简单且易于使用的记录器可能就足够了，而较大且更复杂的项目可能会受益于功能更丰富、性能更佳的日志记录库。","link":"/golang/golang_logging_libs.html"},{"title":"安装Golang","text":"1. 前言Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 罗伯特·格瑞史莫（Robert Griesemer），罗勃·派克（Rob Pike）及肯·汤普逊（Ken Thompson）于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目。 Go是基于Inferno操作系统所开发的。Go于2009年11月正式宣布推出，成为开放源代码项目，并在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言”。 目前，Go每半年发布一个二级版本（即从a.x升级到a.y） Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，但它也具有Pi运算的特征，比如通道传输。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。 与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了 切片(Slice) 型、并发、管道、垃圾回收、接口（Interface）等特性的语言级支持。Go 2.0版本将支持泛型，对于断言的存在，则持负面态度，同时也为自己不提供类型继承来辩护。 不同于Java，Go内嵌了关联数组（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样。 2. 安装和设置Go 语言环境安装 Go的三种安装方式： Go有多种安装方式，你可以选择自己喜欢的。这里我们介绍三种最常见的安装方式： Go源码安装：这是一种标准的软件安装方式。对于经常使用类Unix系统的用户，尤其对于开发者来说，从源码安装可以自己定制。 Go标准包安装：Go提供了方便的安装包，支持Windows、Linux、Mac等系统。这种方式适合快速安装，可根据自己的系统位数下载好相应的安装包，一路next就可以轻松安装了。推荐这种方式. 第三方工具安装：目前有很多方便的第三方软件包工具，例如Ubuntu的apt-get和wget、Mac的homebrew等。这种安装方式适合那些熟悉相应系统的用户。 最后，如果你想在同一个系统中安装多个版本的Go，你可以参考第三方工具GVM，这是目前在这方面做得最好的工具，除非你知道怎么处理。 Go 语言支持以下系统： Linux FreeBSD Mac OS X（也称为 Darwin） Windows 安装包下载地址为：https://go.dev/dl/ 如果打不开可以使用这个地址：https://golang.google.cn/dl/。 各个系统对应的包名： 操作系统 包名 Windows go1.19.3.windows-amd64.zip Linux go1.19.3.linux-amd64.tar.gz Mac go1.19.3.darwin-amd64-osx10.8.pkg FreeBSD go1.19.3.freebsd-amd64.tar.gz 2.1. 在UNIX/Linux/Mac OS X, 以及FreeBSD系统下使用标准包安装golang 下载二进制包：go1.19.3.linux-amd64.tar.gz。 1wget -O /tmp/go1.19.3.linux-amd64.tar.gz https://golang.google.cn/dl/go1.19.3.linux-amd64.tar.gz 将下载的二进制包解压至 /usr/local目录将之前的版本删除掉, 然后安装新版本 1sudo rm -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf /tmp/go1.19.3.linux-amd64.tar.gz 将 /usr/local/go/bin 目录添加至PATH环境变量 新建/etc/profile.d/golang.sh 文件，内容如下 1export PATH=$PATH:/usr/local/go/bin 2.2. Windows 系统下安装Windows 下可以使用 .zip 后缀(在下载列表中可以找到该文件，如go1.19.3.windows-amd64.zip)的安装包来安装。 建议安装在 c:\\program files\\Go 目录下。你可以将 c:\\program files\\Go\\bin 目录添加到 PATH 环境变量中。添加后你需要重启命令窗口才能生效。 Windows 安装包下载地址为：https://go.dev/dl/ 如果打不开可以使用这个地址：https://golang.google.cn/dl/。 2.3. 配置环境变量Go提供了每个平台打好包的一键安装，这些包默认会安装到如下目录：/usr/local/go (Windows系统：c:\\program files\\Go)，当然你可以改变他们的安装位置，但是改变之后你必须在你的环境变量中设置如下信息 vi ~/.bashrc.d/golang.sh 123export GOROOT=/usr/local/go export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin 上面这些命令对于Mac和Unix用户来说最好是写入.bashrc或者.zshrc文件，对于windows用户来说当然是写入环境变量。 2.3.1. 设置 GO111MODULE可以用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。 GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto (推荐) 此设置兼容旧的GOPATH mode 依赖管理方式和新的go module 管理方式, 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。 在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/pkg/mod 中，也会把 go install 的结果放在 $GOPATH/bin 中。 2.3.2. 设置 GOPROXYwindows 设置环境变量: 如果不设置 proxy 有些依赖包由于众所周知的原因下载不了,所以建议安装go以后配置GOPROXY环境变量,一来可解决依赖问题 再者下载依赖包的速度有所提升 1234# windows add a env varialbleGOPROXY=&quot;https://mirrors.aliyun.com/goproxy/&quot; # linux: export GOPROXY=https://mirrors.aliyun.com/goproxy/ 其他go proxies: https://goproxy.io china https://goproxy.cn 关闭 GOSUMDB go env -w GOSUMDB=off 3. 问题排查当出现以下错误时 1234$go build# github.com/mattn/go-sqlite3cgo: C compiler &quot;gcc&quot; not found: exec: &quot;gcc&quot;: executable file not found in %PATH% 需要先安装gcc, 并将其可执行文件路径添加到path环境变量. 安装方法 下载基础程序​​并进行安装 选择MinGW-W64 Online Installer并下载 双击安装程序, 当弹出settings界面时, 选择x86_64, 其它保持默认选项. 4. 参考文档常见问题之Golang——cgo: C compiler","link":"/golang/install_golang.html"},{"title":"mockery v2的介绍和使用","text":"1. 前言由于项目时间比较紧, 我本来是没有打算写一篇文章来介绍mockery的, 但是无奈网上介绍mockery的文章比数量上较少(截至2023-04-27), 而且很多文章都过期了.一方面由于golang更新比较快, 网上解释使用go get 安装mockery的, 到了go 1.6以后都安装不了. 另一方面mockery自身更新也比较快, 很多文章介绍的一些用法在新的版本中已经不灵了, 比如生成mock对象的命令选项-name已经调整为--name, -dir的意义也发生了变化等等, 出现了很多差异的地方. 所以本着稳扎稳打的原则, 不得不放慢脚步, 停下来把golang mock这一块的知识库补充完整. 2. mockery介绍Mockery是一个用于生成Golang接口的Mock的工具. Mockery可以帮助您在测试期间模拟依赖, 以便更轻松地测试代码. Mockery v2是Mocker的最新版本. 2.1. mockery 各版本之间的区别Mockery v1是Mockery的最初版本, 它支持生成带有单个返回值的函数和方法的Mock. Mockery v2和v3支持生成带有多个返回值的函数和方法的Mock, Mockery v3还支持生成带有可变参数的函数和方法的Mock. 另外Mockery v2的CLI在v1的基础上做了一些增强, 以下是Mockery v2新增的一些命令和选项: –version: 显示Mockery的版本号. –debug: 启用调试模式, 以便在生成Mock时输出更多信息. –all: 生成所有接口的Mock, 而不仅仅是在命令行中指定的接口. –recursive: 递归查找指定目录中的所有接口, 并生成它们的Mock. –output: 指定生成Mock的输出目录. –Case: 指定生成Mock时使用的命名约定(例如, snake_case或camelCase) 此外, 可以在当前目录中创建一个名为.mockery.yml的文件, 该文件包含Mockery的默认配置选项. 您可以编辑此文件以自定义Mockery的行为和输出. 例如您可以使用.mockery.yml文件来指定生成Mock时使用的命名规范, 包名, 注释等. 你还可以使用.mockery.yml文件来指定要生成Mock的接口和结构体名称, 以及要生成Mock的目录和文件名.在V2中我们可以将一些运行mockery时需要指定的选项配置到.mockery 相对于Mockery v2而言, Mockery V3对Golang新版本的一些新特性支持更好一些, 例如:支持Go 1.17中引入的新特性, 如泛型, 嵌入式接口, 以及Go 1.18中引入的新特性泛型类型参数, 嵌入式结构体, 嵌入式接口和结构体的混合使用, 类型别名等等. 3. 安装Mockery安装mockery比较简单. 在Golang 1.16及以上的版本需要使用go install 安装prebuilt(也就是binary的程序)的Mockery工具,如果使用的是golang 1.16以前的版本仍然使用go get 来安装. 3.1. go install1go install github.com/vektra/mockery/v2@v2.25.0 这里我安装的是mockery v2当前最新版本2.25.0版本, 版本信息可以在Mockery的release notes页面找到 3.2. DockerMockery也可以结合docker使用 下载docker image 1docker pull vektra/mockery 使用Mockery生成Mock 1docker run -v &quot;$PWD&quot;:/src -w /src vektra/mockery --all 3.3. Homebrew在macOS上可以使用Hombrew来安装, 安装方法如下: 12brew install mockerybrew upgrade mockery 3.4. Mockery CLI的使用前面我们讲了Mockery是一个生成Mock的工具, 那么如何使用它呢, 这里就讲一讲Mockery CLI的用法. 讲解的过程中我们遵循由浅入深的规则. 先从简单的示例开始. 3.4.1. 为某个特定的接口创建mock这里假设我们有一个GreetingService的接口, 我们要为其创建mock 123mockery --name GreetingService 我们可以使用 –name来指定我们需要生成mock的interface由于我们没有指定查找GreetingService的目录, 所有我们要切换到与GreetingService同级的目录执行该命令. 3.4.2. 为多个接口生成mock在项目中往往不只一个接口, 如果我们需要为多个接口生成mock应该怎么做呢? 下面即是使用mockery为多个接口生成mock的例子.这里假设我们有两个接口GreetingService 和 OrderService 并且都处在项目根目录下. 123mockery --name &quot;GreetingService|OrderService&quot; 同时我们也可以使用正则表达式来指导接口, 例如我们可以将上面的命令使用正则表达式简化一下, 因为它们的名字中都含有Service, 所以我们可以利用这个命名规范带来的便利. 正则表达式的语法不在本教程的讲解范围之内, 可以执行搜索相关主题了解. 123mockery --name &quot;.*Service&quot; 甚至, 由于我们举的例子中只有两个接口, 在实际项目中我们也许会有这样的需求, 那就是为当前目录下所有的接口生成mock或更新mock. 那我们就可以这样做. 123mockery --all 3.5. 指定查找service的路径上面我们有一个假定, 多个接口都处在同一个目录, 而且都在根目录下. 这显然不符合项目实际, 在真实项目中, 往往接口是有层次结构并按类别分类存放的. 这里假设GreetingService在目录下的greeting目录下, 而OrderService在order目录下. 那么我们可以使用--dir选项来指定查找路径. 123mockery --dir greeting --dir order --name &quot;GreetingService|OrderService&quot; 当然如果接口一多, 项目层次变深, 命令会变得很冗长, 这时我们可以使用-r或--recursive在当前目录的所有子目录中递归查找接口, 例如 123mockery -r --name &quot;GreetingService|OrderService&quot; 这样就可以很好的解决命令冗长琐碎的问题, 另外就我个人见解,实际上--recursive这种选项可以做成默认行为, 我不知道mockery为什么不这样做. 3.6. 为依赖包中的接口生成mock有时我们的项目不仅仅需要mock 项目自身的接口, 有时也需要mock依赖包中的接口. 例如我们需要模拟sql.Result 这个接口. 此时我们可以使用--srcpkg这个选项. 1mockery --srcpkg database/sql --name=Result 3.7. 修改输出目录mockery默认的输出目录为项目根目录的mocks文件夹, 我们可以使用--output这个选项改变默认的output文件夹, 也可以使用--outpkg改变默认的包名 1mockery -r --output mymock --name &quot;GreetingService|OrderService&quot; 改变默认package那么 1mockery -r --output mymock --outpkg mymock --name &quot;GreetingService|OrderService&quot; 更多关于mockery使用, 可以使用mockery --help或查看官方文档. 3.8. mockery mock实战这里依然以之前我的关于golang单元测试的中所使用的范例为例, 讲解使用mockery如何简化我们的测试. 3.9. 实现代码我们创建一个非常简单的服务，如下所示： GreetingService是一个向用户打招呼的服务。其由两种问候方式：Greet（）根据设置的语言向用户打招呼GreetDefaultMessage（）将使用默认消息向用户打招呼致意，不涉及到语言设置.在GreetingService内部，Greet（）将调用db.FetchMessage（lang），GreetDefaultMessage（）将呼叫db.FetchDefaultMessage（）。我们可以在真实场景想象的样子，db类是调用真实数据库的类。因此，我们需要在测试中使用mock来避免测试调用实际的数据库。golang中没有class的概念，但我们可以认为struct行为与类是等效的。 首先我们定义一个名为service包。然后，我们将创建一个dv结构及其接口，并将其命名为db。 DB.go 12345678910package servicetype db struct{}// DB is fake database interface.type DB interface { FetchMessage(lang string) (string, error) FetchDefaultMessage() (string, error)} 然后我们将创建GreetingService接口和实现一个调用DB接口的greeter struct。greeter struct构造函数第二个参数接收lang参数。 123456789101112type greeter struct { database DB lang string}// GreetingService is service to greet your friends.type GreetingService interface { Greet() string GreetInDefaultMsg() string} 为了使数据库结构实现数据库接口，我们将添加所需的方法，并使用指针接收者。 1234567891011121314151617func (d *db) FetchMessage(lang string) (string, error) { // in real life, this code will call an external db // but for this sample we will just return the hardcoded example value if lang == &quot;en&quot; { return &quot;hello&quot;, nil } if lang == &quot;es&quot; { return &quot;holla&quot;, nil } return &quot;bzzzz&quot;, nil}func (d *db) FetchDefaultMessage() (string, error) { return &quot;default message&quot;, nil} 接下来，我们需要实现greeter的方法Greet（）和GreetInDefaultMsg（）。 1234567891011func (g greeter) Greet() string { msg, _ := g.database.FetchMessage(g.lang) // call database to get the message based on the lang return &quot;Message is: &quot; + msg}func (g greeter) GreetInDefaultMsg() string { msg, _ := g.database.FetchDefaultMessage() // call database to get the default message return &quot;Message is: &quot; + msg} 上面，greetiner方法将会调用DB以获取实际消息。为Greeter和DB创建一个工厂方法用于创建greeter和db实例。 12345678func NewDB() DB { return new(db)}func NewGreeter(db DB, lang string) GreetingService { return greeter{db, lang}} 在实现的最后一部分，我们将编写一个主函数来运行服务。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;testify-mock/service&quot;)func main() { d := service.NewDB() g := service.NewGreeter(d, &quot;en&quot;) fmt.Println(g.Greet()) // Message is: hello fmt.Println(g.GreetInDefaultMsg()) // Message is: default message g = service.NewGreeter(d, &quot;es&quot;) fmt.Println(g.Greet()) // Message is: holla g = service.NewGreeter(d, &quot;random&quot;) fmt.Println(g.Greet()) // Message is: bzzzz} 运行后的输出如下。 1234567$ go run main.goMessage is: helloMessage is: default messageMessage is: hollaMessage is: bzzzz 3.10. Mock和测试之前的博客中, 我们是手写Mock代码, 这次我们的Mock部分借助Mockery帮我们自动生成. 在生成Mock之前, 我们需要安装Mockery. 首先我们使用前面学到的知识为GreetingService生成mock 123mockery -r --name &quot;GreetingService|DB&quot; 运行成功后, mockery帮我们生成了, 想要的mock如下 mocks/GreetingService.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mocksimport mock &quot;github.com/stretchr/testify/mock&quot;// GreetingService is an autogenerated mock type for the GreetingService typetype GreetingService struct { mock.Mock}// Greet provides a mock function with given fields:func (_m *GreetingService) Greet() string { ret := _m.Called() var r0 string if rf, ok := ret.Get(0).(func() string); ok { r0 = rf() } else { r0 = ret.Get(0).(string) } return r0}// GreetInDefaultMsg provides a mock function with given fields:func (_m *GreetingService) GreetInDefaultMsg() string { ret := _m.Called() var r0 string if rf, ok := ret.Get(0).(func() string); ok { r0 = rf() } else { r0 = ret.Get(0).(string) } return r0}type mockConstructorTestingTNewGreetingService interface { mock.TestingT Cleanup(func())}// NewGreetingService creates a new instance of GreetingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.func NewGreetingService(t mockConstructorTestingTNewGreetingService) *GreetingService { mock := &amp;GreetingService{} mock.Mock.Test(t) t.Cleanup(func() { mock.AssertExpectations(t) }) return mock} mocks/DB.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mocksimport mock &quot;github.com/stretchr/testify/mock&quot;// DB is an autogenerated mock type for the DB typetype DB struct { mock.Mock}// FetchDefaultMessage provides a mock function with given fields:func (_m *DB) FetchDefaultMessage() (string, error) { ret := _m.Called() var r0 string var r1 error if rf, ok := ret.Get(0).(func() (string, error)); ok { return rf() } if rf, ok := ret.Get(0).(func() string); ok { r0 = rf() } else { r0 = ret.Get(0).(string) } if rf, ok := ret.Get(1).(func() error); ok { r1 = rf() } else { r1 = ret.Error(1) } return r0, r1}// FetchMessage provides a mock function with given fields: langfunc (_m *DB) FetchMessage(lang string) (string, error) { ret := _m.Called(lang) var r0 string var r1 error if rf, ok := ret.Get(0).(func(string) (string, error)); ok { return rf(lang) } if rf, ok := ret.Get(0).(func(string) string); ok { r0 = rf(lang) } else { r0 = ret.Get(0).(string) } if rf, ok := ret.Get(1).(func(string) error); ok { r1 = rf(lang) } else { r1 = ret.Error(1) } return r0, r1}type mockConstructorTestingTNewDB interface { mock.TestingT Cleanup(func())}// NewDB creates a new instance of DB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.func NewDB(t mockConstructorTestingTNewDB) *DB { mock := &amp;DB{} mock.Mock.Test(t) t.Cleanup(func() { mock.AssertExpectations(t) }) return mock} 4. Mock无参方法在上一节中, 我们使用mockery cli创建了一个DB的mock struct, 现在我们可以在测试中使用它了. 在DB interface上有一个不带参数的方法FetchDefaultMessage, 我们想要在测试中模拟它. 我们可以像下面这样创建一个模拟对象: 123456789101112131415161718package service_testimport ( &quot;mocks&quot; &quot;service&quot; &quot;testing&quot; &quot;github.com/stretchr/testify/assert&quot;)func TestMockMethodWithoutArgs(t *testing.T) { theDBMock := &amp;mocks.DB{} // create the mock theDBMock.On(&quot;FetchDefaultMessage&quot;).Return(&quot;foofofofof&quot;, nil) // mock the expectation g := service.NewGreeter(theDBMock, &quot;en&quot;) // create greeter object using mocked db assert.Equal(t, &quot;Message is: foofofofof&quot;, g.GreetInDefaultMsg()) // assert what actual value that will come theDBMock.AssertNumberOfCalls(t, &quot;FetchDefaultMessage&quot;, 1) // we can assert how many times the mocked method will be called theDBMock.AssertExpectations(t) // this method will ensure everything specified with On and Return was in fact called as expected} 在上面的代码中, 我们创建了一个dbMock对象, 并使用On方法指定了要模拟的方法FetchDefaultMessage().然后, 我们使用Return方法指定了模拟方法的返回值. 当该方法被调用时, 将返回我们指定的模拟值. 5. Mock带参数的方法在上一节中, 我们已经了解了如何模拟没有参数的方法. 在这一节中, 我们将学习如何模拟带有参数的方法. 在DB interface上有一个带参数的方法FetchMessage(lang string), 我们想要在测试中模拟它. 我们可以像下面这样创建一个模拟对象: 123456789func TestMockMethodWithArgs(t *testing.T) { theDBMock := &amp;mocks.DB{} theDBMock.On(&quot;FetchMessage&quot;, &quot;sg&quot;).Return(&quot;lah&quot;, nil) // if FetchMessage(&quot;sg&quot;) is called, then return &quot;lah&quot; g := service.NewGreeter(theDBMock, &quot;sg&quot;) assert.Equal(t, &quot;Message is: lah&quot;, g.Greet()) theDBMock.AssertExpectations(t)} 6. 总结在本文中我们介绍了mockery这个mock工具, 以及它的使用方法, 另外列出了两个mockery结合testify进行单元测试的实例, 希望对您有帮助. 7. 参考文档使用testify和mockery库简化单元测试","link":"/golang/mockery_v2.html"},{"title":"在Golang中使用Testify mock框架","text":"1. 前言我使用golang已经有一段时间了，但直到最近我才终于明白如何在golang测试中进行对象mocking。由于我来自Java，所以在golang中mock对象的方式对我来说并不清楚。这篇文章是我如何达到目前理解的自我记录。在这篇文章中，我使用了来自Testify的mock功能 在阅读这篇这篇文章之前, 读者需要有golang基础。 首先, 我们来创建一个非常简单的服务，如下所示： GreeterService是一个向用户打招呼的服务。其由两种问候方式：Greet（）根据设置的语言向用户打招呼GreetDefaultMessage（）将使用默认消息向用户打招呼致意，不涉及到语言设置.在GreeterService内部，Greet（）将调用db.FetchMessage（lang），GreetDefaultMessage（）将呼叫db.FetchDefaultMessage（）。我们可以在真实场景想象的样子，db类是调用真实数据库的类。因此，我们需要在测试中使用mock来避免测试调用实际的数据库。golang中没有class的概念，但我们可以认为struct行为与类是等效的。 2. 实现代码首先我们定义一个名为service包。然后，我们将创建一个dv结构及其接口，并将其命名为db。 DB.go 12345678910package servicetype db struct{}// DB is fake database interface.type DB interface { FetchMessage(lang string) (string, error) FetchDefaultMessage() (string, error)} 然后我们将创建GreeterService接口和实现一个调用DB接口的greeter struct。greeter struct构造函数第二个参数接收lang参数。 123456789101112type greeter struct { database DB lang string}// GreeterService is service to greet your friends.type GreeterService interface { Greet() string GreetInDefaultMsg() string} 为了使数据库结构实现数据库接口，我们将添加所需的方法，并使用指针接收者。 1234567891011121314151617func (d *db) FetchMessage(lang string) (string, error) { // in real life, this code will call an external db // but for this sample we will just return the hardcoded example value if lang == &quot;en&quot; { return &quot;hello&quot;, nil } if lang == &quot;es&quot; { return &quot;holla&quot;, nil } return &quot;bzzzz&quot;, nil}func (d *db) FetchDefaultMessage() (string, error) { return &quot;default message&quot;, nil} 接下来，我们需要实现greeter的方法Greet（）和GreetInDefaultMsg（）。 1234567891011func (g greeter) Greet() string { msg, _ := g.database.FetchMessage(g.lang) // call database to get the message based on the lang return &quot;Message is: &quot; + msg}func (g greeter) GreetInDefaultMsg() string { msg, _ := g.database.FetchDefaultMessage() // call database to get the default message return &quot;Message is: &quot; + msg} 上面，greetiner方法将会调用DB以获取实际消息。为Greeter和DB创建一个工厂方法用于创建greeter和db实例。 12345678func NewDB() DB { return new(db)}func NewGreeter(db DB, lang string) GreeterService { return greeter{db, lang}} 在实现的最后一部分，我们将编写一个主函数来运行服务。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;testify-mock/service&quot;)func main() { d := service.NewDB() g := service.NewGreeter(d, &quot;en&quot;) fmt.Println(g.Greet()) // Message is: hello fmt.Println(g.GreetInDefaultMsg()) // Message is: default message g = service.NewGreeter(d, &quot;es&quot;) fmt.Println(g.Greet()) // Message is: holla g = service.NewGreeter(d, &quot;random&quot;) fmt.Println(g.Greet()) // Message is: bzzzz} 运行后的输出如下。 1234567$ go run main.goMessage is: helloMessage is: default messageMessage is: hollaMessage is: bzzzz 3. Mock和测试在上面的实现完成后, 我们将编写一个测试并模拟DB行为. 如前所述,我们希望在运行测试时防止调用实际数据库. 为了实现这个目标, 我们将mock DB接口. 不幸的是, 在golang中创建模拟对象并不像在Java中那样直截了当. 在Java中使用mockito, mocking可以像下面这样这么简单: 123GreetingService mock = Mockito.mock(GreetingService.class); 但是在golang中, 我们需要创建一个新的结构体并将testify模拟对象嵌入其中, 如下所示: 12345type dbMock struct { mock.Mock} 然后, 为了使该模拟对象符合DB接口, 我们还需要手动实现接口的所有方法. 还有一个指定方法我们需要去调用它.第一: 如果被模拟的方法有参数的话, 我们需要调用Mock.Called(args)接收参数 第二: 调用的放回值将用作我们要模拟的方法的返回值. 两种方法都返回(string, error). 因此, 模拟方法的返回语句是return args.String(0), args.Error(1). 返回语句的规则是args.&lt;ReturnValueType&gt;(&lt;index&gt;). 索引从零开始 1234567891011func (d *dbMock) FetchMessage(lang string) (string, error) { args := d.Called(lang) return args.String(0), args.Error(1)}func (d *dbMock) FetchDefaultMessage() (string, error) { args := d.Called() return args.String(0), args.Error(1)} 按照这个规则, 假设我们要模拟的方法的返回值类型为(int, string, bool), 那么我们在mock方法返回值时需要这样写 return args.Int(0), args.String(1), args.Bool(2) 如果返回值类型中有复杂类型, 如结构体, 接口之类的, 那么return语句应该像这样写. 1return args.Get(0).(*MyObject), args.Get(1).(*AnotherObjectOfMine) 至此我们几乎创建了mockito一句完成的所有内容, 注意这里的用词是几乎, 这里只是创建了struct, 再创建一个实例对象, 就完全完成了mockito帮助我们完成的所有工作. 这些mock步骤都是机械式的, 好在golang帮我实现了一些自动化工具, 这些mock代码也不用我们自己动手写. 手写的过程对于我们理解mock的底层原理还是有帮助的. 有关go mock更多额外信息，请参阅testift go doc。 4. Mock无参方法在上一节中, 我们创建了一个DB的mock struct, 现在我们可以在测试中使用它了.在这一节中, 我们将了解如何使用Testify模拟不带参数的方法. 在DB interface上有一个不带参数的方法FetchDefaultMessage, 我们想要在测试中模拟它. 我们可以像下面这样创建一个模拟对象: 12345678910func TestMockMethodWithoutArgs(t *testing.T) { theDBMock := dbMock{} // create the mock theDBMock.On(&quot;FetchDefaultMessage&quot;).Return(&quot;foofofofof&quot;, nil) // mock the expectation g := greeter{&amp;theDBMock, &quot;en&quot;} // create greeter object using mocked db assert.Equal(t, &quot;Message is: foofofofof&quot;, g.GreetInDefaultMsg()) // assert what actual value that will come theDBMock.AssertNumberOfCalls(t, &quot;FetchDefaultMessage&quot;, 1) // we can assert how many times the mocked method will be called theDBMock.AssertExpectations(t) // this method will ensure everything specified with On and Return was in fact called as expected} 在上面的代码中, 我们创建了一个dbMock对象, 并使用On方法指定了要模拟的方法FetchDefaultMessage().然后, 我们使用Return方法指定了模拟方法的返回值. 当该方法被调用时, 将返回我们指定的模拟值. 5. Mock带参数的方法在上一节中, 我们已经了解了如何模拟没有参数的方法. 在这一节中, 我们将学习如何模拟带有参数的方法. 在DB interface上有一个带参数的方法FetchMessage(lang string), 我们想要在测试中模拟它. 我们可以像下面这样创建一个模拟对象: 12345678func TestMockMethodWithArgs(t *testing.T) { theDBMock := dbMock{} theDBMock.On(&quot;FetchMessage&quot;, &quot;sg&quot;).Return(&quot;lah&quot;, nil) // if FetchMessage(&quot;sg&quot;) is called, then return &quot;lah&quot; g := greeter{&amp;theDBMock, &quot;sg&quot;} assert.Equal(t, &quot;Message is: lah&quot;, g.Greet()) theDBMock.AssertExpectations(t)} 在上面的代码中, 我们创建了一个dbMock对象, 并使用On方法指定了要模拟的方法FetchMessage和参数”sg”. 然后我们使用Return方法指定了模拟方法的返回值. 现在当我们在测试中调用FetchMessage(“sg”)方法时, 将返回我们指定的模拟值. 如果我们想要校验实际参数是否与预期相同, 我们可以使用AssertExpectations方法. 6. Mock带参数的方法, 但是参数具体内容非测试重点有时我们想模拟一个方法，但我们不在乎传递的实际参数。为此，我们可以在On()方法参数后面的第二个参数中使用mock.Anything。 1234567891011func TestMockMethodWithArgsIgnoreArgs(t *testing.T) { theDBMock := dbMock{} theDBMock.On(&quot;FetchMessage&quot;, mock.Anything).Return(&quot;lah&quot;, nil) // if FetchMessage(...) is called with any argument, please also return lah g := greeter{&amp;theDBMock, &quot;in&quot;} assert.Equal(t, &quot;Message is: lah&quot;, g.Greet()) theDBMock.AssertCalled(t, &quot;FetchMessage&quot;, &quot;in&quot;) theDBMock.AssertNotCalled(t, &quot;FetchMessage&quot;, &quot;ch&quot;) theDBMock.AssertExpectations(t) mock.AssertExpectationsForObjects(t, &amp;theDBMock)} 7. Mock带参数的方法, 并校验实际参数有时我们需要模拟一个具有复杂参数的方法，但希望根据参数的某些属性或从中进行计算来匹配mock。例如，我们想模仿FetchMessage方法，但前提是lang参数以字母i开头。 123456789func TestMatchedBy(t *testing.T) { theDBMock := dbMock{} theDBMock.On(&quot;FetchMessage&quot;, mock.MatchedBy(func(lang string) bool { return lang[0] == 'i' })).Return(&quot;bzzzz&quot;, nil) // all of these call FetchMessage(&quot;iii&quot;), FetchMessage(&quot;i&quot;), FetchMessage(&quot;in&quot;) will match g := greeter{&amp;theDBMock, &quot;izz&quot;} msg := g.Greet() assert.Equal(t, &quot;Message is: bzzzz&quot;, msg) theDBMock.AssertExpectations(t)} 8. Mockery正如我们在上一节中所看到的，在进行实际测试和模拟行为之前，我们需要手动创建mock结构体。Mockery可以帮助我们摆脱手工劳动。首先，我们只需要安装Mockery： 1go get github.com/vektra/mockery/.../ 然后生成mock 1mockery -name &lt;interfaceToMock&gt; 将生成一个包含现成mock的文件，我们可以将其添加到测试中。本文中示例代码的完整来源可在此gitlab仓库中获得。 9. 参考Mocking in Golang Using Testify","link":"/golang/mocking_in_golang_using_testify.html"},{"title":"如何升级Golang","text":"升级golang查看当前版本 1234$ go versiongo version go1.19.3 linux/amd64 下载高版本golang 123wget -O /tmp/go1.21.10.linux-amd64.tar.gz https://golang.google.cn/dl/go1.21.10.linux-amd64.tar.gz 备份低版本golang 12345# 将旧版本备份cd /usr/localsudo mv go go1.19.3 将新版本go压缩包解压到/usr/local 1sudo tar -xzf /tmp/go1.21.10.linux-amd64.tar.gz -C /usr/local 检查go版本 1234$go versiongo version go1.21.10 linux/amd64 至此，Go版本已经升级完成啦~~~ 参考文档快速升级Go版本，仅需3分钟","link":"/golang/upgrade_golang.html"},{"title":"如何使用VS Code调试Go代码","text":"本教程将讨论使用 VS Code 调试 Go 代码所需的步骤。首先我们需要安装扩展、分析工具和调试器。 然后，我们将创建一个示例应用程序。最后，我们将探索如何使用断点和条件断点。 凭借这套技能，您将能够更好地理解应用程序在代码执行的特定点上的值和状态。 先决条件要完成本教程，您需要以下内容： 已在您的机器上安装 Go。要在您的机器上安装 Go，请参照 Go 系列中的教程为您的操作系统设置本地编程环境。您的机器上安装了 VS Code, 请参考VSCode 安装和配置指南进行安装与配置 。 已安装 VSCode -Go 插件。 安装插件后，在 VS Code 中打开任意.go 文件。状态栏右下角会提示您安装分析工具。单击该链接安装插件有效运行所需的 Go 包。 最后，我们需要安装Delve，一个用于 Go 的开源调试器。为此，有针对特定平台的详细安装说明。 第 1 步 - 创建示例应用程序我们将使用两个示例来调试我们的 Go 代码： 生成 JSON 文件的 Go 程序。我们将编写一个函数，编写测试，并了解如何在 VS Code 中调试测试。这是第一个例子的源代码。创建一个文件 main.go： 1nano main.go 在文件中添加以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;log&quot;)// Avenger represents a single herotype Avenger struct { RealName string `json:&quot;real_name&quot;` HeroName string `json:&quot;hero_name&quot;` Planet string `json:&quot;planet&quot;` Alive bool `json:&quot;alive&quot;`}func (a *Avenger) isAlive() { a.Alive = true}func main() { avengers := []Avenger{ { RealName: &quot;Dr. Bruce Banner&quot;, HeroName: &quot;Hulk&quot;, Planet: &quot;Midgard&quot;, }, { RealName: &quot;Tony Stark&quot;, HeroName: &quot;Iron Man&quot;, Planet: &quot;Midgard&quot;, }, { RealName: &quot;Thor Odinson&quot;, HeroName: &quot;Thor&quot;, Planet: &quot;Midgard&quot;, }, } avengers[1].isAlive() jsonBytes, err := json.Marshal(avengers) if err != nil { log.Fatalln(err) } fmt.Println(string(jsonBytes))} 这里我们定义一个结构体Avenger，然后创建一个复仇者数组，将其中一个的状态更改为”alive”，然后将结果转换为 JSON，最后将其打印到 STDOUT。 你可以使用以下命令运行该应用程序： 123go run main.go 它将产生以下输出： 1234Output[{&quot;real_name&quot;:&quot;Dr. Bruce Banner&quot;,&quot;hero_name&quot;:&quot;Hulk&quot;,&quot;planet&quot;:&quot;Midgard&quot;,&quot;alive&quot;:false},{&quot;real_name&quot;:&quot;Tony Stark&quot;,&quot;hero_name&quot;:&quot;Iron Man&quot;,&quot;planet&quot;:&quot;Midgard&quot;,&quot;alive&quot;:true},{&quot;real_name&quot;:&quot;Thor Odinson&quot;,&quot;hero_name&quot;:&quot;Thor&quot;,&quot;planet&quot;:&quot;Midgard&quot;,&quot;alive&quot;:false}] 第 2 步 - 使用断点进行调试要开始调试，我们需要创建一个配置。单击 VS Code 左侧窗格上的调试图标。接下来，单击齿轮图标以创建配置。 在下面创建了一个配置文件，.vscode/launch.json其内容如上所示。更改配置程序以指向该main.go文件。在本例中，由于我们只有一个main.go文件，我们可以将其更改为我们的工作区根目录： 12345678910111213141516{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Launch golang program&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, &quot;program&quot;: &quot;main.go&quot; } ]} 接下来我们需要添加一个断点，因为这就是调试的全部内容。 让我们通过单击行号左侧在第 21 行( ) 添加一个断点。在那里，您将看到一个红点。func main() 接下来，按下或单击左上角调试部分F5上带有绿色播放按钮的启动按钮以打开调试视图。 多次单击调试工具栏Step Over上的按钮。 调试器最终将移动到第 40 行。 左侧的调试部分将为我们提供当前断点位置的状态。 我们可以在变量部分看到特定时间的变量的状态或值。 我们还可以看到调用堆栈，此刻正在运行的函数是该main函数，第 40 行。 avengers您可以继续“跨过”，一旦我们越过该线，您就会看到变化的值。”Tony Stark”是Alive。 第 3 步 - 添加条件断点VS Code 断点为您提供了通过赋予表达式来编辑断点的选项，该表达式大多数时候通常是一个布尔表达式。 例如，在第 40 行，avengers[1].isAlive()我们可以在此处添加一个条件，即仅当表达式计算结果为真时才会引发断点，如avengers[1].Planet == “Earth”。 为此，右键单击断点并选择编辑断点。 如果您没有断点，您仍然可以右键单击，然后系统会提示您添加条件断点。 选择上述任意一项后，让我们添加条件：avengers[1].Planet == “Earth”。 现在，如果您使用 启动调试器，它将不会在断点处停止。应用程序将正常运行，您将在调试控制台F5中看到结果。 接下来，编辑代码以符合我们的预期。将 Tony Stark 的星球更改为Earth 1234567// ...{ RealName: &quot;Tony Stark&quot;, HeroName: &quot;Iron Man&quot;, Planet: &quot;Earth&quot;,},// ... 当我们再次使用 启动调试器时F5，调试视图会打开，并且执行会在断点处停止。我们可以看到 JSON 未显示在调试控制台中。 第 4 步 - 执行step into的调试让我们向文件中添加一个新函数，以启用加法运算 123func add(a, b int) int{ return a+b} 在同一目录下创建一个测试文件main_test.go，内容如下： 12345678910111213package mainimport &quot;testing&quot;func Test_add(t *testing.T) { a, b, c := 1, 2, 3 res := add(a, b) if res != c { t.Fail() }} 代码只是将两个数字相加，测试只是调用该函数。 但是，如果你安装了 VSCode-Go 插件，你会在测试函数顶部看到其他选项 -运行测试和调试测试： 您可以单击运行测试来运行测试并在输出窗口中查看结果。 然而，为了调试测试，可能是因为我们无法弄清楚某些事情，我们需要做的就是添加一个断点，就像我们之前做的那样，然后单击“调试测试”。 在第 10 行添加断点：if res != c。然后点击调试测试。 调试视图再次打开，我们可以使用调试工具来检查左侧变量部分的状态。 结论调试是软件开发的重要部分，借助 VS Code 等工具，我们的生活可以变得更加轻松。 我们已将调试器添加到示例项目中以解释概念，但您可以随意将调试器添加到任何现有项目中并试用它。您最终将减少fmt.Println用于记录的语句，以便在执行期间查看代码在给定点的值或状态。 参考文档How To Debug Go Code with Visual Studio Code","link":"/golang/vscode_debug_golang.html"},{"title":"golang使用Zap日志库","text":"1. zap 介绍Golang Zap库是一个由Uber公司开发的高性能日志记录库，专为Go语言应用程序设计。Zap库以其出色的性能和灵活性而闻名，为开发者提供了结构化、分级别的日志记录功能，此外Zap库还支持日志切割功能，可以根据文件大小、时间或间隔等来切割日志文件，方便管理和分析。Zap库还支持自定义日志格式和输出方式。你可以通过配置Encoder来自定义日志的输出格式，包括时间戳、日志级别、调用文件/函数名和行号等信息。同时，你还可以将日志输出到不同的目的地，如控制台、文件或远程日志系统。 Zap库提供了两种类型的日志记录器：Sugared Logger和Logger。Sugared Logger在性能较好但不建议在关键性的上下文中使用，它相较于其他结构化日志记录包快4-10倍，并支持结构化和printf风格的日志记录。 而Logger则适用于每一微秒和每一次内存分配都至关重要的场景。 Zap库具有一些显著的特点。首先，它提供了极快的日志记录速度，这得益于其内部高效的内存分配和编码机制。其次，Zap库支持结构化日志记录，这意味着你可以将日志记录为键值对的形式，使得日志更加易于理解和分析。此外，Zap库还支持不同的日志级别，如INFO、DEBUG、ERROR等，方便开发者根据需求进行日志级别的调整。 总的来说，Golang Zap库是一个功能强大、性能卓越的日志记录库，适用于各种规模的Go语言应用程序。它提供了灵活的配置选项和丰富的功能，帮助开发者有效地记录和管理日志信息，提高应用程序的可维护性和可观察性。 Zap代码库 2. 快速开始先安装： 123go get go.uber.org/zap 后使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;time&quot; &quot;go.uber.org/zap&quot;)func main() { // zap库的使用与其他的日志库非常相似，先创建一个logger。 // zap提供了几个快速创建logger的方法，zap.NewExample()、zap.NewDevelopment()、zap.NewProduction()， // 还有高度定制化的创建方法zap.New()。创建前 3 个logger时，zap会使用一些预定义的设置，它们的使用场景也有所不同。 // - Example适合用在测试代码中， // - Development在开发环境中使用， // - Production用在生成环境。 logger := zap.NewExample() // zap底层 API 可以设置缓存，所以一般使用defer logger.Sync()将缓存同步到文件中。 defer logger.Sync() url := &quot;http://example.org/api&quot; // 然后调用各个级别的方法记录日志（Debug/Info/Error/Warn） logger.Info(&quot;failed to fetch URL&quot;, // 由于fmt.Printf之类的方法大量使用interface{}和反射，会有不少性能损失，并且增加了内存分配的频次。 // zap为了提高性能、减少内存分配次数，没有使用反射，而且默认的Logger只支持强类型的、结构化的日志。 // 必须使用zap提供的方法记录字段。zap为 Go 语言中所有的基本类型和其他常见类型都提供了方法。 // 这些方法的名称也比较好记忆，zap.Type（Type为bool/int/uint/float64/complex64/time.Time/time.Duration/error等）就表示该类型的字段， // zap.Typep以p结尾表示该类型指针的字段，zap.Types以s结尾表示该类型切片的字段。如： // - zap.Bool(key string, val bool) Field：bool字段 // - zap.Boolp(key string, val *bool) Field：bool指针字段； // - zap.Bools(key string, val []bool) Field：bool切片字段。 // 当然也有一些特殊类型的字段： // zap.Any(key string, value interface{}) Field：任意类型的字段； // zap.Binary(key string, val []byte) Field：二进制串的字段。 zap.String(&quot;url&quot;, url), zap.Int(&quot;attempt&quot;, 3), zap.Duration(&quot;backoff&quot;, time.Second), ) // 当然，每个字段都用方法包一层用起来比较繁琐。zap也提供了便捷的方法SugarLogger，可以使用printf格式符的方式。调用logger.Sugar()即可创建SugaredLogger // SugaredLogger的使用比Logger简单，只是性能比Logger低 50% 左右，可以用在非热点函数中。 // 调用SugarLogger以f结尾的方法与fmt.Printf没什么区别，如例子中的Infof。 // 同时SugarLogger还支持以w结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可，如例子中的Infow。 sugar := logger.Sugar() sugar.Infow(&quot;failed to fetch URL&quot;, &quot;url&quot;, url, &quot;attempt&quot;, 3, &quot;backoff&quot;, time.Second, ) sugar.Infof(&quot;Failed to fetch URL: %s&quot;, url)} 默认情况下，Example输出的日志为 JSON 格式： 12345{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;failed to fetch URL&quot;,&quot;url&quot;:&quot;http://example.org/api&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;}{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;failed to fetch URL&quot;,&quot;url&quot;:&quot;http://example.org/api&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;}{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Failed to fetch URL: http://example.org/api&quot;} 3. 记录层级关系前面我们记录的日志都是一层结构，没有嵌套的层级。我们可以使用zap.Namespace(key string) Field构建一个命名空间，后续的Field都记录在此命名空间中： 123456789101112131415161718func main() { logger := zap.NewExample() defer logger.Sync() //直接调用Info方法输出日志 logger.Info(&quot;tracked some metrics&quot;, zap.Namespace(&quot;metrics&quot;), zap.Int(&quot;counter&quot;, 1), ) // 调研With方法创建logger logger2 := logger.With( zap.Namespace(&quot;metrics&quot;), zap.Int(&quot;counter&quot;, 1), ) logger2.Info(&quot;tracked some metrics&quot;)} 输出： 1234{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:{&quot;counter&quot;:1}}{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:{&quot;counter&quot;:1}} 上面我们演示了两种Namespace的用法， 一种是直接作为字段传入Debug/Info等方法， 一种是调用With()创建一个新的Logger，新的Logger记录日志时总是带上预设的字段。 With()方法实际上是创建了一个新的Logger： 123456789// src/go.uber.org/zap/logger.gofunc (log *Logger) With(fields ...Field) *Logger { if len(fields) == 0 { return log } l := log.clone() l.core = l.core.With(fields) return l} 4. 定制Logger调用NexExample()/NewDevelopment()/NewProduction()这 3 个方法，zap使用默认的配置。我们也可以手动调整，配置结构如下： 1234567891011// src/go.uber.org/zap/config.gotype Config struct { Level AtomicLevel `json:&quot;level&quot; yaml:&quot;level&quot;` Encoding string `json:&quot;encoding&quot; yaml:&quot;encoding&quot;` EncoderConfig zapcore.EncoderConfig `json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;` OutputPaths []string `json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;` ErrorOutputPaths []string `json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;` InitialFields map[string]interface{} `json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`} Level：日志级别； Encoding：输出的日志格式，默认为 JSON； OutputPaths：可以配置多个输出路径，路径可以是文件路径和stdout（标准输出）； ErrorOutputPaths：错误输出路径，也可以是多个； InitialFields：每条日志中都会输出这些值。 其中EncoderConfig为编码配置： 1234567891011121314151617/ src/go.uber.org/zap/zapcore/encoder.gotype EncoderConfig struct { MessageKey string `json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;` LevelKey string `json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;` TimeKey string `json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;` NameKey string `json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;` CallerKey string `json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;` StacktraceKey string `json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;` LineEnding string `json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;` EncodeLevel LevelEncoder `json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;` EncodeTime TimeEncoder `json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;` EncodeDuration DurationEncoder `json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;` EncodeCaller CallerEncoder `json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;` EncodeName NameEncoder `json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`} MessageKey：日志中信息的键名，默认为msg； LevelKey：日志中级别的键名，默认为level； EncodeLevel：日志中级别的格式，默认为小写，如debug/info。 调用zap.Config的Build()方法即可使用该配置对象创建一个Logger： 12345678910111213141516171819202122232425262728func main() { rawJSON := []byte(`{ &quot;level&quot;:&quot;debug&quot;, &quot;encoding&quot;:&quot;json&quot;, &quot;outputPaths&quot;: [&quot;stdout&quot;, &quot;server.log&quot;], &quot;errorOutputPaths&quot;: [&quot;stderr&quot;], &quot;initialFields&quot;:{&quot;name&quot;:&quot;dj&quot;}, &quot;encoderConfig&quot;: { &quot;messageKey&quot;: &quot;message&quot;, &quot;levelKey&quot;: &quot;level&quot;, &quot;levelEncoder&quot;: &quot;lowercase&quot; } }`) var cfg zap.Config if err := json.Unmarshal(rawJSON, &amp;cfg); err != nil { panic(err) } logger, err := cfg.Build() if err != nil { panic(err) } defer logger.Sync() logger.Info(&quot;server start work successfully!&quot;)} 上面创建一个输出到标准输出stdout和文件server.log的Logger。观察输出： 123{&quot;level&quot;:&quot;info&quot;,&quot;message&quot;:&quot;server start work successfully!&quot;,&quot;name&quot;:&quot;dj&quot;} 使用NewDevelopment()创建的Logger使用的是如下的配置： 123456789101112131415161718192021222324252627282930// src/go.uber.org/zap/config.gofunc NewDevelopmentConfig() Config { return Config{ Level: NewAtomicLevelAt(DebugLevel), Development: true, Encoding: &quot;console&quot;, EncoderConfig: NewDevelopmentEncoderConfig(), OutputPaths: []string{&quot;stderr&quot;}, ErrorOutputPaths: []string{&quot;stderr&quot;}, }}func NewDevelopmentEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ // Keys can be anything except the empty string. TimeKey: &quot;T&quot;, LevelKey: &quot;L&quot;, NameKey: &quot;N&quot;, CallerKey: &quot;C&quot;, MessageKey: &quot;M&quot;, StacktraceKey: &quot;S&quot;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.StringDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, }} NewProduction()的配置可自行查看。 5. 选项NewExample()/NewDevelopment()/NewProduction()这 3 个函数可以传入若干类型为zap.Option的选项，从而定制Logger的行为。 zap提供了丰富的选项供我们选择。下面以AddCaller和AddCallerSkip为例进行讲解。 5.1. 输出文件名和行号调用zap.AddCaller()返回的选项设置输出文件名和行号。但是有一个前提，必须设置配置对象Config中的CallerKey字段。也因此NewExample()不能输出这个信息（它的Config没有设置CallerKey）。 12345678func main() { logger, _ := zap.NewProduction(zap.AddCaller()) defer logger.Sync() logger.Info(&quot;hello world&quot;)} 输出： 1{&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1587740198.9508286,&quot;caller&quot;:&quot;caller/main.go:9&quot;,&quot;msg&quot;:&quot;hello world&quot;} Info()方法在main.go的第 9 行被调用。AddCaller()与zap.WithCaller(true)等价。 有时我们稍微封装了一下记录日志的方法，但是我们希望输出的文件名和行号是调用封装函数的位置。这时可以使用zap.AddCallerSkip(skip int)向上跳 1 层： 123456789101112func Output(msg string, fields ...zap.Field) { zap.L().Info(msg, fields...)}func main() { logger, _ := zap.NewProduction(zap.AddCaller(), zap.AddCallerSkip(1)) defer logger.Sync() zap.ReplaceGlobals(logger) Output(&quot;hello world&quot;)} 输出： 1{&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1587740501.5592482,&quot;caller&quot;:&quot;skip/main.go:15&quot;,&quot;msg&quot;:&quot;hello world&quot;} 输出在main函数中调用Output()的位置。如果不指定zap.AddCallerSkip(1)，将输出”caller”:”skip/main.go:6”，这是在Output()函数中调用zap.Info()的位置。因为这个Output()函数可能在很多地方被调用，所以这个位置参考意义并不大。试试看！ 5.2. 输出调用堆栈有时候在某个函数处理中遇到了异常情况，因为这个函数可能在很多地方被调用。如果我们能输出此次调用的堆栈，那么分析起来就会很方便。我们可以使用zap.AddStackTrace(lvl zapcore.LevelEnabler)达成这个目的。该函数指定lvl和之上的级别都需要输出调用堆栈： 123456789101112131415161718func f1() { f2(&quot;hello world&quot;)}func f2(msg string, fields ...zap.Field) { zap.L().Warn(msg, fields...)}func main() { logger, _ := zap.NewProduction(zap.AddStacktrace(zapcore.WarnLevel)) defer logger.Sync() zap.ReplaceGlobals(logger) f1()} 将zapcore.WarnLevel传入AddStacktrace()，之后Warn()/Error()等级别的日志会输出堆栈，Debug()/Info()这些级别不会。运行结果： 123{&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:1587740883.4965692,&quot;caller&quot;:&quot;stacktrace/main.go:13&quot;,&quot;msg&quot;:&quot;hello world&quot;,&quot;stacktrace&quot;:&quot;main.f2\\n\\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:13\\nmain.f1\\n\\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:9\\nmain.main\\n\\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:22\\nruntime.main\\n\\tC:/Go/src/runtime/proc.go:203&quot;} 把stacktrace单独拉出来： 12345678910main.f2d:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:13 main.f1 d:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:9 main.main d:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:22 runtime.main C:/Go/src/runtime/proc.go:203 很清楚地看到调用路径。 全局Logger为了方便使用，zap提供了两个全局的Logger，一个是zap.Logger，可调用zap.L()获得；另一个是zap.SugaredLogger，可调用zap.S()获得。需要注意的是，全局的Logger默认并不会记录日志！它是一个无实际效果的Logger。看源码: 12345678// go.uber.org/zap/global.govar ( _globalMu sync.RWMutex _globalL = NewNop() _globalS = _globalL.Sugar()) 我们可以使用ReplaceGlobals(logger *Logger) func()将logger设置为全局的Logger，该函数返回一个无参函数，用于恢复全局Logger设置： 12345678910111213func main() { zap.L().Info(&quot;global Logger before&quot;) zap.S().Info(&quot;global SugaredLogger before&quot;) logger := zap.NewExample() defer logger.Sync() zap.ReplaceGlobals(logger) zap.L().Info(&quot;global Logger after&quot;) zap.S().Info(&quot;global SugaredLogger after&quot;)} 输出： 1234{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;global Logger after&quot;}{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;global SugaredLogger after&quot;} 可以看到在调用ReplaceGlobals之前记录的日志并没有输出。 预设日志字段如果每条日志都要记录一些共用的字段，那么使用zap.Fields(fs …Field)创建的选项。例如在服务器日志中记录可能都需要记录serverId和serverName： 12345678func main() { logger := zap.NewExample(zap.Fields( zap.Int(&quot;serverId&quot;, 90), zap.String(&quot;serverName&quot;, &quot;awesome web&quot;), )) logger.Info(&quot;hello world&quot;)} 输出： 1{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;hello world&quot;,&quot;serverId&quot;:90,&quot;serverName&quot;:&quot;awesome web&quot;} 与标准日志库搭配使用如果项目一开始使用的是标准日志库log，后面想转为zap。这时不必修改每一个文件。我们可以调用zap.NewStdLog(l *Logger) *log.Logger返回一个标准的log.Logger，内部实际上写入的还是我们之前创建的zap.Logger： 123456789func main() { logger := zap.NewExample() defer logger.Sync() std := zap.NewStdLog(logger) std.Print(&quot;standard logger wrapper&quot;)} 输出： 1{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;standard logger wrapper&quot;} 很方便不是吗？我们还可以使用NewStdLogAt(l *logger, level zapcore.Level) (log.Logger, error)让标准接口以level级别写入内部的zap.Logger。 如果我们只是想在一段代码内使用标准日志库log，其它地方还是使用zap.Logger。可以调用RedirectStdLog(l *Logger) func()。它会返回一个无参函数恢复设置： 12345678910func main() { logger := zap.NewExample() defer logger.Sync() undo := zap.RedirectStdLog(logger) log.Print(&quot;redirected standard library&quot;) undo() log.Print(&quot;restored standard library&quot;)} 看前后输出变化： 12{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;redirected standard library&quot;}2020/04/24 22:13:58 restored standard library 当然RedirectStdLog也有一个对应的RedirectStdLogAt以特定的级别调用内部的*zap.Logger方法。 总结zap用在日志性能和内存分配比较关键的地方。本文仅介绍了zap库的基本使用，子包zapcore中有更底层的接口，可以定制丰富多样的Logger。","link":"/golang/zap_logging.html"},{"title":"Hexo博客搜索引擎优化","text":"1. 如何让自己的博客网站被收录1.1. 首先检查自己的站点有没有被收录以百度为例 打开百度http://www.baidu.com 在收索框输入 site: 你的网站域名 如果你用 site:高级搜索没有搜索到你的网站，那么说明你的网站并没有被搜索引擎收录。 如果搜索到了，但通过网站的关键词搜索不到，说明你的网站排名靠后，正需要 SEO 优化。 1.2. 让百度收录你的网站 首先，进入百度搜索资源平台； 打开平台后，点击用户中心，点击站点管理，如果未登录，需要先登录； 点击添加网站，选择你的协议头 http/https 按照自身情况选择，输入你的网站地址，点击下一步； 验证网站: 一般验证网站有以下几种验证方法: 文件验证 (推荐) 文件验证是指将百度给你的 html 文件放到 source 目录下(即 source/baidu_verify_code_xxxx.html) 值得注意的是:文件验证的文件是一个 HTML 文件，hexo 可能会将他与主题镶嵌在一起，所以要在百度给你的 HTML 文件上加入以下代码: 123---layout: false--- html 标签验证 html 标签验证则是在 head 标签里添加百度所指定的代码 CNAME 验证 (推荐) CNAME 验证就是添加域名解析记录 请将 code-xxxxx.guoapeng.github.io 使用 CNAME 解析到 ziyuan.baidu.com 完成操作后请点击“完成验证”按钮。 为保持验证通过的状态,成功验证后请不要删除该 DNS 记录 对于 hexo 的博客来说，我个人建议 CNAME 和文件验证这两种 网站验证成功后，就可以在站点管理管理你的网站了。 提交完你的网站后，不出意外的情况下，搜索引擎会在几个星期内收录你的网站，一般不超过一个月，超过一个月的话可能就有问题了。 1.3. 让 Bing 收录你的网站 首先，进入bing webmaster tools； 进入bing webmaster tools时，如果未登录，需要先登录； 点击添加网站，输入你的网站地址，点击添加； 验证网站: 一般验证网站有以下几种验证方法: xml 文件验证 (推荐) 文件验证是指将百度给你的 xml 文件放到 source 目录下(即 source/BingSiteAuth.xml) HTML Meta 标记验证 html 标签验证则是在 head 标签里添加百度所指定的代码将 &lt;meta&gt; 标记复制并粘贴到你网站的主页中。该标记应位于第一个 &lt;body&gt; 部分前面的 &lt;head&gt; 部分中。&lt;meta name=&quot;msvalidate.01&quot; content=&quot;xxxxxx&quot; /&gt; 要保持已验证状态，请勿移除 meta 标记，即使验证成功后也是如此. CNAME 验证 (推荐)手动将 CNAME 记录添加到域名服务器中添加名为 xxx 且值为 verify.bing.com 的 CNAME (别名)记录。 以上三种验证方式, 任选一种, 进行验证 1.4. 优化结构seo 搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用 hexo 编译的站点打开文章的 url 是：sitename/year/mounth/day/title 四层的结构，这样的 url 结构很不利于 seo，爬虫就会经常爬不到我们的文章，于是，我们可以将 url 直接改成 sitename/title 的形式，并且 title 最好是用英文，在根目录的配置文件下修改 permalink 如下： 12345678url: http://你的网站root: /permalink: :title.htmlpermalink_defaults:pretty_urls: trailing_index: false # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 这里建议添加 html 后缀, 这样搜索引擎从 url 后缀也能判断是 html 页面这里建议将 trailing_index 设置为 false 这样生成的目录结构又会缩短一层变成’http://你的网站/category/title.html’如果不设置为 false, 则页面的永久连接为’http://你的网站/category/title/index.html’ 1.5. 添加 sitemap 站点地图sitemap 站点地图可以让搜索引擎更便捷的抓取你的网站，一般为 XML 文件。 hexo 有两个插件可以自动生成 sitemap： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 安装完成后，进入 hexo 根目录的_config.yml 配置文件，添加以下代码: 1.6. 自动生成 sitemap12345678# common sitemap for all the search enginessitemap: path: sitemap.xml tags: false categories: false# for baidybaidusitemap: path: baidusitemap.xml 为什么要配置tags:false 和categories: false 主要是为了解决“Noindex page in sitemap”的问题hexo生成的tag页面和category页面中带有&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt; 标记告诉search engine不要index该页面，但是hexo-generator-sitemap又会将其保护到sitemap之中，导致Noindex page in sitemap问题的页面数量过高详情参考Lei Mao的分析Google Search Console Coverage Error Fix for Hexo Blog 每次运行 hexo g ，则会在缓存文件夹下生成 sitemap.xml baidusitemap.xml 则为成功。 生成了 sitemap 后，则需要提交 sitemap 给搜索引擎: 百度则是进入搜索资源平台的站点管理，点击 sitemap，添加 baidusitemap.xml 的路径谷歌则是进入 Google Search Console，进入站点地图，添加 sitemap.xml 的路径其中 sitemap.xml 文件是搜索引擎通用的 sitemap 文件 1.7. 关键词与描述的优化keywords 和 description 是告诉搜索引擎你这个网页的关键词和你这个网页是干什么的，不能乱写。 1.8. 代码压缩网页的代码存在大量空白符，压缩代码可以提高网站被访问速度。 安装以上插件: 123npm install hexo-neat --save 配置插件 修改根目录下的配置文件_config.yml 添加以下代码: 12345678910111213141516neat_enable: trueneat_html: enable: true exclude:neat_css: enable: true exclude: - &quot;**/*.min.css&quot;neat_js: enable: true mangle: true output: compress: exclude: - &quot;**/*.min.js&quot; - &quot;**/index.js&quot; 1.9. 添加 robots.txt在网站优化过程中，有些时候，网站中有重要及私密的内容，站长并不希望某些页面被蜘蛛抓取，比如后台的数据，测试阶段的网站，还有一种很常见的情况，搜索引擎抓取的大量没有意义的页面。 robots.txt 是一个纯文本文件，用于声明该网站中不想被蜘蛛访问的部分，或指定蜘蛛抓取的部分，当蜘蛛访问一个站点时，它会首先检查该站点是否存在，robots.txt，如果找到，蜘蛛就会按照该文件中的内容来确定抓取的范围，如果该文件不存在，那么蜘蛛就会沿着链接直接抓取。即，只有在需要禁止抓取某些内容是，写 robots.txt 才有意义. robots 配置方法如下： 在 …/source 路径下创建 robots.txt 文件，里面输入你的 robots 配置，如果不懂，可以百度 robots 的语法，修改后保存即可提交。 例如： 12345678910111213# welcome to : eagle's blogUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /about/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /lib/Sitemap: https://your_site_address/sitemap.xml 注意 Disallow 与 Allow 行的顺序是有意义的 12345678910111213举例说明：允许爬虫蜘蛛访问 /admin/ 目录下的seo文件夹 User-agent: * Allow: /admin/seo/ Disallow: /admin/如果Allow 和 Disallow 的顺序调换一下： User-agent: * Disallow: /admin/ Allow: /admin/seo/ 爬虫蜘蛛就无法访问到 /admin/ 目录下的 seo 文件夹，因为第一个 Disallow: /admin/ 已匹配成功。 在百度站长平台监测并更新 Robots提示检测到您更新了 Robots 文件即成功。 2. 开启百度推送每次更新博客时，主动向百度提交链接，有利于 SEO． 安装 hexo-baidu-url-submit 123npm install hexo-baidu-url-submit --save# 使用淘宝cnpm可以加快速度cnpm install hexo-baidu-url-submit --save 修改根目录下的_config 配置 设置百度主动推送 12345baidu_url_submit: count: 200 # 比如200，代表提交最新的200个链接 host: www.pengtech.net # 在百度站长平台中注册的域名 token: your_token # 百度站长密钥 path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认 修改根目录下的_config 配置 Deploy 检验是否成功当出现类似以下信息，表示配置成功． 123456INFO Deploying: baidu_url_submitterINFO Submitting urlshttps://pengtech.net/20211028/linux/create_rpm_repository_on_linux/https://pengtech.net/20211028/linux/how_to_create_rpm_package/{&quot;remain&quot;:2978,&quot;success&quot;:22}INFO Deploy done: baidu_url_submitter 3. 谷歌收录站点进行这个之前，首先友情提示下大佬们，最好开个 开启魔法，因为很多涉及谷歌服务，我这里用的是 V2Raya，网上有很多，可以参考2rayA 安装与配置教程 打开 Google Search Console，添加博客地址。并进行相关验证,根据提示即可完成认证,认证成功如下： 认证方法其实这里方法和百度的类似，也有三种，我用的是直接下载文件，放到我的站点 source 目录下，然后我在 git 命令面板里输入以下指令（下面将这一套指令简称为更新并同步文件指令） 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 之后，我去 google 认证，发现并不能验证成功，后来去站点配置_config.yml 下添加了一句代码 1google-site-verification: true 修改 Next theme 的_config.yml 123# Google Webmaster tools verification.# See: https://developers.google.com/searchgoogle_site_verification: your_google_verification_code 4. 首页标题优化SEO 最重要的是你的标题，一般搜索都是搜索你的标题。更改 index.swig 文件(your-hexo-site\\themes\\next\\layout\\layout.njk);将 1&lt;title&gt;{% block title %} {% endblock %}&lt;/title&gt; 修改为: 1&lt;title&gt;{% block title %} - {{ theme.description }} {% endblock %}&lt;/title&gt; 这时候你的首页会更符合网站名称 - 网站描述这习惯。 5. 补充: 让 bing, google, baidu 快速收录网站对于 Hexo 博客，我们需要快速将内容主动提交给搜索引擎，其他人仅搜索文章的关键字时才能看到我们的文章，从而提高了曝光率。这里需要安装插件 并修改 hexo 配置 hexo-submit-urls-to-search-engine安装: 1npm install --save hexo-submit-urls-to-search-engine 配置:需要修改 hexo 的配置文件_config.yml 123456789101112131415hexo_submit_urls_to_search_engine: submit_condition: count # count/period The submitted condition, only supports count now count: 20 ## Submit the latest 10 links period: 900 #A period of time, in seconds, the update time of the article is away from the running time of the plugin. Within this period of time, the link will be submitted google: 1 # 1/0-&gt;on/off Submit to Google bing: 1 #Submit to bing baidu: 1 #Submit to baidu txt_path: submit_urls.txt ## The address of the text document, the link to be pushed will be saved in this text document baidu_host: https://pengtech.net ## Domain name registered in Baidu webmaster platform baidu_token: xxxxx ## Please note that this is your secret key, so do not publish the website source code in the public repository! bing_host: https://pengtech.net ## Domain name registered in Bing webmaster platform bing_token: xxxxx ## Please note that this is your secret key, so do not publish the website source code in the public repository! google_host: https://pengtech.net ## Domain name registered in Google webmaster platform google_key_file: Project.json #Store the json file of the google key in the root directory of the website (same location as the hexo config.yml file), please do not publish the source code of the website in the public warehouse! google_proxy: 0 # 向谷歌提交网址所使用的系统 http 代理，填 0 不使用代理 记得看后面的注释说明，需要注意的是 google_proxy 这个配置项，如果本地能直接访问 google 设置为 0, 表示不通过代理，如果需要通过代理访问 google 服务，这里设为代理 url,如果 Hexo 源代码托管在可以直接访问 Google 的集成部署平台（如：Travis CI、Vercel、Github Actions…）请将代理配置设为 0，并将部署命令由 hexo generate 改为 hexo generate &amp;&amp; hexo deploy 5.1. 如何获得 bing_token登录 bing webmasters, 点击设置-&gt; API 访问 管理凭据 -&gt; API 密钥 管理密钥 -&gt; 即可看到 api 密钥. 5.2. 添加新的 deploy1234deploy: - type: cjh_google_url_submitter - type: cjh_bing_url_submitter - type: cjh_baidu_url_submitter 发布 123hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 此时可以看到日志中已经可以提交连接到百度和 bing 5.3. 如何获得 google_key_file详情请参考: https://blog.dejavu.moe/posts/hexo-seo https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine 打开 Google Indexing API 的官方文档可以看到 使用 Indexing API 的前提条件，按照该文档完成以下步骤： 打开服务帐号页面，登陆。 为客户端创建一个项目 创建服务账号 输入账号名，继续 选择角色： owner 继续 添加密钥 点击服务账号，进入详情，切换到密钥 tab 注意在 创建密钥时以 json 格式保存密钥，点击 创建 会自动下载密钥文件，请妥善保存后面会用到 返回 google console 设置导航到 设置 =》用户和权限 =》添加用户， 将创建服务账号是生成的服务邮箱地址添加为新用户，并授予所有者权限 将 json 文件放置到与_config.yml 同级别目录 修改_config.yml 的 google_key_file 属性指向正确的 keyfile 打开google cloud console 开启 google api 6. 使用 indexnow 快速提交链接 说明： 如果使用了 indexnow 提交链接，那么前面一节讲的 hexo-submit-urls-to-search-engine 中关于向 bing 提交链接的方式可以关闭。更推荐使用 indexnow 向 bing 提交链接。 Bing IndexNow 是一个由微软 Bing 与俄罗斯搜索引擎 Yandex 联合推出的新技术协议，旨在提高搜索引擎对网站内容更新的响应速度和索引效率。 IndexNow 协议允许网站在内容被创建、更新或删除时，通过 API 主动通知搜索引擎。这改变了传统搜索引擎通过爬虫主动抓取网站内容的方式，转变为被动等待网站通知的推送模式。 目前，IndexNow 协议已经被 Bing 和 Yandex 等多个搜索引擎采用，并且已经有超过 8 万个网站开始使用并享受其带来的好处。 6.1. 生成接口密钥获取 indexnow API Key：随后打开一个搜索引擎的 indexnow 界面，例如微软必应 indexnow，向下滑界面，找到 Generate API Key , 将值复制下来 6.2. 验证网站所有权首先按照 bing index 的指导将 1f571e3a4aed400d811a524c70eda337.txt 文件放在本机 hexo/source 目录下 然后部署一次： 1hexo c &amp;&amp; hexo g &amp;&amp; hexo d 最后访问 https://your_domain/1f571e3a4aed400d811a524c70eda337.txt 应该看到： 11f571e3a4aed400d811a524c70eda337 6.3. 安装 hexo-indexnow 插件12345yarn add hexo-indexnow# 或npm i hexo-indexnow --save 6.4. 配置 hexo-indexnow在根目录 _config.yml 添加如下配置: 12345678910hexo_indexnow: count: 10 # 数字或者 &quot;latest&quot;(=1) txt_name: indexnow.txt # 链接文件名 apikey: xxxxxx # 你的 apikey server: bing # indexnow 服务器，可选值有:bing、yandex、indexnowdeploy: - type: indexnow_url_submitter 6.5. 查看推送结果在执行 hexo deploy 的时候，indexnow_url_submitter 将会发挥作用，将连接推送到 bing indexnow。 提交了哪些 urls 可以在 hexo/.deploy_git/indexnow.txt 文件中找到 12345INFO Submitting indexnow urls.....INFO indexnow submitted 然后打开 https://www.bing.com/webmasters 中查看 IndexNow，查看推送结果。 补充：indexnow 也支持使用 http post 提交 urls, 如下所示： 123456{ &quot;host&quot;: &quot;www.your_domain.xyz&quot;, &quot;key&quot;: &quot;1f571e3a4aed400d811a524c70eda337&quot;, &quot;keyLocation&quot;: &quot;https://your_domain.xyz/1f571e3a4aed400d811a524c70eda337.txt&quot;, &quot;urlList&quot;: [&quot;https://www.your_domain.xyz/example.html&quot;]} 7. 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 命令详解 Hexo 博客添加评论功能 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化","link":"/hexo/blog_seo_optimize.html"},{"title":"Hexo配置Next主题","text":"1. 安装环境说明 首先粘贴本教程测试使用的环境，如果在安装配置中，环境有差异，请酌情修改或调整参数． 1234567$hexo vINFO Validating confighexo: 5.4.0hexo-cli: 4.3.0os: linux 5.4.70-amd64-desktop Deepin 20.1 20.1node: 14.17.6v8: 8.4.371.23-node.76 本文是接上一篇文章使用 Hexo 搭建自己的博客网站的续篇，经过上一篇文章的安装配置，目前的目录结构如下： 12345678910111213141516$tree -L 1your_project_dir/blog├── _config.landscape.yml├── _config.yml├── db.json├── node_modules├── package.json├── package-lock.json├── public├── README.md├── scaffolds├── source └── _posts ├── hexo └── rust└── themes source 目录下已经有两篇文章，项目能发布到 github 上，能在公网上通过https://pengtech.net正常访问了．下一步实现尝试一下修改默认的主题，将其替换为 next 主题． 2. 安装 Next 主题安装 Next 主题有两种方式: 通过压缩包安装 通过 git clone 安装 2.1. 安装方式一： 通过压缩包安装 进入项目 123$cd blog$pwdyour_project_dir/blog 项目目录结构如上节所示 找到对应的压缩包 打开https://github.com/theme-next/hexo-theme-next/releases 找到对应的 release 版本，在对应的版本的 release notes 下面找到 Source code(tar.gz) 下载源代码包 Source code(tar.gz) 解压缩将源码包解压到 themes/next 目录下即可． 一键安装 前提是你的电脑支持 curl, wget, grep 等命令，针对大多数 windows 用户，建议还是参考上面的步骤一步一步安装主题，对于 MacOs 和 windows 用户，可以使用如下命令一键安装 理解以上步骤，能更好地帮助你理解一键安装命令 这里将以上步骤压缩成一条命令 123mkdir themes/nextcurl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d '&quot;' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 安装完成后, themes/next 目录的结构如下所示 1234567891011121314$tree -L 2 . └── next ├── _config.yml ├── crowdin.yml ├── docs ├── gulpfile.js ├── languages ├── layout ├── LICENSE.md ├── package.json ├── README.md ├── scripts └── source 安装方式二： 通过 git 克隆安装123git clone --branch v7.8.0 https://github.com/theme-next/hexo-theme-next themes/next# 或者git clone --branch v7.8.0 git@github.com:theme-next/hexo-theme-next.git themes/next 3. 配置 Next 主题3.1. 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件_config.yml， 找到 theme 字段，并将其值更改为 next。 1theme: next 3.2. 验证主题 首先启动 Hexo 本地站点 1hexo server 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 3.3. 修改主题配置文件经过以上配置，blog 的主题反而变得更简陋了, 但是有了 next 主题后，我们可以深度定制它接下我们来深度配置 next 主题，此时我们需要编辑 themes/next/_config.yml 文件 3.3.1. 第一项 修改 schema 目前有四种 shema 可以选择，分别是 Muse, Mist, Pisces, Gemini 这里我选择 scheme: Gemini 这个 schema, 比较适合 PC 端和手机端 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse# scheme: Mist#scheme: Piscesscheme: Gemini 3.4. 博客主标题上方的 logo制作 logo，并将其存放至/uploads/custom-logo.jpg 12# Custom Logo (Do not support scheme Mist)custom_logo: /uploads/custom-logo.jpg 说明:【/uploads/logo.png】 对应的本地 blog 文件夹中位置是 【\\blog\\themes\\next\\source\\uploads\\logo.png】 其中【uploads】文件夹，和【logo.png】文件，都需要自己创建。 3.5. 版权信息声明设定 license, 设定版权信息显示位置 12345678910# Creative Commons 4.0 International License.# See: https://creativecommons.org/share-your-work/licensing-types-examples# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.orgcreative_commons: license: by-nc-sa sidebar: true #侧边栏中的版权标识 post: true #每篇文章底部都显示版权信息 language: 3.6. 添加 local search 首先安装插件 1cnpm install hexo-generator-searchdb --save 修改配置文件 修改站点配置文件_config.yml, 新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 theme next 的配置文件，启用本地搜索功能： themes/next/_config.yml 123# Local searchlocal_search: enable: true 3.7. 开启侧边栏社交链接 编辑主题配置文件 themes/next/_config.yml 1234social: GitHub: https://github.com/your_github_id || fab fa-github E-Mail: mailto:your_email@gmail.com || fa fa-envelope Weibo: https://weibo.com/your_weibo || fab fa-weibo 代码块配置1234567891011121314151617codeblock: # Code Highlight theme # All available themes: https://theme-next.js.org/highlight/ theme: light: a11y-dark dark: a11y-dark highlight: enable: true prismjs: enable: true light: prism dark: prism-dark # Add copy button on codeblock copy_button: enable: true # Available values: default | flat | mac style: flat 3.8. 开启 Utterances 评论功能 (推荐) 参考我的博客文章Hexo 博客添加评论功能 3.9. 配置百度统计登录 百度统计，定位到站点的代码获取页面复制 hm.js? 后面那串统计脚本 id，如下图所示： 123456789&lt;script&gt; var _hmt = _hmt || []; (function () { var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?xxxxxxxxxxxxxx&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s); })();&lt;/script&gt; 编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 1baidu_analytics: # &lt;app_id&gt; 3.10. 开启 google Analytics 申请 google 账号, 创建 Analytics 账号, 修改 themes/next/_config. 1234# Google Analytics# See: https://analytics.google.comgoogle_analytics: tracking_id: # &lt;app_id&gt; 3.11. 开启页面访问量统计这里使用不蒜子进行页面访问量统计其实在 next 中已经集成了不蒜子的统计，在官网上也说了在主题配置文件_config.yml 下搜索 busuanzi_count，enable 设置为 true 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: fa fa-user total_views: true total_views_icon: fa fa-eye post_views: true post_views_icon: far fa-eye 由于我的 hexo v8.8.0, 不需要额外的配置, 即可以看到统计功能生效了. 3.12. 开启字数统计及阅读时长安装插件 hexo-symbols-count-time 1npm install hexo-symbols-count-time --save 修改主题配置文件_config.yml 123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 # awl（Average Word Length）的数值是设定多少字符统计为一个字（word），中文博客建议设置为 2 wpm: 275 # （Words Per Minute）是假设的读者阅读速度，多少字（word）统计为阅读时长一分钟。 说明:在配置项中的:awl（Average Word Length）的数值是设定多少字符统计为一个字（word），中文博客建议设置为 2。wpm（Words Per Minute）是假设的读者阅读速度，多少字（word）统计为阅读时长一分钟。官方文档里的一些参考值：慢速：200中速：275（默认）快速：350 实测需要清理一下缓存, 才能生效,否则会显示时长位置会显示 NaNa 字样 参考为 NexT 主题添加文章阅读量统计功能 3.13. 设置 侧边栏外链123456789# Blog rollslinks_settings: icon: fa fa-globe title: 赞助商链接 # Available values: block | inline layout: blocklinks: &quot;外链1&quot;: https://example.com 3.14. 返回顶部按钮显示阅读进度123456back2top: enable: true # Back to top in sidebar. sidebar: true #这里我把返回到顶部放在sidebar, 因为我的右下角还要留给分享按钮 # Scroll percent label in b2t button. scrollpercent: true 3.15. 关闭动画效果主题中的渐出展开等 js 特效，确实比较炫酷。但是操作延迟也比较高，容易形成一种页面卡顿的错觉。看久了会审美疲劳，我选择关闭。毕竟实用才是最重要的。如果你有同感，可以参考我的配置 123motion: enable: false async: false 3.16. 修改文章底部的那个带#号的标签具体实现方法 12# Use icon instead of the symbol # to indicate the tag at the bottom of the posttag_icon: true 3.17. 设置用户头像将要显示的头像保存在 source 下的 imgs 文件夹中并命名为 avatar.jpg 修改 next 配置文件 themes/next/_config.yml, 找到 Avatar 节点将其修改为如下 12345678# Sidebar Avataravatar: # Replace the default image and set the url here. url: /imgs/avatar.jpg # If true, the avatar will be displayed in circle. rounded: true # If true, the avatar will be rotated with the cursor. rotated: false 3.18. 添加 google 广告注册 Google Adsense 账号注册账号流程比较简单，入口在这里：Google Adsense注册完成后,google 会提供一段广告脚本, 将他放到下面文件的头部位置修改 themes/next/layout/_partials/head.njk 12345&lt;script data-ad-client=&quot;your-ad-client-id&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; 确认无误之后，在 google adsense 上点击确认，开始验证，一般没问题的话几分钟就会出结果，有问题的话要等待一段时间。参考hexo 个人 next 主题博客接入谷歌广告 3.19. 忽略一些文章需求是这样的, 文章还没有写完, 所以我打算把正在写的文章放在 source/in_progress 文件夹下, 等文章写完后准备发布时移动到它该去的位置.这样我就不用担心未完成的文章被发布出去, 写作时使用 markdown 工具预览.编辑站点的配置文件_config.yml 12# Directoryskip_render: [&quot;in_progress/**/*&quot;] 3.20. SEO 搜索引擎优化搜索引擎优化，可以参考我的文章 Hexo 博客搜索引擎优化 3.21. 收到 google 的邮件 出现次数最多的问题，我们在您的网站中发现了以下错误：文字太小，无法阅读可点击元素之间的距离太近 解决办法 修改 next 的配置文件, 将 font.global.size 修改为 1.1 相当于 18pxfonts 设为国内站点https://fonts.lug.ustc.edu.cn 或者 https://fonts.loli.net 12345678910111213141516font: enable: true # Uri of fonts host, e.g. https://fonts.googleapis.com (Default). host: https://fonts.loli.net # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside &lt;body&gt;. global: external: true family: Noto Serif SC, PingFang SC, Microsoft YaHei, sans-serif, Lato size: 1.1 修改 themes\\next\\source\\css\\_variables\\base.styl 12345$font-family-chinese = &quot;Noto Serif SC&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;;$font-family-base = $font-family-chinese, sans-serif;$font-family-base = get_font_family('global'), $font-family-chinese, sans-serif if get_font_family('global'); 将行间距$line-height-base 修改为 2.2 默认是２该文件位于 next &gt; source &gt; css &gt; base.styl 1234// Global line height$line-height-base = 2.2;$line-height-code-block = 1.6; // Can't be less than 1.3; 3.22. 开启 mermaid 图表功能开启 mermaid 图表功能，可以参考我的另一篇文章Hexo 中插入 mermaid 图表 3.23. hexo 命令行工具详解管理站点，或创建博客可能经常会用到 hexo 命令行工具，可参考我的另一篇文章 Hexo 命令详解. 3.24. 添加打赏功能启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 \\source\\imgs\\ 目录下，注意保持图片命名与配置文件中一致： themes\\next_config.yml 123456789reward_settings: # If true, a donate button will be displayed in every article by default. enable: true animation: false #关闭悬停收款码上的文字抖动效果 comment: Buy me a coffeereward: wechatpay: /imgs/wechatpay.jpg alipay: /imgs/alipay.jpg 并非每个页面都需要开启打赏功能，可以在 Front-Matter 中添加 reward 字段来控制是否在本文章中添加打赏信息，然后修改文章布局模板中相关的判定条件： themes/next/layout/_macro/post.njk 12345- {%- if post.reward_settings.enable %}+ {%- if post.reward and post.reward_settings.enable %} {{ partial('_partials/post/post-reward.njk') }} {%- endif %} 为了方便可在草稿模板 scaffolds\\draft.md 中统一添加 reward 字段默认值：scaffolds\\draft.md 12345title: {{ title }}tags:categories:- reward: true 修改打赏按钮的提示 themes\\next\\languages\\en.yml 1234567891011reward:- donate: Donate+ donate: 打赏- wechatpay: WeChat Pay+ wechatpay: 微信支付- alipay: Alipay+ alipay: 支付宝 paypal: PayPal bitcoin: Bitcoin 5. trouble shooting5.1. 链接包含中文不能正常跳转问题 现象：当右侧大纲条目中包括中文时，点击不能正确跳转 打开浏览器开发者模式发现以下错误 12utils.js:240 Uncaught TypeError: Cannot read property 'getBoundingClientRect' of nullat HTMLAnchorElement.&lt;anonymous&gt; (utils.js:240) 原因分析:中文链接在转码后不能正确的映射到相应的页面元素 解决方案 我已经通过此issue反馈给 hexo 社区，社区的回复是在新的 Next theme 中已经解决此问题，需要升级 next theme 到新版本, 以下是来自社区的回复: 12This issue has been fixed in next-theme/hexo-theme-next@0d2b3afTheme NexT version 7.8.0 is outdated. The latest version is v8.8.0 https://github.com/next-theme/hexo-theme-next/releases/tag/v8.8.0 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 命令详解 Hexo 博客添加评论功能 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化","link":"/hexo/hexo_advance_apply_next_theme.html"},{"title":"Hexo 配置 Icarus 主题","text":"本文讲述如何给 hexo 博客网站配置。 1. 安装环境说明 首先粘贴本教程测试使用的环境，如果在安装配置中，环境有差异，请酌情修改或调整参数． 123456789101112131415161718192021$hexo vINFO Validating configInferno is in development mode.INFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===hexo: 5.4.0hexo-cli: 4.3.2os: linux 6.8.8-300.fc40.x86_64 Fedora Linux 40 (Workstation Edition)node: 20.12.2acorn: 8.11.3..... 本文是接上一篇文章使用 Hexo 搭建自己的博客网站的续篇，经过上一篇文章的安装配置，目前的目录结构如下： 12345678910111213141516$tree -L 1your_project_dir/blog├── _config.landscape.yml├── _config.yml├── db.json├── node_modules├── package.json├── package-lock.json├── public├── README.md├── scaffolds├── source └── _posts ├── hexo └── rust└── themes source 目录下已经有两篇文章，项目能发布到 github 上，能在公网上通过https://pengtech.net正常访问了．下一步实现尝试一下修改默认的主题，将其替换为 icarus 主题． 2. 安装 Icarus 主题安装 Icarus 主题有两种方式: 通过 npm 安装 通过 git clone 安装 通过压缩包安装 2.1. 安装方式一： 通过 npm 安装123npm install -S hexo-theme-icarus hexo-renderer-inferno 2.2. 安装方式二： 通过 git 克隆安装123git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --branch 6.1.0 --depth 1#另外，你也可以使用下面的命令将Icarus安装为Git子模块(submodule)：git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --branch 6.1.0 --depth 1 安装 dependencies 1234567npm install -S semver@^7.5.4npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^3.1.0npm install -S hexo-renderer-inferno@^1.0.2 2.3. 安装方式三： 通过压缩包安装 进入项目 123$cd blog$pwdyour_project_dir/blog 项目目录结构如上节所示 找到对应的压缩包 打开https://github.com/ppoffice/hexo-theme-icarus/releases/ 找到对应的 release 版本，在对应的版本的 release notes 下面找到 Source code(targ.gz) 下载源代码包 Source code(tar.gz) 解压缩将源码包解压到 themes/icarus 目录下即可． 一键安装 前提是你的电脑支持 curl, wget, grep 等命令，针对大多数 windows 用户，建议还是参考上面的步骤一步一步安装主题，对于 MacOs 和 windows 用户，可以使用如下命令一键安装 理解以上步骤，能更好地帮助你理解一键安装命令 这里将以上步骤压缩成一条命令 123mkdir themes/icaruscurl -s https://api.github.com/repos/ppoffice/hexo-theme-icarus/releases/latest | grep tarball_url | cut -d '&quot;' -f 4 | wget -i - -O- | tar -zx -C themes/icarus --strip-components=1 安装完成后, themes/icarus 目录的结构如下所示 123456789101112131415161718$tree -L 2.├── _config.landscape.yml├── _config.yml├── db.json├── node_modules├── package.json├── package-lock.json├── scaffolds│ ├── draft.md│ ├── page.md│ └── post.md├── source│ └── _posts├── themes│ └── icarus└── yarn.lock 3. 配置 Icarus 主题3.1. 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件_config.yml， 找到 theme 字段，并将其值更改为 icarus 1theme: icarus 也可以使用 hexo 命令启用 icarus 主题 1hexo config theme icarus 3.2. 验证主题 首先启动 Hexo 本地站点 1hexo server 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 3.3. 配置作者资料卡你可以启用作者资料卡挂件来展示文章作者/网站站长的信息。 资料卡的配置如下所示： _config.icarus.yml 12345678910111213141516171819202122widgets: - position: left type: profile # 作者名称 author: 鹏叔 # 作者头衔 author_title: A GitHub Octocat # 作者所在地/公司 location: GitHub Inc. # 头像图片地址 avatar: https://octodex.github.com/images/hula_loop_octodex03.gif # 是否显示圆形头像 avatar_rounded: false # Gravatar邮箱(如不设置`avatar`项) gravatar: # 关注按钮链接地址 follow_link: &quot;https://pengtech.net&quot; # 社交媒体链接 social_links: Github: icon: fab fa-github url: &quot;https://github.com/guoapeng&quot; 需要注意的是： 如果你希望使用 Gravatar 而不是 avatar 配置项作为头像图片，请在 gravatar 项填入 你的 Gravatar 邮箱地址并在 avatar 一项中留空； social_links 可以采用如下两种格式： 图标形式： 123&lt;链接名称&gt;: icon: &lt;FontAwesome5_图标的_HTML_class名称&gt; url: &lt;链接的URL地址&gt; 文字形式： 1&lt;链接名称&gt;: &lt;链接的URL地址&gt; 3.4. 配置友站链接你可以使用友站链接挂件来展示外部网站的列表。 示例配置如下所示： 1234567widgets: - position: left type: links # 友站名称与链接 links: pengtech: &quot;https://pengtech.net&quot; philoenglish: &quot;https://philoenglish.com&quot; 3.5. 配置最新文章使用如下挂件配置来开启最新文章挂件： _config.icarus.yml 123widgets: - position: right type: recent_posts 3.6. 配置文章归档使用如下挂件配置来开启文章归档挂件： _config.icarus.yml 123widgets: - position: right type: archives 3.7. 配置文章分类使用如下挂件配置来开启文章分类挂件： _config.icarus.yml 123widgets: - position: right type: categories 3.8. 配置文章标签使用如下挂件配置来开启文章标签挂件： _config.icarus.yml 123456widgets: - position: right type: tags order_by: name # 可选项。按名称(name)或长度(length)来排序。加上`-`前缀来倒序排列。 amount: 20 # 可选项。最多显示的标签数量。留空以显示所有标签。 show_count: true # 可选项。是否显示标签名称右侧的文章数量。 3.9. 开启 shareThis 分享按钮 访问 ShareThis 并点击页面上的“从分享按钮开始”(Start with Share Buttons)按钮。 在“选择分享按钮类型”(Choose type of sharing button)页面选择你需要的按钮类型。 不要启用”GDPR 规范工具“，否则可能会导致一些问题。 你也可以点击“自定义你的分享按钮”(Customize your share buttons)链接来进行按钮的进一步配置。 完成后点击“下一步”(Next)。 在”选择你的 CMS 平台“(Choose your CMS platform)页面选择”HTML“并点击”下一步“(Next)。 在“注册并获取代码”(Register and get the code!)页面输入邮箱和密码完成 ShareThis 的注册。 最后，从 HTML 代码段中复制 src 中的 URL 地址到分享按钮配置中。 例如，下面的 ShareThis 代码： 12345&lt;script type=&quot;text/javascript&quot; src=&quot;https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 对应下面的主题配置： 123share: type: sharethis install_url: https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons 3.10. 开启 follow.it安装 hexo-generator-feed 123npm install hexo-generator-feed --save 配置 feed, 参考 https://github.com/hexojs/hexo-generator-feed 修改_config.yml，配置 feed 如下 1234567891011121314feed: enable: true type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png autodiscovery: true template: 按照如下步骤即可启用 follow.it 邮件订阅插件： 首先，使用诸如 hexo-generator-feed 此类的 Hexo 插件生成 你的 Hexo 网站的 RSS 源。 访问 follow.it 并在“向你的站点添加关注功能”(Add the follow feature to your site)下方的 输入框中填写 RSS 源的文件地址，例如http://example.com/atom.xml。 然后，点击“下一步”(Next)。 点击“定义关注表单设计”(Define the follow form’s design)页面上的“继续”(Continue)按钮。 搜索 action=并复制 action=后双引号中的链接。 把你复制的 action 链接粘贴到挂件配置中的 action_url 设置项。 在那之后，点击“完成”(Done)。 3.11. 开启评论系统可以有多种选择，但是我一直使用的是 utterances，这次依然是 utterances 3.11.1. utterances安装指南在线预览准备一个公开的 GitHub 仓库(Repository)。 访问 GitHub Apps - utterances 并点击”安装“(Install)。 GitHub 应用页 - utterancesGitHub 应用页 - utterances (可选)如果你的账号下有组织账号，在下一页中选择需要安装 utterances 的用户。 选择用户 - utterances选择用户 - utterances 在下一页面选择将 utterances 安装到”所有仓库“(All repositories)或是”选定的仓库“(Only select repositories)。 然后点击“安装”(Install)按钮。 选择仓库 - utterances选择仓库 - utterances 若安装成功，网页将跳转到 utterances 官网。 你可以阅读每个的配置项的说明，并按照配置你的 utterances 安装。 完成配置后，转到页面上的”开启 utterances“(Enable Utterances)并从 utterances 的 HTML 代码中复制属性值到主题配置的对应配置项中。 获取代码 - utterances获取代码 - utterances 例如下面的 utterances 代码： utterances 安装代码 对应下面的主题配置： _config.icarus.yml 1234567comment: type: utterances repo: Your-GitHub-Username/Your-Public-Repo-Name issue_term: pathname # 必填项，与issue_number二选一填写 issue_number: 100 # 必填项，与issue_term二选一填写，每篇文章对应一个issue，填写前需要手动创建issue label: some-issue-label # 可选填 theme: github-light # 可选填 开启站内搜索修改icarus配置文件_config.icarus.yml， 123456search: type: insight # Whether to include pages in the search results index_pages: true 4. 支持夜间模式参考 https://www.imaegoo.com/2020/icarus-night-mode-3/ 如何设置默认为night mode: themes/icarus/source/js/imaegoo/night.js 1234var isNight = localStorage.getItem('night') || true;var nightNav; 5. 添加相关文章推建相关文章推荐，每次都是手动写的，最近发现 hexo-related-popular-posts 可以自动生产相关文章推荐。但是这个已经有几年没有更新了，比较适合 next 等较早一批出现的 hexo 主题。网上搜索了一下，发现ZhongHuihong做了向 icarus 主题的适配 - 参考这篇文章 hexo icarus 主题添加相关文章。 这里为了防止网页找不到，结合 hexo-related-popular-posts 官方文档和上述文章将步骤重新整理一下。 5.1. 首先安装 hexo-related-popular-posts 依赖123npm install hexo-related-popular-posts --save 5.2. 修改 icarus 主题源码由于最新的 Icarus 使用 npm 安装的话是安装到 node_modules 下的，所以我们需要把主题弄到 themes 目录下。可以直接 git clone 一份到这个目录或者是复制出来，hexo 加载 themes 目录下的主题优先级是大于 node_modules 目录。 layout\\common 目录下新增 related.jsx 123456789101112131415161718192021const { Component } = require(&quot;inferno&quot;);const view = require(&quot;hexo-component-inferno/lib/core/view&quot;);module.exports = class extends Component { render() { const { config, helper, page } = this.props; const { __, popular_posts } = helper; let relatedText = popular_posts({}, page); if (!relatedText || relatedText.length == 0) { return null; } return ( &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;h3&gt;相关文章&lt;/h3&gt; &lt;span dangerouslySetInnerHTML={{ __html: relatedText }}&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); }}; 说明与其他主题不同，icarus 的 post 叫做 page，this.props 中是不包含 post 的。hexo-related-popular-posts 注册了 popular_posts 函数用于渲染相关文章，这个需要在 helper 加上。hexo-related-popular-posts 生成的 html text 需要使用 dangerouslySetInnerHTML 设置，否则直接渲染出来的是带引号的。下面是我编写的 related.jsx。 修改 article.jsx编写好了 related.jsx，就需要在 article.jsx 中修改了。需要引入自定义的 jsx 文件，并在合适的位置插入标签。 require.jsx 1234const Share = require('./share');const Donates = require('./donates');const Comment = require('./comment');+ const Related = require('./related'); 插入相关文章标签 12345678+ {/* Related articles */}+ {!index ? &lt;Related config={config} page={page} helper={helper}/&gt; :null}{/* Donate button */}{!index ? &lt;Donates config={config} helper={helper} /&gt; : null} 把它放在文章的尾部，捐赠的上方，!index 表示首页不出现。 效果预览&amp;后记如果有啥报错的话，记得 hexo clean 一下。 具体的样式可以自己微调，上述代码的改动效果如下。hexo-related-popular-posts 生成的 div 有自带 class，可以自行添加 icarus/source/css/style.styl 与修改 icarus/include/style 目录下的 style 进行样式的微调。 6. 添加 google 广告注册 Google Adsense 账号注册账号流程比较简单，入口在这里：Google Adsense注册完成后,google 会提供一段广告脚本, 将他放到下面文件的头部位置 从脚本获取到 google adsense client_id 和 slot_id 修改icarus配置文件_config.icarus.yml， 配置google adsense widget如下 12345678910widgets: ... # Where should the widget be placed, left sidebar or right sidebar position: right #type: adsense # AdSense client ID #client_id: 'ca-pub-zzzzzzz' # AdSense AD unit ID #slot_id: 'yyyyyyyyyy' ... 7. hexo Icarus主题优化记 hexo icarus 主题优化 Google PageSpeed Insights 分数 8. 解决 SEO LCP 问题Hexo和icarus主题那些坑：打开速度太慢，google console长期报告 LCP问题，几乎每一个页面都有这个问题， 用PageSpeed Insights测试了一下，主要是FontAwesome CDN，JSDelivr CDN，Google Fonts下载速度慢，严重影响性能。 解决办法： 找到_config.icarus.yml，在最后的providers，修改：全部修改为loli 123456789providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: loli # Name or URL template of the webfont CDN provider #默认用的google fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 其次，找到themes/icarus(主题)/layout/common/head.jsx注释掉：default: fontcdn(‘Ubuntu:wght@400;600&amp;family=Source+Code+Pro’,‘css2’) 12345const fontCssUrl = { // default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2')}; 参考这篇文章 https://blog.csdn.net/m0_52549699/article/details/118249206 8. 参考文档Icarus 快速上手 hexo icarus 主题添加相关文章 记 hexo icarus 主题优化 Google PageSpeed Insights 分数","link":"/hexo/hexo_apply_icarus_theme.html"},{"title":"Hexo博客添加评论功能","text":"考虑到每篇博客都有可能有错误的地方，需要用户及时反馈，我能相应的做出修改，逐渐完善整个博客系统，所以评论功能对我来说非常重要． 1. 评论功能概述目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus 也被挡在墙外，友言貌似也不行。 可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气．） 来必力：https://livere. （来自韩国，使用邮箱注册。） Utterances: https://utteranc.es (github 账号登录，使用 github issue 来存储评论) 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。） Gitment： https://github.com/imsun/gitment （有点小 bug，比如说每次需要手动初始化，登录时会跳到主页。） Valine: https://github.com/xCss/Valine (基于 Leancloud 的极简风评论系统，用了下，没效果，是我 Next 主题的原因还是？） 综上，最终采用了 Utterances，理由：安装配置简单，本人的博客偏向技术博客，大多数技术人员几乎都有 github 账号，省去用户注册的麻烦，用户体验会更好一些． 1.1. 开启 Utterances 评论功能 (推荐) 比较了几个第三方评论插件，还是 Utterances 配置最简单，权限最小最安全 创建存放 comments 的代码仓库，必须为 public，且可创建 issue。 install utterances app 点击这个链接安装 utterances app 到刚刚创建的那个仓库。 点击安装，选择你用来存放评论的库，选择相应的权限，点击保存． 编辑主题配置文件 themes/next/_config.yml 123456789# Utterances# For more information: https://utteranc.esutterances: enable: true repo: yoour_github_id/the_repo_name_to_store_comments # Github repository name # Available values: pathname | url | title | og:title issue_term: pathname # Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light theme: github-light 编辑站点配置文件 _config.yml 123# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://your_site_url 重启即 Hexo 可以看到评论区 2. trouble shooting 评论区点击登录后，登录成功授权成功后被导航至 example.com 的问题 原因分析 站点配置有一项，默认配置是http://example.com, utteranc 默认去读这个配置，作为验证授权后返回的站点，需要修改这个 url 123# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://guoapeng.github.io 解决方案 3. 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 命令详解 Hexo 博客添加评论功能 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化","link":"/hexo/hexo_blog_comments.html"},{"title":"Hexo命令详解","text":"1. 背景介绍本文主要讲解 hexo cli 的使用和详细信息，以及相关示例． 2. Hexo 项目初始化初始化项目(博客网站), 可以使用 init 命令 1$hexo init [folder] 说明: 用于新建一个网站。 如果没有设置 folder ，Hexo 默认在当前的文件夹建立网站。 本命令相当于执行了以下几步:Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录.使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装, nodejs 安装可以参考安装并配置 nodejs。 延伸阅读我的博客使用 Hexo 搭建自己的博客网站 3. Hexo new 命令1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。这里 layout 在很多文章中都翻译成布局似乎不能反应它在上下文中的意思，查了一下词典，它还有一个意思叫版面，更贴切一些，版面在汉语中的意思如下 版面是一个印刷词汇，指印刷好的页张，包括图文、余白整个部分。 Hexo 有三种默认版面：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他版面和 post 相同，都将储存到 source/_posts 文件夹。这里的 title 是必须指定的，如果标题包含空格的话，请使用引号括起来。例如： 1$hexo new &quot;post title with whitespace&quot; new 指令还有一些选项可供使用 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 说明： 这里的 slug 也是印刷术语，而且是上一代印刷术铅字印刷术中的一个术语，意为铅字条，即把单个铅字组成一长条，其用途百度了很久也不知道和这里的文件名有何联系，如果知道的欢迎在原文下面留言． 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me” 注意！title 是必须指定的！如果不指定 title, 例如在下面的例子中： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。相信这往往不是人们所期望的． 4. 发表草稿相信看了 Hexo new 命令的讲解后，一定还有一个疑惑，如果使用hexo new draft &quot;xxx title&quot;创建了一篇草稿文章后，如果完成了文章打算发表怎么办，难道要手动的创建 post 和 page 再 copy 过去，阅读了这一节，相信大家会有更好的选择，那就是使用 publish 命令．这里吐槽一下这个命令，publish 往往隐含地意味着将文章发表到网站面向公众，而这里实际的行为是将文章由草稿状态，转变为可发表状态，中间还有校对，部署等一系列动作，其实离发表还是有一段距离．其实此命令更多的是移动文件夹，转变状态，还不如 move 或 transfer, 因为 publish 让人一下子处于一种紧张的临战状态，如果不去深入了解它实际会干什么，往往不敢轻易使用． 1hexo publish [layout] &lt;filename&gt; 说明，这里的 layout 可以是 post 或者 page, 文件名必须指定． 5. 生成静态文件生成静态文件使用如下命令 123$ hexo generate# 或者简写形式$ hexo g 可用选项 选项 描述 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 6. 本地启动网站123hexo server# 或者简写形式hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 7. 部署1234$ hexo deploy# 或者简写形式$ hexo d 部署网站。部署之前还有一些准备工作，请参考我的博客文章使用 Hexo 搭建自己的博客网站. 参数 描述 -g, –generate 部署之前预先生成静态文件 8. render 渲染文件1$hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, –output 设置输出路径 9. 从其他博客系统移植博客1$hexo migrate &lt;type&gt; 从其他博客系统 迁移内容, 目前支持从 RSS，Jekyll, Octopress, WordPress, Joomla, 具体如何移植，请参考这篇文章迁移 10. clean1$hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 11. list1hexo list &lt;type&gt; 列出网站资料。类型有 page, post, route, tag, category． 12. version1hexo version 显示 Hexo 版本。 13. 选项13.1. 安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 13.2. 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 13.3. 简洁模式1hexo --silent 隐藏终端信息。 13.4. 自定义配置文件的路径12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml 自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 13.5. 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 13.6. 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 14. 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 命令详解 Hexo 博客添加评论功能 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化 15. 参考文档Hexo 指令","link":"/hexo/hexo_cli.html"},{"title":"使用 Hexo 快速搭建自己的博客系统","text":"在开始博客写作之前，一个重要的决定就是选择合适的博客框架进行独立部署。博客框架主要分为两种：动态博客和静态博客。除此之外，如果不愿意独立部署，还有一些一站式的博客平台可以选择。 1. 什么是静态博客？静态Web网站是指主要由静态页面组成的网站，这些静态页面通常包括HTML、CSS、JavaScript、图片等文件，它们直接存储在服务器上，并在用户请求时由服务器发送给用户的浏览器进行显示。与动态Web网站相比，静态Web网站不依赖于服务器端脚本或数据库来生成页面内容，而是直接展示预先设计好的页面。 静态博客是指将博客内容（如文章、页面等）通过生成工具将作者书写的博文直接编译成 HTML、CSS、JS 等静态web技术支持的博客形式，并通过静态服务器进行托管和访问的博客系统。 1.1. 工作原理作者使用 Markdown、HTML 等标记语言编写文章，并通过生成工具（如 Hexo、Hugo 等）将文章编译成静态的 HTML 文件。这些文件随后被部署到静态服务器上，用户通过浏览器访问这些静态文件来浏览博客内容。 本文原文位于使用 Hexo 搭建自己的博客网站, 如需获取最近更新，以及遇到 markdown 排版问题，请访问原文，以获得最佳阅读体验。 1.2. 静态博客的优点 访问速度快：由于静态文件直接由服务器提供，无需经过复杂的后端处理，因此访问速度通常较快。 资源消耗少：静态博客不需要运行后端程序和数据库，因此占用的服务器资源较少，成本也相对较低。 安全性高：由于静态文件不包含可执行代码，因此相比动态博客更不容易受到攻击。 专注于内容：静态博客的设计初衷是专注于内容创作和分享，避免了复杂的功能和插件干扰，使得博主能够更专注于写作。 可高度定制化：通过修改 HTML、CSS、JS 等文件，静态博客可以实现高度的定制化，满足博主的个性化需求。 1.3. 静态博客生成工具 Hexo：一款快速、简洁且高效的博客框架，支持 Markdown 语法，具有丰富的插件和主题资源。 Hugo：另一个流行的静态网站生成器，以其高性能和易用性著称，适合构建个人博客、文档站点等。 Jekyll：由 GitHub 开发并维护的静态网站生成器，支持 Markdown 语法，并与 GitHub Pages 紧密集成，方便用户托管和发布博客。 Zola 是一个使用 Rust 编写的静态网站生成器，力求简单且快速，是一个保持简单并专注于提供高速生成的工具。 Astro 是一个前端框架，用于构建快速、优化的网站和应用。Astro 允许你编写现代的 JavaScript 或 TypeScript，同时通过只在顾客端发送最小静态 js 脚本，确保了更优的性能。 Gatsby 是一个基于 React 的静态站点生成器，可以创建快速、安全、高质量的网站和应用。 Next.js 是一个基于 React 框架的服务端渲染应用框架，也支持静态网站生成。 Docsify 是一个轻量级的 JavaScript 文档网站生成器，使用 Markdown 文本文件来生成静态站点。 VuePress 是一个基于 Vue.js 的静态网站生成器，主要用于快速搭建文档型网站。 Statty 是一款简洁高效的静态博客生成器，由开发者 Vesparny 创建。 InkPaper 是一款由 Golang 编写的静态博客生成器，专为 Markdown 写作打造。 1.4. 常见的静态Web服务器有哪些？ Apache HTTP Server Apache是最流行的开源HTTP服务器软件之一，可在多种操作系统上运行，包括Windows、Linux和macOS。它提供了稳定可靠的静态网站托管方案，并支持各种自定义配置和强大的模块。 Nginx Nginx是一款高性能的开源HTTP和反向代理服务器，也常用于托管静态网站。它的设计目标是处理大量并发请求，对静态文件的传输非常高效。Nginx还支持反向代理、负载均衡、SSL加密等多种功能。 Microsoft Internet Information Services (IIS) IIS是微软提供的Web服务器软件，专为Windows操作系统设计。它支持静态网站托管，并提供与其他Microsoft产品的集成和兼容性。 Lighttpd Lighttpd是一个轻量级的Web服务器，专注于高性能和低资源消耗。它也支持静态文件服务，并且由于其轻量级特性，在资源受限的环境中特别有用。 Caddy Caddy是一个现代化的Web服务器，以易用性和安全性著称。它提供了自动的HTTPS、HTTP/2支持以及简化的配置选项，也适用于托管静态网站。 GitHub Pages GitHub Pages是GitHub提供的免费静态网站托管服务。它支持通过git进行版本控制，并与GitHub仓库关联，方便开发者将静态网站发布到互联网。 Amazon S3 Amazon Simple Storage Service (S3)是亚马逊提供的对象存储服务，也可以用来托管静态网站。用户可以将静态文件上传到S3桶中，并通过配置相应的访问权限和域名解析来实现网站的访问。 2. 什么是动态博客？动态博客是最常见的博客形式。WordPress、Typecho、Ghost, Laravel, ThinkPHP 等动态博客系统在服务器上动态生成网页，这意味着每当用户访问博客时，内容都会动态生成，然后发送到浏览器。 优点： 易于使用：动态博客系统通常提供用户友好的界面，让你无需编程知识就可以方便地发布和编辑内容。 功能丰富：动态博客系统提供了丰富的插件和扩展，可以很方便地添加新功能，比如社交媒体分享、评论系统、分析工具等。 灵活性：动态博客系统可以方便地进行定制和修改，满足不同的需求。 缺点： 运行速度：由于每个页面都是实时生成的，因此加载速度可能会稍慢。 需要数据库：动态博客系统需要数据库来存储和检索内容，这可能增加了配置和管理的复杂性。 安全性问题：动态博客系统由于其复杂性，可能更容易受到安全攻击。 3. 选择博客生成工具需要考虑哪些因素？3.1. 需求匹配 博客类型与目的：明确博客的定位，是营销网站、出版网站、文档网站、博客、个人作品集、Landing page、社区网站以及电子商务网站等。不同类型的博客可能需要不同的功能和特性。 功能需求：确定需要哪些功能，如评论系统、分类、标签、搜索、SEO 优化、多语言支持等。 定制化需求：是否希望独立定制博客的样式和布局，以及是否需要插件或扩展来增强功能。 3.2. 学习曲线 易用性：选择易于安装、配置和使用的博客生成工具，减少搭建过程中的学习成本和时间。 学习曲线：考虑自己的技术背景，选择适合自己技术水平的工具。如果技术基础较弱，可以选择那些文档齐全、社区活跃的博客生成工具。 3.3. 扩展性与插件支持 扩展性：博客生成工具应该具备良好的扩展性，以便在需要时添加新的功能或插件。 插件支持：查看工具的插件生态系统是否丰富，是否有足够多的插件来满足未来的需求。 3.4. 成本与许可 成本：考虑工具的使用成本，包括是否需要购买许可、支付托管费用等。 许可协议：了解工具的许可协议，确保自己的使用方式符合规定。 3.5. 维护与更新 更新频率：查看工具的更新频率，以了解其开发者的活跃度和对工具的重视程度。 兼容性：确保工具与当前及未来的浏览器、操作系统等平台兼容。 4. 为什么选择 Hexo？Hexo 搭建博客具有快速且简单、功能强大且灵活、静态网页的优势、官方支持和社区活跃以及易于维护和优化等优势。这些优势使得 Hexo 成为众多博主和开发者搭建博客的首选工具之一。 以下是选择 hexo 的一些理由： 简洁的 Markdown 支持：Hexo 原生支持 Markdown，这种轻量级标记语言使得撰写博客文章变得既快捷又方便。Markdown 的简洁语法让内容创作者能够专注于内容本身，而无需过多关注格式排版。 丰富的主题选择：Hexo 拥有庞大的主题库，从简约到华丽，从学术到个人博客，应有尽有。用户可以轻松找到符合自己风格的主题，并且这些主题大多数都支持自定义配置，满足个性化需求。 高效的性能：Hexo 生成的是静态网页，这意味着在访问时不需要经过服务器端的渲染，直接由浏览器加载显示，从而提高了网站的访问速度和性能。这对于提升用户体验至关重要。 可扩展性强：Hexo 支持通过插件来扩展功能。无论是添加新的部署方式、优化 SEO、集成评论系统还是实现其他自定义功能，都可以通过安装和使用插件来实现。 社区支持强大：Hexo 拥有活跃的社区和大量的用户，这意味着当你遇到问题时，很容易在社区中找到解决方案或者得到他人的帮助。社区中的分享和交流也能帮助你更快地学习和成长。 文档完善：Hexo 的官方文档非常完善，涵盖了安装、配置、使用、插件开发等各个方面。无论你是初学者还是有一定经验的开发者，都能通过官方文档快速上手 Hexo。 版本控制友好：由于 Hexo 博客的内容都存储在 Git 仓库中（如 GitHub、GitLab 等），因此你可以很方便地利用版本控制工具来管理你的博客内容。这有助于你跟踪和管理博客的变更历史，以及与他人协作编辑博客。 安全性高：静态网页不依赖数据库等后端服务，减少了被攻击的风险。同时，Hexo 生成的网页是纯 HTML、CSS 和 JS 等静态文件，因此也更容易进行安全加固和防护。 部署灵活：Hexo 支持多种部署方式，包括 GitHub Pages、GitLab Pages、Vercel、Netlify 等。你可以根据自己的需求和喜好选择合适的部署平台，轻松实现博客的在线发布。 持续更新与维护：Hexo 团队和社区会不断关注最新的技术和趋势，并对 Hexo 进行更新和维护。这意味着 Hexo 将始终保持与时俱进，为用户提供更好的使用体验和功能支持。 5. 安装 Hexo 的前提条件 需要先安装 nodejs 的相应版本 安装 git 发布博客需要注册 github 账号 6. 安装 Hexo在安装 Hexo 首先需要了解 hexo 版本与 nodejs 版本的兼容性，避免安装之后出现版本兼容性问题。详情参考Install-Hexo。 Hexo version Minimum (Node.js version) Less than (Node.js version) 7.0+ 14.0.0 latest 6.2+ 12.13.0 latest 6.0+ 12.13.0 18.5.0 5.0+ 10.13.0 12.0.0 4.1 - 4.2 8.10 10.0.0 4.0 8.6 8.10.0 3.3 - 3.9 6.9 8.0.0 3.2 - 3.3 0.12 unknown 3.0 - 3.1 0.10 or iojs unknown 0.0.1 - 2.8 0.10 unknown 6.1. 安装 nodejs首先需要安装 nodejs, 可以参考我以前写的一篇博文安装并配置 nodejs，需要从以上表格中找到对应的版本进行替换。 6.2. 安装 Hexo 命令行工具123456sudo npm install hexo-cli -g 或者#（推荐使用cnpm安装, 速度快）sudo cnpm install hexo-cli -g 说明:npm 是 nodejs 的包管理工具，sudo 是 linux 或 unix 下将命令以管理员身份运行, windows 环境下不需要 sudo, install 为 npm 子命令用于安装工具包或项目依赖 -g 为全局安装，安装一次后，在命令行中处于任何目录位置都能使用，如果不带-g 工具包被安装在当前项目的 node_modules， 需要借助 npx 才能执行相关命令，像 hexo-cli 这样的命令行工具建议全局安装 这一步需要管理员权限，sudo 即为以超级用户运行安装命令，linux 和 mac 安装方法相同 如果是 windows 环境可能需要以管理员身份运行，可以将 sudo 去掉, windows 下如果需要管理员权限,会弹出请求授权框即 npm install hexo-cli -g 或者 cnpm install hexo-cli -g 如果访问墙外资源较慢，可以是 cnpm 经过阿里的镜像安装 hexo-cli 命令行工具，cnpm 前面的 c 即为 china 的意思，wall 内专用 nodejs 包管理工具 7. 创建博客系统7.1. 初始化博客系统12345678# 创建博客目录(blog为目录名,可以根据自己的喜好进行调整)mkdir blog# 进入博客目录cd blog# 初始化hexohexo init blog 命令说明： hexo: 是 hexo 的命令 init: hexo 的子命令，用于初始化一个博客系统． blog: 是博客系统的名字，这里我没有考虑太多，直接将博客系统的名字命名为 blog, 你可以根据自己的喜好设定名字． 进入 blog 目录，安装项目依赖包(第三方 nodejs 类库或工具) 12# 安装nodejs依赖包npm install 初始化完成后的简要目录结构如下: 12345678910./blog ├── _config.landscape.yml ├── _config.yml ├── db.json ├── node_modules ├── package.json ├── package-lock.json ├── scaffolds ├── source └── themes 7.1.1. 目录结构说明 package.json: 这个是 nodejs 要用到的，里面存放着项目信息，版本，项目所依赖的第三方 nodejs 工具和代码库 package-lock.json: 这个 nodejs 解析依赖包时会用到的 scaffolds: 博客脚手架，当你创建新的博文时可以基于其中的某个模板进行修改． source: 源代码文件夹，这里存放你网站的内容． themes: 主题，博客 css 样式，背景图片等等． node_modules: 这里存放 npm install 时从网络下载下来的依赖包 config.yml 项目配置文件 配置文件详细说明 这里重点说明一下项目配置文件． 你可以修改项目的默认配置文件_config.yml 以满足你个人的需求．比如标题，网站的描述，搜索关键字等等一些信息 | setting | chinese | desc | | :------------- | :-------------- | :--------------- | | title | 标题 | 你网站的标题 | | subtitle | 子标题 | 你网站的子标题 | | description | 网站描述 | 你网站的描述信息 | | keywords | 关键字 | 关键字 | | author | 作者 | 网站的作者 | | language | 语言 | 网站支持的语言 | | timezone | 网站时区 | 网站时区 | | theme | 主题 | 使用的主题名称 | | per_page | 每页文章数量 | 每页显示的文章量 | | pagination_dir | 分页url | 指定博客生成后，每页的 index.html 文件存放目录 | 8. 本地启动博客系统当前目录下执行以下命令，启动博客系统. 1 hexo serve 如果启动成功，会输出以下信息，最后一行会提示，通过什么网址可以访问博客．打开浏览器，将网址粘贴到浏览器即可访问到博客系统． 1234$hexo serveINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 使用浏览器打开http://localhost:4000打开博客首页会看到一些默认的博客页面，后面我们将会讲解如何修改代码来构建自己的博客系统． 9. 创建第一篇博文将一篇 markdown 格式的文章拷贝到 source 目录下，在博文开头加上标题，日期，标签页．刷新浏览器，即可看到自己的第一篇博客文章． 创建一篇博文, 向世界宣布你来了. 123456789101112---title: 使用Hexo搭建自己的博客网站date: 2021/10/4tags: - Hexocategories: - blog---## first bloghello world! 10. 如何发布博客10.1. 创建 github 代码仓库创建一个以你的 github 用户名命名的代码仓库例如 xxxx.github.io, 10.2. 安装 deployer 插件并配置 deploy安装 hexo-git plugin 123npm install hexo-deployer-git --save或者cnpm install hexo-deployer-git --save //推荐 修改配置文件_config.yml 配置 deploy 12345678# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git repo: git@github.com:your_github_id/xxxx.github.io.git branch: gh-pages name: yourname email: your_email@xxx.com 说明: 这里的 url 可以是 http https 也可以是 git url 但是建议使用 git url实测在 push 文件到 github 时使用 https 路径，经常会有异常抛出，使用 git url 后比较稳定使用 https url 需要在 url 上添加授权方式和 token 像这样 repository: https://oauth2:your_token@github.com/*****.github.io, 实测可行 on Nov 1 2021 为了防止将一些非必要的文件推送到 github 仓库，创建一个.gitignore 文件, 内容如下： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 10.3. 创建 gitHub token打开自己的 GitHub 主页，点击自己的头像找到 Settings 并进入, 选择 developer settings 在左边目录栏找到 Personal access tokens，点击 Generate new token，按照步骤申请即可，过程比较简单, 这里不详述。Scopes（范围）只需要授权 repo:status 和 repo:public_repo 权限即可 。Token 申请成功后，将 Token 复制并保存起来．当运行发布命令时需要输入此 token 作为密码 这样前期准备工作基本完成，现在开始发布博客。发布博客系统使用如下命令: 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 当提示输入 git 用户名密码时，输入你的 github 用户名, 当提升输入密码时，输入上面生成的 token 10.4. 验证发布是否成功浏览器打开自己的博客首页 https://xxxx.github.io/ 由于我设置了 dns cname 所以实际会跳转到https://pengtech.net/ 回头看一下 hexo 上传了哪些文件到 github, 其实只是上传了编译后的文件 所以需要自己将源文件保存到一个私有仓库，或者上传到另一个 github 仓库 12345672021/10/04/postarchivescssfancyboxjstags/Hexoindex.html 11. 选择一个漂亮的主题可以参考我的文章，里面有 10 多款精美的主题可供选择16 款精美的 hexo 博客主题推荐 | 鹏叔的技术博客 12. 进阶: 如何开启评论, 转发, 优化界面等等可以参考我的文章 Hexo 博客添加评论功能 | 鹏叔的技术博客 更多 Hexo 相关主题可以访问我的博客 hexo 主题https://pengtech.net/hexo/ 13. 插入图片Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。因此我们需要选择一款合适的图床来支持博客写作，目前各大云服务商都提供了对象存储服务，如七牛云 KODO、又拍云 USS、腾讯云 COS、阿里云 OSS 等。 可以使用PicGo工具上传图片到图床上。 14. 进阶: SEO 优化可以参考我的文章 Hexo 博客搜索引擎优化| 鹏叔的技术博客 15. 文章置顶这一功能已被加入 hexo-generator-index。之前老的方法使用 hexo-generator-index-pin-top 替换 hexo-generator-index, 这种不要再参考了, pin-top 已经八年没有更新了. 详细使用方法可以参考 hexo-generator-indexed 在文章的 Front-matter 中增加一个 sticky 参数用来置顶，其值应为大于 0 的整数，表示置顶的优先级（未指定则默认为 0）。数字越大，文章越靠前。 1234---title: examplesticky: 100--- 16. 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 配置 Next 主题 Hexo 配置 Icarus 主题 Hexo 博客搜索引擎优化 Hexo 命令详解 Hexo 博客添加评论功能 17. 参考文档Hexo 官方文档 Hexo 配置文档 hexo 博客文章置顶功能实现的两种方法 18. trouble shooting 问题: 启动时遇到 err: Error: ENOSPC: System limit for number of file watchers reached 具体错误信息如下 12345678910111213141516171819202122$hexo serverINFO Validating configINFO Start processingFATAL {err: Error: ENOSPC: System limit for number of file watchers reached, watch '$your_project_dir/blog/source/'at FSWatcher.&lt;computed&gt; (internal/fs/watchers.js:218:26)at Object.watch (fs.js:1582:34)at createFsWatchInstance ($your_project_dir/blog/node_modules/chokidar/lib/nodefs-handler.js:119:15)at setFsWatchListener ($your_project_dir/blog/node_modules/chokidar/lib/nodefs-handler.js:166:15)at NodeFsHandler._watchWithNodeFs ($your_project_dir/blog/node_modules/chokidar/lib/nodefs-handler.js:331:14)at NodeFsHandler._handleDir ($your_project_dir/blog/node_modules/chokidar/lib/nodefs-handler.js:559:19)at processTicksAndRejections (internal/process/task_queues.js:95:5)at async NodeFsHandler._addToNodeFs ($your_project_dir/blog/node_modules/chokidar/lib/nodefs-handler.js:609:16)at async $your_project_dir/blog/node_modules/chokidar/index.js:451:21at async Promise.all (index 0) {errno: -28,syscall: 'watch',code: 'ENOSPC',path: '$your_project_dir/blog/source/',filename: '$your_project_dir/blog/source/'}} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 解决办法 扩大能 watch 的文件数上限 1echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 问题: The TLS connection was non-properly 12345678910fatal: unable to access 'https://github.com/xxxx/xxxx.github.io/': gnutls_handshake() failed: The TLS connection was non-properly terminated.FATAL {err: Error: Spawn failedat ChildProcess.&lt;anonymous&gt; ($your_project_dir/blog/node_modules/_hexo-util@2.5.0@hexo-util/lib/spawn.js:51:21)at ChildProcess.emit (events.js:400:28)at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) {code: 128}} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 原因分析 其实出现这个问题，很大可能是因为 https 和 http 的 proxy 的对应的分别是 https 和 http 开头的 proxy server，而 https 的 proxy server 可能无法正常工作。一个 workaround 是把 https 的 proxy server 换成 http 的 proxy server: 解决办法 解决办法有三种,修改_config.yml 文件的 deploy 部分，将 https 修改为 http url 或者 设置为 git url, 配置为 https oauth2 加 token 设置为 git url(推荐) 1234deploy: type: git repo: git@github.com:your_github_id/your_github_id.github.io.git branch: gh-pages 这里建议配置为 git url 将 https 修改为 http url 1234deploy: type: git repo: git@github.com:your_github_id/your_github_id.github.io.git branch: gh-pages 在 repo https url 上要添加授权方式和 token 1234deploy: type: git repo: https://oauth2:your_github_token@github.com/your_github_id/your_github_id.github.io.git branch: gh-pages 问题: 站内链接跳转不灵 现象: 当时使用 markdown 标准的站内跳转链接写法时，再发布后发现链接是错的跳转不过去，例如 1[如何创建一个 nodejs 模块](how_to_create_a_node_module.md) 原因分析: 生成的链接是不对的，路径上缺少了年月等信息 解决办法 替换为下面这种写法，就能正确跳转 1{% post_link nodejs/how_to_create_a_node_module %} 更多详细分析可以参考知乎上的这篇文章 链接包含中文不能正常跳转问题 现象：当右侧大纲条目中包括中文时，点击不能正确跳转打开浏览器开发者模式发现以下错误 12utils.js:240 Uncaught TypeError: Cannot read property 'getBoundingClientRect' of nullat HTMLAnchorElement.&lt;anonymous&gt; (utils.js:240) 原因分析: 中文链接在转码后不能正确的映射到相应的页面元素 解决方案 我已经通过此issue反馈给 hexo 社区，社区的回复是在新的 Next theme 中已经解决此问题，需要升级 next theme 到新版本, 以下是来自社区的回复: 12This issue has been fixed in next-theme/hexo-theme-next@0d2b3afTheme NexT version 7.8.0 is outdated. The latest version is v8.8.0 https://github.com/next-theme/hexo-theme-next/releases/tag/v8.8.0 19. 相关阅读使用 Hexo 搭建自己的博客网站 Hexo 命令详解 Hexo 博客添加评论功能 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化 博客的发展简史和框架简介","link":"/hexo/hexo_create_site.html"},{"title":"Hexo中插入mermaid图表","text":"1. mermaid简介mermaid是一种基于文本的格式生成图表和流程图的工具，是markdown文本很好的补充。可以生成各种图表，其中包括流程图, 时序图, 甘特图等等． 2. vscode安装mermaid插件 (可选)由于我使用的是vscode来编辑markdown文档，所以需要安装Markdown Preview Mermaid Support插件才能看到mermaid预览图. 3. 安装mermaid插件hexo中要使用mermaid图表 1npm install hexo-filter-mermaid-diagrams --save 4. 修改配置修改主题文件_config.yml这里很多教程说修改根目录下的，而不是主题，但是我发现我需要修改主题的，我用的是 next，所以修改themes/next下的_config.yml，之前改成用根目录下不管用，后面发现原来 next 的配置中也有mermaid配置，如下所示 1234567# Mermaid tagmermaid: enable: true # Available themes: default | dark | forest | neutral theme: light: default dark: dark 很多博客说需要手动修改foot模板引入mermaid，实际测试在我当前使用的next 版本中不需要任何手动修改． 5. 测试一段mermaid图表在markdown文档中插入一段mermaid图标下面是三个mermaid图表实例，很明显文字已经转换成了漂亮的图表． 流程图(FLOWCHART) 文本: 12345graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; 图表 graph TD; A-->B; A-->C; B-->D; C-->D; 时序图(SEQUENCE DIAGRAM) 文本: 1234567891011sequenceDiagram participant Alice participant Bob Alice-&gt;John:Hello John, how are you? loop Healthcheck John-&gt;John:Fight against hypochondria end Note right of John:Rational thoughts &lt;br/&gt;prevail... John--&gt;Alice:Great! John-&gt;Bob: How about you? Bob--&gt;John: Jolly good! 图表 sequenceDiagram participant Alice participant Bob Alice->John:Hello John, how are you? loop Healthcheck John->John:Fight against hypochondria end Note right of John:Rational thoughts prevail... John-->Alice:Great! John->Bob: How about you? Bob-->John: Jolly good! 甘特图文本 123456789101112131415gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 图表 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 饼图文本： 123456pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5 图表： pie title Key elements in Product X \"Calcium\" : 42.96 \"Potassium\" : 50.05 \"Magnesium\" : 10.01 \"Iron\" : 5 状态图文本： 12345678910111213141516stateDiagram [*]--&gt;Active state Active { [*]--&gt;NumLockOff NumLockOff--&gt;NumLockOn : EvNumLockPressed NumLockOn--&gt;NumLockOff : EvNumLockPressed -- [*]--&gt;CapsLockOff CapsLockOff--&gt;CapsLockOn : EvCapsLockPressed CapsLockOn--&gt;CapsLockOff : EvCapsLockPressed -- [*]--&gt;ScrollLockOff ScrollLockOff--&gt;ScrollLockOn : EvCapsLockPressed ScrollLockOn--&gt;ScrollLockOff : EvCapsLockPressed } 图表： stateDiagram [*]--&gt;Active state Active { [*]--&gt;NumLockOff NumLockOff--&gt;NumLockOn : EvNumLockPressed NumLockOn--&gt;NumLockOff : EvNumLockPressed -- [*]--&gt;CapsLockOff CapsLockOff--&gt;CapsLockOn : EvCapsLockPressed CapsLockOn--&gt;CapsLockOff : EvCapsLockPressed -- [*]--&gt;ScrollLockOff ScrollLockOff--&gt;ScrollLockOn : EvCapsLockPressed ScrollLockOn--&gt;ScrollLockOff : EvCapsLockPressed } 6. 相关阅读使用Hexo搭建自己的博客网站 Hexo命令详解 Hexo博客添加评论功能 Hexo配置Next主题 Hexo配置Icarus主题 Hexo博客搜索引擎优化","link":"/hexo/hexo_mermaid_plugin.html"},{"title":"16 款精美的 hexo 博客主题推荐","text":"根据 Github 影响力,是否在积极维护以及实际使用体验筛选出 16 款精致的 Hexo 主题。欢迎评论区留言，告诉大家你最喜欢的主题。 1. Icarus 主题一款简单，精致和现代的主题。Icarus，灵感来源于古希腊神话中飞翔的少年，寓意着向光明和自由的追求，正是这款主题设计精神的体现。它由开发者【张瑞鹏】的创作，以其独特的设计理念，为你的博客添上一抹清新脱俗之风。 Icarus 主题采用了流行的Bulma CSS 框架，这赋予了它高度灵活的响应式设计，确保无论是在手机、平板还是桌面设备上都能呈现完美的视觉体验。此外，借助如highlight.js、Moment.js、lightgallery等一系列开源工具，Icarus 实现了代码高亮、时间人性化显示、以及图片灯箱特效等功能，让技术分享与美文阅读都变得更为愉悦。 Github 地址：https://github.com/ppoffice/hexo-theme-icarus Github stars: 6.3K (as of July 2024) 在线演示： 默认风格 https://ppoffice.github.io/hexo-theme-icarus/ 暗黑风格 https://pengtech.net 赛博朋克风格 https://www.cyberpunk.net/sg/zh-cn/ 安装教程：https://pengtech.net/hexo/hexo_apply_icarus_theme.html 效果图： 变体： icarus 还有一些变体可供选择：hexo-theme-amazing 2. Butterfly 主题Butterfly 是一款功能丰富且视觉效果出色的 Hexo 主题，以其高度可定制性和美观的界面设计而受到用户喜爱。该主题支持多种布局、阅读模式、夜间模式等，并提供了许多实用的小功能。Hexo-theme-Butterfly 的设计以简洁和优雅为核心。它通过清晰的布局和和谐的色彩搭配，为用户提供一个舒适的阅读和创作环境。这种设计理念不仅体现在页面布局上，还贯穿于每一个细节，如字体选择、图标设计和动画效果等。 主要有以下特点： Material Design 设计，简单漂亮，文章内容美观易读； 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现； 功能多，支持友链、评论模块、文章统计、音乐播放、视频播放等; 性能优化, SEO 优化, 丰富的 Markdown 扩展, 多语言支持, 夜间模式; 活跃的社区支持。 Github 地址：https://github.com/jerryc127/hexo-theme-butterfly Github stars: 6.9K (as of July 2024) 在线演示：https://butterfly.js.org/ 安装教程：https://butterfly.js.org/posts/21cfbf15/ 效果图： 3. NexT 主题NexT 是一款风格优雅的高质量 Hexo 主题，以其丰富的配置选项和多种风格（如 Muse、Mist、Pisces、Gemini 等）而受到广泛欢迎。NexT 主题一直在持续更新和维护，支持许多外部插件和功能选项。 主要有以下特点： 优雅 支持中文 多平台自适应 Github 地址：https://github.com/next-theme/hexo-theme-next Github stars: 8.1K (as of July 2024) 在线演示： 💟 Muse scheme: LEAFERx | Alex LEE | OAwan🔯 Mist scheme: Jeff | uchuhimo | xirong♓ Pisces scheme: Vi | Jiaxi He♊ Gemini scheme: Ivan.Nginx | Raincal | Dandy | Mimi | Banban | KaitoHH 安装教程：https://pengtech.net/hexo/hexo_advance_apply_next_theme.html 效果图： 4. Anzhiyu 主题简洁明了的 Hexo 主题，设计师风格，一款基于 hexo-theme-butterfly 修改的主題。 Github 地址：https://github.com/anzhiyu-c/hexo-theme-anzhiyu Github stars: 1.1K (as of July 2024) 在线演示：https://blog.lixiaomu.fun/ 安装教程：https://docs.anheyu.com/initall.html 效果图： 5. Stellar 主题Stellar Hexo theme 是一款基于 Hexo 框架的静态博客主题，它以其独特的功能和设计风格受到了许多程序员和博主的青睐。 主题特点: 专栏功能： Stellar 主题支持专栏功能，这对于需要按主题或分类组织内容的博主来说非常有用。它允许读者通过专栏快速定位到感兴趣的内容，提高阅读体验。 响应式设计： 该主题采用响应式设计，确保网站在不同设备（如桌面、平板和手机）上都能良好地展示，提供优秀的阅读体验。 自定义配置： Stellar 主题提供了丰富的配置选项，用户可以根据自己的需求调整颜色方案、布局、导航菜单等，满足个性化需求。 SEO 优化： 考虑到搜索引擎友好性，该主题集成了 SEO 相关设置，如自定义 meta 标签等，有利于提高网站的可见度。 插件支持： 作为 Hexo 的主题，Stellar 可以无缝集成各类 Hexo 插件，扩展其功能，如评论系统、社交媒体分享等。 Github 地址：https://github.com/xaoxuu/hexo-theme-stellar Github stars: 1.2K (as of July 2024) 在线演示： XAOXUU 独钓寒江雪 Stellar Hexo theme examples 安装教程：https://xaoxuu.com/wiki/stellar/#start 设计理念： 真正的简约远不止删繁就简，而是在纷繁中建立秩序。 人的注意力是有限的，要提高有效信息的醒目程度，就必须降低不重要信息醒目程度，删除所有无效信息。 降低视觉密度 增加留白，增加间距。减少颜色丰富度，大面积出现的是中性色，彩色必须有其特殊意义，意义相同的元素使用同一种颜色。提高有效信息优先级 文章标题永远是最大的，对比度最高的不可交互的不重要的小标题（如侧边栏某个插件的标题）降低对比度与文章相关的不重要的小标题，使用小号字体 删掉无效信息 文章标签、字数、阅读量、评论数网站访问量、字数、搭建时间全局播放器（除了特殊文章） 效果图： 6. Solitude 主题Solitude 主题是一款优雅、简洁、响应式的 Hexo 主题，专注于内容，提供出色的阅读体验。Solitude 主题早期是基于 Hexo-Theme-Acrylic-Next 修改的，结构清晰，在 1.2.1 版本之后的作者完全重写了整个theme！ 主题特点: 文档完善 SEO友好 页面组件懒加载(pjax 方案) 图片懒加载 多种代码高亮方案 多语言配置 支持多种评论插件 内置网页访问统计 支持暗色模式 支持脚注语法 支持自定义 CDN 静态资源 支持多功能右键菜单 支持定制化的主色调随封面图片颜色变化 支持沉浸式状态栏 支持聊天系统 支持百度分析 支持图片大图查看 支持瀑布流即刻说说 支持自定义图标（iconfont、CoDeSign、fontawesome） 支持高速缓存的 swpp，pwa 特性 优秀的隐私协议支持 文章摘要 AI 支持 支持全局中控台 支持本地搜索和 algolia 搜索 支持 Latex 数学公式 Github 地址：https://github.com/everfu/hexo-theme-solitude Github stars: 555 (as of Aug 2024) 在线演示：https://everfu.github.io/Solitude/ 安装教程： 安装教程 https://solitude.js.org/guide/quick-start 配置教程 https://solitude.js.org/config/basic 效果图： 首页 即刻短文 友情链接 音乐馆 7. Indigo 主题Github 地址：https://github.com/yscoder/hexo-theme-indigo Github stars: 2.8K (as of July 2024) 在线演示：https://yscoder.github.io/ 安装教程： 安装教程 https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85 配置教程 https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE 效果图： 8. Cactus 主题Github 地址：https://github.com/probberechts/hexo-theme-cactus Github stars: 3.1K (as of July 2024) 在线演示：https://probberechts.github.io/hexo-theme-cactus/ 安装教程：https://github.com/probberechts/hexo-theme-cactus 效果图： 9. Diaspora 主题一款基于 WordPress 移植的 Hexo 主题，适合喜欢摄影，影评，乐评和玩弄文字的你，干净，清新； 响应式，Ajax，更多好玩的等你来发现。 Github 地址：https://github.com/Fechin/hexo-theme-diaspora Github stars: 1.3K (as of July 2024) 在线演示：http://fech.in/ 安装教程：https://github.com/Fechin/hexo-theme-diaspora?tab=readme-ov-file 效果图： 10. Snippet 主题Snippet 是一款基于 Hexo 的现代化博客主题，以其简洁、高效的特性而受到技术博主的青睐。 Github 地址：https://github.com/shenliyang/hexo-theme-snippet Github stars: 1.1K (as of July 2024) 在线演示：https://snippet.shenliyang.com/ 安装教程：https://github.com/shenliyang/hexo-theme-snippet 效果图： 11. Fluid 主题响应式设计，支持多种布局和颜色方案，适合追求视觉效果的用户。 Github 地址：https://github.com/fluid-dev/hexo-theme-fluid Github stars: 7.1K (as of July 2024) 在线演示：https://hexo.fluid-dev.com/ 安装教程：https://github.com/fluid-dev/hexo-theme-fluid 效果图： 12. Sakura 主题以樱花为主题元素，营造浪漫温馨的氛围，适合女性用户或文学爱好者。 Github 地址：https://github.com/honjun/hexo-theme-sakura Github stars: 671 (as of July 2024) 在线演示：https://dragonbaby308.github.io/hexo-theme-sakura/ 安装教程：https://docs.hojun.cn/sakura/docs 效果图： 13. Volantis 主题Volantis 是一个多功能的 Hexo 主题，支持多种布局和样式，适合需要高度自定义的用户。 Github 地址：https://github.com/volantis-x/hexo-theme-volantis Github stars: 2K (as of July 2024) 在线演示：https://volantis.js.org/examples/ 安装教程：https://volantis.js.org/v6/getting-started/ 效果图： 14. Matery 主题采用 Material Design 和响应式设计的精美主题 Github 地址：https://github.com/blinkfox/hexo-theme-matery Github stars: 5.2K (as of July 2024) 在线演示：http://blinkfox.com/ 安装教程：https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md 效果图： 15. Tranquilpeak 主题Tranquilpeak 是一个华丽响应的 Hexo 主题，支持中文和多平台自适应。 Github 地址：https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak Github stars: 1.8K (as of July 2024) 在线演示：https://louisbarranqueiro.github.io/hexo-theme-tranquilpeak/ 安装教程：https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/main/DOCUMENTATION.md 效果图： 16. Yilia 主题Github 地址：https://github.com/litten/hexo-theme-yilia Github stars: 8.4K (as of July 2024) 在线演示：http://litten.me/ 安装教程：https://github.com/litten/hexo-theme-yilia 效果图： 17. 其他Hexo theme由于精力有限，还有一些优秀的theme, 没有来得及认真整理，这里简单列举在此，等有空整理时再详细介绍。 Maupassant： 一款极简风格的博客主题 Github 地址：https://github.com/tufu9441/maupassant-hexo Github stars: 2.6K (as of July 2024) 在线演示：https://www.haomwei.com/ hexo-theme-nexmoe： Github 地址：https://github.com/theme-nexmoe/hexo-theme-nexmoe Github stars: 1.6K (as of July 2024) 在线演示：https://nexmoe.com/ Aurora 主题做得非常有艺术性，是那种一眼就能爱上的主题 Github 地址：https://github.com/auroral-ui/hexo-theme-aurora Github stars: 1.4K (as of July 2024) 在线演示：https://tridiamond.tech/ 18. 关联阅读使用 Hexo 搭建自己的博客网站 Hexo 配置 Icarus 主题 Hexo 配置 Next 主题 Hexo 博客搜索引擎优化 Hexo 命令详解 Hexo 博客添加评论功能 19. 参考文档hexo 博客主题推荐 Awesome Hexo Theme Hexo - 主题推荐 九个好看实用的 Hexo 主题推荐 easyhexo 发现你的博客新美学 —— Typecho 主题”Icarus”深度解析","link":"/hexo/hexo_theme_recommendation.html"},{"title":"javascript 内置对象","text":"1. BOM对象概述BOM：浏览器对象模型（Browser Object Model）BOM提供了独立于内容的、可以与浏览器窗口进行互动的对象结构. graph TD; A[Window]-->B[history]; A-->C[document]; A-->D[location]; C-->C1[link]; C-->C2[form]; C-->C3[anchor]; C2-->D1[button]; C2-->D2[checkbox]; C2-->D3[text]; C2-->D7[...]; C2-->D4[textarea]; C2-->D5[radio]; C2-->D6[select]; BOM可实现功能： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口的大小 页面的前进、后退 2. window对象下的主要对象 属性名称 说明 location 有关客户访问过的历史信息 history 有关当前url的信息 语法 1window.属性名 = &quot;属性值&quot; 举例说明 :页面定义一个按钮,点击按钮跳转至百度代码 : 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML案例&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function goBaidu(){ window.location = &quot;https://www.baidu.com&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;goBaidu();&quot;&gt;点我跳转至百度&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.1. history对象 主要管理浏览记录 常用方法 名称 说明 back() 加载history对象列表中的前一个URL forward() 加载history对象列表中的下一个URL go() 加载history对象列表中的某个具体URL history.back() 等价于 history.go(-1)history.forward() 等价于 history.go(1) 2.2. location对象 主要管理页面跳转 常用属性 名称 说明 host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完整的URL 常用方法 名称 说明 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 3. window对象的常用方法 方法名称 说明 prompt() 显示可提示用户输入的对话框 alert() 显示带有一个提示信息和一个确定按钮的警示框 confirm() 显示一个带有提示信息，确定和取消的对话框 close() 关闭浏览器 open() 打开一个新的浏览器，加载给定URl所指定的文档 语法： 1234567confirm(“对话框中显示的纯文本”)confirm()与alert ()、 prompt()区别:alert( )：一个参数，仅显示警告对话框的消息，无返回值，不能对脚本产生任何改变prompt( )：两个参数，输入对话框，用来提示用户输入一些信息，单击“取消”按钮则返回null，单击“确定”按钮则返回用户输入的值，常用于收集用户关于特定问题而反馈的信息confirm( )：一个参数，确认对话框，显示提示对话框的消息、“确定”按钮和“取消”按钮，单击“确定”按钮返回true，单击“取消”按钮返回false，因此与if-else语句搭配使用 举例说明 : 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML案例&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var con = window.confirm(&quot;确定要删除这条数据么?&quot;); if(con == true){ alert(&quot;删除成功!&quot;); }else{ alert(&quot;你取消了删除!&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4. document对象概述document 对象 : 主要管理页面中的各种元素的JS把页面所有的标签都看成对象,而document对象包含的就是标签之间的一些标签,通过document对象可以获取他们并进行操作;它的常用方法有: 方法名称 说明 getElementById() 返回指定id的对象引用 getElementsByName() 返回指定名称的对象集合 getElementsByTagName() 返回指定标签的对象集合 write() 向文档写文本，html表达式 或javascript代码 5. 参考文档JavaScript内置对象","link":"/javascript/js-builtin-object.html"},{"title":"计算机发展极简编年史","text":"1. 前言我为什么要写这篇文章? 计算机发展的速度太快了, 已经进入了蓬勃发展期. 但是依然看不到它的尽头, 看不清它的终极形态. 很多人都在追逐新的技术, 但是很少有人拿起笔系统的记录它的过去. 很多年以后当我们要追寻一项技术的来龙去脉的时候, 可能连它的”尸身”都找不到了. 比如说软盘驱动器（floppy disk driver）现在谁手上还保存有一张1.44MB的3.5英寸软盘, 谁电脑上还会装有软驱呢, 这在当时可是一项创新性的技术, 是便携式存储的鼻祖, 是一代人的回忆. 一张小小的软盘能装下一整套DOS操作系统, 能装下一个夏天的劳动成果. 但是现在当我想介绍存储技术的演进过程时, 不仅找不到一部软驱, 一张软盘, 就连一张合适的图片的很难找到了. 同样的命运的还有寻呼机机, 这个承载着很多人青春记忆的通信设备, 可能剩下脑海中的BiBi声了. 同样的命运的还有功能机, 早已过了手机换脸盆的淘汰期, 曾经层出不穷的款式, 不知道现在还有几款健在. 更不用说他们所依赖的生态系统, 比如基站设备, 外设装置. 站在当下这个似乎还能朦朦胧胧看到过去的时间节点, 在不费太多力气的情况下, 将不太遥远的过去记录下来, 省得后来人花费昂贵的代价去考古, 也不失为一件幸事. 为什么以编年体的形式记录这段历史? 其实这是我的某项计划的一部分, 还处于材料收集阶段, 收集计算机发展史也是我副业中的副业, 没有太多时间深入研究和系统性地整理, 只能以最简单的方式快速呈现内容, 不至于让整个计划胎死腹中(我已经有很多文章由于计划过于宏大而胎死腹中的先例了). 编年体是快速理清脉络, 呈现材料的最好方式. 它不需要花太多时间去整理去构思, 而且呈现效果也非常清晰. 另外我也非常喜欢将软件工程中的一些概念应用到写作中, 那就是小步快跑, 快速迭代; 再者就是重构. 有了足够的材料后, 我相信通过不断地重构, 不断地迭代, 能将其打造为我心中理想的样子. 所以这篇文章会是一篇不断完善的文章, 请有兴趣的朋友关注鹏叔的技术博客获取最新内容. 另外如何您有兴趣资助鹏叔的计划, 原文末尾有打赏功能, 请点一点, 在此表示感谢! 2. 引言计算机的历史始于 19 世纪初的原始设计，并在 20 世纪继续改变世界。 计算机的历史可以追溯到 200 多年前。最初由数学家和企业家提出理论，在 19 世纪，机械计算机的设计和制造是为了解决日益复杂的数字运算挑战。到 20 世纪初，技术的进步使得计算机变得越来越复杂，计算机变得越来越大、越来越强大。 如今，计算机几乎无法从 19 世纪的设计（例如查尔斯·巴贝奇的分析机）中辨认出来，甚至从 20 世纪占据整个房间的大型计算机（例如电子数值积分器和计算器）中也无法辨认。 这是计算机的简史，从其原始的数字处理起源到强大的现代机器，可以上网、运行游戏和流式传输多媒体。 3. 机械计算机公元前150年-100年: 安提基特拉机械(Antikythera mechanism) 是古希腊时期为了计算天体在天空中的位置而制造的青铜机器，属于模拟计算机。该机器是于1901年在希腊安提基特拉岛附近的安提基特拉沉船里发现的。该机械的制造年代约在西元前150到100年之间，至今已有二千多年。 1613: “计算机”一词首次使用于1613年，最初描述的是进行计算或计算的人。 计算机的定义一直保持不变，直到 19 世纪末开始指计算机器。 1614: 苏格兰人John Napier (1550-1617)发表了一篇论文，其中提到他发明了一种可以计算四则运算和方根运算的精巧装置。 1617: 约翰·纳皮尔 (John Napier) 推出了“纳皮尔之骨”，这是一种由角（骨头或象牙）制成的装置。该设备允许通过加法进行乘法，通过减法进行除法。 1621: 圆形计算尺是由威廉·奥特雷德(William Oughtred)发明的。 1623: Wilhelm Schickard (1592-1635)制作了一个能进行六位以内数加减法，并能通过铃声输出答案的”计算钟”。通过转动齿轮来进行操作。 1625: William Oughtred (1575-1660) 发明计算尺, 直接进行乘除计算。他首先使用”×”来表示乘法运算. 1632: 剑桥大学的威廉·奥特雷德 (William Oughtred) 将两条Gunter尺结合起来，制造出一种类似于今天计算尺的装置。 1642: 法国数学家Pascal 在WILLIAM Oughtred计算尺的基础上将计算尺加以改进，能进行八位计算。并且还卖出了许多，成为一种时髦的商品。 1668: 英国人Samuel Morl制作了一个非十进制的加法装置，适宜计算钱币。 1671: 德国数学家Gottfried Leibniz(莱布尼茨)推出了步进计算器，这是一种可以进行乘法、除法和计算平方根的设备, 最终答案可以最大达到16位的计算设备。 1679: Gottfried Leibniz演示了二进制算术，这一发现表明只需要用0和1就能表示每一个数。 1775: 英国Charles制作成功了一台与 Leibniz’s 的计算机类似的机器。但更先进一些。 1776: 德国人Mathieus Hahn成功的制作了一台乘法器。 1801 年：法国商人兼发明家 Joseph Marie Jacquard 发明了一种织机，可以使用穿孔木卡自动编织织物图案。早期的计算机会使用类似的打孔卡。 1820: 法国人Charles Xavier Thomas de Colmar (1785-1870),制作成功第一台成品计算机，非常的可靠，可以放在桌面上，在后来的90多年间一直在市场上出售。 1821 年：英国数学家查尔斯·巴贝奇 (Charles Babbage) 构想出一种能够计算数字表格的蒸汽驱动计算机。据明尼苏达大学称，该项目由英国政府资助，名为“差异引擎”，但由于当时缺乏技术而失败。 1832: Babbage 和Joseph Clement 制成了一个差分机的成品，开始可以进行6位数的运算。后来发展到20位、30位，尺寸将近一个房子那么大。结果以穿孔的形式输出。但限于当时的制造技术，他们的设计难以制成。 1834: 斯德哥尔摩的George Scheutz用木头做了一台差分机。 1834: Babbage 设想制造一台通用的分析机，在只读存储器（穿孔卡片）中存储程序和数据，Babbage在以后的时间继续他的研究工作，并于1840年将操作数提高到了40位，并基本实现了控制中心（CPU）和存储程序的设想，而且程序可以根据条件进行跳转，能在几秒内作出一般的加法，几分钟内作出乘除法。 1842: Babbage的差分机项目因为研制费用昂贵，被政府取消。但他自己仍花费大量的时间和精力于他的分析机研究。 1843: Scheutz 和他的儿子Edvard Scheutz 制造了一台差分机，瑞典政府同意继续支持他们的研究工作。 1847: Babbage 花两年时间设计了一台较简易的、31位的差分机，但没有人感兴趣并支持他造出这台机器。但后来伦敦科学博物馆用现代技术复制出这台机器后发现，它确实能准确地工作。 1848: 英国数学家George Boole创立二进制代数学。提前差不多一个世纪为现代二进制计算机铺平了道路。 1848 年：英国数学家、诗人拜伦勋爵的女儿艾达·洛夫莱斯 (Ada Lovelace) 编写了世界上第一个计算机程序。德国明斯特大学理论数学教授安娜·西弗特 (Anna Siffert) 表示，洛夫莱斯在将一篇关于巴贝奇分析机的论文从法文翻译成英文时编写了第一个程序。“她还对文本提供了自己的评论。她的注释，简称为“注释”，结果是实际文字记录的三倍，”西弗特在马克斯·普朗克学会的一篇文章中写道。“洛夫莱斯还添加了使用巴贝奇机器（基本上是一种算法）计算伯努利数的分步描述，这实际上使她成为世界上第一位计算机程序员。” 伯努利数是计算中经常使用的有理数序列。 1853 年：瑞典发明家 Per Georg Scheutz 和他的儿子 Edvard 设计出了世界上第一台打印计算器。根据 Uta C. Merzbach 的书“ Georg Scheutz and the First Printing Calculator ”（史密森学会出版社，1977 年），该机器的重要意义在于它是第一台“计算表格差异并打印结果”的机器。 1853: 令Babbage感到高兴的是，Scheutzes制造成功了真正意义上的比例差分机，能进行15位数的运算。象Babbage所设想的那样输出结果。后来伦敦的Brian Donkin又造出了更可靠的第二台。 1858: 第一台制表机被Albany的Dudley天文台买走。第二台被英国政府买走。但天文台并没有将其充分利用，后来被送进了博物馆。而第二台却被幸运地使用了很长时间。 1871: Babbage 制造了分析机的部分部件和印表机。 1878: 纽约的西班牙人Ramon Verea，制造成功桌面计算器。比前面提到的都要快。但他对将其推向市场不感兴趣，只是想表明，西班牙人可以比美国人做得更好。 1879: 一个调查委员会开始研究分析机是否可行，最后他们的结论是：分析机根本不可能工作。此时Babbage已经去世了。调查之后，人们将他的分析机彻底遗忘了。但Howard Aiken例外。 1885: 这时期更多的计算机涌现出来。如美国、俄国、瑞典等。他们开始用有槽的圆柱代替易出故障的齿轮。 1886: 芝加哥的Dorr E. Felt (1862-1930), 制造了第一台用按键操作的计算器，而且速度非常快，按键抬起，结果也就出来了。 1889: Felt推出桌面印表计算器。 1890: 1890美国人口普查。1880年的普查人工用了7年的时间进行统计。这意味着1890年的统计将会超过10年。美国人口普查部门希望能得到一台机器帮助提高普查的效率。Herman Hollerith，建立制表机公司的那个人，后来他的公司发展成了IBM公司。借鉴了Babbage的发明，用穿孔卡片存储数据，并设计了机器。结果仅仅用了6个周就得出了准确的数据（62622250人）。据哥伦比亚大学称，这台机器为政府节省了数年的计算时间，并为美国纳税人节省了大约 500 万美元。 Herman Hollerith大发其财。 1892: 圣多美和普林西比的William S. Burroughs (1857-1898),制作成功了一台比Felt的功能更强的机器，真正开创了办公自动化工业。 1896: Herman Hollerith创办了IBM公司的前身。 1906: Henry Babbage, Charles Babbage 的儿子，在R. W. Munro的支持下，完成了父亲设计的分析机，但也仅能证明它能工作，而没有将其作为产品推出。 4. 电子管计算机在这之前的计算机，都是基于机械运行方式，尽管有个别产品开始引入一些电学内容，却都是从属于机械的，还没有进入计算机的灵活：逻辑运算领域。而在这之后，随着电子技术的飞速发展，计算机就开始了由机械向电子时代的过渡，电子越来越成为计算机的主体，机械越来越成为从属，二者的地位发生了变化，计算机也开始了质的转变。下面就是这一过渡时期的主要事件： 1906: 美国的Lee De Forest发明了电子管。在这之前造出数字电子计算机是不可能的。这为电子计算机的发展奠定了基础。 1924年2月:IBM，一个具有划时代意义的公司成立。 1935: IBM推出IBM 601机。这是一台能在一秒钟算出乘法的穿孔卡片计算机。这台机器无论在自然科学还是在商业意义上都具有重要的地位。大约造了1500台。 1931 年：据斯坦福大学称，Vannevar Bush 在麻省理工学院 (MIT) 发明并建造了微分分析仪，这是第一台大型自动通用机械模拟计算机。 1936 年：英国科学家和数学家艾伦·图灵 ( Alan Turing ) 根据克里斯·伯恩哈特 (Chris Bernhardt) 的著作《图灵的愿景》(麻省理工学院出版社，2017 年)在一篇名为《论可计算数……》的论文中提出了通用机器的原理，后来称为图灵机）。图灵机能够计算任何可计算的东西。现代计算机的中心概念就是基于他的思想。据英国国家计算博物馆称，图灵后来参与了图灵-韦尔奇曼炸弹的开发，这是一种机电设备，旨在在第二次世界大战期间破译纳粹密码。 1937 年：爱荷华州立大学物理和数学教授约翰·文森特·阿塔纳索夫 (John Vincent Atanasoff) 提交了一份拨款提案，旨在建造第一台纯电动计算机，而不使用齿轮、凸轮、皮带或轴。 1937: BELL试验室的George Stibitz展示了用继电器表示二进制的装置。尽管仅仅是个展示品，但却是第一台二进制电子计算机。 1938: Claude E. Shannon 发表了用继电器进行逻辑表示的论文。 1938: 柏林的Konrad Zuse 和他的助手们完成了一个机械可编程二进制形式的计算机，其理论基础是Boolean代数。后来命名为Z1。它的功能比较强大，用类似电影胶片的东西作为存储介质。可以运算七位指数和16位小数。可以用一个键盘输入数字，用灯泡显示结果。 1939 年：大卫·帕卡德 (David Packard) 和比尔·休利特 (Bill Hewlett) 在加利福尼亚州帕洛阿尔托创立了惠普公司。据麻省理工学院称，两人通过抛硬币决定了新公司的名称，而惠普的第一个总部就位于帕卡德的车库里。 1939年1月1日: 加利福尼亚的David Hewlet和William Packard 在他们的车库里造出了Hewlett-Packard计算机。名字是两人用投硬币的方式决定的。包括两人名字的一部分。(惠普) 1939年11月: 美国John V. Atanasoff和他的学生Clifford Berry 完成了一台16位的加法器，这是第一台真空管计算机。 1939: 二次世界大战的开始，军事需要大大促进了计算机技术的发展。 1939: Zuse和Schreyer开始在他们的Z1计算机的基础上发展Z2计算机。并用继电器改进它的存储和计算单元。但这个项目因为Zuse服兵役被中断了一年 1939/1940: Schreyer利用真空管完成了一个10位的加法器，并使用了氖灯做存储装置。 1940年1月: Bell实验室的Samuel Williams和Stibitz制造成功了一个能进行复杂运算的计算机。大量使用了继电器，并借鉴了一些电话技术，采用了先进的编码技术。 1941 年：德国发明家兼工程师 Konrad Zuse 完成了他的 Z3 机器，根据 Gerard O’Regan 的《计算简史》（Springer，2021 年）一书，这是世界上最早的数字计算机。这是第一台可编程的电子计算机。可处理7位指数、14位小数。使用了大量的真空管。每秒钟能作3到4次加法运算。一次乘法需要3到5秒。该机器在第二次世界大战期间对柏林的轰炸袭击中被毁。据 O’Regan 介绍，Zuse 在纳粹德国战败后逃离了德国首都，并于 1950 年发布了世界上第一台商用数字计算机 Z4。 1941 年：阿塔纳索夫和他的研究生 Clifford Berry 设计了美国第一台数字电子计算机，称为阿塔纳索夫-贝里计算机 (ABC), 用电容作存储器，用穿孔卡片作辅助存储器，那些孔实际上是”烧”上的。时钟频率是60HZ，完成一次加法运算用时一秒。。根据《计算机的诞生》（剑桥学者出版社，2016 年）一书的说法，这标志着计算机第一次能够在主内存上存储信息，并且能够每 15 秒执行一次操作 1943: 1943年到1959年时期的计算机通常被称作第一代计算机。使用真空管，所有的程序都是用机器码编写，使用穿孔卡片。典型的机器就是：UNIVAC。 1943年1月: Mark I，自动顺序控制计算机在美国研制成功。整个机器有51英尺长，重5吨，75万个零部件，使用了3304个继电器，60个开关作为机械只读存储器。程序存储在纸带上，数据可以来自纸带或卡片阅读器。被用来为美国海军计算弹道火力表。 1943年4月: Max Newman、Wynn-Williams和他们的研究小组研制成功”Heath Robinson”，这是一台密码破译机，严格说不是一台计算机。但是其使用了一些逻辑部件和真空管，其光学装置每秒钟能读入2000个字符。同样具有划时代的意义。 1943年9月 : Williams和Stibitz完成了”Relay Interpolator”，后来命名为”Model II Relay Calculator”。这是一台可编程计算机。同样使用纸带输入程序和数据。其运行更可靠，每个数用7个继电器表示，可进行浮点运算。 1943年12月: 最早的可编程计算机在英国推出，包括2400个真空管，目的是为了破译德国的密码，每秒能翻译大约5000个字符，但使用完后不久就遭到了毁坏。据说是因为在翻译俄语的时候出现了错误。 1945 年：宾夕法尼亚大学的两位教授 John Mauchly 和 J. Presper Eckert 设计并制造了电子数值积分器和计算器 (ENIAC)。根据 Edwin D. Reilly 的著作《计算机科学和信息技术的里程碑》（格林伍德出版社，2003 年），该机器是第一台“自动、通用、电子、十进制、数字计算机”。 1946 年： Mauchly 和 Presper 离开宾夕法尼亚大学，并获得人口普查局的资助，建造了 UNIVAC，这是第一台用于商业和政府应用的商用计算机。 5. 晶体管计算机1947 年：贝尔实验室的 William B. Shockley、 John Bardeen和Walter H. Brattain 发明了晶体管。他们发现了如何用固体材料制造电气开关，而不需要真空。 1949 年：剑桥大学的一个团队开发了电子延迟存储自动计算器 (EDSAC)，据奥雷根介绍，这是“第一台实用的存储程序计算机”。“EDSAC 于 1949 年 5 月运行了第一个程序，当时它计算了一个平方表和一个素数列表，”奥雷根写道。1949 年 11 月，科学与工业研究委员会 (CSIR)（现称为 CSIRO）的科学家建造了澳大利亚第一台数字计算机，称为科学与工业研究委员会自动计算机 (CSIRAC)。据 O’Regan 介绍，CSIRAC 是世界上第一台可以播放音乐的数字计算机。 1950: 软磁盘由东京帝国大学的Yoshiro Nakamats发明。其销售权由IBM公司获得。开创存储时代新纪元。 1950: 英国数学家和计算机先驱Alan Turing说：计算机将会具有人的智慧，如果一个人和一台机器对话，对于提出和回答的问题，这个人不能区别到底对话的是机器还是人，那么这台机器就具有了人的智能。 1951: Grace Murray Hopper完成了高级语言编译器。 1951: Whirlwind：美国空军的第一个计算机控制实时防御系统研制完成。 1951: UNIVAC-1：第一台商用计算机系统。设计者：J. Presper Eckert 和John Mauchly。被美国人口普查部门用于人口普查，标志着计算机的应用进入了一个新的、商业应用的时代。 1952: EDVAC (Electronic Discrete Variable Computer)：由Von Neumann领导设计并完成。取名：电子离散变量计算机。 1953 年： Grace Hopper开发了第一种计算机语言，最终被称为 COBOL，根据美国国家历史博物馆的说法，它代表 COmmon、面向业务的语言。霍珀后来在她死后获得的总统自由勋章表彰中被称为“软件第一夫人”。IBM 首席执行官 Thomas Johnson Watson Sr. 的儿子 Thomas Johnson Watson Jr. 构思了 IBM 701 EDPM，以帮助联合国在战争期间密切关注朝鲜情况。 1953: 此时世界上大约有100台计算机在运转。 1953: 磁芯存储器被开发出来。 1954 年： John Backus 和他在 IBM 的程序员团队发表了一篇论文，描述了他们新创建的 FORTRAN 编程语言（据麻省理工学院称，FORTRAN 是 FORmula TRANslation 的缩写）是一种适合科学研究使用的计算机高级语言。 1956: 第一次有关人工智能的会议在Dartmouth 学院召开。 1957: IBM开发成功第一台点阵打印机。 1957: FORTRAN 高级语言开发成功。 6. 集成电路计算机尽管晶体管的采用大大缩小了计算机的体积、降低了其价格，减少了故障。但离人们的要求仍差很远，而且各行业对计算机也产生了较大的需求，生产性能更强、更轻便、更便宜的机器成了当务之急，而集成电路的发明正如“及时雨”，当春乃发生。其高度的集成性，不仅仅使体积得以减小，更使速度加快，故障减少。人们开始制造革命性的微处理器。计算机技术经过多年的积累，终于驶上了用硅铺就的高速公路。 1958年9月12日: 杰克·基尔比 (Jack Kilby) 和罗伯特·诺伊斯 (Robert Noyce 后来INTEL公司的创始人） 发明了集成电路，即计算机芯片。不久又推出了微处理器。但因为在发明微处理器时借鉴了日本公司的技术，所以日本对其专利不承认，因为日本没有得到应有的利益。过了30年，日本才承认，这样日本公司可以从中得到一部分利润了。但到2001年，这个专利也就失效了。 1959: Grace Murray Hopper开始开发COBOL (COmmon Business-Orientated Language)语言，完成于1961年。 1960: ALGOL：第一个结构化程序设计语言推出。 1961: IBM的Kennth Iverson推出APL编程语言。 1963: PDP-8：DEC公司推出第一台小型计算机。 1964: IBM发布PL/1编程语言。 1964: 发布IBM 360首套系列兼容机。 1964: DEC发布PDB-8 小型计算机。 1965: 摩尔定律发表，处理器的性能每年提高一倍。后来其内容又发生了改变。 1965: Lofti Zadeh创立模糊逻辑，用来处理近似值问题。 1965: Thomas E. Kurtz和John Kemeny完成BASIC(Beginners All Purpose Symbolic Instruction Code)语言的开发。特别适合计算机教育和初学者使用，得到了广泛的推广。 1965: Douglas Englebart 提出鼠标器的设想，但没有进一步的研究。直到1983年被苹果电脑公司大量采用。 1965: 第一台超级计算机CD6600开发成功。 1967: Niklaus Wirth开始开发PASCAL语言，1971年完成。 1967 年 4 月: 在美国密歇根州安娜堡召开的 ARPA IPTO PI 会议上，拉里·罗伯茨组织了有关 ARPANET 设计方案的讨论。不久后就发表第一篇关于 ARPANET 设计的论文《Multiple Computer Networks and Intercomputer Communication》（多计算机网络和计算机之间的通信）。 1968: Robert Noyce和他的几个朋友创办了INTEL公司。 1968: Seymour Paper和他的研究小组在MIT开发了LOGO语言。 1968 年：道格拉斯·恩格尔巴特 (Douglas Engelbart) 在旧金山秋季联合计算机会议上展示了现代计算机的原型。据道格·恩格尔巴特研究所称，他的演讲名为“增强人类智力研究中心”，包括现场演示他的计算机，包括鼠标和图形用户界面（GUI ）。这标志着计算机从学术专用机器发展成为普通大众更容易使用的技术。 1968年: 拉里·罗伯茨在研究报告《资源共享的计算机网络》中，着力阐述了让 ARPA 的计算机互相连接，从而使大家分享彼此的研究成果。同年夏天，美国国防部正式启动了 ARPANET 项目的商业招标。 1969 年：肯·汤普森 (Ken Thompson)、丹尼斯·里奇 (Dennis Ritchie) 和贝尔实验室的其他开发人员开发了 UNIX，根据贝尔实验室的说法，该操作系统使“不同计算系统的大规模网络以及互联网变得实用”。 UNIX 继续使用 C 编程语言开发操作系统，并对其进行了优化。 1969 年 1 月，来自马萨诸塞州坎布里奇市的Bolt Beranek and Newman Inc公司赢得了价值 100 万美元的ARPANET项目合同。同年，ARPA 建立了 IMP 的研发测试中心，IMP 的基础硬件是配有 12K Memory 的 Honeywell DDP-516 小型计算机。 1969年 12 月: 第一个 ARPANET 就诞生了，将加利福尼亚州大学洛杉矶分校、加州大学圣巴巴拉分校、斯坦福大学、犹他州大学四所大学的 4 台大型计算机进行了互联。人类社会开始进入 “网络时代”。 1969 年4月7日: 第一个网络协议标准RFC推出。 1970: 第一块RAM芯片由INTEL推出，容量1K。 1970 年：新成立的英特尔推出了英特尔 1103，首款动态存取存储器 (DRAM) 芯片。 1970: Forth编程语言开发完成。 1970: Internet的雏形ARPAnet (Advanced Research Projects Agency network) 基本完成。开始向非军用部门开放，许多大学和商业部门开始接入。 1971 年： Alan Shugart 领导的 IBM 工程师团队发明了“软盘”，使数据能够在不同计算机之间共享。 1971年11月15日: Marcian E. Hoff在INTEL公司开发成功第一块微处理器4004，含2300个晶体管，是个4位系统，时钟频率108KHz ，每秒执行6万条指令。 1971: PASCAL语言开发完成。 7. 大规模集成电路计算机1972年以后的计算机习惯上被称为第四代计算机。基于大规模集成电路，及后来的超大规模集成电路。计算机功能更强，体积更小。人们开始怀疑计算机能否继续缩小，特别是发热量问题能否解决？人们开始探讨第五代计算机的开发。 1972: C语言的开发完成。其主要设计者是UNIX系统的开发者之一 Dennis Ritche。这是一个非常强大的语言，开发系统软件，特别受人喜爱。 1972: Hewlett-Packard发明了第一个手持计算器。 1972年4月1日: INTEL推出8008微处理器。 1972: ARPANET开始走向世界，INTERNET革命拉开序幕。 1972 年：据美国计算机博物馆称，德裔美国工程师 Ralph Baer 于 1972 年 9 月发布了 Magnavox Odyssey，这是世界上第一台家用游戏机。几个月后，企业家诺兰·布什内尔 (Nolan Bushnell) 和工程师阿尔·奥尔康 (Al Alcorn) 与 Atari 一起发布了 Pong，这是世界上第一个商业上成功的视频游戏。 1973 年：施乐研究人员罗伯特·梅特卡夫 (Robert Metcalfe) 开发了用于连接多台计算机和其他硬件的以太网。 1974: 第一个具有并行计算机体系结构的CLIP-4推出。 1974年4月1日: INTEL发布其8位的微处理器芯片8080。 1974年12月: MITS发布Altair 8800，第一台商用个人计算机，价值397美元，内存有256个字节。 1975: Bill Gates和Paul Allen完成了第一个在MITS 的Altair计算机上运行的BASIC程序。 1975: IBM公司介绍了他的激光打印机技术。1988年向市场推出其彩色激光打印机。 1975: Bill Gates和Paul Allen创办MicorSoft公司。现在成为最大、最成功的软件公司。三年后就收入50万美元，增加到15个人。1992年达28亿美元，1万名雇员。其最大的突破性发展是在1981年为IBM的PC机开发操作系统，从此后便开始了对计算机业的巨大影响。 1975: IBM 5100发布。 1975 年：《大众电子》一月号杂志封面强调 Altair 8080 是“世界上第一款可与商业型号相媲美的小型计算机套件”。看到该杂志后，两位“计算机极客”保罗·艾伦和比尔·盖茨提出使用新的 BASIC 语言为 Altair 编写软件。4 月 4 日，在第一次努力取得成功后，这两个儿时好友组建了自己的软件公司——微软。 1976: Stephen Wozinak和Stephen Jobs创办苹果计算机公司。并推出其Apple I计算机 1976 年： 愚人节，史蒂夫·乔布斯和史蒂夫·沃兹尼亚克共同创立了苹果电脑。据麻省理工学院称，他们推出了 Apple I，这是第一台带有单电路板和 ROM（只读存储器）的计算机。 1976: Zilog推出Z80处理器。8位微处理器。CP/M就是面向其开发的操作系统。许多著名的软件如：Wordstar 和dBase II基于此款处理器。 1976: 6502, 8 位微处理器发布，专为Apple II计算机使用。 1976: Cray 1，第一台商用超级计算机。集成了20万个晶体管，每秒进行1.5亿次浮点运算。 1977年5月: Apple II型计算机发布。 1977 年： Commodore 个人电子交易器 (PET) 投放家用计算机市场，采用 MOS 技术 8 位 6502 微处理器，可控制屏幕、键盘和磁带播放器。奥雷根表示，PET 在教育市场尤其成功。 1977 年： Radio Shack 开始首次生产 3,000 台 TRS-80 Model 1 计算机（被轻蔑地称为“Trash 80”），据美国国家历史博物馆称，售价为 599 美元。根据《 TRS-80 爱好者如何帮助引发 PC 革命》（The Seeker Books，2007 年）一书的记载，一年之内，该公司收到了 250,000 份计算机订单。 1977 年：第一届西海岸计算机博览会在旧金山举行。乔布斯和沃兹尼亚克在博览会上展示了 Apple II 计算机，其中包括彩色图形并具有用于存储的录音带驱动器。 1978 年：推出第一个计算机化电子表格程序 VisiCalc。 1978: Commodore Pet发布：有8K RAM，盒式磁带机，9英寸显示器。 1978年6月8日: INTEL发布其16位微处理器8086。但因其非常昂贵，又推出8位的8088满足市场对低价处理器的需要，并被IBM的第一代PC机所采用。其可用的时钟频率为4.77、8、10MHz。大约有300条指令，集成了29000根晶体管。 1979 年：由软件工程师 Seymour Rubenstein 创立的 MicroPro International 发布了世界上第一个商业上成功的文字处理器 WordStar。根据 Matthew G. Kirschenbaum 的著作《 Track Changes: A Literary History of Word Handling》（哈佛大学出版社，2016 年），WordStar 由 Rob Barnaby 编写，包含 137,000 行代码。 1979: 街机游戏”太空入侵者”发布，引起轰动。很快便使得类似的游戏机大规模流行起来，其收入超过了美国电影业。 1979: Jean Ichbiah 开发完成Ada计算机语言。 1979年6月1日: INTEL发布了8位的8088微处理器，纯粹为了迎合低价电脑的需要。 1979: Commodore PET发布了采用1MHz的6502处理器，单色显示器、8K内存的计算机，并且可以根据需要购买更多的内存扩充。 1979: 发明了低密盘。 1979: Motorola公司发布68000微处理器。主要供应Apple公司的Macintosh，后继产品68020用在Macintosh II机型上。 1979: IBM公司眼看着个人计算机市场被苹果等电脑公司占有，决定也开发自己的个人计算机，为了尽快的推出自己的产品，他们大量的工作是与第三方合作，其中微软公司就承担了其操作系统的开发工作。很快他们便在1981年8月12日推出了IBM-PC。但同时也为微软后来的崛起，施足了肥料。 1980:“只要有1兆内存就足够DOS尽情表演了”。微软公司开发DOS初期时说。今天来听这句话有何感想呢？ 1981: Xerox开始致力于图形用户界面、图标、菜单和定位设备（如鼠标）的研制。结果研究成果为苹果所借鉴。而苹果电脑公司后来又指控微软剽窃了他们的设计，开发了WINDOWS系列软件。 1981: INTEL发布的80186/80188芯片，很少被人使用，因为其寄存器等与其他不兼容。但其采用了直接存储器访问技术和时间片分时技术。 1981年8月12日: 据 IBM 称，IBM 的第一台个人计算机“Acorn”以 1,565 美元的价格投放市场。Acorn 使用 Windows 的 MS-DOS 操作系统。可选功能包括显示器、打印机、两个软盘驱动器、额外内存、游戏适配器等。 1981年8月12日: MDA (Mono Display Adapter, text only) 能够显示文本的单色显示器随IBM-PC机发布。 1981年8月12日: MS-DOS 1.0，PC-DOS1.0发布。Microsoft是受IBM委托开发DOS操作系统，他们从Tim Paterson那里购买了一个叫86-DOS的程序并加以改进。但IBM测试时竟发现有300个BUG。于是他们又继续改进，最初的DOS1.0有4000行汇编程序。从IBM卖出去的叫PC-DOS。从Microsoft卖出去的叫MS-DOS。Micorsoft与IBM的合作一直到1991年的DOS5.0为止。最初的DOS1.0非常的简陋，每张盘上只一个根目录，不支持子目录。直到1983年3月的2.0版才有所改观。MS-DOS在1995年以前一直是与IBM-PC兼容的操作系统，WINDOWS95推出并迅速占领市场之后，其最后一个版本命名为DOS7.0。现在微软的操作系统已经在世界大多数计算机上运行了。 1982: 基于TCP/IP协议的INTERNET初具规模。 1982: 基于6502微处理器的计算机大受欢迎，特别是在学校大量普及。 1982 年1月: Commodore 64计算机发布，价格：595美元。 1982 年2月: 80286发布。时钟频率提高到20MHz，并增加了保护模式，可访问16M内存。支持1GB以上的虚拟内存。每秒执行270万条指令，集成了134000个晶体管。 1982: Compaq公司发布了其IBM-PC兼容机。 1982: MIDI（Musical Instrument Digital Interface）标准制定。允许计算机连接标准的类似键盘数字乐器。 1982: Sony和Phillips公布了压缩音频的红皮书。很快得到欧美的认同。 1982年3月: MS-DOS 1.25PC-DOS 1.1 1982年4月: Sinclair ZX Spectrum发布：基于Z80芯片，时钟频率3.5MHz。能显示8种颜色。 1982年5月: IBM推出双面320K的软盘驱动器。 1983 年1月: IBM PC在欧洲展示。 1983: Borland公司成立。 1983春季: IBM XT机发布，增加了10兆的硬盘，128K RAM，一个软驱、单色显示器、一台打印机、可以增加一个8087数字协处理器。价格5000美元。 1983年3月: MS-DOS 2.0、PC-DOS 2.0增加了类似UNIX分层目录的管理形式 1983年10月: MS-DOS 2.25，包括支持其他字符设置，开辟东方市场。 1983 年：根据美国国家历史博物馆 ( NMAH ) 的说法，Apple Lisa 代表“本地集成软件架构”，也是史蒂夫·乔布斯女儿的名字，是第一台配备 GUI 的个人电脑。该机器还包括一个下拉菜单和图标。同样在今年，Gavilan SC 发布，它是第一款采用翻盖设计的便携式电脑，也是第一款作为“笔记本电脑”出售的电脑。 1984年1月： Apple Macintosh 在超级碗广告中向全世界发布, 基于Motorola 68000微处理器。可以寻址16M。据 NMAH 称，Macintosh 的零售价为 2,500 美元。 1984: DNS (Domain Name Server) 域名服务器发布，互连网上有1000多台主机运行。 1984: Hewlett-Packard发布了优异的激光打印机，HP也在喷墨打印机上保持领先技术。 1984年8月: MS-DOS 3.0、PC-DOS 3.0、IBM AT发布，采用ISA标准，支持大硬盘和1.2M高密软驱。 1984年9月: Apple 发布了有512Kb内存的Macintosh，但其他方面没有什么提高。 1984底: Compaq开始开发IDE接口，可以更快的速度传输数据，并被许多同行采纳，后来更进一步的EIDE推出，可以支持到528MB的驱动器。数据传输也更快。 1985: Philips和Sony合作推出CD-ROM驱动器。 1985: EGA标准推出。 1985年3月: MS-DOS 3.1、PC-DOS 3.1。这是第一个提供部分网络功能支持DOS版本。 1985年10月17日: 80386 DX推出。时钟频率到达33MHz，可寻址1GB内存。比286更多的指令。每秒6百万条指令，集成275000个晶体管。 1985 年：据《卫报》报道，作为对 Apple Lisa GUI 的回应，微软于 1985 年 11 月发布了 Windows 。与此同时，Commodore 发布了 Amiga 1000。 1985年11月: Microsoft Windows发布。但在其3.0版本之全面没有得到广泛的应用。需要DOS的支持，类似苹果机的操作界面，以致被苹果控告。诉讼到1997年8月才终止。 1985年12月: MS-DOS 3.2、PC-DOS 3.2。这是第一个支持3.5英寸磁盘的系统。但也只是支持到720KB。到3.3版本时方可支持1.44兆。 1986年1月: Apple 发布较高性能的Macintosh。有四兆内存，和SCSI适配器。 1986年9月: Amstrad Announced发布便宜且功能强大的计算机Amstrad PC 1512。具有CGA图形适配器、512KB内存、8086处理器20兆硬盘驱动器。采用了鼠标器和图形用户界面，面向家庭设计。 1987: Connection Machine超级计算机发布。采用并行处理，每秒钟2亿次运算。 1987: Microsoft Windows 2.0发布，比第一版要成功，但并没有多大提高。 1987: 英国数学家Michael F. Barnsley找到图形压缩的方法。 1987: Macintosh II发布，基于Motorola 68020处理器。时钟16MHz，每秒260万条指令。有一个SCSI适配器和一个彩色适配器。 1987年4月2日: IBM推出PS/2系统。最初基于8086处理器和老的XT总线。后来过渡到80386，开始使用3.5英寸1.44MB软盘驱动器。引进了微通道技术，这一系列机型取得了巨大成功。出货量达到200万台。 1987: IBM发布VGA技术。 1987: IBM发布自己设计的微处理器8514/A。 1987年4月: MS-DOS 3.3、PC-DOS 3.3。随IBM PS/2一起发布，支持1.44MB驱动器和硬盘分区。可为硬盘分出多个逻辑驱动器。 1987年4月: Microsoft和IBM发布S/2Warp操作系统。但并未取得多大成功。 1987年8月: AD-LIB声卡发布。一个加拿大公司的产品。 1987年10月: Compaq DOS (CPQ-DOS) v3.31发布。支持的硬盘分区大于32Mb。 1988: 光计算机投入开发，用光子代替电子，可以提高计算机的处理速度。 1988: XMS标准建立。 1988: EISA标准建立。 1988 6月6日: 80386 SX为了迎合低价电脑的需求而发布。 1988年7月到8月: PC-DOS 4.0、MS-DOS 4.0。支持EMS内存。但因为存在BUG，后来又陆续推出4.01a。 1988年9月: IBM PS/20 286发布，基于80286处理器，没有使用其微通道总线。但其他机器继续使用这一总线。 1988年10月: Macintosh Iix发布。基于Motorola 68030处理器。仍使用16 MHz主频、每秒390万条指令，支持128M RAM。 1988年11月: MS-DOS 4.01、PC-DOS 4.01发布。 1989 年：欧洲核研究组织 ( CERN ) 的英国研究员蒂姆·伯纳斯·李 (Tim Berners-Lee) 提交了他关于万维网的提案。他的论文详细介绍了他对超文本标记语言 (HTML)（Web 的构建块）的想法。 1989: Phillips和Sony发布CD-I标准。 1989年1月: Macintosh SE/30 发布。基于新型68030处理器。 1989年3月: E-IDE标准确立，可以支持超过528MB的硬盘容量。可达到 33.3 MB/s 的传输速度。并被许多CD-ROM所采用。 1989年4月10日: 80486 DX发布，集成120万个晶体管。其后继型号时钟频率达到100MHz。 1989年11月: Sound Blaster Card（声卡）发布。 1990: SVGA标准确立。 1990年3月 : Macintosh Iifx发布，基于68030CPU，主频40MHz，使用了更快的SCSI接口。 1990年5月22日: 微软发布Windows 3.0。兼容MS-DOS模式。 1990年10月: Macintosh Classic发布，有支持到256色的显示适配器。 1990年11月: 第一代MPC (多媒体个人电脑标准)发布。处理器至少80286/12MHz，后来增加到80386SX/16 MHz ，及一个光驱，至少150 KB/sec的传输率。 1990 年 6 月 1 日，ARPANET 正式退出历史舞台。 1990 年 9 月，由 Merit、IBM 和 MCI 公司联合建立了一个非盈利的组织 ANS（Advanced Network&amp;Science Inc.，先进网络科学公司）。ANS 的目的是建立一个全美范围的 T3 级主干网，能以 45Mbps 的速率传送数据。1991 年底，NSFnet 主干网与 ANS T3 级主干网进行互联互通，并宣布开始对全社会进行商业运营。后来大家都知道，网络连接数量开始指数级增长。Internet 真正变成了全球互联网，开始走进人们的生活。 1990 年 12 月 25 日，Tim Berners-Lee 和罗伯特·卡里奥一起实现了基于 HTTP 协议的 Web Server，并通过 Internet 成功完成了 HTTP Client 和 Web Server 的第一次通信。 1991: 发布ISA标准。 1991年5月: Sound Blaster Pro发布。 1991年6月: MS-DOS 5.0、PC-DOS 5.0。为了促进OS/2的发展，Bill Gates说：DOS5.0是DOS终结者,今后将不再花精力于此。该版本突破了640KB的基本内存限制。这个版本也标志着微软与IBM在DOS上的合作的终结。 1991 年 8 月 6 日，Tim Berners-Lee 基于 HTTP 和 HTML 设计并开发了第一个网页浏览器，并发布了世界上第一个 Web 网站。它被称为 The First Website（第一个网站）或 InfoMesh（信息管理系统项目），运行在 CERN 的服务器上，旨在帮助研究人员共享信息和文献。基于 HTML，该网站可以提供一些链接，让用户通过单击超链接跳转到其他页面或文档，这种超链接的设计 Web 技术最重要的创新之一。同年，Tim Berners-Lee 正式提出了 WWW（World Wide Web，万维网）的概念。 1992: Windows NT发布，可寻址2G RAM。 1992年4月: Windows 3.1发布。 1992年6月: Sound Blaster 16 ASP发布。 1992年: 几个 Internet 组织合并成立统一的 ISOC（因特网协会），此时的 Internet 已经注册了超过 100 万台主机，并持续指数级疯狂增长。 1993: INTERNET开始商业化运行。 1993: 经典游戏Doom发布。 1993: Novell并购Digital Research, DR-DOS成为Novell DOS。 1993年3月22: Pentium发布。集成了300多万个晶体管。初期工作在60-66MHz。每秒钟执行1亿条指令。奔腾微处理器推动了 PC 上图形和音乐的使用。 1993年5月: MPC标准2发布。CD-ROM传输率要求300KB/sec。在320＊240的窗口中每秒播放15帧图像。 1993年12月: MS-DOS6.0发布，包括一个硬盘压缩程DoubleSpace,，但一家小公司声称，微软剽窃了其部分技术。于是在后来的DOS6.2中，微软将其改名为：DriveSpace。后来WIN95中的DOS成为DOS7.0，WIN95OSR2中称为DOS7.10. 1994年3月7日: Intel 发布90-100 MHz Pentium处理器。 1994年9月: PC-DOS 6.3发布。 1994 年 10 月 1 日: Tim Berners-Lee 创建了非营利性的 W3C（World Wide Web Consortium，万维网联盟），邀集 Microsoft、 Netscape、 Sun、Apple、IBM 等共 155 家互联网上的著名公司。由 Tim Berners-Lee 担任 W3C 的主席，致力推动 WWW 协议的标准化，并进一步推动 Web 技术的发展。 1994年10月10日: Intel 发布75 MHz Pentium处理器。 1994: Doom II 发布。开辟了PC机游戏广阔市场。 1994: Netscape 1.0 浏览器发布。 1994: Comm&amp;Conquer（命令与征服）发布。 1994 年，举办互联网大会。 1995年3月27日: Intel发布120 Mhz的Pentium处理器。 1995年6月1日: Intel发布133 Mhz的Pentium处理器。 1995年8月23日: Windows’95发布。大大不同于其以前的版本。完全脱离MS-DOS，但照顾用户习惯还保留了DOS形式。纯32位的多任务操作系统。该版本取得了巨大的成功。 1995年11月1日: Pentium Pro发布。主频可达200 MHz，每秒钟完成4.4亿条指令，集成了550万个晶体管。 1995 年，由 Brian Behlendorf 发布了基于 HTTP/0.9 的 Apache HTTP Server 开源项目。同年，网景和微软开启浏览器大战，但好在 Tim Berners-Lee 担心的 “撕裂“ 并未发生，HTTP 协议已经逐成气候。 1995年12月: Netscape发布其.JavaScript。 1996: Quake、Civilization 2、Command&amp; Conquer - Red Alert等一系列的著名游戏发布。 1996年1月: Netscape Navigator 2.0发布，第一个支持JavaScript的浏览器。 1996年1月4日: Intel发布150-166MHz的Pentium处理器，集成了330万个晶体管。 1996: Windows ‘95 OSR2发布，修复了部分BUG，扩充了部分功能。 1996 年： Sergey Brin 和 Larry Page 在斯坦福大学开发了 Google 搜索引擎。 1997: Gr和 Theft Auto、Quake 2、Blade Runner等著名游戏发布，3D图形加速卡大行其道。 1997年1月8日: Intel发布Pentium MMX。对游戏和多媒体功能进行了增强。 1997年4月: IBM的深蓝（Deep Blue）计算机，战胜人类国际象棋世界冠军卡斯帕罗夫。 1997年5月7日: Intel发布Pentium II，增加了更多的指令和更多CACHE。 1997年6月2日: Intel 发布233 MHz Pentium MMX. 1997年16日: Apple遇到严重的财务危机，微软伸出援助之手，注资1.5亿美元。条件是Apple撤消其控诉：微软模仿其视窗界面的起诉，并指出Apple也是模仿了XEROX的设计。这项投资结束了一场正在进行的法庭案件. 1998年2月: Intel发布333 MHz Pentium II处理器。采用0.25微米技术，提高速度，减少发热量。 1998年6月25日: Microsoft发布Windows’98，一些人企图肢解微软，微软回击说这会伤害美国的国家利益。 1998 年，美国成立非营利性民间组织 ICANN（Internet Corporation for Assigned Names and Numbers，互联网名称与数字地址分配机构），它由商务部的国家电信和信息管理局监督，负责全球互联网域名系统、根服务器系统、IP 地址资源的协调、管理和分配。由 ICANN 的下属机构 IANA（Internet Assigned Numbers Authority，互联网号码分配机构）负责管理全球互联网域名的根服务器。 1999 年，HTTP/1.1 发布并成为标准，写入 RFC。至此，HTTP 协议已然成为了 Web 世界的奠基石。 1999年1月25日: Linux Kernel 2.2.0发布。人们对其寄予厚望。 1999 年： Wi-Fi（“无线保真度”的缩写）问世，据《连线》报道，最初覆盖距离可达 300 英尺（91 米）。 1999年2月22日: AMD公司发布K6-III 400MHz。有测试说其性能超过Intel P-III 。集成2300万个晶体管、socket 7结构。 2000年: Apache 基金会的第一任主席 Roy Thomas Fielding 在博士论文《Architectural Styles and the Design of Network-based Software Architectures（架构风格和基于网络的软件架构设计）》中提出了 REST（Representational State Transfer，表现层状态转移）的理念。 2000年: 计算机继续工作，没有像一些人担心的千年虫可能会发生的那样。 2001 年： Apple 发布 Mac OS X（后来更名为 OS X，然后简称为 macOS），作为其标准 Mac 操作系统的继承者。据 TechRadar 报道，OS X 有 16 个不同的版本，每个版本的标题都是“10”，前 9 个版本以大型猫科动物的名字命名，第一个版本的代号为“Cheetah” 2001年10月25日: Windows XP 家庭版和专业版发布. 2003年: Android 由 Andy Rubin 于 2003 年 10 月创立。 2003 年： AMD 的 Athlon 64 向客户发布，这是首款用于个人计算机的 64 位处理器。 2004 年： Mozilla 公司推出 Mozilla Firefox 1.0。Web 浏览器是对 Microsoft 旗下 Internet Explorer 的首要挑战之一。根据网页设计博物馆的数据，在最初的五年里，Firefox 的用户下载量就超过了 10 亿次。 2004 年: Ubuntu于2004年10月20日发布。 2005年：谷歌收购Android，一种基于Linux的手机操作系统 2005 年 8 月，NSF（美国国家科学基金会）投资了 GENI（Global Environment for Networking Innovations，全球网络创新研究环境）和 FIND（Future Internet Network Design，未来的互联网设计）两个项目。 2005年：苹果公司于 2005 年 6 月 6 日宣布计划将其机器改用英特尔处理器。 2006 年： Apple MacBook Pro 上市。Pro 是该公司首款基于英特尔的双核移动计算机。 2007 年 3 月，NSF 通过 GENI 和 FIND 项目资助几项大学研究，斯坦福大学的一个跨学科研究项目 Clean Slate Program（意为：白手起家，或从头再来）就是其中之一。Clean Slate 项目的最终目的是要重新发明 Internet，旨在改变设计已略显不合时宜，且难以革命性进化发展的传统网络基础架构。该课题除了得到 NSF 的支持外，后来还逐渐得到了 Cisco、德国电信、NTT DoCoMo、NEC 和 Xilinx 等商业伙伴的支持。 2007 年: Apple 于 2007 年 1 月 9 日发布了搭载 iOS 的 iPhone，随后于 2007 年 1 月 29 日在 Macworld 大会暨博览会上向公众展示。 2008 年，Nick McKeown 教授等人在 ACM SIGCOMM 发表了题为《OpenFlow: Enabling Innovation in Campus Networks》（OpenFlow：校园网的创新使能）的论文，首次详细地介绍了 OpenFlow 和 OpenFlow Switch 的概念。 2008年9月23日: T-Mobile推出了G1（HTC Dream），这是第一款使用谷歌移动设备新操作系统Android 1.0版本的智能手机。 2008年: Apple 推出了 App Store，这是一个针对 iOS 设备的软件市场。 2008 年10 月11日: Google 推出了 Android Market，这是一个针对 Android 设备的在线软件市场。 后来它与另外两个 Google 市场（Google Music 和 Google eBookstore）合并成为 Google Play。 2008年12月11日:Google发布了Chrome浏览器的第一个公开发行版。 2009年1月3日: 一个化名为中本聪 (Satoshi Nakamoto) 的人推出了比特币。 2009 年：微软于 7 月 22 日推出 Windows 7。据 TechRadar 报道，新操作系统具有将应用程序固定到任务栏、通过摇动另一个窗口分散窗口、易于访问的跳转列表、更轻松的图块预览等功能。 2009 年，基于 OpenFlow 为网络带来的可编程特性，Nick McKeown 教授团队与加州大学伯克利分校的 Scott Shenker 教授进一步提出了 SDN（Software Defined Network，软件定义网络）的概念。 2010 年： Apple 旗舰手持平板电脑 iPad 发布。 2010 年，Google 开始将数据中心与数据中心之间的网路连线（G-scale），转换成 SDN 架构。 2011 年，在 Nick McKeown 教授等研究学者的推动下，成立了开放网络基金会（ONF，Open Networking Foundation）。 2011 年： Google 发布了 Chromebook，它运行在 Google Chrome 操作系统上。 2014 年，ICANN决定将监管权移交给一个由多方利益相关者管理的独立机构。 2015 年：苹果发布 Apple Watch。微软发布了 Windows 10。 2016 年：第一台可重新编程的量子计算机诞生。“到目前为止，还没有任何量子计算平台能够将新算法编程到他们的系统中。它们通常都是针对攻击特定算法而定制的，”该研究的主要作者、量子物理学家和科学家 Shantanu Debnath 说。马里兰大学帕克分校的光学工程师。 2016年10月1日: ICANN 表示，正式将互联网的控制权移交给一个非盈利的全球互联网多方利益相关者组织。这标志着美国结束对这一互联网核心资源近 20 年的单边垄断，对于每一个网民来说都是一大喜事。 2016年3月12日:谷歌 DeepMind AI（人工智能）AlphaGo 在围棋比赛中第三次击败围棋冠军李世石。 虽然AlphaGo赢得了冠军，但李世石确实赢得了第四局。 2017 年：国防高级研究计划局 (DARPA) 正在开发一项新的“分子信息学”程序，该程序使用分子作为计算机。DARPA 国防科学办公室项目经理 Anne Fischer 在一份声明中表示：“化学提供了一系列丰富的特性，我们可以利用它们来进行快速、可扩展的信息存储和处理。” “存在数百万个分子，每个分子都有独特的三维原子结构以及形状、大小甚至颜色等变量。这种丰富性为探索新颖的多值编码和处理方式提供了广阔的设计空间数据超出了当前基于逻辑的数字架构的 0 和 1。” 2019 年 6 月，Intel 收购 Barefoot Networks 公司，并由 Nick McKeown 教授出任 Intel SVP，继续领导网络研发团队（现已退居二线）。在同年的 ONF Connect 2019 演讲中，Nick McKeown 教授第一次定义了 SDN 发展的 3 个阶段： 2010–2020 年：通过 OpenFlow 将控制面和数据面分离，用户可以通过集中的控制端去控制每个交换机的行为； 2015–2025 年：通过 P4 编程语言以及可编程 FPGA 或 ASIC 实现数据面可编程，这样，在包处理流水线加入一个新协议的支持，开发周期从数年降低到数周； 2020–2030 年：展望未来，网卡、交换机以及协议栈均可编程，整个网络成为一个可编程平台。 2019年6月: Apple发布了适用于 iPad 的 iPadOS。 2023年3月15日: OpenAI发布了 GPT-4 8. 后续如果能看到这里, 相信您是对计算机非常感兴趣的人, 我们也算是有缘人. 相信您仍然有意犹未尽的感觉. 正如标题所说的这是一部极简的编年史, 每一项技术背后的原理以及发展脉络都没有展开讲解, 此部分仍然在收集材料阶段. 后续我打算将这个超大的话题拆解为小模块进行讲解, 计划会出芯片发展史, 存储技术发展史, 输入输出设备发展史, 操作系统发展史, 网络技术发展史, 虚拟化技术发展等等模块. 说实在的这本该是大学教授研究的范畴, 但是正如我调研发现的以及您所看到的, 这部分公开的资料并不多, 而且非常零散也不系统. 我想做的是一部开发版权的中文的计算机发展史. 这非常需要时间和精力, 目前是个人兴趣引导用爱发电. 如果能得到您的资金支持, 对于我来说将是莫大的鼓舞. 我所有的博文都发布在https://pengtech.net. 本文原文位于 https://pengtech.net/history/computer_history_brief_timeline.html 文末有打赏功能, 如我认可我的工作以及接下来的计划, 希望能得到您的支持. 另外希望您共同参与多提问题和建议, 你的问题和建议或许会成为研究的方向. 作为回报, 支持金额超过一定数量的, 目前暂定为超过100元及以上将永久的出现在我接下来的三篇计算机发展史文章的Acknowledge章节. 其它金额会有相应的博文表示感谢!","link":"/history/computer_history_brief_timeline.html"},{"title":"使用 JavaScript 开启被禁用的网页选择功能","text":"现在有很多的网站关闭了拷贝功能，下面介绍一种方法，将拷贝功能打开。 禁止拷贝的原来实际上是将是给文本元素添加了disabled属性，将该属性祛除即可。 12345678910111213141516171819202122232425262728293031323334353637javascript: (function () { function allowTextSelection() { window.console &amp;&amp; console.log(&quot;allowTextSelection&quot;); var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; style.innerHTML = &quot;*,p,div{user-select:text !important;-moz-user-select:text !important;-webkit-user-select:text !important;}&quot;; document.head.appendChild(style); var elArray = document.body.getElementsByTagName(&quot;*&quot;); for (var i = 0; i &lt; elArray.length; i++) { var el = elArray[i]; el.onselectstart = el.ondragstart = el.ondrag = el.oncontextmenu = el.onmousedown = el.onmouseup = function () { return true; }; if ( el instanceof HTMLInputElement &amp;&amp; [&quot;text&quot;, &quot;password&quot;, &quot;email&quot;, &quot;number&quot;, &quot;tel&quot;, &quot;url&quot;].indexOf( el.type.toLowerCase() ) &gt; -1 ) { el.removeAttribute(&quot;disabled&quot;); el.onkeydown = el.onkeyup = function () { return true; }; } } } allowTextSelection();})(); 上面的代码将其压缩成一行代码如下，只要打开console(Ctrl+Shift+I), 将下面的代码执行一下就ok了。 123javascript:(function(){function allowTextSelection(){window.console&amp;&amp;console.log('allowTextSelection');var style=document.createElement('style');style.type='text/css';style.innerHTML='*,p,div{user-select:text !important;-moz-user-select:text !important;-webkit-user-select:text !important;}';document.head.appendChild(style);var elArray=document.body.getElementsByTagName('*');for(var i=0;i&lt;elArray.length;i++){var el=elArray[i];el.onselectstart=el.ondragstart=el.ondrag=el.oncontextmenu=el.onmousedown=el.onmouseup=function(){return true};if(el instanceof HTMLInputElement&amp;&amp;['text','password','email','number','tel','url'].indexOf(el.type.toLowerCase())&gt;-1){el.removeAttribute('disabled');el.onkeydown=el.onkeyup=function(){return true};}}}allowTextSelection();})(); 参考文档Enabling blocked text selection using JavaScript","link":"/javascript/js_allow_selection.html"},{"title":"JavaScript之this关键字","text":"1. 背景介绍在开发过程中，常常被javascript中的this搞晕，直到自己静下心来系统的把他梳理清楚，下面是由浅如深的理解this关键字. 2. javascript中的this简介面向对象语言中 this 表示当前对象的一个引用.但在 JavaScript 中 this在编译时不是固定不变的，它会随着运行时环境的改变而改变． 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象 3. 普通方法中的this 首先我们来定义一个普通js方法，在方法中我们打印this以及this相关的属性． 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var a = 9999; function explainThis() { //在函数内部访问全局变量 console.log(a); //output: 9999 console.log(this.a); //output: 9999 console.log(window.a); //output: 9999 console.log(this); //output: window对象 console.log(window.a === this.a); //output: true console.log(window.a === a); //output: true console.log(window === this); //output: true } explainThis(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 说明 在这个例子中我们在函数外部定义了一个变量，我们尝试在函数内部访问这个变量，能访问到该变量及其值，这很好理解，因为很多语言中都有全局变量，此时a相当于一个全局变量． 然后我们通过this关键字来访问a变量, 也能访问到a, 这里就有些疑惑了，这里的this在语义上到底指什么，this翻译为中文为＂这个，这里＂，这个是哪个？ 这里是哪里？而且this在其他编程语言中是指方法所属对象，我们此处还还没有涉及到对象的概念，当前还是是面向过程编程，但是现在居然有this可以用了．什么乱七八糟的，我们知道有这么回事就好了，到后面我们会继续探究这里的this． 紧接着我们通过javascript内置的全局变量window去访问全局变量a, 这个好理解，全局变量嘛，把它挂在window下面或gloabal． 紧接着我们打印一下this看看他到底是什么样的一个结构，一打印发现这里的this是就是window对象．但是这里的this为什么是window从逻辑上仍然不好理解，知其然不知其所以然．既然能使用window去访问全局对象，为何还要有个this, 而且this在此的意义令人费解，而且看不出有何存在的必要．当然设计这门语言的人这样设计了我们只能试图去理解它，至于很多面试题特意去考这个知识点，似乎就有点孔乙己卖弄茴香豆几种写法的嫌疑了，装高深．后面会继续探讨这里的this. 接下来我们来探讨一下这里的window有没有存在的必要．其实在其他语言C, pascal, python中都有全局变量，这些全局变量可以直接通过全局变量的变量名去访问，而不需要通过global, window等内置变量去访问，就访问用户自定义的变量而言window也没有存在的必要．但是考虑到浏览器为我们提供了很多的api, 这些系统自带的变量和api接口，通过window内置变量作为统一入口去访问，还是很有必要的，例如: 1234var version = window.navigator.appVersion;window.addEventListener(&quot;click&quot;, function (e) { //do something }); 4. 对象构造方法中的this 接下来我们, 我们将上面的例子稍微改变一下，这时结果就会发生变化． 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var a = 9999; function explainThis() { console.log(a); // 9999 console.log(this.a); //output: undefined console.log(window.a); // 9999 console.log(this); // object console.log(window.a === this.a); //output: false console.log(this.a); //output: undefined console.log(window.a === a); //output: true console.log(window === this); //output: false } new explainThis(); // 改变就在这里, 使用new关键字去创建一个对象． &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同样的函数，因为调用方式不一样，产生的结果完全不一样，这对于一个喜欢函数编程，崇尚幂等性的人来说这几乎是完全不能接受的语言特性，而且javascript是支持函数式编程的，到了这里完全是不伦不类．当然入乡只能随俗，入了这门语言的门，就只能试图去理解它，虽然很丑陋，还是要去接受，这就叫做无奈． 这里如果按照面向对象的思想似乎变得好理解一些，this就是对象本身．但是其中又耦合了全局变量 window, a 也变得不那么纯粹，也没有包的概念有效的避免重名．回到这门语言诞生的时代，还是可以接受的，那时新生代语言毕竟受c, c++影响较大，全局变量多不做隔离的． 所以这里this就是对象本身，那么再回顾上一节的this为什么会存在并指向了window对象呢? 如果要深究，就得研究javascript的实现了，javascript的this实际上是一个内置对象，而且全局就这么一个this对象，它相当一个指针或者reference，当它执行对象的方法时就会将this指向对象的本身，在上一节中，explainThis相当于全局函数，所以它将它当作全局方法来使用时他是属于全局对象global或windows的方法，此时this指向window. 如果当作对象构造函数时，一旦新对象创建，this就会指向新的对象，所以在本例子它指向了新对象．这可能就是作者当时的思路．但是站在一个面向对象编程爱好者和函数编程爱好者的角度，是很难理解的．作者当时没有使用单独的关键字去区分类和对象的定义，全局方法的定义，这种不成熟的思路越来越成为一种技术债务，后面的es6+也好，typescript也好，coffeescript也好都在慢慢偿还这些债务． 5. 事件方法中的this 如果this只有windows和对象本身两种变化，也就不值得写一篇几百字的博文单独介绍它了，对于一个关键字需要写长篇大论来介绍它．并不是因为它有多高深，恰恰相反，而是说明了它设计得很丑陋．恰恰那些不用介绍一看就明白，一用就对的关键字，方法，函数，类，才是真正优秀的． 下面来看this的第三种变化，事件方法中的this. 为了说明这一点，我设计了一个新的例子． 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = 1; function explainThis() { console.log(this.a); //这里会打印什么呢？ } explainThis.prototype = { a: 2 } x = { a:3, explainThis: explainThis }; explainThis(); //output: 1 new explainThis(); //output: 2 x.explainThis(); //output: 3 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 同样的一行代码console.log(this.a); 没有传任何参数的情况下，它可以有三种不同的输出． 甚至可能由于所属对象的结构不同而报错． 上面的例子很好的说明了this关键所代表的内容，只能在运行时才能确定，即使将this定义在某个对象执行，也不能保证．完全由运行时来决定．this的变动会让设计js类库的人非常头疼，比较好奇是不是很多人IT人的头发是被this消耗光的． 6. 匿名函数中的this7. nodejs中的this8. 参考文档‘this’ in TypeScript","link":"/javascript/js_this_explanation.html"},{"title":"如何在springboot中配置多个数据源","text":"1. 配置数据库详细信息首先，我们将配置多个数据源，在application.properties文件中提供详细信息. 12345678910111213#primary dbspring.primary.jdbcUrl=jdbc:postgresql://localhost:5432/test spring.primary.username=postgresspring.primary.password=testspring.primary.driverClassName=org.postgresql.Driver#secondory dbspring.secondary.jdbcUrl=jdbc:mysql://localhost:3306/testspring.secondary.username=rootspring.secondary.password=testspring.secondary.driverClassName=com.mysql.jdbc.Driver Config.java 分别创建两个数据源, 两个JdbcTemplate. 123456789101112131415161718192021222324@Bean@ConfigurationProperties(prefix = &quot;spring.primary&quot;)public DataSource primaryDatasource() { return DataSourceBuilder.create().build();}@Bean@ConfigurationProperties(prefix = &quot;spring.secondary&quot;)@Primarypublic DataSource secondaryDataSource() { return DataSourceBuilder.create().build();}@Beanpublic JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;primaryDatasource&quot;) DataSource dataSource) { return new JdbcTemplate(dataSource);}@Beanpublic JdbcTemplate secondaryJdbcTemplate(@Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) { return new JdbcTemplate(dataSource);} 2. 使用jdbcTemplate创建了两个数据源以及jdbcTemplate后, 我们就可以在任意的class中使用了. 使用之前先引入相应的jdbcTemplate. 例如 InsertController.java 12345678910111213141516171819@RestControllerpublic class InsertController { @Autowired @Qualifier(&quot;primaryJdbcTemplate&quot;) JdbcTemplate posgreJdbc; @Autowired @Qualifier(&quot;secondaryJdbcTemplate&quot;) JdbcTemplate mysqlJdbc; @RequestMapping(&quot;/insert&quot;) public String insert(){ posgreJdbc.execute(&quot;insert into test_user(id, name,email)values(1, 'javatpoint','java@javatpoint.com')&quot;); return&quot;data inserted Successfully&quot;; } } 3. 参考文档","link":"/java/configure_multiple_ds_in_springboot.html"},{"title":"如何手动创建一个springBoot项目","text":"1. 介绍在本文中，您将学习如何创建一个简单的Spring Boot应用程序，以及您需要哪些依赖项和技术需要了解。此外，我们将更深入地了解基本原理。我将解释一些最关键的工作机制，如果你想成为一名专业开发人员，你需要了解这些机制。 2. 创建一个SpringBoot项目2.1. 先决条件要创建新的Spring Boot应用程序，我们需要以下开发环境： Java 1.8或更高版本 IDE: Spring STS, Intellij Idea或者vscode 包管理工具: Maven 3.2+ 或者gradle 4+ 2.2. 初始化项目初始化Spring Boot项目, 可以使用web版的Initializer创建, 也可以手动创建. 我们首先使用web ininitializer创建, 然后在此基础上讲解手动创建Spring Boot工程的一些要点. 2.2.1. 使用Spring boot initializer初始化项目使用Spring boot initializer初始化项目, 请执行以下操作： 导航到https://start.spring.io.此服务将获取应用程序所需的所有依赖项，并为您完成大部分设置。 选择Gradle或Maven以及您要使用的语言。本指南假设您选择了Java。 单击Dependencies并选择SpringWeb。 单击“生成”。 下载生成的ZIP文件，该文件是根据您的选择配置的web应用程序的存档。 123456789101112131415161718192021demo├── README.md├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat├── settings.gradle└── src ├── main │ ├── java │ │ └── Demo │ │ └── App.java │ └── resources └── test ├── java │ └── DemoTest └── resources 2.2.2. 手动创建Spring boot项目如果要手动创建Spring Boot项目, 可以参考以下步骤. 创建一个文件夹用来包含Spring Boot项目 1mkdir demo 获取Gradle wrapper相关文件, 并将其拷贝到Spring Boot项目文件夹gradle wrapper涉及到的文件主要有如下一些. 123456789demo├── README.md├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat 如果你已经安装了gradle runtime, 可以使用gradle task创建gradle wrapper 12gradle wrapper&gt; Task :wrapper 如果不指定参数, 那么创建出来的gradle wrapper的版本是和gradle runtime一致的版本. 但是有时候或者大多数时候我们的项目的要求的版本和gradle runtime是不一样的, 所以这个时候我们需要在gradle wrapper命令中指定gradle的版本. 此时可以使用类似如下命令创建gradle wrapper, 将其中的版本替换成你所需要的版本. 12345$ gradle wrapper --gradle-version 7.5 --distribution-type all&gt; Task :wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 此处使用到了两个选项, –gradle-version 和 –distribution-type –gradle-version用于指定下载和执行Wrapper的Gradle版本。 –distribution-type用于指定采用的Gradle分发包类型, Gradle分发包分为两种类型bin和all, 并包含了必要binary文件, 包体积更小一些, all 不仅包含binary文件, 还包含了documents和source code文件。可用选项为bin和all。默认值为bin。 –gradle-distribution-url 由于执行以上命令需要到远程服务器去下载Gradle分发包, 由于众所周知的原因, 可能会出现超时的情况. 此时可以使用另外选项 –gradle-distribution-url来指定gradle分发包的位置. 也可以参考我早年写的教程获取gradle分发包 Linux下安装gradle 如果没有在本机安装gradle, 可以从其它gradle项目拷贝gradle wrapper文件到Spring Boot项目文件夹, 这些文件都是可以重用的.如果你手上没有gradle项目, 那就从上一步Spring boot initializer初始化项目生成的文件中拷贝过来. 2.2.2.1. gradle wrapper文件介绍执行完gradle wrapper后, 项目的文件结构如下, 下面简单介绍一下这些文件 gradle-wrapper.jar Wrapper JAR文件包含用于下载Gradle分发的代码。有人可能会问在执行gradle wrapper时不是已经下载过gradle分发包了吗, 为什么这里还需要gradle-wrapper.jar,这主要是方便, 将项目源码分析给项目成员时使用的, 当我们共享项目或将项目纳入source control时, 是不会共享gradle分发包的, 当成员拿到源代码时, 就依赖这个jar文件去相应位置下载gradle分发包. 或者当我们的环境完全的destroy, 我们要重建项目, 也需要使用这个文件, 而不需要将构建gradle环境再执行一遍. gradle-wrapper.properties 主要提供gradle wrapper运行时需要的一些参数, 比如去哪里下载分发包, 是否需要代理, 代理配置等信息. gradle wrapper执行的环境千差万别, 依赖此配置文件, gradle wrapper就能在任何环境下, 完成它的任务和使命. gradlew, gradlew.bat 用于使用Wrapper执行构建的shell脚本和Windows批处理脚本。简单来说gradlew 是在Linux 或者Unix, Unix like环境也可以在git bash, cygwin下执行的gradle wrapper命令, 而gradlew.bat是在windows dos上执行的gradle wrapper命令. 设置完成后运行一些gradlew 命令来查看一下版本 12345678910111213141516$./gradlew -v------------------------------------------------------------Gradle 7.5.1------------------------------------------------------------Build time: 2022-08-05 21:17:56 UTCRevision: d1daa0cbf1a0103000b71484e1dbfe096e095918Kotlin: 1.6.21Groovy: 3.0.10Ant: Apache Ant(TM) version 1.10.11 compiled on July 10 2021JVM: 1.8.0_321 (Oracle Corporation 25.321-b07)OS: Windows 11 10.0 amd64 2.2.2.2. 初始化Java项目安装配置完gradle wrapper后, 我们就可以使用gradle wrapper来初始化一个java项目了. 步骤如下: 此处, 虽然我的开发环境是windows的, 但是我是在git bash下执行命令, 所以我使用的是./gradlw init, 如果是在windows dos下请替换成gradle.bat init 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$./gradlew initStarting a Gradle Daemon (subsequent builds will be faster)Select type of project to generate: 1: basic 2: application 3: library 4: Gradle pluginEnter selection (default: basic) [1..4] 2Select implementation language: 1: C++ 2: Groovy 3: Java 4: Kotlin 5: Scala 6: SwiftEnter selection (default: Java) [1..6] 3Split functionality across multiple subprojects?: 1: no - only one application project 2: yes - application and library projectsEnter selection (default: no - only one application project) [1..2] 1Select build script DSL: 1: Groovy 2: KotlinEnter selection (default: Groovy) [1..2] 1Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no]Select test framework: 1: JUnit 4 2: TestNG 3: Spock 4: JUnit JupiterEnter selection (default: JUnit Jupiter) [1..4] 1Project name (default: demo):Source package (default: demo):&gt; Task :initGet more help with your project: https://docs.gradle.org/7.5.1/samples/sample_building_java_applications.htmlBUILD SUCCESSFUL in 1m 34s2 actionable tasks: 2 executed 通过以上步骤, 就可以创建一个基本的java项目 创建完成后的项目结构如下, 可以看出, init task帮我 添加了src目录, 其中的内容是java项目常见的一些结构, 此处不做展开.此处可以看到init task帮我们在项目的根目录下创建了一个settings.gradle文件并在app目录下创建了app/build.gradle文件. 123456789101112131415161718192021demo├── app│ ├── build.gradle│ └── src│ ├── main│ │ ├── java│ │ │ └── demo│ │ │ └── App.java│ │ └── resources│ └── test│ ├── java│ │ └── demo│ │ └── AppTest.java│ └── resources├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradle 2.2.2.3. settings.gradle下面重点介绍一些, settings.gradle和build.gradle文件. 一个gradle项目通常含有三个重要文件 build.gradle, gradle.properties和settings.gradle, 在init项目的使用由于项目还没有变得很复杂, 所以还没有必要定义属性, 所以初期看不到 gradle.properties文件, 而该文件是用来定义一些公用属性的. settings.gradle中配置的是gradle中要build的项目信息： 12rootProject.name = 'demo'include('app') 上面的例子中，rootProject.name指定了项目的名字，include(‘app’)表示需要引入一个叫做app的子项目，这个子项目中包含着实际的要打包的内容。 如果要更加深入的了解settings.gradle可以继续参考下面的详细介绍. Gradle构建生命周期由三个阶段组成：初始化(initialization)、配置(configuration)和执行(execution)。settings.gradle在初始化阶段并用到。 Gradle查看settings.gradle文件，以便识别不同的项目。在初始化阶段结束时，Gradle将为每个项目(Project)或子项目(sub-project)创建一个对应的org.Gradle.api.Project的实例。 settings.gradle文件是一个Groovy脚本。settings.gradle脚本在整个构建声明周期中只会在初始化阶段被执行一次(与多项目构建中的多个build.gradle脚本相比）。settings.grade脚本将在任何构建之前执行。甚至在创建Project实例之前, 因此，它将对Settings对象产生影响。 settings.gradle的主要作用是定义所有被包含的子模块, 将一个大的工程按模块分解为子模块, 更加符合模块化设计的思路. settings.gradle可能包含以下一些属性 属性 描述 buildCache build cache configuration extentions The container of extensions gradle the Gradle instance for the current build pluginManager The plugin manager for this plugin aware object plugins the container of plugins that have been applied to this object rootDir The root directory of the build. The root directory is the project directory of the root project. rootProject The root project of the build. settings Returns this settings object. settingsDir The settings directory of the build. The settings directory is the directory containing the settings file. startParameter The set of parameters used to invoke this instance of Gradle. settings.gradle 可能含有以下一些方法. 方法 描述 apply(closure) Applies zero or more plugins or scripts. apply(options) Applies a plugin or script, using the given options provided as a map. Does nothing if the plugin has already been applied. apply(action) Applies zero or more plugins or scripts. buildCache(action) Configures build cache. findProject(projectDir) Returns the project with the given project directory. findProject(path) Returns the project with the given path. include(projectPaths) Adds the given projects to the build. Each path in the supplied list is treated as the path of a project to add to the build. Note that these path are not file paths, but instead specify the location of the new project in the project hierarchy. As such, the supplied paths must use the ‘:’ character as separator (and NOT ‘/’). includeBuild(rootProject) Includes a build at the specified path to the composite build. includeBuild(rootProject, configuration) Includes a build at the specified path to the composite build, with the supplied configuration. includeFlat(projectNames) Adds the given projects to the build. Each name in the supplied list is treated as the name of a project to add to the build. project(projectDir) Returns the project with the given project directory. project(path) Returns the project with the given path. 2.2.2.4. build.gradlebuild.gradle是gradle中非常重要的一个文件，因为它描述了gradle中可以运行的任务，今天本文将会带大家体验一下如何创建一个build.gradle文件和如何编写其中的内容。 先看看app中的build.gradle文件 123456789101112131415161718192021222324plugins { // Apply the application plugin to add support for building a CLI application in Java. id 'application'}repositories { // Use Maven Central for resolving dependencies. mavenCentral()}dependencies { // Use JUnit test framework. testImplementation 'junit:junit:4.13.2' // This dependency is used by the application. implementation 'com.google.guava:guava:31.0.1-jre'}application { // Define the main class for the application. mainClass = 'demo.App'} 很简单，指定了插件，仓库地址，依赖包和应用程序的main class路径。 一切准备好之后，我们就可以进行构建和运行了。如果我们运行项目已经可以看到”hello world”消息了 12345678$./gradlew runStarting a Gradle Daemon (subsequent builds will be faster)&gt; Task :app:runHello World!BUILD SUCCESSFUL in 6s2 actionable tasks: 2 executed plugin{}闭包：配置Gradle插件 语法格式: id: ‘插件名称’, 如果需要用到多个插件, 可以添加多个id:’插件名称’示例中的application插件用来帮助构建一个命令行应用程序, 如果是libary或gradle插件程序需要做相应替换.如果是java libary需要替换为’java-library’, 如果是java编写的gradle plugin需要替换为’java-gradle-plugin’, 当然目录结构和命名规范也要做相应调整. repositories{}闭包: 配置依赖包仓库, 即告诉gradle去哪里查找和下载dependencies{}闭包中定义的依赖包. dependencies{}闭包: 定义依赖包的版本, 以及何时使用该依赖包, 编译阶段, 还是运行阶段, 测试阶段等等. application{}闭包: 是application插件需要的, 用来指定主函数, 用于启动项目. build.gradle还有更多高级用法, 这里不做展开, 英文好的同学可以到gradle官网详细了解. 至此项目的骨架已经建立, 接下来我们将讲述, 如何添加springboot相关依赖, 来创建restful api和web application. 3. 引入spring boot要引入spring boot首先我们要了解spring boot starter. starter是SpringBoot中的一个新发明，它有效的降低了项目开发过程的复杂程度，对于简化开发操作有着非常好的效果. 简单来说就是spring boot start简化了我们创建一个项目的配置过程. 在spring boot starter出现之前, 首先我们要引入一堆依赖包, 比如spring bean, spring-context, spring-mvc, spring-jdbc, struts 2, hibernate 或者mybatis等等一堆的依赖包, 并执行解决包版本的依赖性, 然后写一堆的配置文件, 比如spring的配置文件, hibernate的配置文件, struts配置文件等等一堆的配置文件后才能正式开始写业务代码. 自从spring boot starter出现以后这些统统都不需要了, 只需要找到合适的starter, 引入它就够了. 去哪里找合适的spring boot starter? starter 有官方为我们提供了很多的spring boot starters, 也有第三方组件厂商提供的starters, spring boot 官方starters 可以在下面位置找到;https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 这里简单列举一些starters和starters的描述信息. 1、application starters 这一个表格是 Spring Boot 所有应用程序级的 Starters，一起来看都有哪些。 starters名称 starter描述 spring-boot-starter 核心starter, 包括自动配置, 日志及YAML支持 spring-boot-starter-activemq 集成Apache ActiveMQ, 基于JMX消息队列 spring-boot-starter-Artemis 集成Apache Artemis, 基于JMX消息队列 spring-boot-starter-amqp 集成 spring amqp 和Rabbit MQ消息队列 spring-boot-starter-aop 集成 spring AOP 和 AspectJ面向切面编程 spring-boot-starter-batch 集成 spring Batch (批处理) spring-boot-starter-cache 集成 spring cache (缓存) spring-boot-starter-data-cassandra 集成cassandra(分布式数据库) 和 Spring Data Cassandra spring-boot-starter-data-cassandra-reactive 集成cassandra(分布式数据库) 和 Spring Data Cassandra Reactive spring-boot-starter-data-couchbase 集成 Couchbase(文档型数据库) 和 Spring Data Couchbase spring-boot-starter-data-couchbase-reactive 集成 Couchbase(文档型数据库) 和 Spring Data Couchbase Reactive spring-boot-starter-data-elasticsearch 集成 Elasticsearch(搜索引擎) 和 Spring Data Elasticsearch spring-boot-starter-data-solr 集成Apache Solr(搜索引擎) 和 Spring Data Solr spring-boot-starter-data-jdbc 集成Spring Data JDBC spring-boot-starter-data-jpa 集成Spring Data JPA 和 Hibernate spring-boot-starter-data-ldpa 集成Spring Data LDPA spring-boot-starter-data-mongodb 集成MongoDB (文档型数据库) 和 Spring Data MongoDB spring-boot-starter-data-mongodb-reactive 集成MongoDB (文档型数据库) 和 Spring Data MongoDB Reactive spring-boot-starter-data-neo4j 集成neo4j (图形数据库) 和 Spring Data Neo4j spring-boot-starter-data-r2dbc 集成Spring Data R2DBC spring-boot-starter-data-redis 集成Redis(内存数据库) 结合 Spring Data Redis 和 Lettuce 客户端 spring-boot-starter-data-redis-reactive 集成Redis(内存数据库) 结合 Spring Data Redis Reactive 和 Lettuce 客户端 spring-boot-starter-data-redis-rest 集成 Spring Data REST 暴露 Spring Data repositories 输出REST资源 spring-boot-starter-thymeleaf 集成 thymeleaf 视图构建 MVC Web 应用 spring-boot-starter-freemarker 集成 FreeMarker 视图构建 MVC Web 应用 spring-boot-starter-groovy-templates 集成 Groovy 模板视图构建 MVC Web 应用 spring-boot-starter-groovy-hateoas 集成 Spring MVC 和 HATEOAS 构建超媒体 RESTful Web 应用程序 spring-boot-starter-integration 集成 Spring Integration spring-boot-starter-jdbc 集成 JDBC 结合 HikariCP 连接池 spring-boot-starter-jersey 集成 JAX-RS 和 jersey 构建 RESTful web 应用, 是 spring-boot-starter-web 的一个替代starter spring-boot-starter-jooq 集成 JOOQ 访问SQL数据库, 是spring-boot-starter-jdbc 和 spring-boot-starter-data-jpa的替代starter spring-boot-starter-json 用于读写json spring-boot-starter-jta-automikos 集成Automikos实现JTA事务 spring-boot-starter-jta-bitronix 集成Bitronix实现JTA事务(从2.3.0标识为Deprecated) spring-boot-starter-mail 集成Java mail和Spring 框架的发邮件功能 spring-boot-starter-mustache 集成Mustache 视图构建 web应用 spring-boot-starter-security 集成Spring Security spring-boot-starter-oauth2-client 集成Spring Security’s OAuth2/OpenID连接客户端功能 spring-boot-starter-oauth2-resource-server 集成Spring Security’s OAuth2资源服务器功能 spring-boot-starter-quartz 集成Quartz任务调度 spring-boot-starter-rsocket 构建RSocket客户端和服务端 spring-boot-starter-test 集成Junit Jupiter, Hamcrest 和Mockito 测试Spring Boot 应用和类库 spring-boot-starter-validation 集成Java Bean Validation 结合Hibernate Validator spring-boot-starter-web 集成Spring MVC 构建RESTful web应用, 使用Tomcat作为默认内嵌服务器 spring-boot-starter-web-services 集成Spring Web Services spring-boot-starter-webflux 集成Spring Reactive Web 构建WebFlux应用 spring-boot-starter-websocket 集成Spring Websocket 构建Websocket应用 而在我们手工创建Spring boot应用时, 由于我想创建的是一个RESTful风格的服务器, 所以我们选择spring-boot-starter-web, 测试starter选择spring-boot-starter-test. 接下来我们在build.gradle中添加这两个依赖. 1234567891011121314dependencies { // This dependency is used by the application. implementation 'com.google.guava:guava:29.0-jre' implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' // Use JUnit Jupiter API for testing. testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.2' // Use JUnit Jupiter Engine for testing. testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.6.2'} 这里不需要指定starter的版本, 但是我们要引入两个plugins, 在plugins中指定版本. 在plugin{}闭包中, 引入’org.springframework.boot’ 和 ‘io.spring.dependency-management’ 这两个plugin, 并分别指定版本 ‘2.7.6’ 和 ‘1.0.15.RELEASE’ 12345678plugins { id 'java' id 'org.springframework.boot' version '2.7.6' id 'io.spring.dependency-management' version '1.0.15.RELEASE' id 'application'} 4. 创建Idea工程由于我的Intellij Idea版本较低, 对高版本的gradle支持不是很好, 不能支持直接导入高版本的gradle项目, 所以我需要引入idea plugin将项目手动转换成idea项目, 再导入Idea. 12345678910plugins { id 'java' // 添加idea plugin用于转换成idea工程 id 'idea' id 'org.springframework.boot' version '2.7.6' id 'io.spring.dependency-management' version '1.0.15.RELEASE' id 'application'} 123./gradlew idea 5. 创建Controllers现在，您可以为一个简单的web应用程序创建一个web控制器，如下所示 （src/main/java/comple/springboot/HelloController.java）所示： 123456789101112131415package demo;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @GetMapping(&quot;/&quot;) public String index() { return &quot;Greetings from Spring Boot!&quot;; }} 6. 创建主函数123456789101112131415package demo;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.SpringApplication;@SpringBootApplicationpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } } 1234567891011121314151617181920212223242526$./gradlew bootRun&gt; Task :app:bootRun . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.6)2022-12-21 08:57:07.468 INFO 23232 --- [ main] demo.App : Starting App using Java 1.8.0_321 on eagle_hw with PID 23232 (C:\\dev\\proj\\demo\\app\\build\\classes\\java\\main started by eagle in C:\\dev\\proj\\demo\\app)2022-12-21 08:57:07.468 INFO 23232 --- [ main] demo.App : No active profile set, falling back to 1 default profile: &quot;default&quot;2022-12-21 08:57:08.823 INFO 23232 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2022-12-21 08:57:08.829 INFO 23232 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2022-12-21 08:57:08.829 INFO 23232 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.69]2022-12-21 08:57:08.963 INFO 23232 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2022-12-21 08:57:08.963 INFO 23232 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1456 ms2022-12-21 08:57:09.240 INFO 23232 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2022-12-21 08:57:09.251 INFO 23232 --- [ main] demo.App : Started App in 2.094 seconds (JVM running for 2.427)2022-12-21 08:57:17.484 INFO 23232 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2022-12-21 08:57:17.484 INFO 23232 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2022-12-21 08:57:17.484 INFO 23232 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 0 ms&lt;==========---&gt; 80% EXECUTING [55s]&gt; :app:bootRun 访问RESTful api, 可以通过curl命令行工具访问, 也可以通过浏览器访问http://localhost:8080查看结果. 1234$curl localhost:8080Greetings from Spring Boot! 至此一个简单的spring boot 应用就创建完成了. 7. 相关文章本文原文位于鹏叔的技术博客 - 如何手动创建一个springBoot项目, 若需获取文章最新, 请访问原文! 8. 参考文档Building an Application with Spring Boot The gradle wrapper What is settings.gradle in Gradle? gradle中的build script详解 Spring Boot Starters是什么 54 个官方 Spring Boot Starters 出炉！别再重复造轮子了","link":"/java/how_to_create_springBoot_proj.html"},{"title":"如何使用Maven结合IDEA进行Debug","text":"1. 介绍由于 Idea 和 Maven class loading 的规则不同， 同样的测试使用 Maven 运行和使用 Idea 运行可能会得到不同的结果。 而我们的 CI(持续集成)往往是使用 maven 命令去运行的。在此情况下， 将测试使用 maven 运行起来， 然后结合 IDEA 强大的 debug 能力就显得非常必要。如果熟练掌握此种 debug 方式， 也可以减少我们依赖 idea 进行编译，更新 index 这些极其耗时的工作。 2. 创建一个测试假设我们已经创建了一个工程 maven_debug, 并且创建了一个测试类 MySuperClassTest 3. 启动 mmaven 测试并运行在 debug 模式1mvn -Dtest=MySuperClassTest -Dmaven.surefire.debug test JVM 参数 -Dmaven.surefire.debug 即表示将测试运行在 debug 模式下 这时 maven 将会首先编译测试，然后启动测试，并等待 IDE 接入 debug 模式， 此时我们要配置 IDEA 运行一个 remote JVM debug 进程， 接入 mvn debug. 通常情况下， 测试将会监听在 5005 端口。 4. 配置 remote JVM debug 模板 打开 idea, 从以下路径 打开 remote JVM debug 配置界面 run-&gt; edit configurations-&gt; Edit configuration templates -&gt; remote JVM debug 修改或检查 command line arguments for remote JVM 中的端口和其他参数正确， 端口即为上一步 mven debug 监听的端口， 默认为 5005 1-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 说明 这里的参数 jdwp 即为 java 的 debug 协议, 全称 Java Debug Wire Protocol transport=dt_socket 确保 host 参数正确， transport 参数正确 参数都填写正确后， 点击 appy 按钮保存修改， 这一步完成，代表我们的 remote JVM debug 模板配置完成， 接下来我们需要基于此模版， 创建一个进程去连接 maven 测试。 5. 启动 remote JVM debug 进程打开 run/debug configuration 界面， 路径 run-&gt; edit configurations点左上角+按钮， 在弹出的选择框中， 选择 remote JVM debug 模板，创建一个 run/debug 配置，点击 apply 保存。此时在 tools bar run/debug 下拉列表就可以看到新创建的 run/debug 配置， 单击即可启动此该 remote JVM debug 进程 6. 设置断点在 IDEA 中设置断点， 当程序运行到断点位置就会停下。 7. 其他7.1. 如何 debug maven 插件?如果你需要 debug 一个 maven 插件 那么需要使用另外一个 maven 命令 mvnDebug 1mvnDebug -Dtest=MySuperClassTest test mvnDebug 默认监听在 8000 端口， 需要启动一个 remote JVM debug 进程连接其 8000 端口, 这样即可在 IDEA 中 debug maven 插件。 1-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000 8. 后记本文原文位于如何 Maven 结合 IDEA 进行 Debug, 若需最近更新, 请访问原文! 9. 参考文档How to Debug a Test Run with Maven Run Maven tests with -Dmaven.surefire.debug and -DforkMode=never Java Debug Wire Protocol","link":"/java/how_to_debug_with_maven_cli.html"},{"title":"如何通过表名获取所有字段信息","text":"1. 前言通常情况下, 如果想写一些比较通用的应用程序, 我们需要通过表名去了解整个表的情况, 才能编写一些比较通用的数据库工具.通过表名获取字段名有多种方式: 第一种 我们可以查询系统表或者数据字典来获取表的信息, 其优点是效率比较高, 缺点是所写的工具往往只适用与某种特定的数据库. 第二种 通过一些标准的数据库连接库获取数据库元数据, 从而获取到相应表的结构信息, 这样做的优点是由于程序是面向标准库的API,无论底层是何种数据库都能够兼容. 在Java领域可以通过Jdbc库提供的接口获取表信息, 在.net领域可以通过odbc, PHP领域可以使用PDO,SQLAPI ++ 之于C++, database/sql之于golang, sqlx之于Rust等等 本文主要介绍使用jdbc获取数据库字段信息. 2. 概念讲解 数据库驱动首先我们要连接数据库, 需要通过数据库驱动来完成.什么是数据库驱动? 我们可以设想一下如果没有驱动的情况下, 我们明明知道远程有一台数据库服务器监听在3306或1521或者5432端口上. 如果我们不是数据库专家, 不了解网络连接的细节, 我们往往不得其门而入. 而数据库驱动帮助我们屏蔽了连接方面的复杂性以及细节, 最终暴露给开发者一下简单的接口. 简单来说数据库驱动就是客户端一个库程序帮助开发者方便地连接到特定的数据库. 数据库驱动由谁提供?一般来说数据库驱动由厂商针对特定的开发语言, 提供特定的驱动程序, 数据库厂商才是最了解自家产品的. 但是开发语言有千千万, 厂商不可能面面俱到, 对于一些小众的开发语言, 或者新兴的开发语言, 往往由社区或某些该领域的大牛来提供驱动程序, 以提高该语言在数据库开发领域的占有率. 比如golang领域, 针对oracle的驱动godror就不是Oracle提供的. 标准库为什么需要数据库标准库?相信读到这里答案应该很明显了, 如果没有标准库, 我们需要针对特定的数据库驱动来编程, 这样的结果就是程序的可移植性会非常差, 另外对工具开发者或者第三方库开发者来说成本会非常高.为什么标准库能够得到驱动开发者的支持?因为如果驱动开发者不支持标准库, 他们的驱动就得不到更大范围的采用, 导致其数据库产品的流行度不高, 相信这不是数据库厂商也不是驱动开发者想要看到的结果.标准库有没有什么缺点?前面光讲了标准库的好处, 标准库的缺点也是显而易见的. 由于在驱动和应用程序之间增加了一层抽象, 常常会带来一些性能上的损失. 对于那些极度追求性能的应用程序来说, 这点有时是无法接受的. 所以往往会看到一些app在经过长期稳定的运行后, 为了调优方面的考虑将标准库这一层部分地去掉的, 因为经过长期的运行, 他们覆盖的数据库类型已经非常确定了. 另外一点, 由于标准库的变化或版本升级往往是非常缓慢的, 这会导致数据库厂商在数据库的创新上不能立即被纳入到标准库, 而得不到大规模使用. 这会影响数据库厂商创新的积极性以及投资回报. 但是有些应用为了获得数据库厂商创新方面的优势而绕过标准库与驱动耦合在一起. 数据库连接数据库连接通常都是长连接, 如果是短连接的话, 用户每执行一次SQL, 都需要认证鉴权等等操作, 效率会非常地下. 但是一台服务器能开启的长连接是有限的, 此时就需要用到复用技术, 那就是数据库连接池. 这样程序就不用频繁地创建连接, 节省在执行SQL前后的开销. 3. 实现思路最后回到本文的重点 - 如何通过表名获取所有字段信息. 首先加载驱动 然后通过Jdbc与数据库建立连接 通过连接获取到数据库的元数据 通过元数据获取表信息 4. 代码示例在正式写代码之前, 我们需要创建一个gradle项目, 使用gradle来管理依赖包. 1gradle init 在build.gradle中添加mysql驱动 1runtimeOnly 'mysql:mysql-connector-java:5.1.37' 核心代码如下 123456789101112131415161718192021222324252627282930import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.DriverManager;import java.sql.ResultSet;public class App { public static void main(String[] args) throws Exception { try (Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/test&quot;, &quot;root&quot;, &quot;password&quot;)) { // create a Statement DatabaseMetaData dbMetaData = conn.getMetaData(); ResultSet tabs = dbMetaData.getTables(null, null, &quot;Test&quot;, new String[]{&quot;TABLE&quot;}); while (tabs.next()) { ResultSet resultSet = dbMetaData.getColumns(null, tabs.getString(&quot;TABLE_SCHEM&quot;), tabs.getString(&quot;TABLE_NAME&quot;), null); while (resultSet.next()) { String colName = resultSet.getString(&quot;COLUMN_NAME&quot;); System.out.println(colName); } } } }} 直接将其封装成一个函数. 我们的输入参数, 是connection和table name, 输出使用由column name数组. 12345678910111213141516171819private String[] getColumnsByTableName(Connection conn, String tableNamePattern) throws SQLException { DatabaseMetaData dbMetaData = conn.getMetaData(); ResultSet tabs = dbMetaData.getTables(null, null, tableNamePattern, new String[] { &quot;TABLE&quot; }); List&lt;String&gt; columnList = new ArrayList&lt;&gt;(); while (tabs.next()) { ResultSet resultSet = dbMetaData.getColumns(null, tabs.getString(&quot;TABLE_SCHEM&quot;), tabs.getString(&quot;TABLE_NAME&quot;), null); while (resultSet.next()) { columnList.add(resultSet.getString(&quot;COLUMN_NAME&quot;)); } } return columnList.toArray(new String[columnList.size()]); } 相关文章本文原文位于如何通过表名获取所有字段信息, 若需要获得最近更新, 请访问原文. 更多数据库相关文章, 请访问鹏叔的技术博客 - 数据库专题 5. 参考文档DatabaseMetaData类","link":"/java/how_to_get_columns_by_table_name.html"},{"title":"JDK17安装","text":"1. 前言 JDK17是自2018年JDK11后的第二个长期支持版本, 支持到2029年9月, 支持时间长达8年, 这下可以不用死守JDK8了, JDK17+也可以是一种新的选择了.这次更新之所以重要, 伴随着新版本的发布, Oracle还做了重要决定, 从JDK17开始, 后面的版本全部免费提供, 包括商用, 更详细的条款可以阅读这里. Oracle这次真是发善心了.英文版的通用安装说明可以移步到这里 2. 下载JDK17安装包 下载页: https://www.oracle.com/java/technologies/downloads/ 这里我选 x64压缩包for windows, 理由:我不想让windows安装向导污染我的注册表, 我希望能在java各版本之间自由切换. 下载连接: https://download.oracle.com/java/17/latest/jdk-17_windows-x64_bin.zip 3. 解压 下载完成后解压到 C:\\Program Files\\Java\\jdk-17 说明: 解压到系统目录需要管理员权限, 授权即可, 如果你无法获取到管理员权限, 建议安装到自己的主目录下, 或者其它有读写权限的目录下. 解压后的文件结构 1234567891011121314151617181920C:\\PROGRAM FILES\\JAVA\\JDK-17+---bin| \\---server+---conf| +---management| \\---security| \\---policy| +---limited| \\---unlimited+---include| \\---win32| \\---bridge+---jmods+---legal| +---java.base| +---java.compiler...................\\---lib +---jfr \\---security 4. 配置环境变量 打开环境变量配置界面 方式一: windows+r, 输入rundll32.exe sysdm.cpl,EditEnvironmentVariables, 然后按回车 方式二: 鼠标点击左下角的windows图标, 选择运行,输入rundll32.exe sysdm.cpl,EditEnvironmentVariables, 然后按回车 方式三: 鼠标右键点击我的电脑 -&gt; 高级系统设置 -&gt; 环境变量 说明: 方式三需要管理员权限, 而且设置的是管理员的环境变量或所有用户的环境变量, 方式一二都是设置当前用户的环境变量, 这里请根据实际需要进行选择. 如果权限足够大, 并且要为所有用户设置环境变量请选择方式三. 打开环境变量配置界面后设置如下环境变量: 12JAVA_HOME=C:\\Program Files\\Java\\jdk-17Path=%JAVA_HOME%\\bin;%Path% 说明:如果你的jdk不是解压在C:\\Program Files\\Java\\jdk-17, 需要做相应替换 5. 检查是否安装成功 运行java -version 查看java版本, 如果见到如下输出说明安装配置成功. 如果任然看到旧的java版本, 或者找不到java命令, 请检查Path环境变量, 确保java17的路径在其他版本之前. C:\\Users\\eagle&gt;java -version java version &quot;17&quot; 2021-09-14 LTS Java(TM) SE Runtime Environment (build 17+35-LTS-2724) Java HotSpot(TM) 64-Bit Server VM (build 17+35-LTS-2724, mixed mode, sharing) `` 6. 后记本技术博客原创文章位于鹏叔的技术博客 - JDK17安装, 要获取最近更新请访问原文. 更多技术博客请访问: 鹏叔的技术博客","link":"/java/jdk17_installation.html"},{"title":"java实现websocket的五种方式","text":"1. 前言WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上. 本文主要讲述在Java技术领域实现websocket服务的五种方式. 2. 第一种使用Java原生代码实现websocket使用Java原生代码实现websocket服务的方法, 此方法需要引入一个第三方库java-websocket.jar. 截至目前2023/01/01最新版本为1.5.3. 项目源代码位于: https://github.com/TooTallNate/Java-WebSocket 示例代码位于: https://github.com/TooTallNate/Java-WebSocket/tree/master/src/main/example 2.1. 首先在项目中引入依赖 如果你的项目使用gradle作为管理工具, 可以添加以下gradle依赖 123implementation group: 'org.java-websocket', name: 'Java-WebSocket', version: '1.5.3' 如果你的项目使用maven进行管理, 可以添加以下maven依赖 mven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.java-websocket&lt;/groupId&gt; &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt; 2.2. 创建WebsocketServer类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.InetSocketAddress;import java.net.UnknownHostException;import org.java_websocket.WebSocket;import org.java_websocket.handshake.ClientHandshake;import org.java_websocket.server.WebSocketServer;public class SocketServer extends WebSocketServer { public SocketServer(int port) throws UnknownHostException { super(new InetSocketAddress(port)); } public SocketServer(InetSocketAddress address) { super(address); } @Override public void onOpen(WebSocket conn, ClientHandshake handshake) { conn.send(&quot;Welcome to the server!&quot;); // This method sends a message to the new client broadcast(&quot;new connection: &quot; + handshake .getResourceDescriptor()); // This method sends a message to all clients connected System.out.println( conn.getRemoteSocketAddress().getAddress().getHostAddress() + &quot; entered the room!&quot;); } @Override public void onClose(WebSocket conn, int code, String reason, boolean remote) { broadcast(conn + &quot; has left the room!&quot;); System.out.println(conn + &quot; has left the room!&quot;); } @Override public void onMessage(WebSocket conn, String message) { broadcast(message); System.out.println(conn + &quot;: &quot; + message); } @Override public void onError(WebSocket conn, Exception ex) { ex.printStackTrace(); if (conn != null) { // some errors like port binding failed may not be assignable to a specific // websocket } } @Override public void onStart() { System.out.println(&quot;Server started!&quot;); setConnectionLostTimeout(0); setConnectionLostTimeout(100); }} 2.3. 启动SocketServer我们以及创建好了SocketServer, 这个时候我们可以启动它了, 启动代码如下. 123456789101112131415161718public static void main(String[] args) throws InterruptedException, IOException { int port = 8887; // 843 flash policy port SocketServer s = new SocketServer(port); s.start(); System.out.println(&quot;ChatServer started on port: &quot; + s.getPort()); BufferedReader sysin = new BufferedReader(new InputStreamReader(System.in)); while (true) { String in = sysin.readLine(); s.broadcast(in); if (in.equals(&quot;exit&quot;)) { s.stop(1000); break; } } } 写好main方法后, 我们可以启动它, 当控制台输出ChatServer started on port: 8887表示启动成功. 2.4. 测试web socket server此时web socket server已经监听在了localhost:8887上. 我们可以使用websocket在线调试工具对其进行测试. 该工具主要是利用html5 的websocket去连接服务端的websocket,因此，无论你是内网还是外网都可使用! 打开工具在输入框中输入 ws://localhost:8887点击连接, 既可以看到服务器端的反馈, 同时web socket server的控制台也会输出日志信息. 3. 使用Java原生+SpringBoot混合在此种方式中, SocketServer依然使用原生的java代码编写, 但是SocketServer实例化过程由spring来管理. 此时我们需要引入spring-boot-starter-websocket, 上一节中的依赖包Java-WebSocket已经不需要了. 两种方式采用了不同的机制. 可以参考我的博文创建spring boot项目, 里面有详细讲解 - 如何手动创建一个springBoot项目 3.1. 引入依赖12345678910111213plugins { id 'org.springframework.boot' version '2.7.7' id 'io.spring.dependency-management' version '1.0.15.RELEASE' }dependencies { implementation 'org.springframework.boot:spring-boot-starter-websocket'} 此处我们需要在gradle配置文件的plugins闭包内添加两个plugins, 一个复制控制spring boot的版本, 一个负责管理依赖. 对于maven, 需要如下配置 1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2. 创建ServerEndpoint创建ServerEndpoint代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.springframework.stereotype.Component;import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;import java.io.IOException;@ServerEndpoint(&quot;/myWs&quot;)@Componentpublic class WsServerEndpoint { /** * 连接成功 * * @param session */ @OnOpen public void onOpen(Session session) { System.out.println(&quot;连接成功&quot;); } /** * 连接关闭 * * @param session */ @OnClose public void onClose(Session session) { System.out.println(&quot;连接关闭&quot;); } /** * 接收到消息 * * @param text */ @OnMessage public String onMsg(String text) throws IOException { return &quot;servet 发送：&quot; + text; }} 说明 这里有几个注解需要注意一下，首先是他们的包都在 javax.websocket下。并不是 spring 提供的，而 jdk 自带的，下面是他们的具体作用。 @ServerEndpoint通过这个 spring boot 就可以知道你暴露出去的 ws 应用的路径，有点类似我们经常用的@RequestMapping。比如你的启动端口是 8080，而这个注解的值是 ws，那我们就可以通过 ws://127.0.0.1:8080/ws 来连接你的应用 @OnOpen当 websocket 建立连接成功后会触发这个注解修饰的方法，注意它有一个 Session 参数 @OnClose 当 websocket 建立的连接断开后会触发这个注解修饰的方法，注意它有一个 Session 参数 @OnMessage 当客户端发送消息到服务端时，会触发这个注解修改的方法，它有一个 String 入参表明客户端传入的值 @OnError 当 websocket 建立连接时出现异常会触发这个注解修饰的方法，注意它有一个 Session 参数 服务器主动发送消息 当服务器端要主动给客户端发送, 需要获取到相应客户端与服务器端的session, 通过 session.getBasicRemote().sendText(), 将消息发送到前端. 因此最好在onOpen方法中将session对象保存起来, 这样下次主动连接客户端时能找到相应的session对象. 3.3. 添加Spring配置有了WsServerEndpoint后我们还要配置ServerEndpointExporter, 将Endpoint暴露出去让客户端来建立连接. 而配置ServerEndpointExporter的方式非常简单, 只需要创建一个ServerEndpointExporter bean即可, 它会去获取Spring上下文中所有的Endpoint实例, 完成endpoint的注册过程, 并监听在application.properties 的server.port 属性所指定的端口. 12345678910111213141516import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configuration@EnableWebSocketpublic class WebsocketConfig { @Bean public ServerEndpointExporter serverEndpoint() { return new ServerEndpointExporter(); } } 3.4. 启动应用程序并测试我们只需要向一般的Spring boot应用一样启动它即可. 123456789@SpringBootApplicationpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); }} 测试, 我们依然使用websocket在线调试工具来测试, 详情可参考上一节中的介绍 与前一种实现方式稍微不同的地方是, 我们可以url中指定endpoint了 ws://127.0.0.1:8080/myWs 4. 使用SpringBoot实现websocket4.1. 引入依赖1implementation 'org.springframework.boot:spring-boot-starter-websocket' 4.2. 实现类HttpAuthHandler.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.TextWebSocketHandler;import java.time.LocalDateTime;@Componentpublic class HttpAuthHandler extends TextWebSocketHandler { /** * socket 建立成功事件 * * @param session * @throws Exception */ @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception { Object sessionId = session.getAttributes().get(&quot;session_id&quot;); if (sessionId != null) { // 用户连接成功，放入在线用户缓存 WsSessionManager.add(sessionId.toString(), session); } else { throw new RuntimeException(&quot;用户登录已经失效!&quot;); } } /** * 接收消息事件 * * @param session * @param message * @throws Exception */ @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception { // 获得客户端传来的消息 String payload = message.getPayload(); Object sessionId = session.getAttributes().get(&quot;session_id&quot;); System.out.println(&quot;server 接收到 &quot; + sessionId + &quot; 发送的 &quot; + payload); session.sendMessage(new TextMessage(&quot;server 发送给 &quot; + sessionId + &quot; 消息 &quot; + payload + &quot; &quot; + LocalDateTime.now().toString())); } /** * socket 断开连接时 * * @param session * @param status * @throws Exception */ @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception { Object sessionId = session.getAttributes().get(&quot;session_id&quot;); if (sessionId != null) { // 用户退出，移除缓存 WsSessionManager.remove(sessionId.toString()); } } } WsSessionManager.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.springframework.web.socket.WebSocketSession;import java.io.IOException;import java.util.concurrent.ConcurrentHashMap;public class WsSessionManager { /** * 保存连接 session 的地方 */ private static ConcurrentHashMap&lt;String, WebSocketSession&gt; SESSION_POOL = new ConcurrentHashMap&lt;&gt;(); /** * 添加 session * * @param key */ public static void add(String key, WebSocketSession session) { // 添加 session SESSION_POOL.put(key, session); } /** * 删除 session,会返回删除的 session * * @param key * @return */ public static WebSocketSession remove(String key) { // 删除 session return SESSION_POOL.remove(key); } /** * 删除并同步关闭连接 * * @param key */ public static void removeAndClose(String key) { WebSocketSession session = remove(key); if (session != null) { try { // 关闭连接 session.close(); } catch (IOException e) { // todo: 关闭出现异常处理 e.printStackTrace(); } } } /** * 获得 session * * @param key * @return */ public static WebSocketSession get(String key) { // 获得 session return SESSION_POOL.get(key); }} 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Map;import org.apache.logging.log4j.util.Strings;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.server.HandshakeInterceptor;@Componentpublic class MyInterceptor implements HandshakeInterceptor { /** * 握手前 */ @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception { System.out.println(&quot;握手开始&quot;); String hostName = request.getRemoteAddress().getHostName(); String sessionId = hostName+String.valueOf((int)(Math.random()*1000)); if (Strings.isNotBlank(sessionId)) { // 放入属性域 attributes.put(&quot;session_id&quot;, sessionId); System.out.println(&quot;用户 session_id &quot; + sessionId + &quot; 握手成功！&quot;); return true; } System.out.println(&quot;用户登录已失效&quot;); return false; } /** * 握手后 */ @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) { System.out.println(&quot;握手完成&quot;); }} 4.3. Spring 配置123456789101112131415161718192021222324252627282930import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;import com.philoenglish.ws.HttpAuthHandler;import com.philoenglish.ws.MyInterceptor;@Configuration@EnableWebSocketpublic class WebsocketConfig implements WebSocketConfigurer { @Autowired private HttpAuthHandler httpAuthHandler; @Autowired private MyInterceptor myInterceptor; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry .addHandler(httpAuthHandler, &quot;myWS&quot;) .addInterceptors(myInterceptor) .setAllowedOrigins(&quot;*&quot;); }} 4.4. 启动与测试启动代码如下: 123456789101112131415161718192021222324import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) { return args -&gt; { System.out.println(&quot;application started&quot;); }; }} 执行main方法启动应用程序 测试依然使用websocket在线调试工具 5. 使用TIO+SpringBoot实现websocket以下是关于t-io的一些信息, 如果需要更详细的了解tio可以访问以下这些站点 sit link t-io site https://www.t-io.org t-io on gitee https://gitee.com/tywo45/t-io t-io on github https://github.com/tywo45/t-io 5.1. 添加相应依赖gradle: 123implementation 'org.t-io:tio-websocket-spring-boot-starter:3.6.0.v20200315-RELEASE' maven: 12345 &lt;dependency&gt; &lt;groupId&gt;org.t-io&lt;/groupId&gt; &lt;artifactId&gt;tio-websocket-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.6.0.v20200315-RELEASE&lt;/version&gt;&lt;/dependency&gt; 5.2. 编写消息处理类12345678910111213141516171819202122232425262728293031323334353637383940414243import org.springframework.stereotype.Component;import org.tio.core.ChannelContext;import org.tio.http.common.HttpRequest;import org.tio.http.common.HttpResponse;import org.tio.websocket.common.WsRequest;import org.tio.websocket.server.handler.IWsMsgHandler;@Componentpublic class MyWebSocketMsgHandler implements IWsMsgHandler { @Override public HttpResponse handshake(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception { return httpResponse; } @Override public void onAfterHandshaked(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception { System.out.println(&quot;握手成功&quot;); } @Override public Object onBytes(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception { System.out.println(&quot;接收到bytes消息&quot;); return null; } @Override public Object onClose(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception { return null; } @Override public Object onText(WsRequest wsRequest, String s, ChannelContext channelContext) throws Exception { System.out.println(&quot;接收到文本消息：&quot; + s); return null; }} 5.3. 修改配置文件application.properties 12tio.websocket.server.port=9876tio.websocket.server.heartbeat-timeout=60000 5.4. 启动tio Websocket Server启动tio Websocket Server 的方式如下, 执行main方法. 1234567891011121314151617@SpringBootApplication@EnableTioWebSocketServerpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) { return args -&gt; { System.out.println(&quot;application started&quot;); }; }} 6. STOMP实现websocket6.1. 添加相应依赖gradle: 1implementation 'org.springframework.boot:spring-boot-starter-websocket' maven: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 6.2. 实现配置WebSocketMessageBrokerConfigurer接口WebSocketConfig.java 12345678910111213141516171819202122232425262728import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { // 配置客户端尝试连接地址 registry.addEndpoint(&quot;/ws&quot;).setAllowedOrigins(&quot;*&quot;); } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { // 设置广播节点 registry.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;); // 客户端向服务端发送消息需有/app 前缀 registry.setApplicationDestinationPrefixes(&quot;/app&quot;); // 指定用户发送（一对一）的前缀 /user/ registry.setUserDestinationPrefix(&quot;/user/&quot;); }} 6.3. 实现消息请求处理的ControllerWSController.java 123456789101112131415161718192021222324252627282930313233import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.handler.annotation.MessageMapping;import org.springframework.messaging.handler.annotation.Payload;import org.springframework.messaging.simp.SimpMessagingTemplate;import org.springframework.messaging.simp.annotation.SendToUser;import org.springframework.stereotype.Controller;@Controllerpublic class WSController { @Autowired private SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(&quot;/greeting&quot;) @SendToUser(&quot;/queue/serverReply&quot;) public String greating(@Payload String data) { System.out.println(&quot;received greeting: &quot; + data); String msg = &quot;server replys: &quot; + data; return msg; } @MessageMapping(&quot;/shout&quot;) public void userShout(Shout shout) { //String name = principal.getName(); String message = shout.getMessage(); System.out.println(&quot;收到的消息是：&quot; + message); simpMessagingTemplate.convertAndSend(&quot;/queue/notifications&quot;, shout); }} domain object Shout.java 12345678910111213public class Shout { private String message; public String getMessage() { return message; } public void setMessage(String message) { this.message = message; }} 6.4. 启动123456789101112131415161718192021222324import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) { return args -&gt; { System.out.println(&quot;application started&quot;); }; }} 6.5. 实现消息客户端index.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .newmessage { color: green; } .errormessage { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; id='urlInput' class=&quot;form-control&quot; placeholder='输入websocket端点'&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;reconnect();&quot;&gt;重新连接&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-8&quot; id=&quot;output&quot; style=&quot;border:1px solid #ccc;height:365px;overflow: auto;margin-left:15px&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; id='messageInput' class=&quot;form-control&quot; placeholder='待发信息'&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;doSend();&quot;&gt;发送&lt;/button&gt; &lt;/span&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;broadcast();&quot;&gt;广播&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var defaultUrl = &quot;ws://localhost:81/ws&quot; document.getElementById(&quot;urlInput&quot;).value = defaultUrl; var stomp; var appendMessage = function (msg) { var div = &quot;&lt;div class='newmessage'&gt;&quot; + msg + &quot;&lt;/div&gt;&quot;; $(&quot;#output&quot;).append(div); } var reportError = function (msg) { var div = &quot;&lt;div class='errormessage'&gt;&quot; + msg + &quot;&lt;/div&gt;&quot;; $(&quot;#output&quot;).append(div); } function connects(url) { var promise = new Promise(function (resolve, reject) { var client = Stomp.client(url); var headers = { username: 'admin', password: 'admin', // additional header 'client-id': 'stomp-client-id' }; appendMessage('connecting to ' + url) client.connect(headers, function (frame) { resolve(client); }, function (error) { reject(error) }); }); return promise; } var connect_callback = function (client) { stomp = client appendMessage('subscribing on ' + '/queue/subscribe') client.subscribe('/user/queue/serverReply', function (message) { console.log('subscribe topic callback:' + message.body); appendMessage('subscribe topic callback:' + message.body) }); appendMessage('subscribing on ' + '/user/queue/notifications') client.subscribe(&quot;/queue/notifications&quot;, function (message) { var content = message.body; var obj = JSON.parse(content); console.log(&quot;收到广播消息：&quot; + message.body); appendMessage(&quot;收到广播消息：&quot; + message.body); }); var payload = JSON.stringify({ 'message': 'greeting to stomp broker!' }); client.send(&quot;/app/greeting&quot;, {}, payload); }; var error_callback = function (error) { reportError(&quot;连接失败!&quot;); }; var doSend = function () { var msg = document.getElementById(&quot;messageInput&quot;).value var payload = JSON.stringify({ 'message': msg }); stomp.send(&quot;/app/greeting&quot;, {}, payload); } var broadcast = function () { var msg = document.getElementById(&quot;messageInput&quot;).value var payload = JSON.stringify({ 'message': msg }); stomp.send(&quot;/app/shout&quot;, {}, payload); } function reconnect() { if (stomp) { stomp.disconnect(function () { console.log(&quot;See you next time!&quot;); }) } connects(document.getElementById(&quot;urlInput&quot;).value).then(connect_callback).catch(error_callback) } reconnect();&lt;/script&gt;&lt;/html&gt; 7. 相关文章本技术博客原创文章位于鹏叔的技术博客 - java实现websocket的五种方式, 要获取最近更新请访问原文. 更多技术博客请访问: 鹏叔的技术博客 更新: 2023/04/14 上面所讲的都是关于Java程序作为服务端与前端通信. 在Websocket完整体系中还缺少了一块, 那就是服务端向客户端推送消息, 这时候则需要java作为客户端, 这里我写了一个java程序作为webSocket客户端的例子, 而不是将服务器代码耦合在WSController中, 希望我的这篇文章对您有所帮助使用stomp的java客户端向前端推送数据 8. 参考文档websocket - spring boot 集成 websocket 的四种方式 websocket在线调试工具 JAVA实现WebSocket服务器 让网络编程更轻松和有趣 t-io tio-websocket-spring-boot-starter 的简单使用 STOMP原理与应用开发详解 Spring消息之STOMP WebSocket详解：技术原理、代码演示和应用案例 WebSocket 是什么原理？为什么可以实现持久连接","link":"/java/spring_websocket.html"},{"title":"使用stomp实现服务器端向web客户端推送数据","text":"1. 前言在上篇文章java实现websocket的五种方式, 我详细讲述了使用java实现websocket的五种方式.五种方式都集中在服务器端的实现, 客户端我们使用的是一个在线测试工具进行测试的. 只有针对stomp这种方式我自己写了一个javascript版本的客户端. 但是随着项目的推进, 发现整个体系就像魔方或拼图一样, 在完整体系中还缺少了一块, 那就是java客户端去连接stomp websocket服务. 其作用是,在服务器端主动向客户端发送消息时, 通过stomp客户端连接stomp websocket服务, 将消息发布到某个topic, 最终被订阅消息的前端页面接收到. 三者之间的关系 java client -&gt; stomp websocket服务 -&gt; 前端页面. 采用的是消息订阅模式, 消息订阅并不是pull, 实际是push. 2. 目标编写并配置一个stomp java client, 实现在服务器端程序任何一个需要向前端发送消息位置通过客户端, 而非与stomp websocket服务器端程序耦合的方式向前端发送消息. 3. 实现思路 首先需要stomp client相关依赖 构建stomp java client 发送消息到特定通道 利用stomp本身的消息传输机制传递到客户端 4. 引入相关依赖12345678plugins { id 'java' id 'org.springframework.boot' version '2.7.7' id 'io.spring.dependency-management' version '1.0.15.RELEASE' id 'application'}implementation 'org.springframework.boot:spring-boot-starter-websocket' 5. 构建stomp java client12345678910111213141516171819202122232425262728293031323334353637383940414243import java.net.URI;import java.util.Scanner;import org.springframework.messaging.converter.MappingJackson2MessageConverter;import org.springframework.messaging.simp.stomp.StompHeaders;import org.springframework.messaging.simp.stomp.StompSession;import org.springframework.messaging.simp.stomp.StompSessionHandler;import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;import org.springframework.web.socket.client.standard.StandardWebSocketClient;import org.springframework.web.socket.messaging.WebSocketStompClient;public class StompClient { public static void main(String[] args) throws Exception { WebSocketStompClient stompClient = new WebSocketStompClient(new StandardWebSocketClient()); stompClient.setMessageConverter(new MappingJackson2MessageConverter()); // 接收大小限制 stompClient.setInboundMessageSizeLimit(1024 * 1024); // 处理心跳 ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler(); taskScheduler.afterPropertiesSet(); // for heartbeats stompClient.setTaskScheduler(taskScheduler); StompSessionHandler customHandler = new CustomStompSessionHandler(); // 可以发送请求头 StompHeaders stompHeaders = new StompHeaders(); stompHeaders.add(&quot;username&quot;, &quot;admin&quot;); stompHeaders.add(&quot;password&quot;, &quot;admin1&quot;); URI uri = URI.create(&quot;ws://localhost:81/ws&quot;); StompSession session = stompClient.connect(uri, null, stompHeaders, customHandler).get(); // Don't close immediately. Scanner scanner = new Scanner(System.in); while (true) { System.out.print( &quot;userXyz &gt;&gt; &quot;); System.out.flush(); String userinput = scanner.nextLine(); ClientMessage message = new ClientMessage(&quot;userXyz&quot;, userinput); session.send(&quot;/app/shout&quot;, message); } }} 实现思路, 首先需要通过连接websocket服务器建立连接, 建立连接之前需要构建stompclient, 而构建stomclient又要依赖StandardWebSocketClient去连接webscoket server建立连接时需要连接websocket的Endpoint即ws://localhost:81/ws. 连接建立成功后会返回session, 通过session对象就可以与服务端通讯了.在连接服务器时我们还有传递一个StompSessionHandler负责处理连接异常, 传输异常, 以及连接建立后subsrible相应的channel. 本例中我们构建了一个简单的StompSessionHandler, 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.springframework.messaging.simp.stomp.*;import java.lang.reflect.Type;public class CustomStompSessionHandler extends StompSessionHandlerAdapter { public CustomStompSessionHandler(){ } @Override public void afterConnected(final StompSession session, StompHeaders connectedHeaders) { System.out.println(&quot;StompHeaders: &quot; + connectedHeaders.toString()); //订阅地址，发送端前面没有/user String destination = &quot;/queue/notifications&quot;; //订阅消息 session.subscribe(destination, new StompFrameHandler() { @Override public Type getPayloadType(StompHeaders headers) { return byte[].class; } @Override public void handleFrame(StompHeaders headers, Object payload) { //todo 只能接收到byte[]数组，没时间研究原因 System.out.println(new String((byte[])payload)); } }); } @Override public void handleException(StompSession session, StompCommand command, StompHeaders headers, byte[] payload, Throwable exception) { System.out.println(exception.getMessage()); } @Override public void handleTransportError(StompSession session, Throwable exception) { exception.printStackTrace(); System.out.println(&quot;transport error.&quot;); }} 6. 通过客户端向前端发送消息上一节我们通过stompclient与服务器端建立了连接, 获得了session对象, 通过session对象, 我们就可以向服务器端相应的channel发送消息,服务器端可以将消息转发消息到相应的web客户端, 这样就实现了端到端的webscoket通信. 完整代码可以参考上一节中main方法的最后几行.这里重点摘抄其中的核心代码进行讲解. 123String userinput = scanner.nextLine();ClientMessage message = new ClientMessage(&quot;userXyz&quot;, userinput);session.send(&quot;/app/shout&quot;, message); 在发送对象的使用还需要做序列化处理, 此处我们使用一个通用的message converter即MappingJackson2MessageConverter. 1stompClient.setMessageConverter(new MappingJackson2MessageConverter()); 此处的ClientMessage是一个自定义对象, 为了节省大家动手的时间, 这里将代码附在下面. 这里将消息发送到了一个广播channel.当然如果要向特定客户端发送消息, 还要在服务端设计相应的转发机制, 然后发送到特定的channel. 由于本篇文章的主要目的是讲解stomp java客户端发送消息, 为了使得简化目的, 没有使得案例更复杂, 有兴趣的读者可以在此基础上进行改进. ClientMessage.java 12345678910111213141516171819202122232425262728293031public class ClientMessage { private String from; private String message; public ClientMessage() { } public ClientMessage(String from, String text) { this.from = from; this.message = text; } public String getFrom() { return from; } public void setFrom(String from) { this.from = from; } public String getMessage() { return message; } public void setMessage(String text) { this.message = text; }} 7. 参考文章使用stomp的java客户端接收websocket数据 Spring Boot + WebSocket With STOMP Tutorial Spring Websocket 中文文档 Java WebSocketStompClient类代码示例","link":"/java/websocket_java_client.html"},{"title":"Helm 应用升级与回滚","text":"在本教程中，我们首先会使用helm部署一个mysql实例，然后尝试升级mysql到更高版本，并魔力升级出错后回滚该次升级。 部署mysql实例123456789101112131415161718[root@master ~]# helm install stable/mysql -n bdqn-mysql --set mysqlRootPassword=123.com #创建实例，并设置密码[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEbdqn-mysql-mysql-7b89c7b99-kg4wf 0/1 Init:0/1 0 17s #正在初始化[root@master ~]# kubectl get pvcNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGEbdqn-mysql-mysql Bound mysqlpv 8Gi RWO 48s#还需要一个小镜像docker pull busybox:1.25.0[root@master ~]# kubectl get podNAME READY STATUS RESTARTS AGEbdqn-mysql-mysql-7b89c7b99-kg4wf 1/1 Running 0 2m10s[root@master ~]# kubectl get deployments.NAME READY UP-TO-DATE AVAILABLE AGEbdqn-mysql-mysql 1/1 1 1 2m13s 查看密码是否设置成功： 12kubectl get secret --namespace default bdqn-mysql-mysql -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode; echo123.com 验证数据有没有问题[root@master ~]# kubectl exec -it bdqn-mysql-mysql-7b89c7b99-kg4wf – mysql -u root -p123.commysql&gt; show databases;+——————–+| Database |+——————–+| information_schema || mysql || performance_schema || sys |+——————–+4 rows in set (0.01 sec) 在部署mysql的时候，如何开启storageclass，以及如何使用？ 首先需要部署storageclass（存储类），让他可以自动创建PV 1、 需要基于NFS环境 2、RBAC权限 3、nfs-deployment. 4、storageclass 123456vim values.yaml 找到storageClass，去掉注释即可 storageClass: &quot;test-nfs&quot; #storageclass的名称 accessMode: ReadWriteOnce size: 8Gi 123456[root@master mysql]# helm install stable/mysql -n bdqn-mysql --set mysqlRootPassword=123.com -f values.yaml[root@master mysql]# kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEbdqn-mysql-mysql NodePort 10.104.45.139 &lt;none&gt; 3306:30165/TCP 13mkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 60d 升级mysql1234567[root@master mysql]# helm upgrade --set imageTag=5.7.15 bdqn-mysql stable/mysql -f values.yaml[root@master mysql]# kubectl get deployments. -o wideNAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORzhb-mysql 1/1 1 1 9m22s zhb-mysql mysql:5.7.15 app=zhb-mysql 回滚12345678910111213#查看有哪些版本[root@master mysql]# helm history zhbREVISION UPDATED STATUS CHART DESCRIPTION 1 Mon Mar 2 16:33:26 2020 SUPERSEDED mysql-0.3.5 Install complete2 Mon Mar 2 16:37:04 2020 DEPLOYED mysql-0.3.5 Upgrade complete回滚到1版本[root@master mysql]# helm rollback zhb 1Rollback was a success.[root@master mysql]# kubectl get deployments. -o wideNAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORzhb-mysql 1/1 1 1 13m zhb-mysql mysql:5.7.14 app=zhb-mysql","link":"/k8s/helm_release_upgrade_and_rollback.html"},{"title":"如何安装 helm 命令行工具","text":"本指南介绍如何安装 Helm CLI。 Helm 项目提供了两种获取和安装 Helm 的方法。从源代码或预构建的二进制版本安装，这些是获取 Helm 版本的官方方法。除此之外，Helm 社区还提供了通过不同包管理器安装 Helm 的方法。通过这些方法进行安装的方法可以在官方方法下方找到。 1. 确定版本首先到 helm Github repository Release History 确定你要安装的版本。目前最新的是 3.15.4。 2. 安装 Helm安装过程中可能需要魔法，魔法可以去我的博客站 - 鹏叔的技术博客上找。 2.2. 二进制文件安装Helm 的每个 版本都为各种操作系统提供了二进制版本。这些二进制版本可以手动下载和安装。 12345678# 下载您 想要的版本wget -O /tmp/helm-v3.15.4-linux-amd64.tar.gz https://get.helm.sh/helm-v3.15.4-linux-amd64.tar.gz# 解压 tar -zxvf /tmp/helm-v3.15.4-linux-amd64.tar.gz -C /tmp/helm-v3.15.4# helm在解压的目录中找到二进制文件，并将其移动到所需目标位置mv /tmp/helm-v3.15.4/helm /usr/local/bin/helm 使用自动化脚本安装Helm 现在有一个安装程序脚本，它将自动获取最新版本的 Helm 并在本地安装。 你可以获取该脚本，然后在本地执行它。它有详尽的文档，因此您可以在运行它之前通读它并了解它在做什么。 12345curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3chmod 700 get_helm.sh./get_helm.sh 2.1. 使用包管理工具安装 Helm2.1.1. Windows 上安装 Helm使用 Chocolatey 安装 Helm 社区成员 为 Chocolatey 贡献了一个 Helm 软件包构建 。此软件包通常是最新的。 1choco install kubernetes-helm 使用 Scoop 安装 Helm 社区成员 为 Scoop 贡献了一个 Helm 软件包构建 。此软件包通常是最新的。 1scoop install helm 使用 Winget 安装Helm 社区成员 为 Winget 贡献了一个 Helm 软件包构建 。此软件包通常是最新的。 1winget install Helm.Helm 2.1.2. 在 macOS 上使用 Homebrew 安装 HelmHelm 社区成员向 Homebrew 贡献了 Helm formula 构建。此 formula 通常是最新的。 1brew install helm 2.1.3. Debian 系列 Linux 安装 HelmHelm 社区成员为 Apt 贡献了一个 Helm 包。此包通常是最新的。 1234567curl https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg &gt; /dev/nullsudo apt-get install apt-transport-https --yesecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main&quot; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.listsudo apt-get updatesudo apt-get install helm 2.1.4. Redhat 系列 Linux 安装 Helm从 Fedora 35 开始，helm 可在官方存储库中使用。你可以使用以下命令安装 helm 1sudo dnf install helm 使用 snap 包管理器安装Snapcrafters 社区维护 Helm 包的 Snap 版本 ： 1sudo snap install helm --classic 使用 pkg 安装 (FreeBSD)FreeBSD 社区成员已向 FreeBSD Ports Collection 贡献了一个 Helm 软件包构建 。此软件包通常是最新的。 1pkg install helm 从源代码（Linux、macOS）从源代码构建 Helm 的工作量稍微大一些，但如果您想测试最新的（预发布）Helm 版本，这是最好的方法。 您必须有一个可以运行的 Go 环境。 123git clone https://github.com/helm/helm.gitcd helmmake 4. 配置 Helm准备好 Helm 后，您可以添加 Chart 存储库。 123helm repo add bitnami https://charts.bitnami.com/bitnami 安装完成后，您将能够列出可以安装的 Charts： 123456789$ helm search repo bitnamiNAME CHART VERSION APP VERSION DESCRIPTIONbitnami/bitnami-common 0.0.9 0.0.9 DEPRECATED Chart with custom templates used in ...bitnami/airflow 8.0.2 2.0.0 Apache Airflow is a platform to programmaticall...bitnami/apache 8.2.3 2.4.46 Chart for Apache HTTP Serverbitnami/aspnet-core 1.2.3 3.1.9 ASP.NET Core is an open-source framework create...# ... and many more 5. 验证 Helm 配置配置完成后，可以尝试部署一个 mysql release。 可以运行 helm install 命令。Helm 有几种查找和安装 Chart 的方法，但最简单的方法是使用 bitnami chart 库。 1234567891011$ helm repo update # Make sure we get the latest list of charts$ helm install bitnami/mysql --generate-nameNAME: mysql-1612624192LAST DEPLOYED: Sat Feb 6 16:09:56 2021NAMESPACE: defaultSTATUS: deployedREVISION: 1TEST SUITE: NoneNOTES: ... 在上面的例子中，bitnami/mysql chart 已经发布，我们新发布的名称是 mysql-1612624192。 通过运行，您可以简单了解此 MySQL chart 的功能 helm show chart bitnami/mysql。或者您可以运行 helm show all bitnami/mysql 以获取有关 chart 的所有信息。 每当您安装一个 chart 时，都会创建一个新版本。因此，一个图表可以多次安装到同一个集群中。并且每个图表都可以独立管理和升级。 结论在大多数情况下，安装就像获取预构建的 helm 二进制包一样简单。本文档为那些想要使用 Helm 做更复杂事情的人介绍了更多案例。 成功安装 Helm 客户端后，您可以继续使用 Helm 管理图表并 添加稳定的 repo。","link":"/k8s/install_helm_3.html"},{"title":"Helm v3 命令详解","text":"Helm 是云原生领域最火热的应用管理工具。众所周知 Kubernetes 是自动化的容器管理平台，然而 Kubernetes 并没有抽象出应用的概念，通常应用的描述是非常复杂的，一个应用可能是由多种资源组成。 我们通过多次 kubectl apply -f 上述资源，但是后续无法有效管理应用所包含的资源。这也正是 Helm 要解决的难题，更好地帮助用户定义、部署以及管理应用。 1. helm version12345# 查看版本$ helm versionversion.BuildInfo{Version:&quot;3.15.4&quot;, GitCommit:&quot;fa9efb07d9d8debbb4306d72af76a383895aa8c4&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.22.6&quot;} 12345# 查看短版本$ helm version --short3.15.4+gfa9efb0 2. helm help123456789101112查看命令行帮助，有以下几种方式：helmhelm helphelm help [command]helm -h(常用)helm --helphelm [command] -h(常用)helm [command] -helphelm [command] [sub command] -h(常用)helm [command] [sub command] -help查看命令行帮助。 3. helm env12345678910111213141516171819202122232425$ helm envHELM_BIN=&quot;helm&quot;HELM_BURST_LIMIT=&quot;100&quot;HELM_CACHE_HOME=&quot;/home/your_id/.cache/helm&quot;HELM_CONFIG_HOME=&quot;/home/your_id/.config/helm&quot;HELM_DATA_HOME=&quot;/home/your_id/.local/share/helm&quot;HELM_DEBUG=&quot;false&quot;HELM_KUBEAPISERVER=&quot;&quot;HELM_KUBEASGROUPS=&quot;&quot;HELM_KUBEASUSER=&quot;&quot;HELM_KUBECAFILE=&quot;&quot;HELM_KUBECONTEXT=&quot;&quot;HELM_KUBEINSECURE_SKIP_TLS_VERIFY=&quot;false&quot;HELM_KUBETLS_SERVER_NAME=&quot;&quot;HELM_KUBETOKEN=&quot;&quot;HELM_MAX_HISTORY=&quot;10&quot;HELM_NAMESPACE=&quot;default&quot;HELM_PLUGINS=&quot;/home/your_id/.local/share/helm/plugins&quot;HELM_QPS=&quot;0.00&quot;HELM_REGISTRY_CONFIG=&quot;/home/your_id/.config/helm/registry/config.json&quot;HELM_REPOSITORY_CACHE=&quot;/home/your_id/.cache/helm/repository&quot;HELM_REPOSITORY_CONFIG=&quot;/home/your_id/.config/helm/repositories.yaml&quot; 4. Helm repo4.1. 增加仓库增加仓库，以下命令为增加 helm 官方 stable 仓库，命令中 stable 为仓库名称，链接为仓库的 Chart 清单文件地址。当增加仓库时，Helm 会将仓库的 Chart 清单文件下载到本地并存放到 Kubernetes 中，以后 helm search、install 和 pull 等操作都通过仓库名称到 Kubernetes 中查找该仓库相关的 Chart 包。可以注意到官方的 stable 仓库的地址和 Helm Hub 地址是不同的，两者是独立存在的，stable 仓库只是众多公共仓库之一，但是是 Helm 官方提供的。 1234# helm repo addhelm repo add stable https://charts.helm.sh/stable 以下为官方 stable 仓库的清单文件，地址https://charts.helm.sh/stable。可以看出就是一个个 Chart 包的信息，按照字母顺序排列，而且只到 D 开头的 Chart 包，所有 Chart 清单应该分片为多个清单文件，应该多次请求才能全部下载下来。也可以直接访问https://charts.helm.sh/stable/ambassador-5.3.1.tgz将 tgz 包下载下来。 以下为几个常用的仓库的添加命令。 123456helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.comhelm repo add bitnami https://charts.bitnami.com/bitnamihelm repo add aliyuncs https://apphub.aliyuncs.comhelm repo add kong https://charts.konghq.com 12345678910$ helm repo list查看加到本地的仓库列表$ helm repo listNAME URLstable https://charts.helm.sh/stablealiyuncs https://apphub.aliyuncs.combitnami https://charts.bitnami.com/bitnamiincubator https://kubernetes-charts-incubator.storage.googleapis.comkong https://charts.konghq.com Helm v3 取消了 v2 的 local repo，Helm v3 本地增加的仓库列表存放在/root/.config/helm/repositories.yaml 1cat /root/.config/helm/repositories.yaml 仓库的 Chart 清单应该是存储在 Kubernetes 的 etcd 中，但在/root/.cache/helm/repository 存储了备份。下载的 Chart 包也缓存在该目录下 1234$ ls /root/.cache/helm/repositoryaliyuncs-index.yaml bitnami-index.yaml kong-index.yaml nginx-5.1.4.tgz tomcat-6.1.3.tgzambassador-6.1.1.tgz incubator-index.yaml mysql-1.6.2.tgz stable-index.yaml 移除本地仓库 12345$ helm repo removehelm repo remove kong&quot;kong&quot; has been removed from your repositories 更新本地仓库 1234567891011# helm repo update$ helm repo updateHang tight while we grab the latest from your chart repositories......Successfully got an update from the &quot;kong&quot; chart repository...Successfully got an update from the &quot;incubator&quot; chart repository...Successfully got an update from the &quot;aliyuncs&quot; chart repository...Successfully got an update from the &quot;bitnami&quot; chart repository...Successfully got an update from the &quot;stable&quot; chart repositoryUpdate Complete. ⎈ Happy Helming!⎈ 5. helm search查询 Chart 包，查询命令分为 helm search hub 和 helm search repo。 helm search hub 搜索Artifact Hub，其中列出了来自数十个不同存储库的 helm Chart。 helm search repo，从所有加到本地的仓库中查找应用，这些仓库加到本地时 Chart 清单文件已被存放到 Kubernetes 中，所以查找应用时无需联网。 从 Helm Hub 中查询 Chart，而且只展示最新 Chart 版本。 123helm search hub elasticsearch 从本地的仓库列表中查询 Chart，而且只展示 Chart 最新版本。注意 Chart 包本身有版本号，区别于 Chart 包中应用的版本号。 1234567$ helm search repo elasticsearchNAME CHART VERSION APP VERSION DESCRIPTIONelastic/elasticsearch 7.15.0 7.15.0 Official Elastic helm chart for Elasticsearchelastic/eck-operator 1.8.0 1.8.0 A Helm chart for deploying the Elastic Cloud on...elastic/eck-operator-crds 1.8.0 1.8.0 A Helm chart for installing the ECK operator Cu... 查询某个特定 Chart 版本 123$ helm search repo elasticsearch --version &quot;6.8.18&quot;NAME CHART VERSION APP VERSION DESCRIPTIONelastic/elasticsearch 6.8.18 6.8.18 Official Elastic helm chart for Elasticsearch 查询所有 Chart 版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100$ helm search repo elasticsearch --versionsNAME CHART VERSION APP VERSION DESCRIPTIONelastic/elasticsearch 7.15.0 7.15.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.14.0 7.14.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.4 7.13.4 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.3 7.13.3 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.2 7.13.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.1 7.13.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.0 7.13.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.12.1 7.12.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.12.0 7.12.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.11.2 7.11.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.11.1 7.11.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.2 7.10.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.1 7.10.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.0 7.10.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.3 7.9.3 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.2 7.9.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.1 7.9.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.0 7.9.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.8.1 7.8.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.8.0 7.8.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.7.1 7.7.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.7.0 7.7.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.2 7.6.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.1 7.6.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.0 7.6.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.2 7.5.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.1 7.5.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.0 7.5.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.4.1 7.4.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.4.0 7.4.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.3.2 7.3.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.3.0 7.3.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.2.0 7.2.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.1.1 7.1.1 Elasticsearchelastic/elasticsearch 7.1.0 7.1.0 Elasticsearchelastic/elasticsearch 6.8.18 6.8.18 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.17 6.8.17 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.16 6.8.16 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.15 6.8.15 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.14 6.8.14 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.13 6.8.13 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.12 6.8.12 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.11 6.8.11 Official Elastic helm chart for Elasticsearch...查询某个范围的Chart版本，以下要求Chart版本号大于等于1.0.0。```bash$ helm search repo elasticsearch --version &quot;&gt;=6.8.0&quot; --versionsNAME CHART VERSION APP VERSION DESCRIPTIONelastic/elasticsearch 7.15.0 7.15.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.14.0 7.14.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.4 7.13.4 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.3 7.13.3 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.2 7.13.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.1 7.13.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.13.0 7.13.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.12.1 7.12.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.12.0 7.12.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.11.2 7.11.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.11.1 7.11.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.2 7.10.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.1 7.10.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.10.0 7.10.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.3 7.9.3 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.2 7.9.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.1 7.9.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.9.0 7.9.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.8.1 7.8.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.8.0 7.8.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.7.1 7.7.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.7.0 7.7.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.2 7.6.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.1 7.6.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.6.0 7.6.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.2 7.5.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.1 7.5.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.5.0 7.5.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.4.1 7.4.1 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.4.0 7.4.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.3.2 7.3.2 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.3.0 7.3.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.2.0 7.2.0 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 7.1.1 7.1.1 Elasticsearchelastic/elasticsearch 7.1.0 7.1.0 Elasticsearchelastic/elasticsearch 6.8.18 6.8.18 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.17 6.8.17 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.16 6.8.16 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.15 6.8.15 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.14 6.8.14 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.13 6.8.13 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.12 6.8.12 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.11 6.8.11 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.10 6.8.10 Official Elastic helm chart for Elasticsearchelastic/elasticsearch 6.8.9 6.8.9 Official Elastic helm chart for Elasticsearch 6. helm pull将 Chart 包下载到本地，缺省下载的是最新的 Chart 版本，并且是 tgz 包。 1234567891011121314151617181920212223242526272829303132333435# 先查询Chart，选择一个合适的Chart。$ helm search repo charts_name# 拉取Chart包。$ helm pull repo/chart_name$ lsname-version.tgz# 可以解压Chart包。tar zxvf name-version.tgz# 拉取指定版本。$ helm pull bitnami/tomcat --version 2.2.2$ lstomcat-2.2.2.tgz## 拉取Chart包后直接解压为目录，而不是tgz包。$ helm pull bitnami/tomcat --untar$ lstomcat# 直接从URL下拉Chart包。$ helm pull https://charts.helm.sh/stable/ambassador-5.3.1.tgz$ lsambassador-5.3.1.tgz# 拉取Chart包到指定路径。$ helm pull stable/kong -d /root/helm/$ ls /root/helm/kong-0.36.6.tgz 7. helm install安装应用，也就是部署一 Chart Release 实例。缺省安装最新 Chart 版本。其中 my-web 为 Release 名称，–set 配置会覆盖 Chart 的 values。Chart values 其它文档专门介绍。 有五种安装 Chart 的方式。 Chart Reference：helm install myweb bitnami/tomcat Chart Reference 表示为[Repository]/[Chart]，如 bitnami/tomcat，Helm 将在本地配置中查找名为 bitnami 的 Chart 仓库，然后在该仓库中查找名为 tomcat 的 Chart。 2.Chart 包路径：helm install myweb ./tomcat-6.1.3.tgz3.Chart 包目录：helm install myweb ./tomcat4.URL 绝对路径：helm install myweb https://charts.bitnami.com/bitnami/tomcat-6.1.3.tgz 5.仓库 URL 和 Chart Reference：helm install --repo https://charts.bitnami.com/bitnami/ myweb tomcat 安装特定 Chart 版本应用。 12helm install myweb bitnami/tomcat --version 6.0.0 将应用安装到某一命名空间，不同的命名空间 Release 名称可以相同 123456kubectl create namespace web-nshelm install myweb bitnami/tomcat -n web-nshelm list -n web-ns 安装应用时，如果要覆盖 Chart 中的值，可以使用–set 选项并从命令行传递配置。若要强制–set 指定的值为字符串，请使用–set-string。–set 和–set-string 支持重复配置，后面(右边)的值优先级更高。 1234helm install myweb bitnami/tomcat \\ --set service.type=NodePort \\ --set persistence.enabled=false 1234# 也可以将key=values对配置在文件中，可以通过-f或者–values指定覆盖的values文件。-f或者–values支持重复指定，后面(右边)的值优先级更高。$ helm install myweb bitnami/tomcat -f ./values.yaml 如果一个值很大或者占用多行，很难使用–values 或–set，可以使用–set-file 从文件中读取单个大值。 12helm install myweb bitnami/tomcat \\ --set-file podAnnotations=./tomcat-annotations.yaml 通过–dry-run 模拟安装应用，会输出每个模板生成的 yaml 内容，可查看将要部署的渲染后的 yaml，检视这些输出，判断是否与预期相符。 12345$ helm install my-web bitnami/tomcat \\ --dry-run \\ --set service.type=NodePort \\ --set persistence.enabled=false 通过设置–wait 参数，将等待所有 Pod、PVC 和 Service 以及 Deployment、StatefulSet 和 ReplicaSet 的最小 Pod 数都处于就绪状态后，然后才将 Release 标记为 deployed 状态，然后 install 命令行返回成功。等待–timeout 时间，–timeout 缺省为 5m0s。 12345helm install myweb bitnami/tomcat \\ --wait \\ --set service.type=NodePort \\ --set persistence.enabled=false 设置–timeout 参数，缺省为 5m0s。如果超过–timeout 还没有就绪，Release 状态将被标记为 failed，命令行返回值为 1，但并不会回退提交给 Kubernetes 的资源，所以安装不一定失败。如下载镜像时间过长，Release 的状态被置为 failed，但 Kubernetes 仍在会继续下载镜像，所以安装最终会成功，但 Release 不会被重置为 deployed。没有找到修改 Release 状态的命令。 1234567设置–atomic参数，如果安装失败，会自动清除Chart，相当于如果状态为failed时会回退所有操作，保持安装的原子性。当设置–atomic参数时，–wait参数会自动配置。helm install myweb bitnami/tomcat \\ --atomic --timeout=1m \\ --set service.type=NodePort \\ --set persistence.enabled=false 8. helm list列出 default 命名空间的 Release 列表，只显示状态为 deployed 或 failed 的 Release 123helm list 列出某一命名空间的 Release 列表 123helm list -n web-ns 列出所有命名空间的 Release 列表 123helm list --all-namespaces 列出所有的 Release 列表，不止包括状态为 deployed 或 failed 的 Release 123helm list -a 只列出所有状态为 deployed 的 Release 列表 123helm list --deployed 只列出所有状态为 uninstalled 的 Release 列表 123helm list --uninstalled 只列出所有状态为 failed 的 Release 列表。 123helm list --failed 只列出所有状态为 pending-install 的 Release 列表。 1234567# 在一个终端安装Chart，会花费一些时间。$ helm install myweb-4 bitnami/tomcat \\ --wait --timeout=10m \\ --set service.type=NodePort \\ --set persistence.enabled=false 在另一个终端执行如下命令，只列出正在安装的 Release 123helm list --pending 按照时间顺序由早到晚列出 Release 123helm list -d 按照时间顺序由晚到早列出 Release，-r 翻转排序。 123helm list -d -r 9. helm uninstall12345678910# 卸载应用，也就是删除Chart Release实例。$ helm uninstall myweb# 卸载某一命名空间的应用。$ helm uninstall myweb -n web-ns# 卸载应用，但保留历史记录，保留历史记录主要是为了回滚操作。$ helm uninstall myweb --keep-history 10. helm testChart 包含了很多 Kubernetes 资源，而且根据 values。Helm 支持编写测试用例来验证 Chart 是否按预期工作。测试用例也有助于 Chart 使用者了解 Chart 应该做什么。 测试用例在 Helm Chart 中的 templates/目录，是一个 pod 定义，指定一个的命令来运行容器。容器应该成功退出（exit 0），测试被认为是成功的。该 pod 定义必须包含 helm 测试 hook 注释之一：helm.sh/hook: test-success 或 helm.sh/hook: test-failure。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657helm install ambassador stable/ambassador \\ --set authService.create=false \\ --set rateLimit.create=false \\ --set adminService.type=NodePort \\ --set service.type=NodePorthelm pull stable/ambassador# 查看测试用例pod，helm test执行就是该pod。# 其实就是在容器执行命令：wget http://ambassador:80/ambassador/v0/check_readycat ambassador/templates/tests/test-ready.yaml{{- if not .Values.daemonSet }}apiVersion: v1kind: Podmetadata: name: &quot;{{ include &quot;ambassador.fullname&quot; . }}-test-ready&quot; labels: app.kubernetes.io/name: {{ include &quot;ambassador.name&quot; . }} helm.sh/chart: {{ include &quot;ambassador.chart&quot; . }} app.kubernetes.io/instance: {{ .Release.Name }} app.kubernetes.io/managed-by: {{ .Release.Service }} annotations: &quot;helm.sh/hook&quot;: test-successspec: containers: - name: wget image: busybox command: ['wget'] args: ['{{ include &quot;ambassador.fullname&quot; . }}:{{ include &quot;ambassador.servicePort&quot; . }}/ambassador/v0/check_ready'] restartPolicy: Never{{- end }}helm test ambassadorPod ambassador-test-ready pendingPod ambassador-test-ready pendingPod ambassador-test-ready pendingPod ambassador-test-ready succeededNAME: ambassadorLAST DEPLOYED: Wed Feb 12 12:56:51 2020NAMESPACE: defaultSTATUS: deployedREVISION: 1TEST SUITE: ambassador-test-readyLast Started: Wed Feb 12 13:10:24 2020Last Completed: Wed Feb 12 13:10:42 2020Phase: SucceededNOTES:Congratulations! You've successfully installed Ambassador.For help, visit our Slack at https://d6e.co/slack or view the documentation online at https://www.getambassador.io.To get the IP address of Ambassador, run the following commands: export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&quot;{.spec.ports[0].nodePort}&quot; services ambassador) export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&quot;{.items[0].status.addresses[0].address}&quot;) echo http://$NODE_IP:$NODE_PORT 测试时打印容器日志。 123helm test ambassador --logs 11. helm status1234567# 显示Release的状态。$ helm status myweb-2# 显示Release的某个修订版本的状态。$ helm status myweb-2 --revision 2 12. helm get1234567# 显示Release的所有的Kubernetes资源清单，注释标明了该资源生成于那个模板yaml文件。$ helm get manifest myweb# 显示Release的所涉及模板变量的值。$ helm get all myweb --template {{.Release.Name}} 13. helm create创建一个模板 Chart，会根据给定的 Chart 名称生成一个目录以及该 Chart 的一些样例文件。 我们可以使用 create 命令创建一个模板，然后根据该模板快速开发。 123456789101112131415161718192021222324helm create fooCreating foolsfootree foofoo├── charts├── Chart.yaml├── templates│ ├── deployment.yaml│ ├── _helpers.tpl│ ├── ingress.yaml│ ├── NOTES.txt│ ├── serviceaccount.yaml│ ├── service.yaml│ └── tests│ └── test-connection.yaml└── values.yaml3 directories, 9 files 14. helm show显示 Chart 包的各种信息，Chart 包中的 Chart.yaml, values.yaml 和 README.md 文件包含了 Chart 重要关键信息，可以通过 helm show 命令行显示这些文件的内容，方便了解 Chart 关键内容。 显示 Chart.yaml 信息，该文件描述了 Chart 的版本，描述，开发者等信息。 123456789101112131415161718192021222324helm show chart bitnami/tomcatapiVersion: v1appVersion: 9.0.30description: Chart for Apache Tomcathome: http://tomcat.apache.orgicon: https://bitnami.com/assets/stacks/tomcat/img/tomcat-stack-110x117.pngkeywords:- tomcat- java- http- web- application server- jspmaintainers:- email: containers@bitnami.com name: Bitnaminame: tomcatsources:- https://github.com/bitnami/bitnami-docker-tomcatversion: 6.1.3--- 显示 values.yaml 信息，该文件描述了 Chart 模板中各个可以覆盖的参数，这些参数都可以在安装 Chart 时被命令行参数覆盖。 1234567891011121314151617181920helm show values bitnami/tomcat## Global Docker image parameters## Please, note that this will override the image parameters, including dependencies, configured to use the global value## Current available global Docker image parameters: imageRegistry and imagePullSecrets### global:# imageRegistry: myRegistryName# imagePullSecrets:# - myRegistryKeySecretName# storageClass: myStorageClass## Bitnami Tomcat image version## ref: https://hub.docker.com/r/bitnami/tomcat/tags/##image: registry: docker.io repository: bitnami/tomcat tag: 9.0.30-debian-9-r9 15. helm template渲染 Chart 模板并打印输出，并不实际安装。和 helm get manifest 类似。 123helm template myweb bitnami/tomcat \\ --set service.type=NodePort \\ --set persistence.enabled=false 16. helm dependency123456789101112# 管理Chart依赖。helm dependency list# 列出Chart申明的所有依赖的列表。helm dependency update# 更新Chart申明的所有依赖符合要求的最新版本，更新的依赖的tgz包文件会放到charts路径下。更新之前会先更新所有的仓库。ls kong/charts/postgresqlhelm dependency update kong 17. helm lintHelm 运行一系列测试以验证 Chart 格式是否正确。如果遇到会导致 Chart 安装失败的事件，将发出[ERROR]消息。如果遇到违反约定或推荐的问题，将发出[WARNING]消息。 1234helm lint tomcat/==&gt; Linting tomcat/1 chart(s) linted, 0 chart(s) failed 18. helm package将目录结构的 Chart 打包成带版本号 tgz 格式的 Chart 包。和 helm repo index 配合用来搭建私有仓库。 12345678910helm pull bitnami/tomcat --untar --version 6.1.6lstomcathelm package tomcatSuccessfully packaged chart and saved it to: /root/helm/tomcat-6.1.6.tgzlstomcat tomcat-6.1.6.tgz 在打包时，设置覆盖的 values，此时 Chart 包中 values.yaml 文件对应的 key 的键值会被自动替换为命令行中的 values。 123helm package tomcat \\ --set service.type=NodePort \\ --set persistence.enabled=false 19. 参考文档Helm 最详细的命令大全 helm v3 使用指南|常见命令行(2)","link":"/k8s/helm_v3_cli_explanation.html"},{"title":"Vultr 上快速搭建 kubernetes 集群","text":"上前天获得了 https://www.vultr.com 300 美金的试用金，限期 1 个月。。 这两天一直在琢磨如何把这 300 美金霍霍完，免得过期浪费。于是把之前一些好玩的东西从家里的服务器迁移到了 Vultr 上，前天用 Vultr vps 搭建了一个了一个 WEB IDE, 过程记录在这篇文章里Vultr + Code-server 自建 Cloud IDE。 昨天在 Vultr VPS 上使用 wordpress 搭建了一个博客，详情参考这篇文章 Vultr 部署 Wordpress 博客 申请过程参考这篇文章 快速注册 Vultr 账号以及创建 Vultr VPS 今天用在 Vultr 上搭建了一个 k8s 集群，三年前也搭建过一个 k8s 集群, 但是那是在家里的电脑上使用 VMWare 虚拟机搭建的，详情参看这篇文章 创建 kubernetes 集群，当时还是刀耕火种的年代，搭建 k8s 基本靠一条一条名令敲出来的，市面上的公有云搭建 k8s 集群跟手动搭建工作量差不了太多，当时的公有云平台只是搭建好以后，管理 k8s 集群比较直观，但是创建集群的过程还是不够自动化。中间还遇到 google 的一些容器镜像被强的问题，还是手动下载镜像解决得，那叫一个痛苦，不过当时也是为了学习 k8s, 整个搭建过程对 k8s 还是有了很深刻的认识。 今天试验了一下在 vultr 上创建集群，感觉创建集群的过程进步好多。主要得益于他家的 VKE(Vultr kubernetes Engine), 将整个过程自动化了，安全性方面也做了一些增强。 之前公有云上创建 k8s 集群，价格也老贵，基本是创建完成后，用几天就销毁了。现在在公有云平台上创建 k8s 集群基本是能够负担得起的价格了。 目前试用金，还剩 290 多美刀，后续打算将之前折腾的一个大语言模型搬到 Vultr 上，关注我的博客，鹏叔将利用这波优惠，继续探索一些好玩的东西。 1. 申请 Vultr 账号注册并创建 Vultr 主机可以参考我的文章 快速注册 Vultr 账号以及创建 Vultr VPS, 注意：Vultr 普通注册只会获得 100 美金的试用金，使用活动链接注册可以赠送 300 美金，https://www.vultr.com/?ref=9645837。 2. 创建 kubernetes 集群登录到 Vultr 账号，以访问其控制面板。在 Vultr 控制面板页面，选择 Product，点击 Kubernetes 选项，点击 add cluster 进入 kubernetes 集群创建页面。 填写 Kubernetes 集群名称、依次选择 Kubernetes 版本和集群位置。 集群位置，亚洲地区可以选择，首尔、东京、新加坡 为集群设置标签，选择集群节点数量，选择节点类型;选择 plan, 这里选择的是 2U2G 的 60G 的一个 plan;设置完毕后，单击“Deploy Now”立即部署按钮。 集群创建可能需要 3-5 分钟 一旦 Kubernetes 集群准备就绪，集群状态会变成 Running，此时点击右边的”…”按钮，然后点击 manage 菜单进入集群管理界面。 下载配置文件，将其保存到用户目录下的.kube 文件夹下，并将其命名为 config 启动终端，并运行以下命令查看其状态。 如果电脑没有安装 kubectl ，可以参考这篇文章进行安装如何安装 kubectl 命令行工具 123456789101112131415161718192021222324252627$ kubectl get pods -A# 或者, 如果没有将配置文件命名为configkubectl –kubeconfig=/path/to/kube_config.yaml get pods -ANAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-kube-controllers-68865dfcb6-l2j9g 1/1 Running 0 17mkube-system calico-node-8xq2l 1/1 Running 0 17mkube-system calico-node-dhh4l 1/1 Running 0 17mkube-system calico-node-jfs2z 1/1 Running 0 17mkube-system calico-node-smgh4 1/1 Running 0 17mkube-system cluster-autoscaler-74dcd4ff67-ns6jn 1/1 Running 0 16mkube-system coredns-7ddfc8768d-p89ww 1/1 Running 0 16mkube-system csi-vultr-controller-0 4/4 Running 0 16mkube-system csi-vultr-node-cshtd 2/2 Running 0 16mkube-system csi-vultr-node-fbgsw 2/2 Running 0 16mkube-system csi-vultr-node-gxvzx 2/2 Running 0 16mkube-system csi-vultr-node-kbjtb 2/2 Running 0 16mkube-system konnectivity-agent-fhz4t 1/1 Running 0 16mkube-system konnectivity-agent-hbgr6 1/1 Running 0 16mkube-system konnectivity-agent-r6jkx 1/1 Running 0 16mkube-system konnectivity-agent-s68lv 1/1 Running 0 16mkube-system kube-proxy-8djsl 1/1 Running 0 16mkube-system kube-proxy-dxnlj 1/1 Running 0 16mkube-system kube-proxy-k7dbl 1/1 Running 0 16mkube-system kube-proxy-n9p9n 1/1 Running 0 16m 3. 部署 Nginx pod部署 nginx pods 测试 k8s 集群 3.1. 部署一个 nginx deploymentnginx pod 的配置文件 nginx-pod.yml： 123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: selector: matchLabels: app: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:alpine ports: - containerPort: 80 其中配置项： image：用于指定 nginx 容器使用的镜像containerPort：容器内部监听端口，有关 k8s 各种 port 的使用，可以参考 链接使用命令 kubectl apply 创建 pod： 1kubectl apply -f nginx-pod.yml 3.2. 创建 NodePort service使用一个 NodePort 将 nginx 暴露给外部访问。 k8s 使用 service 来实现服务发现，常见配置包括： spec.selector：用于定义如何选择 podspec.ports：用于定义如何暴露端口，其中，nodePort 指定可以在外部访问的端口完整的 nginx-svc.yml 文件如下 12345678910111213apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: selector: app: nginx ports: - protocol: TCP port: 80 targetPort: 80 nodePort: 30081 type: NodePort 3.3. 查看节点状态12345678910111213141516kubectl get all -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESpod/nginx-deployment-6c8cb99bb9-fkl4g 1/1 Running 0 15m 10.244.52.1 tutorial-2e0e100e9962 &lt;none&gt; &lt;none&gt;pod/nginx-deployment-6c8cb99bb9-jnvzh 1/1 Running 0 15m 10.244.37.65 tutorial-c58f596f5e21 &lt;none&gt; &lt;none&gt;pod/nginx-deployment-6c8cb99bb9-xbgmq 1/1 Running 0 15m 10.244.104.193 tutorial-90e1a52c00d0 &lt;none&gt; &lt;none&gt;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 49m &lt;none&gt;service/nginx-service NodePort 10.97.60.167 &lt;none&gt; 80:30081/TCP 6m19s app=nginxNAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdeployment.apps/nginx-deployment 3/3 3 3 15m nginx nginx:alpine app=nginxNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORreplicaset.apps/nginx-deployment-6c8cb99bb9 3 3 3 15m nginx nginx:alpine app=nginx,pod-template-hash=6c8cb99bb9 可以看出 3 个 nginx pod 运行正常，分别监听在 pod 网络的 10.244.52.1:80, 10.244.37.65:80, 10.244.104.193:80 (Endpoints) 上 nginx-service 创建成功, 将会把来自 10.97.60.167:80 的请求 redirect 到 endpoits，在 cluster 内部可以使用 10.97.60.167:80 访问 nginx 服务。 在集群外部，由于我们创建的是 NodePort 类型的服务，并且 nodePort 为 30081，所有服务还会为每一个 worker node 节点开启 30081 端口。 来自集群外部的请求，如果访问 worker node 的 30081 端口，将被 redirect 到 10.97.60.167:80, 再次被 redirect 到某一个 Endpoint 例如10.244.52.1:80，而此 endpoint 正好可以被某个 nginx 实例响应。 123456789101112131415161718192021$ kubectl describe svc nginx-node-serviceName: nginx-node-serviceNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Selector: app=nginxType: NodePortIP Family Policy: SingleStackIP Families: IPv4IP: 10.97.60.167IPs: 10.97.60.167Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPNodePort: &lt;unset&gt; 30081/TCPEndpoints: 10.244.52.1:80,10.244.37.65:80,10.244.104.193:80Session Affinity: NoneExternal Traffic Policy: ClusterInternal Traffic Policy: ClusterEvents: &lt;none&gt; 3.4. 外部访问 nginx现在切换到，Vultr computer 视图，我们可以看到所有 worker node 节点的公网 ip. 打开浏览器，拿任意一个 worker node 的公网 IP, 访问其 30081 端口，就能访问到 nginx 的 index 页面。 4. 创建 Vultr load balancer在生产环境，我们肯定不会将某一个 worker node 暴露给用户访问，这样某个 worker node 的压力会非常大。 此时我们很自然的会想到，在集群前面加高可用负载均衡器。下面演示一下如何用 Vultr 的 Loadbalancer saas 服务来处理用户请求。 选择与 k8s 集群一致的位置 这里选择 3 个节点，做高可用集群; 负载均衡算法可以选择 Round Robin 也可以选择 less connections;端口转发规则 http 80-&gt;30081, 这样 http 访问服务时就不用加端口号了。不过这些在 load balancer 创建后依然可以修改。 health check 将端口修改称 30081, 点击“Add Load Balancer”开始创建 Load Balancer 创建过程大概需要 3-5 分钟 首次创建 load balancer 状态是失败的，因为我们还没有添加任何代理节点。点击 load balancer 进入管理页面。将所有的 k8s 节点添加到 load balancer 中。 最后使用浏览器访问 load balancer 的 80 端口，可以看到，请求被重定向到 k8s 集群内部的 nginx pod 上。","link":"/k8s/kubernates_on_vultr.html"},{"title":"如何安装 kubectl 命令行工具","text":"kubectl 是 Kubernetes 的命令行工具，用于与 Kubernetes 集群进行交互。它允许用户部署和管理容器化应用程序、查看集群资源、执行故障排查以及进行其他管理任务。kubectl 通过与 Kubernetes API 服务器通信来执行这些操作，API 服务器是 Kubernetes 集群的控制平面的一部分，负责处理集群中所有资源的请求。 今天我们将介绍如何在各种操作系统上，使用多种方式安装 kubectl 这个命令行工具。 1. 确定版本首先到 k8s 官网的 Release History 确定你要安装的版本。目前最新的是 1.31。找到与 k8s 集群相匹配的 k8s 版本避免出现兼容性问题。 然后切换到k8s download 2. 安装 kubectl安装过程中可能需要魔法，魔法可以去我的博客站 - 鹏叔的技术博客上找。 2.1. 使用包管理工具安装 kubectl2.1.1. Windows 上安装 kubectl1choco install kubernetes-cli 2.1.2. 在 macOS 上使用 Homebrew 安装123brew install kubectl# 或者brew install kubernetes-cli 2.1.3. Debian 系列 Linux 安装 kubectl1234567891011121314151617181920# 更新apt包索引并安装使用Kubernetes apt 存储库所需的依赖包sudo apt-get update# apt-transport-https可能是一个Dummy包；如果是这样，你可以去掉这个包sudo apt-get install -y apt-transport-https ca-certificates curl gnupg#下载Kubernetes包存储库的公共签名密钥。所有存储库都使用相同的签名密钥，因此您可以忽略URL中的版本：#如果文件夹“/etc/apt/keyrings”不存在，则应在先创建它，命令如下面的注释部分所示。#sudo mkdir-p-m 755 /etc/apt/keyringscurl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpgsudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg # allow unprivileged APT programs to read this keyring# 添加适当的 Kubernetesapt存储库。如果要使用不同于 v1.31 的 Kubernetes 版本，请在以下命令中将 v1.31 替换为所需的次要版本：echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.listsudo chmod 644 /etc/apt/sources.list.d/kubernetes.list # helps tools such as command-not-found to work correctly# 更新apt软件包索引，然后安装 kubectlsudo apt-get updatesudo apt-get install -y kubectl 2.1.4. Redhat 系列 Linux 安装 kubectl12345678910111213# 添加 Kubernetesyum存储库。如果要使用不同于 v1.31 的 Kubernetes 版本，请在下面的命令中将 v1.31 替换为所需的次要版本。cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/enabled=1gpgcheck=1gpgkey=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/repodata/repomd.xml.keyEOF# 使用以下方式安装 kubectlsudo dnf install -y kubectl 2.1.5. SUSE 系列 Linux 安装 kubectl1234567891011121314151617# 添加 Kubernetes zypper存储库。如果要使用不同于 v1.31 的 Kubernetes 版本，请在下面的命令中将 v1.31 替换为所需的次要版本。cat &lt;&lt;EOF | sudo tee /etc/zypp/repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/enabled=1gpgcheck=1gpgkey=https://pkgs.k8s.io/core:/stable:/v1.31/rpm/repodata/repomd.xml.keyEOF# 更新zypper并确认新的 repo 已经添加sudo zypper update#使用以下方式安装 kubectlsudo zypper install -y kubectl 2.1.6. 使用其他包管理进行安装 snap 如果您使用的是 Ubuntu 或其他支持 snap 包管理器的 Linux 发行版，则 kubectl 可作为 snap 应用程序使用。 1234snap install kubectl --classickubectl version --client Homebrew 如果您使用的是 Linux 并使用 Homebrew 包管理器，则可以安装 kubectl 。 12brew install kubectlkubectl version --client 2.2. 二进制文件安装在 Linux 上使用使用二进制文件方式安装 kubectl 1234567891011121314151617181920212223#对于 Linux x86-64 架构curl -LO https://dl.k8s.io/release/v1.31.0/bin/linux/amd64/kubectl#下载 kubectl 校验和文件：curl -LO &quot;https://dl.k8s.io/release/v1.31.0/bin/linux/amd64/kubectl.sha256&quot;#根据校验和文件验证 kubectl 二进制文件echo &quot;$(cat kubectl.sha256) kubectl&quot; | sha256sum --check#对于 Linux ARM64 架构curl -LO https://dl.k8s.io/release/v1.31.0/bin/linux/arm64/kubectl#下载 kubectl 校验和文件：curl -LO &quot;https://dl.k8s.io/release/v1.31.0/bin/linux/arm64/kubectl.sha256&quot;#根据校验和文件验证 kubectl 二进制文件echo &quot;$(cat kubectl.sha256) kubectl&quot; | sha256sum --checkchmod +x kubectlmkdir -p ~/.local/binmv ./kubectl ~/.local/bin/kubectl# and then append (or prepend) ~/.local/bin to $PATH 3. 测试以确保您安装的版本是合适的12345kubectl version --client# 或者使用此视图查看版本的详细内容：kubectl version --client --output=yaml 4. 配置 kubectl123456789# 导航到你的主目录：cd ~# 创建.kube目录：mkdir .kube# 切换到刚刚创建的.kube目录cd .kube# 配置 kubectl 以使用远程 Kubernetes 集群：New-Item config -type file 5. 配置 kubectl命令补全检查是否bash-completion 已经安装： 1type _init_completion 如果已经安装，您将看到类似以下内容： 123456789101112131415161718$type _init_completion_init_completion 是函数_init_completion () { local exclude=&quot;&quot; flag outx errx inx OPTIND=1; while getopts &quot;n:e:o:i:s&quot; flag &quot;$@&quot;; do case $flag in n) exclude+=$OPTARG ;; e) errx=$OPTARG ;; o) outx=$OPTARG ;; 如果尚未安装，请使用 apt 或 yum 安装，具体取决于您使用的包管理器（Ubuntu 通常使用 apt）： 1apt-get install bash-completion 或者 1dnf install bash-completion 为您的 shell 会话设置 kubectl 完成脚本源： 对于系统上的所有用户： 1kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null 重新加载 bash shell。输入kubectl -后按两次 tab 键查看可用选项，并验证自动完成功能是否正常工作： 12345678-as-group (Group to impersonate for the operation, this flag can be repeated to specify mu…)--as-uid (UID to impersonate for the operation.)--as (Username to impersonate for the operation. User could be a regular user or a se…)--cache-dir (Default cache directory)--certificate-authority (Path to a cert file for the certificate authority)--client-certificate (Path to a client certificate file for TLS) 6. 验证 kubectl 配置为了让 kubectl 找到并访问 Kubernetes 集群，它需要一个 kubeconfig 文件，该文件会在您使用 kube-up.sh 创建集群 或成功部署 Minikube 集群时自动创建。默认情况下，kubectl 配置位于~/.kube/config。 通过获取集群状态检查 kubectl 是否正确配置： 123kubectl cluster-info# 或者kubectl --kubeconfig=/PATH/TO/KUBECONFIG cluster-info 如果您看到 URL 响应，则表示 kubectl 已正确配置以访问您的集群。 如果您看到类似以下内容的消息，则表示 kubectl 配置不正确或无法连接到 Kubernetes 集群。 1The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port? 7. 参考文档k8s 官网 Download Kubernetes kubectl reference documentation. 安装 kubectl 命令行工具 Vultr Kubernetes Engine (VKE) Reference Guide","link":"/k8s/linux_install_kubectl.html"},{"title":"创建kubernetes集群","text":"1. 前言本文主要讲述配置一个最简单的 k8s 集群, 本集群由 1 个 master(master01) 和 2 个 node 节点（node01, node02）组成. 当前(2021/02/15) kubernetes 的最新稳定版本为 v1.20.2. 但是我依然采用的是较老的版本 v1.13.2, 因为众多参考文档使用的是这个版本，目前不清楚各组件之间的版本兼容性问题，所以依然采用这个版本，后续经过多次重复安装，验证各版本的兼容性后再回头来更新版本信息。另外网上有很多的 k8s 实验平台, 只需轻松几个点击, 就可以搭建 k8s 集群, 如果只是学习目的, 可以跳过这唬人的安装过程, 直接进入概念学习阶段, 等对 k8s 玩得很溜了再回头来搭建环境. 欲练此功, 不安装 k8s 也可以. 这里推荐play-with-k8s.com, 创建过程可参考这篇文章只要有 github 账号即可以登录使用. 2. 部署工具介绍部署工具和部署环境有很多种选项 常用的部署环境：IaaS 公有云环境：AWS, GCE, Azure，阿里云等；Iaas 私有云环境: OpenStack 和 vSphere 等；Baremetal 环境(裸金属环境)：物理服务器或独立的虚拟机等； 常用部署工具：kubeadmkopskubesprayKontena Pharos 其它更完善的二次封装的常用发行版Rancher (Labs)Tectonic (CoreOS)Openshift (Redhat) 本文主要讲述选择使用 kubeadm 采用 docker 镜像安装，目的是为了更好的掌握 kubernetes 深层次的概念和运行机制。主机规划： 主机名 虚拟机类型 系统 配置 网络 master01 VirtualBox Centos7.9 2U2GB SATA:100GB IP:192.168.1.71 node01 VirtualBox Centos7.9 2U2GB SATA:50GB IP:192.168.1.61 node01 VirtualBox Centos7.9 2U2GB SATA:50GB IP: 192.168.162 2.1. 环境要求各主机（master01, node01, node02）所需的环境如下： (1) 借助于 NTP 服务设定各节点时间精确同步； (2) 借助 DNS 完成各节点的主机名称解析，测试环境主机较少时可以使用 hosts 文件进行名称解析； (3）关闭主机的 iptables 或 firewall 服务，并确保它们被禁止随系统引导过程启动；(4）各主机禁用 SELinux; (5) 各节点禁用所有 Swap 设备 (6）若要使用 ipvs 模型的 proxy, 各节点还需要载入 ipvs 相关的各模块 2.1.1. 设置各主机 ip首先将虚拟机设置为桥接模式在 x86 架构上安装 CentOs7 最小安装时，默认 ip 地址设置为 ipv6，如果需要设置为 ipv4，需要进行如下设置。首先确定以 enp 打头的网卡/etc/sysconfig/network-scripts/ifcfg-enp8s0 1234567修改为 IPV6INIT=noBOOTPROTO=&quot;static&quot; # 使用静态IP地址，默认为dhcpIPADDR=&quot;192.168.1.71&quot; # 设置的静态IP地址NETMASK=&quot;255.255.255.0&quot; # 子网掩码GATEWAY=&quot;192.168.1.1&quot; # 网关地址DNS1=&quot;192.168.1.1&quot; # DNS服务器ONBOOT=yes 修改 /etc/resolv.conf 12# 添加域名解析服务nameserver 192.168.1.1 12 # 修改后立即重启网络服务，使其生效systemctl restart network 2.1.2. 设置时钟同步范围：master01, node01, node02若各节点可直接访问互联网，直接启动 chronyd 系统服务，并设定为开机启动 1systemctl enable --now chronyd.service 时钟同步后和主机不一致的解决办法第一检查 123ls -ltr /etc/localtime#如果不是上海，则修改localtimelrwxrwxrwx. 1 root root 38 Jun 19 2020 /etc/localtime -&gt; ../usr/share/zoneinfo/America/New_York 如下 123451、vi /etc/sysconfig/clock #编辑文件ZONE=&quot;Asia/Shanghai&quot;UTC=false #设置为false，硬件时钟不与utc时间一致ARC=false 123ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #linux的时区设置为上海systemctl restart chronyd.servicesudo hwclock --systohc #设置硬件时间和系统时间一致并校准 不过，建议用户配置使用本地的时间服务器，在节点数量众多时尤其如此。 存在可用的时间服务器时，修改节点的/etc/chrony.conf 配置文件，并将时间服务器指向相应的主机即可， 配置格式如下： 123server CHRONY-SERVER-NAME-OR-IP iburst prefer 2.1.3. 主机名称解析范围：master01, node01, node02 出于简化配置步骤的目的，本教程使用 hosts 文件进行各节点名称解析，文件内容如下所示： hostnamectl set-hostname &lt;主机名&gt; 12345vi /etc/hosts#添加内容如下192.168.1.71 master01.ilinux.io master01 k8s-master k8s-master.ilinux.io192.168.1.61 node01.ilinux.io node01 k8s-node01 k8s-node01.ilinux.io192.168.1.62 node02.ilinux.io node02 k8s-node02 k8s-node02.ilinux.io 2.1.4. 关闭 iptables 或 firewalld 服务范围：master01, node01, node02 在 centos7 上， iptables 或 firewalld 服务通常只会安装并启动一种，在不确定具体启动状态的前提下，这里通过同时关闭并禁用二者即可简单达到设定目标。 123456789systemctl stop firewalld.servicesystemctl stop iptables.servicesystemctl disable firewalld.servicesystemctl disable iptables.service 2.1.5. 关闭并禁用 SELinux范围：master01, node01, node02 修改 /etc/sysconfig/selinux 文件，将 SELINUX 配置设置为 disabled 123456#修改配置文件，永久禁用selinux, 防止重启导致selinux开启vi /etc/sysconfig/selinuxSELINUX=disabled 1234# 禁用SELinux 立即生效setenforce 0 2.1.6. 禁用 Swap 设备范围：master01, node01, node02 部署集群时，kubeadm 默认会预先检查当前主机是否禁用了 swap 设备，并在未禁用时强制终止部署过程。因此，在主机内存资源充裕的条件下，需要禁用所有的 Swap 设备，否则，就需要在后文的 kubeadm init 及 kubeadm join 命令执行时额外使用相关的选项忽略检查错误。 关闭 Swap 设备，需要分两步。首先关闭当前已启用的所有 Swap 设备： 123swapoff -a 然后编辑/etc/fstab 配置文件，注释掉 swap 设备的挂载项（永久关闭 swap 分区） 2.1.7. 启用 ipvs 内核模块范围：master01, node01, node02 创建内核模块载入相关的脚本文件/etc/sysconfig/modules/ipvs.modules, 设定自动载入的内核模块。文件内容如下： 1234567891011121314#!/bin/bashipvs_mods_dir=&quot;/usr/lib/modules/$(uname -r)/kernel/net/netfilter/ipvs&quot;for mod in $(ls $ipvs_mods_dir | grep -o &quot;^[^.]*&quot;); do /sbin/modinfo -F filename $mod &amp;&gt; /dev/null if [ $? -eq 0 ]; then /sbin/modprobe $mod fidone 修改文件权限，并手动为当前系统加载内核模块 12345chmod +x /etc/sysconfig/modules/ipvs.modulesbash /etc/sysconfig/modules/ipvs.modules 3. 安装程序包(在各主机上完成如下设定)3.1. 安装 docker (master01, node01 &amp; node02)安装 docker 之前要确定 docker 版本是否在 kubernetes 相应版本支持列表里面，以避免遇到版本兼容性问题的坑，这里 列出了部分 kubernetes 版本与 docker 版本的兼容信息，希望对你的集群环境搭建有帮助。 3.1.1. 配置 docker-ce yum 源范围：master01, node01, node02 123456789101112131415# 使用阿里云yum源sudo curl https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.reposudo sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo# 或者华为云yum源，两者选其一sudo wget -O /etc/yum.repos.d/docker-ce.repo https://repo.huaweicloud.com/docker-ce/linux/centos/docker-ce.reposudo sed -i 's+download.docker.com+repo.huaweicloud.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo# 更新yum源缓存sudo yum makecache fast#选择合适的版本yum list docker-ce --showduplicates | sort -r#安装指定版本sudo yum -y install docker-ce-18.03.1.ce-1.el7.centos.x86_64 3.1.2. 配置 docker3.1.2.1. 配置镜像加速由于 dockerhub 镜像仓库在国外，访问速度较慢，下载镜像的过程中，多数情况下会因为超时而失败，所以强烈建议配置镜像加速。另外在整个安装过程中主要需要与 internet 上三个镜像仓库打交道 DockerHub, gcr.io 这个几乎不能访问，后面会介绍到如何获得其上相应的镜像 quay.io , 主要是一些网络组件相关的镜像 123456$sudo vi /etc/docker/daemon.json{ &quot;registry-mirrors&quot;: [&quot;https://&lt;你的ID&gt;.mirror.aliyuncs.com&quot;], &quot;live-restore&quot;: true, &quot;debug&quot;: true} 镜像加速列表 提供者 镜像地址 科大镜像 https://docker.mirrors.ustc.edu.cn/ 网易 https://hub-mirror.c.163.com/ 阿里云 &lt;https://&lt;你的ID&gt;.mirror.aliyuncs.com&gt; 七牛云加速器 https://reg-mirror.qiniu.com daocloud 加速器 &lt;http://&lt;你的ID&gt;.m.daocloud.io/&gt; 其他还有华为云镜像加速，显然是为华为云用户准备的，请参考这篇文章进行配置镜像加速 3.1.2.2. docker iptables FORWARD 策略docker 自 1.13 版起会自动设置 iptables 的 FORWARD 默认策略为 DROP，这可能会影响 kubernetes 集群依赖的报文转发功能，因此，需要在 docker 服务启动后，重新将 FORWARD 链的默认策略设置为 ACCEPT，方式是修改/usr/lib/systemd/system/docker.service 文件，在 “ExecStart=/usr/bin/dockerd” 一行之后新增加一行内容如下： 1ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT 重载完成后即可启动 docker 服务： 1234# 重新加载docker服务设置systemctl daemon-reload# 重启docker服务systemctl start docker 设置为开机自启动 1systemctl enable docker 确保默认使用桥接模式 123$ sudo sysctl -a | grep bridgenet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1 如果不是桥接模式（等号后面为 0）， 手动修改这两个参数方法 1：修改/etc/sysctl.conf 添加以上两个参数 方法 2：在 /etc/sysctl.d 中添加一个以 conf 为后缀的文件例如 k8s.conf，将以上两项配置添加进去 手动执行 sysctl -p /etc/sysctl.conf 或者 sysctl -p /etc/sysctl.d/k8s.conf 使其立即生效 123net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1 3.2. 安装 kubelet (master01)范围：master01, node01, node02 3.2.1. 配置 kubernetes yum 源创建 /etc/yum.repos.d/kubernetes.repo 内容如下： 12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 1234567# 更新yum源缓存 sudo yum -y makecache fast#检查版本，选择合适的版本yum list kubeadm --showduplicates | sort -ryum list kubelet --showduplicates | sort -ryum list kubectl --showduplicates | sort -ryum list kubernetes-cni --showduplicates | sort -r 3.2.2. 安装 kubeletmaster 和 node 节点要安装以下软件 1sudo yum install -y kubeadm-1.18.2-0.x86_64 kubelet-1.18.2-0.x86_64 kubectl-1.18.2-0.x86_64 kubernetes-cni-0.8.7-0.x86_64 并且要设置为开机启动 1systemctl enable kubelet &amp;&amp; systemctl start kubelet 说明： kubelet 为 Kubernetes 的核心守护进程之一，负责将配置清单运行为容器(Pod) Kubeadm 相当于部署集群本身的一个工具，用于简化集群的安装工作，负责根据配置文件部署集群，升级集群等等工作。 kubectl 相当于集群的客户端，负责和集群的 API 组件交互，比如查询 node 的状态，容器的运行情况，以及提交任务等等。 3.2.3. 配置 kubelet如果未禁用 swap 设备，则需要编辑 kubelet 的配置文件/etc/sysconfig/kubelet, 设置忽略 Swap 启用的状态错误， 内容如下： 1KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot; 4. 配置 Master 和 Nodescomponents 规划 主机名 组件 备注 master01 kubelet (yum 安装) kubadm (yum 安装) kubectl(yum 安装) docker (yum 安装) kube-apiserver (Pod)kube-scheduler (Pod) kub-controller-manager (Pod) cni (flannel Pod) etcd (Pod) kube-proxy (Pod) node01 kubelet (yum 安装) docker (yum 安装) cni (flannel Pod) kube-proxy (Pod) node02 kubelet (yum 安装) docker (yum 安装) cni (flannel Pod) kube-proxy (Pod) 4.1. 插件安装Metrics-Server(Pod)Dashboard (Pod)CoreDNS (Pod)EFK (Pod)Prometheus (Pod)Ingress-Controller (Pod) 4.2. 配置 master 节点4.2.1. 拉取必要的镜像说明：k8s.gcr.io 上的镜像由于无法描述的原因，在国内无法直接拉取。但是阿里云 registry 中共享了相应版本的 kubernetes 镜像，这里再次感谢阿里的无私贡献，敬佩阿里的企业文化（利他），不仅免费，还有消耗阿里云的大量带宽。由于 docker 镜像命名规范的原因，拉取下来后要重新打 tag 才能使用，以下脚本包含了拉取镜像，更名，清理的功能。本人把安装文档写得足够详细，向阿里致敬！ kubeadm init –kubernetes-version=1.18.1 --apiserver-advertise-address=192.168.1.71 --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 注意修改 apiserver-advertise-address 为 master 节点 ip参数解释：–kubernetes-version: 用于指定 k8s 版本；–apiserver-advertise-address：用于指定 kube-apiserver 监听的 ip 地址,就是 master 本机 IP 地址。–pod-network-cidr：用于指定 Pod 的网络范围； 10.244.0.0/16–service-cidr：用于指定 SVC 的网络范围；–image-repository: 指定阿里云镜像仓库地址 这一步很关键，由于 kubeadm 默认从官网 k8s.grc.io 下载所需镜像，国内无法访问，因此需要通过–image-repository 指定阿里云镜像仓库地址 4.2.2. 初始化 masterkubeadm init 命令支持两种初始化方式， 一是通过命令行选项传递关键部署设定，另一种是基于 yaml 格式的 kubeadm 专用配置文件，后一种运行用户自定义各种部署参数。下面分别给出了两种实现方式的配置步骤，建议读者采用第二种方式进行。 4.2.2.1. 初始化方式一123systemctl enable kubelet.servicesystemctl start kubelet.servicekubeadm init --kubernetes-version=v1.13.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap 命令中的各选项说明：（1）–kubernetes-version 选项的版本号用于指定要部署的 kubernetes 程序版本，它需要与预拉取的 kubernetes 镜像版本一致参考脚本变量（K8S_VERSION）（2）–pod-network-cidr 选项用于指定 pod 网络的网段，它通常应该与要部署使用的网络插件(例如 flannel, calico 等)的默认设定保持一致， 10.244.0.0/16 是 flannel 默认使用的网络；（3）–service-cidr 用于指定为 Service 分配使用的网络地址，它由 kubernetes 管理， 默认即为 10.96.0.0/12 (4）最后一个选项 –ignore-preflight-errors=Swap 防止未禁用 swap 设备而导致初始化失败，生产环境建议关闭 swap 设备，已获得更好的性能，请参考前述禁用 swap 分区进行设定。（5）这里需要读者对 kubernetes 的三层网（node 网络，pod 网络，service 网络）知识有所了解，再来做相关参数的调整。 4.2.2.2. 初始化方式二kubeadm 也可以通过配置文件加载配置， 以定制更丰富的部署选项。以下是符合前述命令设定方式的使用示例，不过，它明确定义了 kubeProxy 的模式为 ipvs， 并支持通过修改 imageRepository 的值修改获取系统镜像时使用的镜像仓库。 1234567891011121314151617181920212223242526272829apiVersion: kubeadm.k8s.io/v1alpha2kind: MasterConfigurationkubernetesVersion: v1.13.2api: advertiseAddress: 192.168.1.71 bindPort: 6443 controlPlaneEndpoint: &quot;&quot;imageRepository: k8s.gcr.iokubeProxy: config: mode: &quot;ipvs&quot; ipvs: ExcludeCIDRs: null minSyncPeriod: 0s scheduler: &quot;&quot; syncPeriod: 30skubeletConfiguration: baseConfig: cgroupDriver: cgroupfs clusterDNS: - 10.96.0.10 clusterDomain: cluster.local failSwapOn: false resolvConf: /etc/resolv.conf staticPodPath: /etc/kubernetes/manifestsnetworking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 serviceSubnet: 10.96.0.0/12 将上面的内容保存于配置文件中， 例如 kuberadm-config.yaml, 而后执行相应的命令： 1# kubeadm init --config kubeadm-config.yaml --ignore-prelight-errors=Swap 注意：对于 kubernetes 系统的新用户来说，无论使用上述哪种方式，命令运行结束后，请记录最后的 kubeadm join 命令输出的最后提示的操作步骤。 下面的内容是需要用户记录的一个命令输出示例，它提示了后续需要操作的步骤： 12345678910To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configyou should now deploy a pod network to the clusterRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ you can now join any number of machines by running the following on each node as root:kubeadm join 172.168.0.70:6443 --token uoutlc.aknhy63zioieuw9x --discovery-toke-ca-cert-hash sha256:cd8bd32c9be6c88573c56f 接下来要部署一个 podnetwork addon以 flannel 为例： 1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml vi kube-flannel.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225------apiVersion: policy/v1beta1kind: PodSecurityPolicymetadata: name: psp.flannel.unprivileged annotations: seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/defaultspec: privileged: false volumes: - configMap - secret - emptyDir - hostPath allowedHostPaths: - pathPrefix: &quot;/etc/cni/net.d&quot; - pathPrefix: &quot;/etc/kube-flannel&quot; - pathPrefix: &quot;/run/flannel&quot; readOnlyRootFilesystem: false # Users and groups runAsUser: rule: RunAsAny supplementalGroups: rule: RunAsAny fsGroup: rule: RunAsAny # Privilege Escalation allowPrivilegeEscalation: false defaultAllowPrivilegeEscalation: false # Capabilities allowedCapabilities: ['NET_ADMIN', 'NET_RAW'] defaultAddCapabilities: [] requiredDropCapabilities: [] # Host namespaces hostPID: false hostIPC: false hostNetwork: true hostPorts: - min: 0 max: 65535 # SELinux seLinux: # SELinux is unused in CaaSP rule: 'RunAsAny'---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: flannelrules:- apiGroups: ['extensions'] resources: ['podsecuritypolicies'] verbs: ['use'] resourceNames: ['psp.flannel.unprivileged']- apiGroups: - &quot;&quot; resources: - pods verbs: - get- apiGroups: - &quot;&quot; resources: - nodes verbs: - list - watch- apiGroups: - &quot;&quot; resources: - nodes/status verbs: - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: flannelroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannelsubjects:- kind: ServiceAccount name: flannel namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: flannel namespace: kube-system---kind: ConfigMapapiVersion: v1metadata: name: kube-flannel-cfg namespace: kube-system labels: tier: node app: flanneldata: cni-conf.json: | { &quot;name&quot;: &quot;cbr0&quot;, &quot;cniVersion&quot;: &quot;0.3.1&quot;, &quot;plugins&quot;: [ { &quot;type&quot;: &quot;flannel&quot;, &quot;delegate&quot;: { &quot;hairpinMode&quot;: true, &quot;isDefaultGateway&quot;: true } }, { &quot;type&quot;: &quot;portmap&quot;, &quot;capabilities&quot;: { &quot;portMappings&quot;: true } } ] } net-conf.json: | { &quot;Network&quot;: &quot;10.244.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot; } }---apiVersion: apps/v1kind: DaemonSetmetadata: name: kube-flannel-ds namespace: kube-system labels: tier: node app: flannelspec: selector: matchLabels: app: flannel template: metadata: labels: tier: node app: flannel spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/os operator: In values: - linux hostNetwork: true priorityClassName: system-node-critical tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.13.1-rc2 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.13.1-rc2 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: &quot;100m&quot; memory: &quot;50Mi&quot; limits: cpu: &quot;100m&quot; memory: &quot;50Mi&quot; securityContext: privileged: false capabilities: add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;] env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run/flannel - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run/flannel - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg 注意：kubernetes 本身没有 pod 网络创建和管理功能，其本身只提供了一组依赖网络组件的接口，网络功能一般有第三方插件完成，比如 flannel, calico 等等。但是 Kubernetes 本身集成了 service 网络的管理功能，其底层实际是创建一系列 iptables 或 ipvs 规则来完成的。 部署完之后查看 kubernetes 相关的容器corednsetcdkube-apiserverkuber-controllerkube-flannel-ds-amd64-bbnz2kube-proxykube-scheduler 4.3. 配置第一个 node 节点, 并添加到集群修改 ip 地址修改主机名部分，改为 k8s-node01 1hostnamectl set-hostname k8s-node01 安装软件 1sudo yum install -y kubeadm-1.18.2-0.x86_64 kubelet-1.18.2-0.x86_64 kubectl-1.18.2-0.x86_64 kubernetes-cni-0.8.7-0.x86_64 并且要设置为开机启动 1systemctl enable kubelet &amp;&amp; systemctl start kubelet 下载 flannel 镜像 1docker pull registry.cn-hangzhou.aliyuncs.com/daoh/flannel:v0.12.0-amd64 为镜像打 tag，保持和 yaml 文件一样。 1docker tag registry.cn-hangzhou.aliyuncs.com/daoh/flannel:v0.12.0-amd64 quay.io/coreos/flannel:v0.12.0-amd64 准备配置文件 123mkdir -p /etc/cni/net.d/vi /etc/cni/net.d/10-flannel.conf{&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: {&quot;isDefaultGateway&quot;: true}} 1234mkdir -p /usr/share/oci-umount/oci-umount.dmkdir /run/flannel/ 1234mkdir ~/k8scd k8swget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlkubectl apply -f kube-flannel.yml 在 master 上查询 join string 1kubeadm token create --print-join-command 在 node 上执行查询结果, 加入集群 12kubeadm join 192.168.1.71:6443 --token ud6ny7.9wzcg5du5zvrbbfv \\--discovery-token-ca-cert-hash sha256:dffb435eb20f133a8419bd406daf79cf6e4ee6af490xyzsd0ba95f610e5b1ec3 设置开机启动 1 查看 node 状态 1234[root@node01 k8s]# kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s-master Ready master 45h v1.18.2k8s-node01 Ready &lt;none&gt; 5m52s v1.18.2 4.4. 配置第二个 node 节点, 并添加到集群修改 ip 地址vi /etc/sysconfig/network-scripts/ifcfg-enp0s3修改 ip 地址修改主机名部分，改为 k8s-node02 1hostnamectl set-hostname k8s-node02 重新启动重新登录 node2重新初始化节点配置, 执行命令 1kubeadm reset 重新加入集群 12kubeadm join 192.168.1.71:6443 --token ud6ny7.9wzcg5du5zvrbbfv \\--discovery-token-ca-cert-hash sha256:dffb435eb20f133a8419bd406daf79cf6e4ee6af490xyzsd0ba95f610e5b1ec3 12345[root@k8s-node02 ~]# kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s-master Ready master 45h v1.18.2k8s-node01 Ready &lt;none&gt; 31m v1.18.2k8s-node02 Ready &lt;none&gt; 4m3s v1.18.2 5. 问题排查 troubleshooting在 k8s 中，大部分的问题，都能通过 logs 和 describe 两个命令进行分析和定位 6. 后记本技术博客原创文章位于鹏叔的技术博客 - 创建 kubernetes 集群, 要获取最近更新请访问原文. 更多技术博客请访问: 鹏叔的技术博客 7. 参考文档kubernetes 官方网站 Kubernetes github k8s 记录-国内下载 k8s 组件镜像 Kubernetes 1.20 版本开始不推荐使用 Docker，你知道吗 Kubernetes 各版本对应支持的 docker 版本列表 k8s 不再支持 docker_k8s 不支持 Docker 了？ 别慌！官方最新解释来了… [Which kubernetes version is supported in docker version 18.09]单机版 kubernetes 1.18.2 安装https://www.cnblogs.com/zhizihuakai/p/12629514.htmlhttps://blog.csdn.net/llinyunxia/article/details/106160654?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242","link":"/k8s/setup_k8s_cluster.html"},{"title":"Linux文件目录结构详解","text":"1. FHS是什么?Filesystem Hierarchy Standard（文件系统层次化标准）的缩写，多数Linux版本采用这种文件组织形式，类似于Windows操作系统中c盘的文件目录，FHS采用树形结构组织文件。FHS定义了系统中每个区域的用途、所需要的最小构成的文件和目录，同时还给出了例外处理与矛盾处理。 通俗的讲就是解决哪些鸡蛋应该放在哪些篮子的问题. 2. 为什么要有FHS?因为基于Linux开发新的产品或distributions的社群、公司以及个人实在是太多啦。如果每个人都用自己的想法来定义目录结构，那么将可能造成很多文件管理上的困扰。你可以闭上眼睛想象一下，你刚刚进入一家企业后，所接触到的Linux目录以及配置方法尽然和你以前所学习到的完全不一样，很难在继续想了吧（花了好多钱以及好多时间竟然白学了）。所以后来就有所谓的Filesystem Hierarchy Standard（FHS）这个标准就风风火火的出炉啦。 根据FHS的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装的软件通常存放在哪个目录下，所以他们希望独立的软件开发商，操作系统制造者，以及想要维护系统的用户（系统管理员），都能够遵循FHS的标准，也就是说，FHS的重点在于规范每个特定的目录下应该要存放什么样子的数据而已。这样做的好处非常多，因为Linux操作系统就能够在既有的面貌下（目录架构不变）发展出开发者想要的独特风格。 事实上，FHS是根据过去的经验总结出来的, 而且一直在持续的改版，FHS依据文件系统使用的频率与否允许使用者是否随意改动，而将目录定义成为4种交互作用的形态。 3. FHS目录的架构都有些啥?12345678910111213141516171819202122232425262728293031323334353637383940414243/├── bin -&gt; usr/bin├── boot├── dev├── etc├── home├── lib -&gt; usr/lib├── lib32 -&gt; usr/lib32├── lib64 -&gt; usr/lib64├── libx32 -&gt; usr/libx32├── media├── mnt├── opt├── proc├── root├── run├── sbin -&gt; usr/sbin├── srv├── sys├── tmp├── usr ├── bin ├── include ├── lib ├── lib32 ├── lib64 ├── libexec ├── libx32 ├── local ├── sbin ├── share └── src└── var ├── cache ├── lib ├── local ├── lock -&gt; /run/lock ├── log ├── mail ├── opt ├── run -&gt; /run ├── spool └── tmp 4. 详解之前在进入详解之前, 我们来思考一个问题, 这个问题对我们理解目录结构将会非常有帮助. 4.1. 程序是由什么构成的?一个完整的程序或软件通常由以下四部分组成, 可执行文件.这些文件一般是可执行的二进制文件(binary), 当然也有例外, 比如shell脚本, 它也是可执行的文件, 这些统称可执行文件.它有个显著的特点就是就是它有不可变性, 当然这里的不可变性是相对的, 不是绝对的. 什么含义? 就是软件一旦安装, 在它的生命周期中, 这些可执行文件几乎是不怎么改变的, 直到升级到新的版本, 或者被卸载. 正因为它有不变性, 我们在备份的时候, 可以不考虑可执行程序, 或者以较低的频率备份可执行文件. 因为他们能够很容易的被重建起来.另外正因为它们有不可变性, 使得他们有较高的共享价值, 即可以在一台机器上只安装一份可执行程序, 所有用户共享一份可执行程序. 甚至我们可以在一个网络中只安装一份可执行程序, 整个网络中共享一份可执行程序. 例如我们可以在NFS服务器上保存可执行程序, 其他主机通过NFS远程挂载的方式挂载到本地主机, 这样我们不必每个主机逐一安装同一软件.另外它的特点是可执行的, 这也是它区别与其它类型文件的显著区别. 什么含义? 即它是可以独立加载进内存, 被CPU执行的. 正因为它有这个特点, 我们要特别小心这些可执行文件, 要防止它们被病毒感染或被恶意程序篡改. 所以针对这类程序的我们进行病毒查杀的频率要高. 库文件程序执行时依赖的一些动态或静态类库, 如一些dll文件. 有时多应用程序可能共享同一份类库. 一些基础类库可能会被很多的软件所依赖. 有时同一家公司的产品可能会共用一份库文件. 有时一份软件有它特有的依赖库. 这类文件, 我们在删除的时候一定要非常小心, 因为意外删除可能导致多款软件运转失灵. 安装时也可能因为新版本覆盖旧版本导致,其它软件出现兼容性问题. 所以我们在进行复杂的升级, 安装前要记得备份这些库文件. 所以这类文件备份频率要高于可执行文件, 以便当系统崩溃时从备份中恢复.另外, 虽然它们不是直接可执行的文件, 但是它们也会被可执行程序, 或系统调用加载到内存被CPU执行, 也需要频繁地进行病毒查杀. 配置文件这类文件通常是文本文件, 例如apache的配置, tomcat的配置. 这类文件通常不具有可共享性, 每个系统之所以会表现出不同的特性, 通常是有配置文件决定的. 不同主机, 用户都有不同的配置文件. 他们具有可变性和不可共享性. 数据数据是一个企业或最重要的资产, 通常情况下数据会随着业务的发展逐渐增长. 这类数据具有高可变性. 所以对备份要求较高, 有些需要定期备份甚至实时备份. 当然数据也分为很多种类, 对于数据种类的研究可以另开一篇专题了, 比如日志类型的数据, 要定期归档, 清理. 帮助文档帮助文档具有高不可变性和高共享性. 其不可变性, 并不代表文档不会更新, 而是指针对特定版本的应用程序, 其帮助文档内容是相当不变化的. 4.2. 软件如何分类? 从系统管理的角度, 软件可以分为系统软件和应用软件. 系统软件一般是支撑整个系统运行的必要软件, 比如磁盘管理工具, 网络工具, shell等. 用于构成整个计算机的infrastrure 或用于维护, 如果以使用者角色划分的话, 他们是系统管理员经常使用的软件. 应用软件是指运行在系统之上特供特定功能的软件, 比如办公软件, 音频视频播放软件等. 以使用者角色划分的话, 他们是用户经常使用的软件. 这里为什么要谈论软件分类, 因为我们在规划目录结构时, 尤其在企业应用中, 管理员角色和用户人群是分开的, 所以要考虑将系统管理员使用的软件与用户使用到的软件及配置要分割开来. 保证应用软件的运行不会导致整个系统的崩溃. 5. 目录详解/ 根目录根目录的意思与内容根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的。同时根目录也是开机、关闭、系统修复等功能有关的。由于系统开机时需要特定的开机软件，核心文件，开机程序所需的程序，函数库等文件数据。因为根目录很重要，所以在FHS要求方面，它希望根目录不要放在非常大的分区上面，因为越大的分区，你会存储更多的数据，如此一来根目录所在的分区就可能会有较大的发生错误的机会, 一旦根分区发生错误就会导致系统崩溃。依据FHS的建议：根目录所在的分区越小越好，且应用程序所安装的软件最好不要与根目录放在一个分区中，保持根目录越小越好。 /bin: binary(二进制) 的简写, 存放用户和系统都可以访问的可执行文件. /usr/usr的意义与内容依据FHS的基本定义，/usr里面存放的数据属于可分享的与不可变动的（shareable、static），如果你知道如何通过网络进行分区的挂载（例如：NFS服务器），那么/usr确实可以分享给全局网络内的其他主机来用啦。很多人都误会/usr为user的缩写，其实usr是Unix software Resourece的缩写，也就是Unix操作系统软件资源所存放的目录。FHS建议所有软件开发者，将他们的可执行文件合理地分类存放到这个目录的子目录下，而不是自行独立创建一级目录。因为所有系统默认的软件（distributions发布者提供的软件）都会放到/usr目录下。就像我们windows系统下的windows文件夹和program files文件夹这两个文件夹的结合体。这个目录占用最多的磁盘空间。而用户安装的非系统程序和其他东西建议存放在/usr/local 下.这样可能在升级新版系统或新distribution时无须重新安装全部程序. /usr/X11R6X Window系统的所有文件.为简化X的开发和安装，X Window的文件没有集成到系统中. X自己在/usr/X11R6 下类似/usr . /usr/X386类似/usr/X11R6 ，但是给X11 Release 5的. /usr/bin几乎所有用户命令.有些命令在/bin 或/usr/local/bin 中. /usr/sbin根文件系统必要的系统管理命令，例如多数服务程序. /usr/man , /usr/info , /usr/doc手册页、GNU信息文档和各种其他文档文件. /usr/includeC编程语言的头文件.为了一致性这实际上应该在/usr/lib 下，但传统上支持这个名字. /usr/lib程序或子系统的不变的数据文件，包括一些site-wide配置文件.名字lib来源于库(library); 编程的原始库存在/usr/lib 里. /usr/local本地安装的软件和其他文件放在这里. 用户自己编译的软件默认会安装到这个目录下。这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面 /var文件系统var是variable的简写形式(可变的). 是运行时会占用比较大的硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用磁盘容量的目录。因为/var目录主要针对经常变动的文件，包括缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件。包括程序文件（log file、run file）。如mysql数据库的文件等。 /var 包括系统一般运行时要改变的数据,具有不可共享性. 每个系统是特定的，即不通过网络与其他计算机共享. /var/catman当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man中；有些man页可能有预格式化的版本，存在/usr/man/cat 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.) /var/lib系统正常运行时要改变的库文件. /var/local/usr/local 中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock . /var/lock锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件. /var/log各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除. /var/run保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息. /var/spoolmail, news, 打印队列和其他队列工作的目录.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中. /var/tmp比/tmp 允许的大或需要存在较长时间的临时文件. (虽然系统管理员可能不允许/var/tmp 有很旧的文件.) /opt：用户级的程序目录这里主要存放那些可选的程序, 在新版的FHS中, 建议使用/usr/local替代, 其一是opt是一个一级目录, 在新版的FHS中, 目录越来越层次化, 其而local的意义更能代表这类软件的意义。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。 /media 一些可以热拔插的介质（如CD-ROMs）的挂载点 (在FHS-2.3中出现). /mnt 临时挂载的文件系统 /dev: 设备文件. device(设备)的简写. /etc: 主要用于存放配置文件. /home: 用户的主目录. 可以存放用户级别的配置文件, 数据等. 比如bash的配置文件, maven, gradle等等的用户配置文件 /root: root用户的主目录, root用户主目录为何单独拥有一个一级目录,而且主目录往往挂载在一个单独的硬盘分区, 一来是为了确保更高的安全性. 另外是root用来救援其它用户的, 当其它其用户挂掉的时候, root是不能挂掉的. /proc: process进程的简写. 将进程和内核信息以文件形式呈现的虚拟文件系统。在Linux中，与procfs mount(进程文件系统)对应. /run: 运行时变量数据:从本次启动到现在的系统信息。如当前登陆的用户和正在运行的守护进程 /srv 本系统提供的特定站点的数据。如web服务器提供的数据和脚本，FTP服务器提供的数据，VCS的仓库 /sys 包含连接到本台计算机的设备信息 /tmp 临时文件(和/var/tmp相同). 通常在重启后清空，并且受到严格的大小限制 6. FHS 约定大多数Linux发行版遵循文件系统层次结构标准(FHS)，并且为保持FHS约定发布了相关政策。GoboLinux 和 NixOS 提供了有意不遵循FHS约定的实现有些基本遵循这个标准的发行版在部分方面有些违背，如 现代Linux发行版将/sys 作为可以被连接到此系统的设备修改和保存的虚拟文件系统(sysfs,相当于/proc)，但是许多UNIX和类UNIX系统使用/sys 作为指向 kernel source tree 的符号连接 许多现代UNIX系统（像FreeBSD ，通过它的端口系统）安装第三方包至/usr/local 然而却将本应是操作系统的代码放在/usr 中 一些Linux发行版不再区分/lib 与/usr/lib,并且将lib 作为指向 /usr/lib 的软连接 一些Linux发行版不再区分 /bin 与 /usr/bin 和/sbin 与/usr/sbin 。他们将 /bin 作为指向 /usr/bin 的软连接， 将/sbin 作为指向/usr/sbin 的软连接 现代Linux发行版将/run 作为(遵循FHS3.0的)保存不稳定的运行时数据的临时文件系统(tmpfs)。根据FHS2.3，这类数据被保存在/var/run ，但是由于在启动时这个目录并不总是可用，会导致一些问题。所以，这些程序必须借助欺骗的方式，如使用类似 /dev/.udev, /dev/.mdadm, /dev/.systemd 或 /dev/.mount 等并不是用来保存这些数据的设备目录。除其他好处外，这样也会使根目录以只读方式挂载的系统更容易使用。例如，以下是Debian在2013年的Wheezy版本中作出的改变: 12345678/dev/.* → /run/*/dev/shm → /run/shm/dev/shm/* → /run/*/etc/* (writeable files) → /run/*/lib/init/rw → /run/var/lock → /run/lock/var/run → /run/tmp → /run/tmp 7. FHS的发展历史当FHS被以FSSTND (Filesystem Standard的缩写)被创建时，其他UNIX和类UNIX系统已经有了他们自己的标准。比较典型的例子有 自从 Version 7 Unix (in 1979)发布以来就存在的the hier(7) description of file system layout； the SunOS filesystem(7) 和它的后继 the Solaris filesystem(5) 7.1. 历史版本 legend Version Release Date Notes 旧版本 1 1994/2/14 FSSTND 旧版本 1.1 1994/10/9 FSSTND 旧版本 1.2 1995/3/28 FSSTND 旧版本 2 1997/10/26 FHS 2.0 直接继承自FSSTND 1.2 。 FSSTND更名为FHS 旧版本 2.1 2000/4/12 FHS 旧版本 2.2 2001/5/23 FHS 仍支持 2.3 2004/1/29 FHS 最新版 3 2015/5/18 FHS 8. 一些疑问8.1. linux下/bin和/usr/bin和/usr/local/bin的区别?/bin 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。/usr/bin 是系统安装时自带的一些可执行程序。即系统程序，轻易不要去动里面的东西，容易入坑。/usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置，这个不小心误删点什么，不会影响大局。 9. 后续更多linux相关知识, 请参考鹏叔的技术博客linux tag, 获取实时更新的Linux文章. 10. 参考文档linux中的/usr,/var,/opt目录详解 文件系统层次结构标准(FHS)(for Linux) wiki Filesystem_Hierarchy_Standard Ubuntu Hier 7 FHS 3.0 Filesystem Hierarchy Standard","link":"/linux/Linux_FHS.html"},{"title":"Linux 上添加 swap 分区","text":"防止应用程序出现内存不足错误的一种方法是向服务器添加一些交换空间。在本指南中，我们将介绍如何向 Almalinux 服务器添加 swap 分区。 1. 什么是 Swap？swap 分区是硬盘存储空间的一部分，专门留给操作系统用来临时存储 RAM 中无法再保存的数据。这可以增加服务器在工作内存中可以保存的信息量，但有一些注意事项。硬盘上的交换空间主要在 RAM 中没有足够的空间来保存正在使用的应用程序数据时使用。 写入磁盘的信息将比保存在 RAM 中的信息慢得多，但操作系统会倾向于将正在运行的应用程序数据保留在内存中，并使用交换空间来存储较旧的数据。总的来说，在系统 RAM 耗尽时，将交换空间作为后备方案，可以很好地防止出现内存不足异常。 2. 检查系统的 swap 分区在开始之前，我们可以检查系统是否已经有可用的交换空间。可能有多个交换文件或交换分区，但通常一个就足够了。 我们可以通过输入以下命令来查看系统是否有任何配置的交换: 123sudo swapon --show 如果没有任何输出，则意味着您的系统当前没有可用的交换空间。 您可以使用以下实用程序验证没有 active 的 swap 分区： 1234567$ free -hOutput total used free shared buff/cache availableMem: 981Mi 122Mi 647Mi 0.0Ki 211Mi 714MiSwap: 0B 0B 0B 正如从输出的 Swap 行中看到的，系统上没有活动的交换。 3. 检查硬盘分区上的可用空间1234567891011121314151617$ df -hOutputFilesystem Size Used Avail Use% Mounted onudev 474M 0 474M 0% /devtmpfs 99M 932K 98M 1% /run/dev/vda1 25G 1.4G 23G 7% /tmpfs 491M 0 491M 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 491M 0 491M 0% /sys/fs/cgroup/dev/vda15 105M 3.9M 101M 4% /boot/efi/dev/loop0 55M 55M 0 100% /snap/core18/1705/dev/loop1 69M 69M 0 100% /snap/lxd/14804/dev/loop2 28M 28M 0 100% /snap/snapd/7264tmpfs 99M 0 99M 0% /run/user/1000 Mounted on 列中的设备/是本例中的磁盘。本例中我们有足够的可用空间（仅使用了 1.4G）。您的使用情况可能有所不同。 虽然关于交换空间的合适大小有很多意见，但这实际上取决于您的个人偏好和应用程序要求。通常等于或两倍于系统 RAM 的量是一个不错的起点。另一个好的经验法则是，如果您只是将其用作 RAM 后备，那么超过 4G 的交换空间可能没有必要。 4. 创建交换文件现在我们知道了可用的硬盘空间，我们可以在文件系统上创建一个交换文件。我们将在根目录分配一个大小与 RAM 相等的 swapfile。 创建交换文件的最佳方法是使用 fallocate 程序。此命令会立即创建指定大小的文件。 由于我们示例中的服务器具有 1G 的 RAM，因此我们将在本指南中创建一个 1G 的文件。不过您可以调整它以满足您自己的服务器的需求： 123sudo fallocate -l 1G /swapfile 我们可以通过输入以下命令来验证是否保留了正确数量的空间： 12345$ ls -lh /swapfile-rw-r--r-- 1 root root 1.0G Apr 25 11:14 /swapfile swap 分区文件已创建并留出了足够的空间。 5. 启用交换文件现在我们有了一个可用且大小正确的文件，我们需要将其真正转变为交换空间。 首先，我们需要锁定文件的权限，以便只有具有 root 权限的用户才能读取内容。这样可以防止普通用户访问该文件，否则将带来严重的安全隐患。 输入以下命令使该文件仅 root 用户可用： 1sudo chmod 600 /swapfile 输入以下命令验证权限是否改变： 12345$ ls -lh /swapfileOutput-rw------- 1 root root 1.0G Apr 25 11:14 /swapfile 如您所见，只有 root 用户启用了读写标志。 我们现在可以通过输入以下命令将文件格式化为交换空间： 123456$ sudo mkswap /swapfileOutputSetting up swapspace version 1, size = 1024 MiB (1073737728 bytes)no label, UUID=6e965805-2ab9-450f-aed6-577e74089dbf 格式化文件后，我们可以启用交换文件，允许系统开始使用它： 1sudo swapon /swapfile 输入以下命令验证交换是否可用： 123456$ sudo swapon --showOutputNAME TYPE SIZE USED PRIO/swapfile file 1024M 0B -2 我们可以再次使用 free 命令检查 active swap 分区： 1234567$ free -hOutput total used free shared buff/cache availableMem: 981Mi 123Mi 644Mi 0.0Ki 213Mi 714MiSwap: 1.0Gi 0B 1.0Gi 我们的交换分区已成功设置，操作系统将在必要时开始使用它。 6. 使交换分区永久化我们最近的更改已为当前会话启用了交换文件。但是，如果我们重新启动，服务器将不会自动保留交换设置。我们可以通过将交换文件添加到我们的/etc/fstab 文件中来更改此设置。 备份/etc/fstab 文件以防万一出现问题： 123sudo cp /etc/fstab /etc/fstab.bak 在/etc/fstab 文件末尾添加以下内容以使交换分区永久有效： 1echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 7. 调整交换分区设置您可以配置一些选项，这些选项会在处理交换时对系统的性能产生影响。 7.1. 调整 Swappiness 属性此 swappiness 参数配置系统将数据从 RAM 交换到交换空间的频率。这是一个介于 0 到 100 之间的值。 如果值接近于零，则除非绝对必要，否则内核不会将数据交换到磁盘。请记住，与 swap 分区文件的交互是“昂贵的”，因为它们比与 RAM 的交互花费的时间更长，并且会显著降低性能。告诉系统不要过多依赖交换通常会使得系统更快。 接近 100 的值将尝试将更多数据放入交换中，以保持更多 RAM 空间可用。根据应用程序的内存配置文件或您使用服务器的目的，在某些情况下这可能会更好。 我们可以通过输入以下命令来查看当前的 swappiness 值： 123456$ cat /proc/sys/vm/swappinessOutput60 对于桌面操作系统来说，将 swappiness 设置为 60 还不错。对于服务器来说，您可能希望将其设置为更接近 0。 我们可以使用命令将 swappiness 设置为不同的值 sysctl。 例如，要将 swappiness 设置为 10，我们可以输入： 1234$ sudo sysctl vm.swappiness=10Outputvm.swappiness = 10 此设置将持续到下次重新启动。我们可以通过在/etc/sysctl.conf 文件中添加以下行来在重新启动时自动设置此值： 123sudo vi /etc/sysctl.conf 可以在底部添加： 123vm.swappiness=10 完成后保存并关闭文件 7.2. 调整缓存压力设置另一个你可能想要修改的相关值是 vfs_cache_pressure。此设置配置系统将选择缓存 inode 和 dentry 信息而不是其他数据的量。 基本上，这是有关文件系统的访问数据。这通常查找起来非常昂贵，而且请求非常频繁，因此这对您的系统来说是一件非常好的事情。您可以通过 proc 再次查询文件系统来查看当前值： 123456$ cat /proc/sys/vm/vfs_cache_pressureOutput100 根据目前的配置，我们的系统从缓存中删除 inode 信息的速度太快。我们可以通过键入以下内容将其设置为更保守的设置，例如 50： 1234$ sudo sysctl vm.vfs_cache_pressure=50Outputvm.vfs_cache_pressure = 50 这仅对我们当前会话有效。我们可以像 swappiness 设置一样，通过将其添加到配置文件中来更改它： 12345$ sudo vi /etc/sysctl.conf# 添加一行配置vm.vfs_cache_pressure=50 完成后保存并关闭文件。 总结按照本指南中的步骤操作，您将在可能导致内存不足异常的情况下获得一些喘息空间。交换空间对于避免这些常见问题非常有用。 如果您遇到 OOM（内存不足）错误，或者发现系统无法使用所需的应用程序，最好的解决方案是优化应用程序配置或升级服务器。 参考文档如何在 Ubuntu 22.04 上添加交换空间","link":"/linux/add_swap_space_on_linux.html"},{"title":"Almalinux 安装与使用","text":"1. 背景介绍CentOS 8 于 2021 年 12 月 31 日正式结束了生命周期。这意味着官方不再提供对该版本的安全补丁、错误修复或功能改进等支持服务。因此，建议用户将其系统升级到最新的操作系统版本以获得更好的性能和安全保障。CentOS-7 由于用户基数与用户贡献较多，因此会按照计划维护至生命周期结束即 2024 年 6 月 30 日，接下来一年会把重心放到 CentOS Stream 上。由于CentOS Stream相对不稳定，因此很多朋友会有从Centos-7迁移至AlmaLinux-8的需求。 笔者在使用 Centos 7 的过程中也经常遇到一些基础软件过于陈旧，例如 git 版本还停留在 1.18 不得不手动安装新版本, gcc, gcc+等编译软件以及一些基础库文件过旧，不得不手动升级基础软件和基础库文件。问题的关键是这些手动升级的基础软件在 Centos7 上的稳定性是无法保障的。 各种代替产品应运而生，例如国产替代品有： 龙蜥操作系统（Anolis OS） 麒麟操作系统 银河麒麟操作系统 (kylinOS) 中标麒麟操作系统（Neokylin） 优麒麟（UbuntuKylin） 统信(UOS) OpenEuler 红旗 Linux Alibaba Cloud Linux TencentOS Server 国外的替代品有： RHEL 系列 Almalinux Rocky Linux Oracle Linux Opensuse Amazon Linux Debian 系列 Ubuntu server Debian 其中 AlmaLinux 是开放源码的、社区驱动的项目，它与 Rocky Linux 被认为是替代 CentOS 的不错选择。 AlmaLinux 是一个基于 Red Hat Enterprise Linux（RHEL）的克隆版本，由 CloudLinux 公司发起创建。AlmaLinux 是在红帽决定停止开发 CentOS（非 Stream 版本）之后才建立的，它的开发始于 2020 年 12 月，第一个正式版本在 2021 年 3 月发布。 AlmaLinux 采用 RHEL 8 作为其基础，AlmaLinux 的源代码完全兼容 RHEL，这意味着用户可以在 AlmaLinux 上运行在 RHEL 上运行的所有应用程序和工具。 通过多方面的比较，功能，社区活跃度，背后的 sponsors, 技术实力比较。 AlmaLinux 目前（2024 年 1 月）在 distrowatch 上过去 12 个月的排名是 21, 而 Rocky Linux 的排名是 47。另外 Gitlab 也从 Centos 8 迁移到了 Almalinux 系统。 基于以上种种，最终选择了 AlmaLinux。 2. 下载 AlmaLinuxAlmaLinux同时支持固件接口：BIOS和UEFI。 AlmaLinux支持四种体系结构： 英特尔/AMD（x86_64） ARM64（aarch64） IBM PowerPC（ppc64le） IBM Z（s390x） AlmaLinux为每个受支持的体系结构提供了3种类型的ISO： boot-通过Internet下载软件包的单个网络安装CD映像。 minimum-一个最小的自包含DVD映像，使离线安装成为可能。 dvd-一个完整的安装dvd映像，其中大部分包含所有AlmaLinux软件包。 详细介绍请查看almalinux官方网站 - download 有几种方法可以下载AlmaLinux ISO： 从镜像下载AlmaLinux ISO。从列表中选择离您的地理区域镜像最近的镜像。您需要版本/ISO/arch/目录来下载合适的ISO。 从公共包存储库下载： AlmaLinux 8 AlmaLinux 9 可以在Vault中找到较低版本和测试版 国内可以选择从以下镜像站点下载，以获得较快的下载速度 mirrors.jxust.edu.cn（江西理工大学） mirrors.aliyun.com（阿里云） mirrors.nju.edu.cn（南京大学） mirror.sjtu.edu.cn(上海交通大学) mirrors.neusoft.edu.cn(大连东软信息学院) mirrors.hit.edu.cn(哈工大) 这里以南京大学镜像站为例，下载Almalinux(版本8.8) x86_64架构dvd完整版。 手动下载，访问页面https://mirrors.nju.edu.cn/almalinux/8.8/isos/x86_64/单击相应版本即可下载。 命令行下载 123curl -O https://mirrors.nju.edu.cn/almalinux/8.8/isos/x86_64/AlmaLinux-8.8-x86_64-dvd.iso 3. 安装AlmaLinux如果在物理机上安装Almalinux，则需要制作USB启动盘. 如果在虚拟机上安装AlmaLinux，可以直接将iso挂载到光驱即可。 这里以虚拟机上安装Almalinux为例。 在停机状态修改虚拟机配置，将iso挂载到光驱； 开启虚拟机，等待开机 开机后将进入安装向导界面，选择安装Almalinux8.8 选择语言 设置localization（可选） 设置Software（可选） 设置硬盘分区，可选择安装盘，选择系统自动分区 设置Root用户密码 设置一个普通用户（可选） 等待安装完成 安装完成后，重启虚拟机 阅读和接受license 设置Privacy 设置About you 经过以上步骤，一台Almalinux虚拟机即安装完成 4. 参考文档AlmaLinux installation guide (ISOs) 同为 CentOS 的替代者，AlmaLinux 和 Rocky Linux 有什么区别？该如何选择？ 从Centos-7迁移到AlmaLinux-8.9的教程","link":"/linux/almalinux_install.html"},{"title":"关于 Almalinux Linux 安全加固的 13 条建议","text":"本帮助手册旨在指导系统管理人员或安全检查人员进行 Linux 操作系统的安全合规性检查和加固。 1. 定期更新系统和软件包定期更新操作系统和软件包可以保持系统最新，以修复已知的安全漏洞和弱点。 123sudo dnf update 2. 禁用或删除无用账号减少系统无用账号，降低安全风险。 操作步骤 使用命令 userdel &lt;用户名&gt; 删除不必要的账号。 使用命令 passwd -l &lt;用户名&gt; 锁定不必要的账号。 使用命令 passwd -u &lt;用户名&gt; 解锁必要的账号。 3. 检查特殊账号检查是否存在空口令和 root 权限的账号。 操作步骤 查看空口令和 root 权限账号，确认是否存在异常账号： 使用命令 awk -F: ‘($2==””)’ /etc/shadow 查看空口令账号。 使用命令 awk -F: ‘($3==0)’ /etc/passwd 查看 UID 为零的账号。 加固空口令账号： 使用命令 passwd &lt;用户名&gt; 为空口令账号设定密码。 确认 UID 为零的账号只有 root 账号。 4. 配置强密码策略加强口令的复杂度等，降低被猜解的可能性。 操作步骤 使用命令 vi /etc/login.defs 修改配置文件。 123456789PASS_MAX_DAYS 90 #新建用户的密码最长使用天数PASS_MIN_DAYS 0 #新建用户的密码最短使用天数PASS_WARN_AGE 7 #新建用户的密码到期提前提醒天数PASS_MIN_LEN 8 #密码长度 使用 chage 命令修改用户设置。 例如，chage -m 0 -M 30 -E 2000-01-01 -W 7 &lt;用户名&gt;表示将此用户的密码最长使用天数设为 30，最短使用天数设为 0，密码 2000 年 1 月 1 日过期，过期前七天警告用户。 设置连续输错三次密码，账号锁定五分钟。使用命令 vi /etc/pam.d/common-auth 修改配置文件，在配置文件中添加 auth required pam_tally.so onerr=fail deny=3 unlock_time=300。 5. 限制用户 su限制能 su 到 root 的用户。 操作步骤 使用命令 vi /etc/pam.d/su 修改配置文件，在配置文件中添加行。例如，只允许 test 组用户 su 到 root。 vi /etc/pam.d/su, 添加如下配置 1auth required pam_wheel.so group=wheel 6. 安装并启用防火墙 切记： 开端端口前，请确保 ssh 监听在 22 端口，如果不是在 ssh 默认的端口，一旦防火墙开启，ssh 服务就连接不上，就好导致登陆不上 vps. 12345678910111213# 检查防火墙是否开启sudo firewall-cmd --state# 开启防火墙sudo systemctl start firewalld# 设置为开机启动sudo systemctl enable firewalld# 显示默认区域的所有规则sudo firewall-cmd --list-allsudo firewall-cmd --reload 7. 禁止 root 用户直接登录禁用 root 用户之前先创建可以登陆的普通用户 123456789101112131415161718192021# 创建用户组sudo groupadd &lt;usergroup&gt;# 创建普通用户, replace normal with actual usernamesudo useradd --comment 'Normal User' --gid &lt;usergroup&gt; --create-home &lt;username&gt; --shell /bin/bash# 为新用户设置密码passwd &lt;username&gt;# 测试新用户是否能够远程登陆ssh username@ip#将用户添加到wheel用户组使用户拥有sudo 权限usermod -a -G wheel &lt;username&gt;# 设置user的sudo权限# 注释掉需要密码那个，开启不带密码那个visudo# 使用密钥验证# ssh-copy-id username@ip 限制 root 用户直接登录。 创建普通权限账号并配置密码,防止无法远程登录; sudo vi /etc/ssh/sshd_config 123# 禁止root用户登陆PermitRootLogin no 重启 sshd 服务 1sudo systemctl restart sshd 查看配置是否生效 1234$ sshd -T | grep -i PermitRootLoginpermitrootlogin no 注意： 有时候 sshd 的配置文件位于 /etc/ssh/sshd_config.d，而且优先级较高，所以两个位置都需要检查 8. 更改 ssh 端口vim /etc/ssh/sshd_config ，更改 Port 或追加 Port 注：重启 sshd 服务使配置生效。 9. 强制 SSH 使用密钥认证禁止密码登录修改如下文件 1234567sudo vi /etc/ssh/sshd_config#禁用密码验证PasswordAuthentication no#启用密钥验证PubkeyAuthentication yes 重启服务生效 1sudo systemctl restart sshd 查看是否生效 1sudo sshd -T | grep -i PasswordAuthentication 10. 关闭不必要的服务关闭不必要的服务（如普通服务和 xinetd 服务），降低风险。 操作步骤 使用命令 systemctl disable &lt;服务名&gt;设置服务在开机时不自动启动。 11. 设置 umask 值设置 umask 值 设置默认的 umask 值，增强安全性。 操作步骤 使用命令 vi /etc/profile 修改配置文件，添加行 umask 027， 即新创建的文件属主拥有读写执行权限，同组用户拥有读和执行权限，其他用户无权限。 12. 设置登录超时设置系统登录后，连接超时时间，增强安全性。 操作步骤 使用命令 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为 TMOUT=180，即超时时间为三分钟。 13. 日志启用日志功能，并配置日志记录。 操作步骤 Linux 系统默认启用以下类型日志： 系统日志（默认）/var/log/messages cron 日志（默认）/var/log/cron 安全日志（默认）/var/log/secure 注意：部分系统可能使用 syslog-ng 日志，配置文件为：/etc/syslog-ng/syslog-ng.conf。 您可以根据需求配置详细日志。 14. 参考文档Linux 服务器安全加固 10 条建议 Linux 操作系统加固 Linux 操作系统安全加固措施","link":"/linux/almalinux_sercurity_enhancement.html"},{"title":"linux环境下创建rpm仓库","text":"1. 环境说明centos 7.7 2. 简要说明第一步：首先配置本地可以安装的rpm仓库 第二步：然后安装apache将仓库export出去， 第三步：让局域网上其他计算机其他计算机可以使用自己创建的rpm仓库，也可以称为yum源。 第四步：如果能让internet上其他计算机可以访问该yum源，需要公网IP，如果方便用户记忆需要配置dns解析。(本文由于篇幅所限，不讲解此步骤, 可自行百度了解, 如何配置DNS解析) 3. 配置本地RPM仓库3.1. 安装工具createrepo检查是否以及createrepo，这是配置本地rpm仓库唯一需要安装的工具，其作用是创建rpm仓库的元数据，创建元数据的目的是让包管理器客户端比如yum能方便的获得rpm仓库的索引，以及rpm包之间的依赖关系, 而不必扫描整个仓库获得rpm包信息，及分析依赖。 检查是否以及安装 12$rpm -q createrepopackage createrepo is not installed 如果没有，执行以下命令安装 createrepo 工具 1$sudo yum install -y createrepo 检查是否安装成功 12345$rpm -q createrepocreaterepo-0.9.9-28.el7.noarch$createrepo --versioncreaterepo 0.9.9 查看帮助 123456789$createrepo --helpUsage: genpkgmetadata.py [options]Options: --version show program's version number and exit -h, --help show this help message and exit -q, --quiet output nothing except for serious errors -v, --verbose output more debugging info. --profile output timing/profile info. 3.2. 创建RPM仓库12345678$sudo mkdir -pv /rpm/centos/{6,7}/os/x86_64mkdir: created directory ‘/rpm’mkdir: created directory ‘/rpm/centos’mkdir: created directory ‘/rpm/centos/6’mkdir: created directory ‘/rpm/centos/6/os’mkdir: created directory ‘/rpm/centos/6/os/x86_64’mkdir: created directory ‘/rpm/centos/7’mkdir: created directory ‘/rpm/centos/7/os’mkdir: created directory ‘/rpm/centos/7/os/x86_64’ 3.3. 拷贝RPM包到RPM仓库12cp /root/vsftpd-2.2.2-24.el6.x86_64.rpm /rpm/centos/6/os/x86_64cp /root/tomcat-7.0.76-2.el7.noarch.rpm /rpm/centos/7/os/x86_64 3.4. 创建元数据12$sudo createrepo /rpm/centos/6/os/x86_64/$sudo createrepo /rpm/centos/7/os/x86_64/ 注：通过执行以上命令， createrepo将会在以上目录下分别根据目录下的rpm生成元数据并保存在repodata下; 如果rpm包有更新，需要运行 以下命令更新元数据 12$sudo createrepo --update /rpm/centos/6/os/x86_64/$sudo createrepo --update /rpm/centos/7/os/x86_64/ 完成以上配置，一个本地yum源已经配置成功，下面对本地yum源进行测试 3.5. 测试本地yum源添加本地yum源 1$sudo vi /etc/yum.repos.d/CentOS-Local.repo 123456# 文件内容如下# CentOS-7-localRepo.repo[local_base]name=CentOS-$releasever-localRepo - Basebaseurl=file:///rpm/centos/$releasever/os/$basearchgpgcheck=0 说明： 第一个[ ]中括号里表示仓库的名字，通常这个名字可以自己决定，以方便记忆和理解为原则，但是一般不建议里面带空格， name：表示仓库的简要说明， baseurl= 表示仓库的路径，也就是repodata所在的目录的父目录， gpgcheck=0表示不检查包的gpg验证，若gpgcheck=1表示要验证。 添加以上内容我们客户端就可以根据以上定义的baseurl去服务器仓库里找相应的包。 3.6. 清除yum缓存，查看仓库列表123456789101112131415161718#清除yum缓存$ sudo yum clean all#查看yum源列表$yum repolistLoaded plugins: fastestmirrorDetermining fastest mirrors* base: mirrors.cqu.edu.cn* extras: mirrors.tuna.tsinghua.edu.cn* updates: mirrors.cqu.edu.cnbase | 3.6 kB 00:00:00extras | 2.9 kB 00:00:00my_base | 2.9 kB 00:00:00updates | 2.9 kB 00:00:00(1/5): my_base/7/x86_64/primary_db | 3.1 kB 00:00:00 安装软rpm以vsftpd为例 12345678$yum install vsftpdLoaded plugins: fastestmirror, securitySetting up Install ProcessLoading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check---&gt; Package vsftpd.x86_64 0:2.2.2-24.el6 will be installed--&gt; Finished Dependency Resolution 4. 搭建局域网rpm仓库4.1. 安装apache web服务器1234# 检查是否以及安装httpd$rpm -q httpdpackage httpd is not installed# 如果没有安装, 则执行以下命令安装$sudo yum -y install httpd 说明：httpd默认工作路径在/var/www/html/ 下，也就是放html网页代码的地方。 4.2. 配置apache web 服务器12# 创建软连接指向，之前安装的yum repo:/rpm/centos$sudo ln -s /rpm/centos /var/www/html/centos 由于我的80端口以及被另一个进程占用，所以我需要修改 apache的配置让其监听在另一个端口上 12$sudo vi /etc/httpd/conf/httpd.confListen 8085 4.3. 启动apach web 服务12345678$systemctl start httpd$systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled) Active: active (running) since Fri 2021-02-05 20:12:27 CST; 1min 53s ago Docs: man:httpd(8) man:apachectl(8) #设置为开机启动$systemctl enable httpd 打开浏览器访问 http://192.168.x.x:8085/centos/ 这里的 ip 替换成自己的服务器ip 4.4. 修改或添加yum源测试1$sudo vi /etc/yum.repos.d/CentOS-Local.repo 123456# 文件内容如下# CentOS-7-localRepo.repo[local_base]name=CentOS-$releasever-localRepo - Basebaseurl=http://192.168.x.x:8085/centos/$releasever/os/$basearchgpgcheck=0 修改之前创建的CentOS-Local.repo 中的baseurl为http://192.168.x.x:8085/centos/$releasever/os/$basearch 清空缓存 yum clean all 这样就可以使用局域网yum源了，可以在局域网内的任意一台centos, fedora 或redhat上使用此 yum源了 5. 关联阅读6. 参考文档Linux系统之rpm仓库搭建","link":"/linux/create_rpm_repository_on_linux.html"},{"title":"Fedora 40 找不到声音设备的问题","text":"硬件配置说明。 12$lspci | grep -i audio00:1f.3 Multimedia audio controller: Intel Corporation Tiger Lake-LP Smart Sound Technology Audio Controller (rev 30) 现象： 电脑播放没有声音， 音量控制显示找不到设备 设置 -&gt; 声音找不到音频设备 日志： 1systemctl status --user pipewire pipewire-pulse wireplumber 以上三个服务，没有完全启动，有打印出错误信息。 wpasynceventhook:0x55b609475590 failed: failed to activate item: object activation aborted: proxy destroyed 解决办法： 在/etc/modprobe.d/目录下创建一个alsa-base.conf配置文件 将以下两行拷贝到文件中，重启解决问题： 12options snd-hda-intel dmic_detect=0options snd-hda-intel index=0 参考文档Help Needed with WirePlumber and PipeWire Multimedia Service","link":"/linux/fedora_sound_issues.html"},{"title":"如何在 Fedora 中安装和切换桌面环境","text":"您是否想在Fedora Workstation spin中使用或尝试其他桌面环境，而不是默认的GNOME 3。在本文中，我们将展示如何使用图形用户界面 (GUI) 和命令行界面 (CLI) 在 Fedora Linux 中安装和切换桌面环境。 1. 在 Fedora 中安装额外的桌面环境要在 Fedora 中安装不同的桌面环境，首先需要通过运行以下命令列出所有可用的桌面环境。 123456789101112131415161718192021222324252627dnf grouplist -v可用环境组： Fedora 定制操作系统 (custom-environment) 最小化安装 (minimal-environment) Fedora Server 版本 (server-product-environment) Fedora Cloud Server (cloud-server-environment) Xfce 桌面环境 (xfce-desktop-environment) Phosh Desktop (phosh-desktop-environment) LXDE 桌面环境 (lxde-desktop-environment) LXQt 桌面环境 (lxqt-desktop-environment) Cinnamon 桌面环境 (cinnamon-desktop-environment) MATE 桌面环境 (mate-desktop-environment) Sugar 桌面环境 (sugar-desktop-environment) Deepin 桌面环境 (deepin-desktop-environment) Budgie Desktop (budgie-desktop-environment) 开发和创意工作站 (developer-workstation-environment) Web 服务器 (web-server-environment) 基础设施服务器 (infrastructure-server-environment) 基本桌面环境 (basic-desktop-environment) i3 desktop (i3-desktop-environment) Sway Desktop (sway-desktop-environment)已安装的环境组： Fedora Workstation (workstation-product-environment) 从上述命令的输出中，查找名为“可用环境组”的部分，并使用dnf install命令安装所选的桌面环境。确保以@符号作为前缀，例如： 123sudo dnf install @cinnamon-desktop-environment # 在 Fedora 中安装 Cinnamon Desktop 2. 在 Fedora 中切换桌面环境登录之前，在登录屏幕上，从用户名列表中选择您的用户名（例如TecMint）（如果没有其他用户，则会显示默认用户名）。然后单击密码字段正下方、登录按钮附近的“首选项”图标。 应该出现一个窗口，显示几个不同桌面环境的列表。如果需要的话选择桌面，然后输入密码登录，如下图所示。 登录后，您现在应该拥有Cinnamon桌面环境，如下图所示。 或者，安装switchdesk（用于从命令行切换桌面）和switchdesk-gui（用于从 GUI 切换桌面）。 1sudo dnf install switchdesk switchdesk-gui 安装上述程序后，通过在活动switchdesk-gui搜索栏中搜索桌面切换程序来启动它。打开后，从可用桌面环境列表中选择默认桌面，然后单击“确定”。 您还可以从命令行切换 Fedora 桌面，只需将选定的桌面环境作为唯一参数传递给switchdesk命令，例如，要切换到cinnamon，请运行以下命令。 1sudo switchdesk cinnamon 就这样！在本文中，我们展示了如何在 Fedora Linux 中安装和切换桌面环境。如果您有任何问题或疑问，请使用下面的评论表询问我们。 3. 如何在Fedora 上删除桌面环境如果由于某种原因您想要从系统中删除桌面环境，请使用默认桌面环境登录系统。然后执行下面给出的命令： sudo dnf remove [@环境名称] 要删除cinnamon-desktop-environment，请执行： 123sudo dnf removed @cinnamon-desktop-environment # 在 Fedora 中安装 Cinnamon Desktop","link":"/linux/fedora_switch_desktop_environment.html"},{"title":"如何制作RPM安装包","text":"1. 原文原文how to build RPM Author: Chris Negus Editor: Allison Pranger Date: 09/16/2011 译者：philoenglish.com 团队 2. 概览您已经创建了一些要安装在Red Hat Enterprise Linux系统上的软件。现在的问题是，“软件编写完成后，如何打包该软件以使其他人易于安装和管理？” 答案是将其打包成RPM安装包。 尽管有其他方式，可以将软件打包成特定格式的压缩包（通过压缩包或其他类型的存档文件）通过解压缩的方式安装到Linux系统，但是将Linux软件打包为RPM，可以为您带来一下好处： 在包中包括描述其组件，版本号，大小，包的元数据, 组，项目网址等待信息。 将软件包添加到yum存储库，以便客户可以轻松找到您的软件 让客户端使用常见的Linux工具（yum，rpm和PackageKit）来安装，删除和管理您的软件。 使用相同的Linux安装工具轻松更新和部署软件的新版本 您无需成为程序员即可创建RPM：只需了解如何创建SPEC文件并使用命令来构建该SPEC文件, 并将内容打包到RPM中。如何打包RPM格式的安装包是本文要详述的内容。创建RPM安装包不仅对管理公司的软件有用，而且也被列为红帽认证工程师（RHCE）考试技能测试范畴。 3. 初步理解RPMS的构建过程3.1. 了解RPMS的构建过程创建RPM包需要了解如何使用文本编辑器以及如何运行一些创建,签名，发布命令 需要打包的软件准备好以后，构建RPM所需的大部分工作是编辑RPM SPEC文件。 在SPEC文件中，您可以： 确定软件包中的命令，配置文件，文档和其他项目 定义最终在目标Linux系统上安装组件的位置 设置每个文件的权限和所有权 定义依赖包 将文件标记为配置文件或文档文件 定义安装或卸载时需要额外执行的命令（例如创建用户帐户，创建目录或移动文件） 添加变更日志，以识别您的每个软件版本中进行了哪些更改 一旦掌握了构建RPM的基本功能（如本文档所述），您便可以会发现大量强大灵活的RPM打包工具帮助您创建RPM。 例如，您可以将平台特定的标签添加到SPEC文件，以便可以使用相同的标签。使用同样的SPEC文件来为多种计算机体系结构构建RPM。 4. 将现有的源代码包重建为RPM学习如何创建RPM软件包的最好方法是从现有的源代码RPM软件包开始,并重建它。 通过该过程，您可以明白创建RPM包所涉及的过程和组件。本节概述了从现有资源重建tree RPM软件包的步骤。 注意：构建此RPM后，请勿在生产系统上使用它，因为该软件包将与一个已经存于Red Hat Enterprise Linux软件频道中的RPM包产生冲突。 登录：以普通用户（非root用户）身份登录Red Hat Enterprise Linux系统 获取源代码包：下载有效的源代码包。 本示例使用的源代码包 123wget ftp://ftp.redhat.com/pub/redhat/linux/enterprise/6Workstation/en/os/SRPMS/tree-1.5.3-2.el6.src.rpm 安装源代码：将源代码安装到新的~/rpmbuild目录 123rpm -ihv tree-1.5.3-2.el6.src.rpm 这将在您的主目录中创建一个rpmbuild目录结构，类似于以下内容： 12345678910111213141516171819~/SPECS~/SPECS/tree.spec~/BUILDROOT~/SOURCES~/SOURCES/tree-1.5.3.tgz~/SOURCES/tree-1.2-no-strip.patch~/SOURCES/tree-no-color-by-default.patch~/SOURCES/tree-1.2-carrot.patch~/SOURCES/tree-preserve-timestamps.patch 注意：您的主目录中的新rpmbuild目录包括一个SPECS目录（该目录包括tree.spec文件）和SOURCES目录。 SOURCES目录包含代码的tree1.5.3.tgz压缩文件和四个补丁文件。 编辑规格文件：查看规格文件。 使用vim或emacs编辑器会在编辑文件时为文件添加颜色 123vim ~/rpmbuild/SPECS/tree.spec 示例文件的内容如下所示。 完成更改后，保存并退出文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Summary: File system tree viewerName: treeVersion: 1.5.3Release: 2%{?dist}Group: Applications/FileLicense: GPLv2+Url: http://mama.indstate.edu/users/ice/tree/Source: ftp://mama.indstate.edu/linux/tree/tree-%{version}.tgzPatch1: tree-1.2-carrot.patchPatch2: tree-1.2-no-strip.patchPatch3: tree-preserve-timestamps.patchPatch4: tree-no-color-by-default.patchBuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)%descriptionThe tree utility recursively displays the contents of directories in a treelike format. Tree is basically a UNIX port of the DOS tree utility.%prep%setup -q# Fixed spelling mistake in man page.%patch1 -p1 -b .carrot# Don't strip binary in the Makefile -- let rpmbuild do it.%patch2 -p1 -b .no-strip# Preserve timestamp on man page.%patch3 -p1 -b .preserve-timestamps# Disable color output by default.%patch4 -p1 -b .no-color-by-default%buildmake CFLAGS=&quot;$RPM_OPT_FLAGS&quot; &quot;CPPFLAGS=$(getconf LFS_CFLAGS)&quot; %{?_smp_mlags}%installrm -rf $RPM_BUILD_ROOTmkdir -p $RPM_BUILD_ROOT%{_bindir}make BINDIR=$RPM_BUILD_ROOT%{_bindir} \\MANDIR=$RPM_BUILD_ROOT%{_mandir}/man1 \\installchmod -x $RPM_BUILD_ROOT%{_mandir}/man1/tree.1%cleanrm -rf $RPM_BUILD_ROOT%files%defattr(-,root,root)%{_bindir}/tree%{_mandir}/man1/tree.1*%doc README LICENSE%changelo... 安装rpm-build软件包后，您可以在以下位置阅读有关SPEC文件功能的信息： /usr/share/doc/rpm-build*/spec文件。 name是程序包的base name, summary是该程序包的单行说明, Version是upstream版本号包， 而Release是您作为打包者添加的编号，以反映该版本的多个版本 相同的上游版本（例如错误修复）, URL指向生成源代码的项目站点， Source指向用于制作程序包的原始源代码, BuildRoot标识位置RPM的临时目录, 其他行准备构建环境，添加 修补，编译和构建软件，标识软件包中的文件和权限，以及 允许您记录随时间变化的日志。 在本文档的最后，您可以找到一些rpm -qp选项，可用于检查 您构建的软件包的内容。 4.5. 构建RPM使用rpmbuild命令将您的spec file和内容转换为RPM包， 您还可以将源代码打包到单独的源RPM(src.rpm)中。 安装rpm-build软件包（以root用户身份）并运行rpmbuild（普通用户）： 123456789# Run as root$ sudo yum install rpm-build#Run as regular user account$ rpmbuild -ba ~/rpmbuild/SPECS/tree.spec -ba 编译后做成*.rpm和src.rpm 这样会在RPMS和SRPMS子目录中分别生成二进制RPM包和源码RPM包。 4.6. 签名RPM为了防止RPM在分发的各个阶段被恶意篡改，需要对RPM包签名。 签名RPM包要求您创建一对公钥和私钥，使用私钥对您的RPM签名， 然后将公钥分发给客户端，以便客户端验证安装包的可靠性，以防止安装包被恶意篡改。 12345#创建 公钥私钥对 $ gpg --gen-key 生成公用/专用密钥时，大多数参数可以使用默认值。 输出结类似于以下形式 123456789pub 2048R/99A9CF07 2011-09-16Key fingerprint = 90BF B5DC 628E C9E0 88D0 E5D1 E828 4641 99A9 CF07uid Chris Negus (My own build of the tree package.)sub 2048R/48E60E56 2011-09-16 使用生成的密钥ID（在本例中为99A9CF07）将私钥导出为公钥: 12345#Export public key$ gpg -a -o RPM-GPG-KEY-ABC –-export 99A9CF07 为了确保使用密钥ID对软件包进行签名，可以在.rpmmacros 文件添加如下_gpg_name参数： 12345#Add _gpg_name keyID to your .rpmmacros filevi ~/.rpmmacros 123%_gpg_name 99A9CF07 现在您可以给RPM包签名了。 12345#Sign pkg$ rpm –-resign ~/rpmbuild/RPMS/x86_64/tree-1.5.3-2.el6.x86_64.rpm 4.7. 在yum存储库中发布RPM发布RPM的一种方式是，在已有 Web服务器的基础桑创建yum存储库，并将RPM发布到yum存储库，以便各种客户端工具可以访问到RPM包。 下面假设系统中已经安装正在运行了Web服务器，以下步骤将演示如何创建一个yum存储库并发布RPM到此存储库。 12345678910111213$ sudo mkdir /var/www/html/abc#Make the public key available$ sudo cp ~/RPM-GPG-KEY-ABC /var/www/html/abc/$ sudo cp ~/rpmbuild/RPMS/x86_84/tree-1.5.3-2.el6.x86_64.rpm /var/www/html/abc/#Create the yum repository$ sudo createrepo /var/www/html/abc 4.8. 创建存储库（.repo）文件创建一个.repo文件，该文件标识存储库的URL。 想要安装软件包的客户端将能够简单地将abc.repo文件复制到自己的文件中 RHEL系统的/etc/yum.repos.d目录将其启用。 替换what.example.com 使用您自己的Web服务器的FQDN： 123$vim abc.repo 123456789[abc-repo]name=My ABC yum repositorybaseurl=http://whatever.example.com/abcgpgkey= http://whatever.example.com/RPM-GPG-KEY-ABC 123cp abc.repo /var/www/html/abc 4.9. 准备客户端以安装RPM要安装RPM，客户端只需简单地将abc.repo文件复制到/etc/yum.repos.d目录，然后使用yum命令从您的存储库安装任何软件包即可。 12345sudo wget http://whatever.example.com/abc/abc.repo -O /etc/yum.repos.d/abc.reposudo yum install tree 要在将来如果要更新RPM，您只需重建RPM，将最新版本复制到yum 存储库目录（本例中为/var/www/html/abc），然后重新运行createrepo命令。 客户下次将安装最新的RPM包或更新软件包。 4.10. 检查您的RPM包装一旦完成RPM的构建，就可以使用rpm命令检查其内容并进行 确保签名是否正常工作。 您可以在任何Red Hat Enterprise Linux系统上执行此操作，只要您 可以获得包和公钥。 4.10.1. 首先导入用于签名软件包的密钥并检查签名123456789# Import key file$ sudo rpm --import ~/RPM-GPG-KEY-ABC# Check signature$ rpm -K ~/rpmbuild/RPMS/x86_64/tree-1.5.3-2.el6.x86_64.rpm 123~/rpmbuild/RPMS/x86_64/tree-1.5.3-2.el6.x86_64.rpm: sha1 md5 OK 4.10.2. 接下来，检查文件的内容这可以通过多种方式来实现。 选项 -q 查询 -p 从软件包查询包信息（如果不指定该参数，命令默认将从rpm数据库查询，而数据库中未安装此rpm包，可能得不到信息，或其他版本的信息） -i 显示信息 123rpm -qpi ~/rpmbuild/RPMS/x86_64/tree-1.5.3-2.el6.x86_64.rpm 123456789101112131415161718192021222324252627Name : tree Relocations: (not relocatable)Version : 1.5.3 Vendor: (none)Release : 2.el6 Build Date: Thu 15 Sep 2011 11:53:37 PM EDTInstall Date: (not installed) Build Host: cnegus.linuxtoys.netGroup : Applications/File Source RPM: tree-1.5.3-2.el6.src.rpmSize : 73868 License: GPLv2+Signature : (none)URL : http://mama.indstate.edu/users/ice/tree/Summary : File system tree viewerDescription :The tree utility recursively displays the contents of directories in atree-like format. Tree is basically a UNIX port of the DOS treeutility. 使用-l（小写L）选项，可以列出软件包的内容： 12345678910111213$ rpm -qpl ~/rpmbuild/RPMS/x86_64/tree-1.5.3-2.el6.x86_64.rpm/usr/bin/tree/usr/share/doc/tree-1.5.3/usr/share/doc/tree-1.5.3/LICENSE/usr/share/doc/tree-1.5.3/README/usr/share/man/man1/tree.1.gz rpm命令还有许多其他选项用于检查和使用RPM软件包。 参考rpm手册页以获取详细信息（键入man rpm）。 5. 从零开始构建RPM要创建自己的RPM，您需要创建自己的spec文件（并将其放在SPECS目录中），然后 将所需的可执行文件，脚本，用户文档文件和配置文件收集到压缩包中 包含在RPM中。 您可以通过简单地复制现有的规范文件并对其进行修改来创建规范文件。 或者您可以使用vim或emacs命令打开以.spec结尾的任何新文件。 编辑器将在新文件中自动创建一个模板以方便编写RPM spec文件。 那你可以 遵循本文档前面介绍的其余部分。 要查看RPM内容压缩包的示例，可以尝试使用tar解压缩tree安装包和源码包： 123456789101112131415161718192021$ tar xvf ~/rpmbuild/SOURCES/tree-1.5.3.tgztree-1.5.3/CHANGEStree-1.5.3/INSTALLtree-1.5.3/LICENSEtree-1.5.3/Makefiletree-1.5.3/READMEtree-1.5.3/tree.ctree-1.5.3/strverscmp.ctree-1.5.3/man/tree.1tree-1.5.3/man/tree.1.fr 要创建自己的tarball，你可以简单的将内容放在 一个目录中（例如〜/ abc-1.0）并把包含在SOURCES的文件包装成一个tarball即可： 123tar -cvzf ~/rpmbuild/SOURCES/abc-1.0-1.tar.gz ~/abc-1.0/ 6. 获得更多关于RPMS的帮助构建RPM的能力远远超出本文档中的描述。 大多数复杂性来自构建 spec文件。 您可以定义依赖对其他应用或库文件的依赖关系，设置文件的类型和权限，并在安装或卸载软件包时运行脚本。 下面是一些可以寻找帮助的地方： 怎样创建RPM包 (Fedora Project) 已经为Fedora项目创建了数千个RPM软件包。 FedoraProject.org网站上有一个 与创建用于Red Hat Enterprise Linux的RPM相似的出色文档： http://fedoraproject.org/wiki/How_to_create_an_RPM_package 使用 RPM 打包软件 还可以在以下站点找到更多信息，以帮助您开始构建第一个RPM： http://www.ibm.com/developerworks/library/l-rpm1/ 参考文档rpmbuild命令详解","link":"/linux/how_to_create_rpm_package.html"},{"title":"Linux下安装gradle","text":"1. 前言Gradle 是以 Groovy 语言为基础，面向Java应用为主。基于DSL（领域特定语言）语法的自动化构建工具 下面就描述一下如何在linux环境下安装配置gradle环境. 2. 前置条件2.1. 需要先安装Java8 或更高版本1234567java -versionPicked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gaspopenjdk version &quot;1.8.0_171&quot;OpenJDK Runtime Environment (build 1.8.0_171-8u171-b11-2-b11)OpenJDK 64-Bit Server VM (build 25.171-b11, mixed mode) 3. 安装123456789$sudo mkdir /opt/gradle$cd /opt/gradle$sudo wget https://services.gradle.org/distributions/gradle-5.3.1-all.zip$sudo unzip -d /opt/gradle gradle-5.3.1-all.zip$ls /opt/gradle/gradle-5.3.1bin docs getting-started.html init.d lib LICENSE media NOTICE samples src 4. 后续更多linux相关知识, 请参考鹏叔的技术博客linux tag, 获取实时更新的Linux文章.","link":"/linux/install_gradle_on_linux.html"},{"title":"在fedora35上安装virtualbox","text":"1. 安装 virtualBox 首先下载oracle_vbox.asc文件到本地： wget -q https://www.virtualbox.org/download/oracle_vbox.asc 再执行import： 1sudo rpm --import oracle_vbox.asc cd 进入目录：/etc/yum.repos.d新建一个文件virtualbox.repo 123456789sudo cat &lt;&lt; EOF &gt; /etc/yum.repos.d/virtualbox.repo[virtualbox]name=Oracle Linux / RHEL / fedora-\\$releasever / \\$basearch - VirtualBoxbaseurl=http://download.virtualbox.org/virtualbox/rpm/fedora/\\$releasever/\\$basearchenabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://www.virtualbox.org/download/oracle_vbox.ascEOF 更新缓存 1dnf check-update 查询可安装版本 1dnf list virtualbox-6.1 --showduplicates 然后执行命令行 1yum install VirtualBox-6.1 安装kernal-devel 1sudo dnf install kernel-devel-5.14.10-300.fc35 版本应该与当前内核版本一致 更新virtualbox配置 1sudo /sbin/vboxconfig 1.1. 参考文档virtualbox 官方wiki 2. 后续更多linux相关知识, 请参考鹏叔的技术博客linux tag, 获取实时更新的Linux文章.","link":"/linux/install_virtualbox_on_fedora35.html"},{"title":"Linux expect 详解","text":"1. Expect简介 Expect是Unix系统中用来进行自动化控制和测试的软件工具，由Don Libes制作，作为Tcl(Tool Command Language)脚本语言的一个扩展，应用在交互式软件中如telnet，ftp，passwd，fsck，rlogin，tip，ssh等等。该工具利用Unix伪终端包装其子进程，允许任意程序通过终端接入进行自动化控制；也可利用Tk工具，将交互程序包装在X11的图形用户界面中。 Expect含有利用正则表达式进行模式匹配以及通用的编程功能，允许简单的脚本智能地管理如下工具：telnet,ftp和ssh（这些工具都缺少编程的功能），宏以及其它程序。Expect脚本的出现使得这些老的软件工具有了新的功能和更多的灵活性。 2. 安装expect首先检查系统是否自带了expect程序， 一般在 系统的/usr/bin目录下， 如果没有自带expect, 那么需要自行安装expect. 这里仅介绍ubuntu和redhat系列linux的安装方法。ubuntu系列 1apt-get install expect redhat系列 1yum install expect 3. 一个简单的ssh登录远程服务器的例子 创建一个ssh_auto_login.exp脚本文件 123456#!/usr/bin/expectset timeout 30 spawn ssh -l username 192.168.1.2 expect &quot;password:&quot; send &quot;ispass\\r&quot;interact 说明： 第一行 #!/usr/bin/expect 与执行方式有关， 当我么以 ./ssh_auto_login.exp，我们必须通过第一行告诉操作系统，脚本需要通过/usr/bin/expect程序来运行，而且我们还要授予文件可执行权限。如果我们以下面这种方式执行ssh_auto_login.exp， 也可以不用写第一行， 而且不必授予其可执行权限。 1expect ssh_auto_login.exp 第二行 set timeout 30 设置命令的命令的超时时间， 单位是秒。 第三行 spawn ssh -l username 192.168.1.2，后面的ssh登录命令很好理解，这里主要解释前面为什么需要添加一个spawn, spawn是expect程序的一个内置命令，使用它将我们需要执行的各种shell命令包裹起来，这样就shell命令注入了和自动化脚本expect, send交互的能力。只有包裹后程序才有机会获取shell命令的输出，并根据输出做出反应。它是expect的灵魂所在。不清楚软件作者这里为什么要使用spawn这个单词，这里有些晦涩难懂，spawn作动词主要是产卵， 繁殖的意思，我始终不能把产卵和spawn在expect程序中的行为和作用联系起来。我只能发挥想象把spawn想象成一个大卵泡， 卵泡里面包裹的DNA物质就是我们正真执行的核心程序，脚本通过这个巨大的卵泡与核心程序进行交互。 第四行expect “password:”这里的expect是expect的一个内部命令, 是不是有点晕，此expect非彼expect， 彼expect是指第一行中的#!/usr/bin/expect, 或者expect ssh_auto_login.exp 中的expect, 彼expect是一个shell命令， 而此expect是/usr/bin/expect内部的一个子命令。 有点像一个叫expect的妈妈怀了一个叫expect的小崽子。是不是更晕了， 如果更晕了，那就对了， 慢慢体会。 我真搞不懂英语中那么多表示期望期待的单词词组，作者为什么要卯着这一个词用，害苦了这帮后入行的程序员， 一代比一代脱发厉害:)。 回归正题， 这个命令的意思是判断上次输出结果里是否包含“password:”的字符串 如果有则立即返回否则就等待一段时间后返回这里等待时长就是前面设置的30秒。 注意这里的用词是包含，也就是如果完整输出是”please in put your password:”也算中，河南话中，普通话也算满足期待的条件，哪个简洁? :) 输出是千变万化的，比如不同的主机，ssh过去它的提示信息可能都不一样，难道我们的我们expect程序就要认怂嘛，这才第四行代码当然不能，expect 后面可以接收正则表达式, 这样无论提示符号是pwd, passwd, password, 正则表达式都能搞定它，正则就是如来佛的手掌心。 这里的输出是指哪里的输出， 这里的输出是指控制台的输出不是文件输出，控制台有正常输出和错误输出，怎么算？留个思考题 第五行 send “ispass\\r” 当expect接收到“password:”提示符，所以上面的expect实际是在等待“password:”提示符出现，使用等待多好，wait, 等待“password:”提示符出现后继续往后执行，紧接着地就是send命令， send将密码发送到控制台，这里是输入通道。 写到这里想象善于思考的朋友，肯定会想到，如果前面的expect命令等待超时了，即没有出现输入密码提示，这里的send 会不会被执行？代码不长，大家可以自己动手测试一下。只有把这个搞清楚了， 第二行代码的作用才算彻底弄明白。 这里再留个思考题，代码这样写密码是不是很容易泄露，有什么办法即使脚本被截获，密码不泄露？ 第六行 interact 前面几行都是本地机器和远程机器自动的在交互，自动程序帮你把电脑开机了，服务器登录了，空调开启了，茶泡好了(假设程序能泡茶，可以想象一下)，接下来控制权还是要交给人类， 这里的interact即使将控制权由机器控制转换为人机交互， 由人来接管。 4. 后记本文原文位于鹏叔的技术博客 - Linux expect 详解, 获取最近更新, 请访问原文. 5. 参考文档Expect—百科篇命令 expect(1) - Linux man page","link":"/linux/linux-expect-explanation.html"},{"title":"Redhat系列yum源介绍","text":"CentOS 默认自带 CentOS-Base.repo 源，但官方源中去除了很多有版权争议的软件，而且安装的软件也不是最新的稳定版。 Fedora 自带的源中也找不到很多多媒体软件，如果需要安装，必需先添加其他源，如 RPMFusion 和 RPMForge 等第三方软件库。 下面鹏叔来一一介绍各种第三方软件库，以下软件库适用于与 RHEL 完全兼容的 linux 发行版 1. EPEL 源EPEL,即 Extra Packages for Enterprise Linux,是由 Fedora 社区创建维护，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。EPEL 中含有大量的软件，对官方标准源是一个很好的补充。 wiki: https://docs.fedoraproject.org/en-US/epel/ Fedora EPEL 下载：https://admin.fedoraproject.org/mirrormanager/ 1.1. 安装 EPEL 源针对各种不同的版本安装 EPEL 源： EL9 CentOS Stream 9 1234dnf config-manager --set-enabled crbdnf install epel-release epel-next-release RHEL 9 1234subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpmsdnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm AlmaLinux 9, Rocky Linux 9 1234dnf config-manager --set-enabled crbdnf install epel-release EL8CentOS Stream 8 12dnf config-manager --set-enabled powertoolsdnf install epel-release epel-next-release RHEL 8 1234subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpmsdnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm AlmaLinux 8, Rocky Linux 8 12dnf config-manager --set-enabled powertoolsdnf install epel-release EL7 RHEL 7 1234subscription-manager repos --enable rhel-*-optional-rpms \\ --enable rhel-*-extras-rpms \\ --enable rhel-ha-for-rhel-*-server-rpmsyum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm CentOS 7 123yum install epel-release 2. REMI 源REMI yum 源是一个包含最新版本 PHP 和 MySQL 包的 Linux 软件源，由 Remi 提供维护。使用这个源可以方便地通过 YUM 安装或更新 PHP、MySQL、phpMyAdmin 等服务器相关程序，是 Linux 系统管理员和开发者常用的 yum 仓库之一。 Remi 下载地址：https://rpms.remirepo.net/ 2.1. 安装 REMI 源最简单的方法是安装 remi release 包，该包提供 YUM/DNF 的存储库配置和用于签署 RPM 的 GPG 密钥。 Enterprise Linux 9 - x86_64 123dnf install https://rpms.remirepo.net/enterprise/remi-release-9.rpm Enterprise Linux 8 - x86_64 123dnf install https://rpms.remirepo.net/enterprise/remi-release-8.rpm Enterprise Linux 7 (with EPEL) x86_64 123456# REMI 依赖EPEL包wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmwget https://rpms.remirepo.net/enterprise/remi-release-7.rpmrpm -Uvh remi-release-7.rpm epel-release-latest-7.noarch.rpm for RHEL only 1subscription-manager repos --enable=rhel-7-server-optional-rpms Fedora 39 x86_64 1dnf install https://rpms.remirepo.net/fedora/remi-release-39.rpm Fedora 38 x86_64 1dnf install https://rpms.remirepo.net/fedora/remi-release-38.rpm Fedora 37 x86_64 1dnf install https://rpms.remirepo.net/fedora/remi-release-37.rpm 2.2. REMI 源与其他 yum 源的兼容性虽然 REMI repo 提供了许多有用的软件包，但与其他 repo 的兼容性可能需要额外的注意和管理。通过仔细规划和管理您的软件包安装和更新过程，您可以最大限度地减少潜在的问题。 在 Fedora 上，REMI 上可用的 RPM 主要使用来自 fedora 和 updates yum 源，有时来自 Rpmfusion yum 源。 在 RHEL 和 CentOS 上，依赖项位于 main 和 EPEL yum 源。不建议使用 Rpmforge yum 源（众所周知与 EPEL 的冲突）。 在 RHEL-6 上，必须启用 RHEL 服务器可选通道。 2.3. 安装 REMI 签名如果使用包管理器（Yum 或 dnf），则不需要执行此步骤。YUM/DNF 将建议您在首次安装存储库 RPM 时自动安装它。 RPM 有效性检查要求在使用之前将密钥导入您的系统。下载GPG 密钥、GPG 密钥 2017、GPG 钥匙 2018、GPG 关键字 2019、GPG 密码 2020、GPG 密匙 2021、GPG 加密匙 2022、GPG 破解匙 2023、GPG 解密匙 2024，并使用以下软件安装所需软件： 1234567891011rpm --import RPM-GPG-KEY-remirpm --import RPM-GPG-KEY-remi2017rpm --import RPM-GPG-KEY-remi2018rpm --import RPM-GPG-KEY-remi2019rpm --import RPM-GPG-KEY-remi2020rpm --import RPM-GPG-KEY-remi2021rpm --import RPM-GPG-KEY-remi2022rpm --import RPM-GPG-KEY-remi2023rpm --import RPM-GPG-KEY-remi2024 3. RPM Fusion 源RPMFusion 是一个为 Fedora、Red Hat Enterprise Linux (RHEL)及其衍生版本（如 CentOS 和 Scientific Linux）提供额外软件包的软件仓库，它包含了许多在默认仓库中不可用的开源软件，如音频和视频编解码器、图形软件等。。这个仓库包含了官方发行版中不可用的许多开源软件包，旨在扩展这些 Linux 发行版的功能。 RPMFusion 有两个主要的子仓库：free 和 non-free。 RPMFusion Free：这个子仓库包含了遵循自由软件许可证（如 GPL）的软件包。这些软件包是开源的，用户可以自由使用、修改和重新分发。RPMFusion Free 仓库提供了广泛的软件选择，包括音频和视频编解码器、图形软件、科学计算工具等。 RPMFusion Non-Free：这个子仓库包含了不遵循自由软件许可证的软件包，可能包括专有软件或受专利保护的编解码器。这些软件包通常不是开源的，但仍然非常有用，特别是对于那些需要特定功能（如商业软件的插件或驱动程序）的用户。 需要注意的是，由于 RPMFusion 提供了官方仓库之外的软件包，这些软件包可能没有经过与官方发行版相同的测试和验证过程。因此，在安装和使用 RPMFusion 中的软件包时，用户需要谨慎并确保它们与系统的其他组件兼容。此外，RPMFusion 仓库中的软件包可能不会受到官方发行版的支持和维护，因此在遇到问题时，用户可能需要依赖社区或软件包维护者提供的帮助。 RPMFusion 是一个非常有价值的资源，它扩展了 Fedora、RHEL 及其衍生版本的功能，使用户能够轻松安装和使用许多额外的开源和专有软件包。然而，在使用 RPMFusion 源时，用户需要了解其提供的软件包的许可证和兼容性，并愿意自行解决可能出现的问题。 RPMfusion 官网：https://rpmfusion.org/ 3.1. 安装 RPM Fusion 源要启用对免费和非免费存储库的访问，请使用以下命令： Fedora with dnf: 12sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpmsudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm 在 Fedora 上，我们默认使用 openh264 库，因此您需要明确启用存储库： 123sudo dnf config-manager --enable fedora-cisco-openh264 RHEL or compatible like CentOS 123sudo dnf install --nogpgcheck https://dl.fedoraproject.org/pub/epel/epel-release-latest-$(rpm -E %rhel).noarch.rpmsudo dnf install --nogpgcheck https://mirrors.rpmfusion.org/free/el/rpmfusion-free-release-$(rpm -E %rhel).noarch.rpm https://mirrors.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-$(rpm -E %rhel).noarch.rpm CentOS Steam 8 requires an additional step 1sudo dnf config-manager --enable powertools CentOS 8 (older version) used a case sensitive name for the PowerTools repository 1sudo dnf config-manager --enable PowerTools RHEL 8 requires an additional step 1sudo subscription-manager repos --enable &quot;codeready-builder-for-rhel-8-$(uname -m)-rpms&quot; 4. IUS (Inline with Upstream Stable) 源IUS 源提供了许多与上游稳定版本保持一致的开源软件包，包括 PHP、Python、Nginx 等。如果你需要跟踪上游软件的最新版本，同时又想保持系统的稳定性，那么 IUS 源是一个不错的选择。 5. Nux DextopNux Dextop repository：这个仓库提供了一些最新的桌面软件和开发工具，如 LibreOffice、GIMP 等。如果你需要在 RHEL 上使用最新的桌面应用程序，那么 Nux Dextop 源是一个很好的选择。 6. 查询安装包对应的 yum 源有一些网站和工具可以帮助你查询安装包对应的 yum 源以及提供的版本。以下是一些常用的资源： RPM Search：这是一个在线搜索 RPM 软件包的网站，你可以在上面搜索特定的软件包，并查看提供该软件包的不同 yum 源及其版本信息。 RPM Seek：这是一个提供 RPM 包搜索服务的网站。你可以在该网站上搜索特定的 RPM 软件包，并获取相关的下载链接和版本信息。 PKGS.org：这是一个综合性的软件包搜索网站，支持多种 Linux 发行版和包管理器，包括 RPM。你可以在该网站上搜索 RPM 软件包，并查看不同发行版中的软件包版本和可用性。 rpmfind.net 是一个提供 RPM 包搜索服务的网站。用户可以在该网站上搜索并查找特定的 RPM 软件包。该网站通常会索引多个不同的 RPM 仓库和软件源，以便用户能够找到他们所需的软件包。 Repoquery：这是一个在本地系统上查询 yum 源的软件包信息的工具。使用 repoquery，你可以查找特定软件包在哪个 yum 源中可用，以及该源提供的软件包版本。要使用 repoquery，你需要在终端中运行相应的命令，如 repoquery –whatprovides 。repoquery 是 yum 扩展工具包 yum-utils 中的一个工具，所有如果你没有 repoquery 命令的话，可以先 sudo yum install yum-utils 安装 yum-utils 包。 YUM Utils：这是一组额外的工具和程序，用于管理和维护 YUM 软件包安装器。其中一些工具，如 package-cleanup，可以帮助你查找并管理系统中安装的软件包及其版本。你可以使用 YUM Utils 来查询软件包在不同 yum 源中的可用性。 需要注意的是，具体的网站和工具可能会因 Linux 发行版和软件包管理器的不同而有所变化。对于基于 RHEL、CentOS 或 Fedora 的系统，上述资源通常适用。然而，对于其他发行版，你可能需要查找相应的资源或工具来查询软件包对应的 yum 源和版本信息。 另外，记得在使用第三方 yum 源时要谨慎，并确保其可信度和与你的系统版本兼容。在添加新的 yum 源之前，最好先在测试环境中进行验证，以确保稳定性和安全性。 7. 参考文档RHEL/CentOS/Fedora 各种源(EPEL、Remi、RPMForge、RPMFusion)配置","link":"/linux/linux_RHEL_yum_extra_repos.html"},{"title":"linux命令行连接wifi","text":"1. 环境描述 以下是验证本教程使用的环境 12345$uname -a Linux computer_name 5.4.70-amd64-desktop #1 SMP Wed Oct 14 15:24:23 CST 2020 x86_64 GNU/Linux $cat /proc/version Linux version 5.4.70-amd64-desktop (deepin@deepin-PC) (gcc version 8.3.0 (Uos 8.3.0.3-3+rebuild)) #1 SMP Wed Oct 14 15:24:23 CST 2020 2. 确认无线网卡状态 使用 iwconfig 命令查询当前网卡状态 123$iwconfig$iwconfigwlp3s0 IEEE 802.11 ESSID:&quot;&quot; 我的无线网卡id为wlp3s0 如果无线网卡未开启，需要将其开启 1sudo ip link set wlp3s0 up 3. 查看可用wifi扫描可用wifi 1sudo iw wlp3s0 scan|grep SSID 4. 配置wifi说明：本人连接的是企业版wifi,需要验证用户名和密码。如果是个人版，配置文件会和下面不一样以管理员身份修改/etc/wpa_supplicant/wpa_supplicant.conf 123456789network={ssid=&quot;wifi name&quot;scan_ssid=1key_mgmt=WPA-EAPeap=PEAPidentity=&quot;your login id&quot;password=&quot;your password&quot;priority=1} 5. 链接wifi123sudo wpa_supplicant -i wlp3s0 -c /etc/wpa_supplicant/wpa_supplicant.conf#或者启动为守护进程sudo wpa_supplicant -B -i wlp3s0 -c /etc/wpa_supplicant/wpa_supplicant.conf 6. 获取ip 地址1sudo dhclient wlp3s0 7. 验证是否链接成功 检查是否成功连接到wifi 获取到ip 地址 123ifconfig或者ip address 8. trouble shooting issue 1:如果遇到类似下面这样的问题， 可以考虑关闭wpa_applicant 进程，再重新连接wlp3s0: Associated with 6c:8b:d3:wlp3s0: CTRL-EVENT-EAP-STARTED EAP authentication startedwlp3s0: CTRL-EVENT-DISCONNECTED bssid=6c:8b:d3:c7: reason=3 locally_generated=1 solution: 1sudo killall wpa_supplicant 9. 后续更多linux相关知识, 请参考鹏叔的技术博客linux tag, 获取实时更新的Linux文章.","link":"/linux/linux_connect_wifi.html"},{"title":"在Fedora 39上安装Libreoffice","text":"1. 办公软件产品介绍 LibreOffice 是一款开放源代码的自由免费全能办公软件，可运行于 Microsoft Windows、GNU/Linux 以及 macOS 等操作系统上。它包含了 Writer、Calc、Impress、Draw、Math 以及 Base 等组件，可分别用于文本文档、电子表格、幻灯片演示文稿、绘图文档、数学公式编辑、数据库管理等工作。 Apache OpenOffice：这是另一个开源的办公软件套件，与 LibreOffice 类似，也支持各种文档格式和扩展插件。它包括文字处理、电子表格、幻灯片、数据库和绘图等功能。 Microsoft Office：这是微软公司开发的办公软件套件，其中包括 Word、Excel、PowerPoint 等组件，具有强大的文档处理、表格制作、幻灯片演示等功能。此外，它还支持各种扩展插件和自定义工具，可根据用户需求进行定制。 Google Docs：这是谷歌公司开发的在线办公软件套件，包括文档、表格、幻灯片等功能。它支持实时协作和编辑，允许多个用户同时在线编辑文档，并且可以方便地分享和导出文件。 WPS Office：这是一款出自中国的办公软件套件，包括文字处理、电子表格、幻灯片等功能。它支持多种文档格式，并且具有轻量级、快速启动和运行的特点。WPS Office 还提供了许多模板和素材，方便用户快速创建专业的文档、表格和幻灯片演示文稿。 2. 选择libreoffice的原因之所以选择LibreOffice，主要基于以下几个原因： 自由和开源：LibreOffice是一款自由开源的软件，用户可以自由地使用、修改和分发该软件的源代码。这使得用户能够更加信任和依赖该软件，同时也可以为该软件的发展做出贡献。 跨平台：LibreOffice可以在多个操作系统上运行，包括Windows、Linux和macOS等。这使得用户可以在不同的操作系统上使用该软件，无需担心兼容性问题。 功能强大：LibreOffice包含了多个组件，如Writer、Calc、Impress、Draw等，可分别用于处理文本文档、电子表格、幻灯片演示文稿、绘图文档等。这些组件的功能强大，可以满足用户的不同需求。 兼容性好：LibreOffice支持多种文档格式，如OpenDocument Format、Microsoft Word、Excel、PowerPoint等。这使得用户可以轻松地导入和导出这些格式的文件，与其他软件进行协作。 易于使用：LibreOffice的界面设计简洁明了，易于使用。对于初学者来说，可以通过简单的操作就能快速上手；对于专业用户来说，该软件也提供了许多高级功能和工具，可以更加高效地完成工作任务。 社区支持：LibreOffice有一个活跃的社区，用户可以在社区中寻求帮助和支持，或者与其他用户分享经验和技巧。这使得用户在使用该软件时可以得到更好的帮助和支持。 3. 安装 Libreoffice今天我们就介绍一下如何在 Fedora 39 上安装 Libreoffice. 第 1 步: 在安装新软件之前，最好先更新系统。执行以下命令，更新系统。 1234sudo dnf clean allsudo dnf update 第 2 步: 在 Fedora 39 上安装 LibreOffice。 通过 DNF（包管理器）安装 LibreOffice使用以下命令通过 DNF 包管理器安装 LibreOffice： 123sudo dnf install -y libreoffice 第 3 步: 在 Fedora 上访问 LibreOffice。 在 Fedora 上访问 LibreOffice。 安装完成后，您可以通过在应用程序菜单中搜索 LibreOffice 或在终端中运行以下命令来验证 LibreOffice 是否已安装 123libreoffice 4. 参考文档如何在 Fedora 上安装 LibreOffice 39","link":"/linux/linux_install_libreoffice.html"},{"title":"linux上ifconfig命令详解","text":"1. ifconfig 简介用于显示或设置网络设备 2. 用法123456789101112131415ifconfig [-a] [-v] [-s] &lt;interface&gt; [[&lt;AF&gt;] &lt;address&gt;][add &lt;address&gt;[/&lt;prefixlen&gt;]][del &lt;address&gt;[/&lt;prefixlen&gt;]][[-]broadcast [&lt;address&gt;]] [[-]pointopoint [&lt;address&gt;]][netmask &lt;address&gt;] [dstaddr &lt;address&gt;] [tunnel &lt;address&gt;][outfill &lt;NN&gt;] [keepalive &lt;NN&gt;][hw &lt;HW&gt; &lt;address&gt;] [mtu &lt;NN&gt;][[-]trailers] [[-]arp] [[-]allmulti][multicast] [[-]promisc][mem_start &lt;NN&gt;] [io_addr &lt;NN&gt;] [irq &lt;NN&gt;] [media &lt;type&gt;][txqueuelen &lt;NN&gt;][[-]dynamic][up|down] ... 3. 参数说明3.1. 选项介绍1234567891011121314151617181920212223-a 显示所有的可用网卡, 包括当前处于关闭状态的网卡.-s 显示短列表(结果类似于netstat -i )-v 出错状况下显示更多信息.&lt;interface&gt; 设备名称.[&lt;AF&gt;] &lt;address&gt; 指定网络设备的地址, 根据不同的协议族, AF 为地址族 &lt;address&gt;不同地址族类型的的地址, 若不指定地址族默认为IPv4地址.add &lt;address&gt;[/&lt;prefixlen&gt;] 设置网络设备IPv6的IP地址, 格式参考示例.del &lt;address&gt;[/&lt;prefixlen&gt;] 删除网络设备IPv6的IP地址, 格式参考示例.[-]arp 启用或关闭设备上的ARP协议.[-]promisc 启用或关闭设备的promiscuous模式 如果启用, 网络上所有的包都将会被设备接受到.hw &lt;HW&gt; &lt;address&gt; 设置网络设备的类型与硬件地址, 格式参考示例: 用ifconfig修改MAC地址.o_addr &lt;NN&gt; 设置网络设备的I/O地址.irq &lt;NN&gt; 设置网络设备的IRQ.media &lt;type&gt; 设置网络设备的媒介类型.mem_start &lt;NN&gt; 设置网络设备在主内存所占用的起始地址.mtu &lt;NN&gt; 设置网络设备的MTU最大传输单元.netmask &lt;address&gt; 设置网络设备的子网掩码.tunnel &lt;address&gt; 建立IPv4与IPv6之间的隧道通信地址.[-]broadcast [&lt;address&gt;] 将要送往指定地址的数据包当成广播数据包来处理.[-]pointopoint [&lt;address&gt;] 与指定地址的网络设备建立直接连线，此模式具有保密功能.up 该信号将会使得网卡被激活, 当一个IP地址被指定的时候, 暗含激活网卡的意思, 但是你可以通过指定网卡别名附加一个 - 压制该默认行为, 当使用IPv4 0.0.0.0 地址时, 该行为也会被压制, 因为内核将会删除网卡别名.down 该信号将会使得指定的网卡关闭. 3.2. 硬件类型HW=硬件类型 Hardware Type. 硬件类型列表: loop (Local Loopback) slip (Serial Line IP) cslip (VJ Serial Line IP) slip6 (6-bit Serial Line IP) cslip6 (VJ 6-bit Serial Line IP) adaptive (Adaptive Serial Line IP) ash (Ash) ether (Ethernet) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) rose (AMPR ROSE) tunnel (IPIP Tunnel) ppp (Point-to-Point Protocol) hdlc ((Cisco)-HDLC) lapb (LAPB) arcnet (ARCnet) dlci (Frame Relay DLCI) frad (Frame Relay Access Device) sit (IPv6-in-IPv4) fddi (Fiber Distributed Data Interface) hippi (HIPPI) irda (IrLAP) ec (Econet) x25 (generic X.25) eui64 (Generic EUI-64) AF=地址族 Address family. 默认: IPv4 网络协议地址族(inet) 3.3. 地址族列表 unix (UNIX Domain) UNIX 域协议地址 inet (DARPA Internet) IPv4 网络协议地址族 inet6 (IPv6) IPv6 网络协议地址族 ax25 (AMPR AX.25) netrom (AMPR NET/ROM) rose (AMPR ROSE) ipx (Novell IPX) ddp (Appletalk DDP) ec (Econet) ash (Ash) x25 (CCITT X.25)说明: DARPA 美国国防部先进项目研究局. AMPR: Amateur Radio Digital Communications. AX.25: Amateur Radio AX.25 国际业余无线电联盟正式公布了专门的通信协议. AX.25 作为业余分组网的标准补充了 HDIC 和 OSI 模型对无线信道分组网的规定。 虽然 AX.25 协议是由国际业余无线电爱好者联盟制定的，但由于美军及后来发展分组无线网的厂家都遵循了该项协议，使得该协议已超出业余的性质 , 而成为一种通用的国际标准协议 netrom: IPX: [互联网分组交换协议]https://baike.baidu.com/item/IPX/609379?fr=aladdin, IPX 是指互联网分组交换协议，提供分组寻址和选择路由的功能，保证可靠到达，相当于数据报的功能；SPX 是顺序报文分组交换协议，它可保证信息流按序、可靠地传送；IPX/SPX 为 Novell 网在网络层和传输层采用的协议；SDLC 是 SNA 中的数据链路层协议，后修改为 HDLC（高级数据链路控制）；NFS 是 SUN 制定的网络文件服务标准；ODBC 是微软制定的异构数据库互访的标准，真正体现了数据库开放性. 用来对通过互联网络的数据包进行路由选择和转发，它指定一个无连接的数据包，相当于 TCP/IP 协议簇中的 IP 协议。 ddp (Appletalk DDP): 数据报传送协议 Datagram Delivery Protocal. appletalk ( AT )是由 Apple 公司创建的一组网络协议的名字，它用于 Apple 系列的个人计算机。协议栈中的各种协议用来提供通信服务，例如文件服务、打印、电子邮件和其他一些网络服务。表 8-1 列出了构成 AT 协议套件的具体协议。它也同时显示了协议之间的相互联系以及与 OSI 模型的联系。特定型号的路由器和交换机支持 Apple Talk 协议栈。使用这些路由和交换机实现 Apple Talk 网络能够使所有的 Apple 计算机用户享受全球的文件、打印和应用程序服务。 ec (Econet): 3.3.1. 说明 promiscuous 模式:混杂模式, 是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。在 Linux 操作系统中设置网卡混杂模式时需要管理员权限。在 Windows 操作系统和 Linux 操作系统中都有使用混杂模式的抓包工具，比如著名的开源软件 Wireshark。 4. 示例4.1. 示例 1: 如何重启网卡?1234567# 查看网卡名, 以及网卡状态$ ifconfig# 如果有多块网卡, 选定网卡名, 先关闭网卡, 再打开网卡$ sudo ifconfig -s enp6s0 down# 激活网卡$ sudo ifconfig -s enp6s0 up 4.2. 示例 2: 配置网卡 eno16777736 的 IP 地址，同时激活该设备1sudo ifconfig eno16777736 192.168.0.2 netmask 255.255.255.0 up 4.3. 示例 3: 配置网卡 eno16777736 的别名设备 eno16777736:1 的 IP 地址 (未激活)1ifconfig eno16777736:1 192.168.0.3 4.4. 示例 4: 激活网卡 eno16777736:1 设备1ifconfig eno16777736:1 up 4.5. 示例 5: 查看网卡 eno16777736 设备的配置1ifconfig eno16777736 4.6. 示例 6: 关闭网卡 eno16777736:1 设备1ifconfig eno16777736:1 down 4.7. 示例 7: 为网卡配置和删除 IPv6 地址123456# 为网卡eth0设置IPv6地址$ sudo ifconfig eth0 add 33ffe:3240:800:1005::2/64# 为网卡删除IPv6地址$ sudo ifconfig eth0 del 33ffe:3240:800:1005::2/64 4.8. 示例 8: 用 ifconfig 修改 MAC 地址1234567891011121314# 方法 1# 关闭网卡$ sudo ifconfig eth0 down# 修改MAC地址$ sudo ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE# 启动网卡$ sudo ifconfig eth0 up# 方法 1#关闭网卡并修改MAC地址$ sudo ifconfig eth1 hw ether 00:1D:1C:1D:1E# 启动网卡$ sudo ifconfig eth1 up //启动网卡 4.9. 示例 9: 配置 IP 地址12345678# 给eth0网卡配置IP地址$ sudo ifconfig eth0 192.168.1.56# 给eth0网卡配置IP地址,并加上子掩码$ ifconfig eth0 192.168.1.56 netmask 255.255.255.0# 给eth0网卡配置IP地址,加上子掩码,加上个广播地址$ ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255 4.10. 示例 10: 启用和关闭 ARP 协议1234# 开启$ ifconfig eth0 arp# 关闭$ ifconfig eth0 -arp 4.11. 示例 11: 设置最大传输单元12# 设置能通过的最大数据包大小为 1500 bytes$ ifconfig eth0 mtu 1500 5. 后续更多 linux 相关知识, 请参考鹏叔的技术博客 - linux 专题, 获取实时更新的 Linux 文章.","link":"/linux/linux_shell_ifconfig.html"},{"title":"linux上的rsync命令详解","text":"1. rsync 简介rsync 就是远程同步的意思remote sync.rsync 被用在UNIX / Linux执行备份操作操作.rsync 工具包被用来从一个位置到另一个位置高效地同步文件和文件夹. rsync可以实现在同一台机器的不同文件直接备份,也可以跨服务器备份. 2. rsync的重要特性 速度快: 初次同步时, rsync会全量拷贝从源文件或目录到目标位置. 第二次往后同步时, rsync 仅仅会拷贝变化的数据块或字节到目标位置这将使得文件传输非常迅速. 安全: rsync 可以使用ssh协议加密传输. 占用带宽少: rsync 在发送时会压缩数据块, 接收后再解压缩数据块. 所以和其他文件传输协议比起来, rsync在跨主机传输文件时会占用较小的带宽. 不需要特殊权限: 安装和运行rsync 不需要特殊权限. 3. 用法rsync 语法如下 1234567$ rsync [OPTION]... SRC [SRC]... DEST or rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST or rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST or rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST or rsync [OPTION]... [USER@]HOST:SRC [DEST] or rsync [OPTION]... [USER@]HOST::SRC [DEST] or rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 从语法结构我们可以看出, 源和目标即可以在本地也可以在远端. 如果是远端的话,需要指明登录用户名, 远端服务器名, 和远端文件或目录. 同时源可以是多个, 目标位置只能是一个. 4. 示例4.1. 示例 1. 同步同一台机上的两个目录12345678$ rsync -zvr /var/opt/installation/inventory/ /root/tempbuilding file list ... donesva.xmlsvB.xml.sent 26385 bytes received 1098 bytes 54966.00 bytes/sectotal size is 44867 speedup is 1.63$ 说明: -z: –compress 使用压缩机制 -v: –verbose 打印详细信息 -r: –recursive 以递归模式同步子目录 注意: 同步完成后, 我们会发现文件的时间戳timestamps发生了改变. 123$ ls -l /var/opt/installation/inventory/sva.xml /root/temp/sva.xml-r--r--r-- 1 bin bin 949 Jun 18 2009 /var/opt/installation/inventory/sva.xml-r--r--r-- 1 root bin 949 Sep 2 2009 /root/temp/sva.xml 4.2. 示例 2: 保留文件的时间戳有时我们希望拷贝或同步时, 时间戳不要发生变化, 源文件是什么时间戳,目标文件就是什么时间戳, 这时我们需要使用 -a –archive 归档模式选项. -a 选项相当于7个选项的组合 -rlptgoD -r, –recursive: 递归模式Recursive mode-l, –links: 将符号链接当作符号链接文件拷贝, 不拷贝符合链接指向的文件内容.-p, –perms: 保留文件权限-t, –times: 保留修改时间戳-g, –group: 保留用户组信息-o, –owner: 保留用户信息(需要超级用户权限)-D, 相当于 –devices –specials 的组合, 保留设备文件, 保留特殊文件. 123456789$ rsync -azv /var/opt/installation/inventory/ /root/temp/building file list ... done./sva.xmlsvB.xml.sent 26499 bytes received 1104 bytes 55206.00 bytes/sectotal size is 44867 speedup is 1.63$ 同步完成后, 我们再来看文件属性, 时间戳信息得到了保留, 不仅如此文件的所有者 和所在组也得到保留. 123$ ls -l /var/opt/installation/inventory/sva.xml /root/temp/sva.xml-r--r--r-- 1 root bin 949 Jun 18 2009 /var/opt/installation/inventory/sva.xml-r--r--r-- 1 root bin 949 Jun 18 2009 /root/temp/sva.xml 4.3. 示例 3: 拷贝单个文件12345$ rsync -v /var/lib/rpm/Pubkeys /root/temp/Pubkeyssent 42 bytes received 12380 bytes 3549.14 bytes/sectotal size is 12288 speedup is 0.99 说明: Pubkeys 是一个普通文件, /root/temp/是一个目录-v: –verbose 打印详细信息 4.4. 示例 4. 从本地拷贝多个文件到远端使用rsync, 也可以从本地拷贝多个文件或目录到远端, 以下即为示例: 12345678910$ rsync -avz /root/temp/ thegeekstuff@192.168.200.10:/home/thegeekstuff/temp/Password:building file list ... done./rpm/rpm/Basenamesrpm/Conflictnamesent 15810261 bytes received 412 bytes 2432411.23 bytes/sectotal size is 45305958 speedup is 2.87 说明: -z: –compress 使用压缩机制 -v: –verbose 打印详细信息 -a: -a –archive 归档模式选项, 详见示例2 注意: 与本地文件拷贝不同的地方在于, 当拷贝文件到远程服务器时, 我们指定远程主机上的用户名, 服务器地址, 路径等信息, 类似于使用scp命令拷贝,与scp不同的地方在于, rsync更加强大, 支持各种选项, 最重要的一点是它支持断点续传. 如果没有设置ssh免密码登录我们还需要提供远程用户的密码等信息.有时你不想频繁输入密码, 或者rsync运行在一个无人执守的脚本里面, 这是需要预先设置ssh免密登录, 或者使用结合expect命令,自动输入密码, 但是出于安全考虑, 密码需要加密. 所以在条件许可的情况下, 还是推荐设置ssh免密登录. 4.5. 示例 5. 从远程服务器拷贝文件到本地与示例 4 稍有不同, 这时远端目录或文件作为源位置, 本地目录或文件作为目标位置, 示例如下: 12345678$ rsync -avz thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/rpm/Basenames.sent 406 bytes received 15810230 bytes 2432405.54 bytes/sectotal size is 45305958 speedup is 2.87 4.6. 示例 6. Remote shell for Synchronizationrsync 允许指定远程主机上运行shell命令.这时需要使用 -e 选项:-e, –rsh=COMMAND 指定远端使用的shell命令 Use rsync -e ssh to specify which remote shell to use. In this case, rsync will use ssh. 12345678$ rsync -avz -e ssh thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/rpm/Basenamessent 406 bytes received 15810230 bytes 2432405.54 bytes/sectotal size is 45305958 speedup is 2.87 4.7. 示例 7. 拷贝时不覆盖目标位置已修改过的文件在一下特殊的使用场景中, 我们不希望拷贝文件时, 我们不希望拷贝过程覆盖掉目标位置中用户做出的修改. 这时我们需要使用 -u 选项明确的告诉rsync命令保留用户在目标文件中作出的修改. 在下面的例子中, 文件Basenames是用户基于上次的拷贝, 修改过的文件, 当我们使用了-u 选项后, 该文件中的修改将不会被覆盖掉. 123$ ls -l /root/temp/Basenamestotal 39088-rwxr-xr-x 1 root root 4096 Sep 2 11:35 Basenames 1234567$ rsync -avzu thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/sent 122 bytes received 505 bytes 114.00 bytes/sectotal size is 45305958 speedup is 72258.31 123$ ls -lrttotal 39088-rwxr-xr-x 1 root root 4096 Sep 2 11:35 Basenames 4.8. 示例 8. 仅拷贝目录结构, 不拷贝文件在某些特殊场景中, 我们只需要远程服务器上的目录结构, 而不希望花大量时间, 带宽拷贝文件内容, 这时我们可以使用 -d, –dirs选项来达到目的. 12345678910$ rsync -v -d thegeekstuff@192.168.200.10:/var/lib/ .Password:receiving file list ... donelogrotate.statusCAM/YaST2/acpi/sent 240 bytes received 1830 bytes 318.46 bytes/sectotal size is 956 speedup is 0.46 4.9. 示例 9. 文件传输时显示进度有时我们希望拷贝文件时, 能实时的显示拷贝进度, 以及传输速率等信息. 尤其是拷贝大文件时, 程序不输出信息, 用户往往无法区分程序是在响应中, 还是已经挂起, 在这种情况下如果使用 –progress 就会非常有帮助.rsync –progress option displays detailed progress of rsync execution as shown below. 123456789101112$ rsync -avz --progress thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ...19 files to consider./Basenames 5357568 100% 14.98MB/s 0:00:00 (xfer#1, to-check=17/19)Conflictname 12288 100% 35.09kB/s 0:00:00 (xfer#2, to-check=16/19)sent 406 bytes received 15810211 bytes 2108082.27 bytes/sectotal size is 45305958 speedup is 2.87 你也可以使用rsnapshot工具 (rsnapshot会调用rsync)来备份本地linux服务器, 或者备份远程linux服务器. 4.10. 示例 10. 同步时删除目标位置多余的文件或目录有时我们希望目标文件和源文件保持严格地一致, 不要多文件也不要少文件, 这是我们可能需要使用 -delete 选项来达到目的. 如果使用 -delete 选项, rsync将删除目标位置多余的文件或文件夹. 此选项还可以结合–delete-excluded 选项一起使用, 添加一些例外的文件. 12# 现在Source and target 文件是一致的. 现在让我们在目标位置创建一个新文件.$ touch new-file.txt 12345678$ rsync -avz --delete thegeekstuff@192.168.200.10:/var/lib/rpm/ .Password:receiving file list ... donedeleting new-file.txt./sent 26 bytes received 390 bytes 48.94 bytes/sectotal size is 45305958 speedup is 108908.55 上述示例中, new-file.txt 是源文件中没有的文件, 其将会在拷贝时被删除掉. 4.11. 示例 11. Do not Create New File at the Target在某些特殊的场景下, 我们只想更新, 目标位置已经存在的文件或目录, 而不关心源位置的新文件, 这时我们可以使用-existing 选项仅仅更新已经存在的文件.让我们来验证一下这个选项的功能, 首先在源端添加一个新文件 new-file.txt. 12[/var/lib/rpm ]$ &gt; new-file.txtNext, execute the rsync from the target. 123456$ rsync -avz --existing root@192.168.1.2:/var/lib/rpm/ .root@192.168.1.2s password:receiving file list.. donesent 26 bytes received 419 bytes 46.84 bytes/sectotal size is 88551424 speedup is 198991.96 从上面的例子可以看到, 由于加了–existing选项新文件new-file.txt没有被拷贝到目标位置 4.12. 示例 12. 查看目标位置和源位置之间的差异选项-i, –itemize-changes 非常有用, 当我们想了解目标位置和源位置的文件差异时. 此选项可以用在拷贝前或拷贝后比较差异. 在源端: 1234$ ls -l /var/lib/rpm-rw-r--r-- 1 root root 5357568 2010-06-24 08:57 Basenames-rw-r--r-- 1 root root 12288 2008-05-28 22:03 Conflictname-rw-r--r-- 1 root root 1179648 2010-06-24 08:57 Dirnames 在目标端: 1234$ ls -l /root/temp-rw-r--r-- 1 root root 12288 May 28 2008 Conflictname-rw-r--r-- 1 bin bin 1179648 Jun 24 05:27 Dirnames-rw-r--r-- 1 root root 0 Sep 3 06:39 Basenames 注意: 在上面的例子中, 源位置和目标位置有两处差异. 第一, 源文件Basenames的所有者和组与目标文件不同, 第一Dirnames文件大小也不一样.现在让我们来看看rsync会怎样显示这些差异 12345678$ rsync -avzi thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done&gt;f.st.... Basenames.f....og. Dirnamessent 48 bytes received 2182544 bytes 291012.27 bytes/sectotal size is 45305958 speedup is 20.76 输出信息只在相应文件前面显示了9个字母来标识改变, 这些字母具体是什么意思呢? 请参考以下详细说明 表示文件已经被拷贝到了本地f 代表该项目是一个文件.s 代表文件大小发生了变化.t 代表时间戳有差异.o 所有者有差异g 所属组有差异. 4.13. 示例 13. 使用通配符过滤文件rsync 可以使用–include 和 –exclude 选项结合通配符进行文件或文件夹过滤 1234567891011$ rsync -avz --include 'P*' --exclude '*' thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done./PackagesProvidenameProvideversionPubkeyssent 129 bytes received 10286798 bytes 2285983.78 bytes/sectotal size is 32768000 speedup is 3.19 在上面的示例中, 仅仅以P打头的文件和文件夹被包含了进来, 其他的文件都被过滤掉, 在拷贝的过程中被排除在外了. 4.14. 示例 14. 不拷贝大文件可以使用–max-size 告诉rsync 不要拷贝大小超过某个值的文件, 可以使用K, M, G指定文件大小, M for megabytes and G for gigabytes. 1234567891011121314$ rsync -avz --max-size='100K' thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done./ConflictnameGroupInstalltidNameSha1headerSigmd5Triggernamesent 252 bytes received 123081 bytes 18974.31 bytes/sectotal size is 45305958 speedup is 367.35 4.15. 示例 15. 拷贝整个文件rsync 有个重要优点就是, 可以做到在拷贝的过程中, 只拷贝发生变化了的部分, 而不是发送整个文件.但是在某些场景中, 比如文件较少, 文件size较小时, 我们的带宽又足够大, cpu资源相对又贫乏, 我们不希望它这样做, 因为毕竟计算源端和目标端的checksum, 并做对比, 也需要额外cpu开销. 这时我们可以使用 -W, –whole-file 选项, 让rsync不用计算那么多, 一上来就直接开始传送文件. 我们可以像下面这么做. 1234567891011121314# rsync -avzW thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/tempPassword:receiving file list ... done./BasenamesConflictnameDirnamesFilemd5sGroupInstalltidNamesent 406 bytes received 15810211 bytes 2874657.64 bytes/sectotal size is 45305958 speedup is 2.87 4.16. 示例 16. 断点续传默认的情况下，当rsync传输中断后，新的rsync传输将删除所有的未完成的残余文件片段，然后开始新的传输。而使用–partial后，将会进行我们所说的断点续传。 值得注意的是-P这个参数是综合了–partial –progress两个参数，所以rsync的断点续传可以用下面的例子来说明： 1rsync -avzP /tmp/bigfile cnangel@10.1.6.160:/tmp/bigfile 5. 相关文章本文原文位于鹏叔的技术博客 - linux上的rsync命令详解, 获取最近更新请访问原文. 更多linux相关知识, 请参考鹏叔的技术博客linux tag, 获取实时更新的Linux文章. 6. 参考文档15个Rsync命令实例","link":"/linux/linux_shell_rsync.html"},{"title":"Linux systemd 服务详解","text":"Linux 系统中也有“服务”这一说法, 也即 systemd service unit，通过服务我们可以便捷地管理一些程序功能，也可以作为程序开机自启的一个手段之一。今天我来分享一下如何创建自己简易的 Linux 服务。本文主要讲述如何在 Linux 下自定义 service. 1. 服务文件位置介绍/usr/lib/systemd/system/ 随安装的 RPM 软件包分发的系统单元文件。该目录中包含的是软件包安装的单元,也就是说通过 yum、dnf、rpm 等软件包管理命令管理的 systemd 单元文件，都放置在该目录下。 /run/systemd/system/ 这个目录一般是进程在运行时动态创建 unit 文件的目录，一般很少修改，除非是修改程序运行时的一些参数时，即 Session 级别的，才在这里做修改。 /etc/systemd/system/ Systemd 创建的单元文件 systemctl enable 以及为扩展服务而添加的单元文件。此目录优先于包含运行时单元文件的目录。 1.1. 三个文件位置的关系包管理软件初始安装的包中，如果包含 systemd 单元文件也即服务定义文件，一般会放在/usr/lib/systemd/system/。如果要开启该服务，会在/etc/systemd/system/目录创建一个软链接指向/usr/lib/systemd/system/中的服务定义文件。 其中/etc/systemd/system/又分为 basic.target.wants， graphical.target.wants， multi-user.target.wants 等子目录，具体服务链接至哪个子目录是由服务定义文件中的Install 部分的 WantedBy 属性所决定的。 /run/systemd/system/则是放置程序运行时动态创建 unit 文件。 例如： 1234$ sudo systemctl enable clamd@scan.service# 等同于$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service' 2. 新建服务文件每一个服务在 Linux 有它自己的对应的配置文件，这个文件可以通过文本编辑器编辑，扩展名为 xxx.servive（xxx 为服务名称）。这些文件位于/usr/lib/systemd/system 目录下。在这个目录下新建 service 文件即可创建我们的服务。文件的内容结构如下： 12345678910111213[Unit]Description=服务描述After=服务依赖（再这些服务后启动本服务）[Service]Type=服务类型ExecStart=启动命令ExecStop=终止命令ExecReload=重启命令[Install]WantedBy=服务安装设置 服务配置文件分为 Unit、Service 和 Install 三大部分。 Unit 部分：提供对服务的描述和定义服务的依赖关系。 Service 部分：服务（Service）类型的 Unit 特有的，用于定义服务的具体管理和操作方法 Install 部分：这个部分指定了服务在 Systemd 系统中的安装设置。 2.1. Unit 部分介绍 Description：描述这个 Unit 文件的信息 Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径 Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止 Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功 After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务 Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行 Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启 Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动 OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块 Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然 2.2. Service 部分介绍服务生命周期控制相关 Type：定义启动时的进程行为，它有以下几种值： Type=simple：默认值，执行 ExecStart 指定的命令，启动主进程 Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 Type=dbus：当前服务通过 D-Bus 启动 Type=notify：当前服务启动完毕，会通知 Systemd，再继续往下执行 Type=idle：若有其他任务执行完毕，当前服务才会运行 RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。 ExecStart：启动当前服务的命令 ExecStartPre：启动当前服务之前执行的命令 ExecStartPos：启动当前服务之后执行的命令 ExecReload：重启当前服务时执行的命令 ExecStop：停止当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测 TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程 服务上下文配置相关 Environment：为服务指定环境变量 EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义 Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级 WorkingDirectory：指定服务的工作目录 RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件 User：指定运行服务的用户 Group：指定运行服务的用户组 MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上 slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上 private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上 LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等 注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。 2.3. Install 部分介绍在理解 Install 部分前我们需要向了解两个基本概念： Unit 和 TargetUnit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。 Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。 简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。 2.3.1. Install 属性详解这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束： WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“ RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中 Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit Alias：当前 Unit 可用于启动的别名 3. Systemctl 命令service 管理查看当前系统的所有 Unit 12345678910111213141516171819# 列出正在运行的 Unit$ systemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的$ systemctl list-units --all# 列出所有没有运行的 Unit$ systemctl list-units --all --state=inactive# 列出所有加载失败的 Unit$ systemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unit$ systemctl list-units --type=service# 查看 Unit 配置文件的内容$ systemctl cat docker.service 查看 service 的状态12345678# 显示系统状态$ systemctl status# 显示单个 Unit 的状态$ ystemctl status bluetooth.service# 显示远程主机的某个 Unit 的状态$ systemctl -H root@rhel7.example.com status httpd.service Unit 的管理12345678910111213141516171819202122232425262728# 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500 查看 Unit 的依赖关系1234567# 列出一个 Unit 的所有依赖，默认不会列出 target 类型$ systemctl list-dependencies nginx.service# 列出一个 Unit 的所有依赖，包括 target 类型$ systemctl list-dependencies --all nginx.service Target 管理Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。 在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 12345678910111213141516# 查看当前系统的所有 Target$ systemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unit$ systemctl list-dependencies multi-user.target# 查看启动时的默认 Target$ systemctl get-default# 设置启动时的默认 Target$ sudo systemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程$ sudo systemctl isolate multi-user.target 日志管理Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。 Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。 默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ sudo journalctl# 查看内核日志（不显示应用日志）：--dmesg 或 -k$ sudo journalctl -k# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b$ sudo journalctl -b$ sudo journalctl -b -0# 查看上一次启动的日志（需更改设置）$ sudo journalctl -b -1# 查看指定服务的日志：--unit 或 -u$ sudo journalctl -u docker.servcie# 查看指定服务的日志$ sudo journalctl /usr/lib/systemd/systemd# 实时滚动显示最新日志$ sudo journalctl -f# 查看指定时间的日志$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;$ sudo journalctl --since &quot;20 min ago&quot;$ sudo journalctl --since yesterday$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;# 显示尾部的最新 10 行日志：--lines 或 -n$ sudo journalctl -n# 显示尾部指定行数的日志$ sudo journalctl -n 20# 将最新的日志显示在前面$ sudo journalctl -r -u docker.service# 改变输出的格式：--output 或 -o$ sudo journalctl -r -u docker.service -o json-pretty# 查看指定进程的日志$ sudo journalctl _PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看指定用户的日志$ sudo journalctl _UID=33 --since today# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ sudo journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有 8 级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ sudo journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ sudo journalctl --no-pager# 以 JSON 格式（单行）输出$ sudo journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ sudo journalctl -b -u nginx.serviceqq -o json-pretty# 显示日志占据的硬盘空间$ sudo journalctl --disk-usage# 指定日志文件占据的最大空间$ sudo journalctl --vacuum-size=1G# 指定日志文件保存多久$ sudo journalctl --vacuum-time=1years 4. 参考文档Linux 添加自定义服务 Chapter 10. Managing Services with systemd 可能是史上最全面易懂的 Systemd 服务管理教程！","link":"/linux/linux_systemd_service_explanation.html"},{"title":"如何在fedora上关闭ipv6","text":"有时因为某些服务器不支持ipv6会出现EHOSTUNREACH错误，需要关闭ipv6 将如下几行配置添加到 /etc/sysctl.conf 123net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1 重新加载以上配置 1sysctl -p Check. A ‘1’ means IPv6 has been disabled 1cat /proc/sys/net/ipv6/conf/all/disable_ipv6","link":"/linux/linux_turnoff_ipv6.html"},{"title":"update-alternatives 命令详解","text":"1. 介绍update-alternatives 命令在 Linux 系统中具有重要的作用。它主要用于维护符号链接，这些符号链接确定了各种任务或实用工具的默认命令或应用程序。update-alternatives 允许系统管理员或用户选择在其系统上使用哪个版本的特定命令或应用程序。 当一个软件在系统上安装了多个版本时，update-alternatives 命令变得非常有用。例如，当系统上同时安装了 gcc 4.8.5 和 gcc 7.2.0 版本时，可以使用 update-alternatives 命令来选择执行哪个版本。通过创建指向替代程序的符号链接组，并通过更新链接以指向所需程序，用户可以在不手动更新每个符号链接的情况下在不同版本的相同程序之间轻松切换。 2. 一个软件多版本管理的例子2.1. 向 alternatives 注册多个版本假设我们系统中安装了多个版本的 python, 分别是 python2.7，python3.5，python3.12 /usr/local/python2.7 /usr/local/python3.5 /usr/local/python3.12 我们可以将这三个版本使用 alternatives 来管理 12345update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100update-alternatives --install /usr/bin/python python /usr/bin/python3.5 200update-alternatives --install /usr/bin/python python /usr/bin/python3.12 300 第一个参数: –install 表示向 update-alternatives 注册服务名。 第二个参数: link，成功后将会把命令在这个固定的目的地址做真实命令的软链，以后管理就是管理这个软链； 第三个参数: 服务名，以后管理时以它为关联依据。 第四个参数: 被管理的命令绝对路径。 第五个参数: 优先级，数字越大优先级越高。 这里的 install 实际是很令人费解的一个选项，其实这里理解为组成注册一个替代更容易理解一些 这三条指令执行完后，alternatives 会创建一个软连接/usr/bin/python 指向=&gt;/etc/alternatives/python 而/etc/alternatives/python 也是一个软连接指向/usr/bin/python3.12 这里为什么多一层软连接/etc/alternatives/python, 而不直接指向/usr/bin/pythonx.xx? 这与 alternatives 设计和实现方式有关，个人理解可能是方便管理。 为什么软链接会最终指向/usr/bin/python3.12？ 因为这一条注册记录的优先级最高 这些注册信息保存在哪里？ alternatives 的数据存储在/var/lib/alternatives/目录下。这个目录下包含了多个子目录和文件，用于存储软链接的配置信息和优先级信息等。 使用如下命令可以查看 python 当前的状态 123alternatives --display python 2.2. 如何切换版本123456789$ update-alternatives --config python有 2 个候选项可用于替换 python (提供 /usr/bin/python)。 选择 路径 优先级 状态------------------------------------------------------------ 0 /usr/bin/python3.12 300 自动模式 1 /usr/bin/python2.7 100 手动模式 2 /usr/bin/python3.5 200 手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号： 2.3. 删除一条注册记录remove 参数用于删除一个命令的 link 值，其附带的 slave 也将一起删除 1update-alternatives –remove python /usr/bin/python2.7 3. update-alternatives 的原理update-alternatives 的工作原理基于软链接管理。在 Linux 系统中，软链接类似于 Windows 中的快捷方式，它是一个指向实际文件或目录的指针。通过使用软链接，update-alternatives 可以创建、删除、修复和显示已存在的软链接信息。 update-alternatives 的工作原理如下：首先，它会检查系统路径下的符号链接，这些符号链接指向了实际的软件目录或可执行文件。符号链接的路径通常在/usr/bin 下，例如/usr/bin/&lt;name&gt;。这些符号链接指向了/etc/alternatives/&lt;name&gt;这个文件，该文件也是一个软链接。最终，这个符号链接指向了实际可执行文件。 通过创建、删除、修复和显示软链接，update-alternatives 允许系统管理员或用户在不同的版本之间切换特定命令或应用程序。这使得在不进行手动更新每个符号链接的情况下，轻松地在不同版本的相同程序之间进行切换。 4. update-alternatives 在切换版本时作了哪些事情？update-alternatives 在切换版本时主要做了以下几件事情： 检查系统中已存在的符号链接，这些符号链接指向了实际的可执行文件。 根据用户的选择或配置文件中的设置，确定要使用的软链接的路径。 创建、删除、修复或显示软链接，以实现不同版本之间的切换。 更新软链接的优先级信息，以确保系统默认使用正确的版本。 通过这些步骤，update-alternatives 实现了在不进行手动更新每个符号链接的情况下，轻松地在不同版本的相同程序之间进行切换的功能。这有助于提高系统的灵活性和可维护性。 5. update-alternatives 软件版本管理的局限性我们都知道一个软件基本由以下几个基本部分组成： 应用程序代码 配置 数据 文档和帮助 另外软件的执行依赖操作系统，系统库，以及其他外部环境，如果不一致则会导致兼容性问题。 update-alternatives 在管理应用程序，以及自身携带的数据与配置方面已经很优秀了，但是在其他方面可能存在不足之处，例如在自动保持环境变量一致性方面。虽然 update-alternatives 可以管理可执行文件的链接，但它并不能直接修改环境变量与系统配置。因此，需要额外的脚本或手动配置来确保环境变量与切换后的应用程序版本的一致性。 另外，对于系统库文件的管理，update-alternatives 主要关注可执行命令的切换，而不是库文件的切换。因此，如果需要管理不同版本依赖的库文件，可能需要采取其他方法，例如使用动态链接器配置或特定的软件包管理工具。 总的来说，update-alternatives 是一个有用的工具，但需要根据具体的需求和场景进行适当的配置和结合其他工具使用。对于系统管理员而言，了解其工作原理和限制，并根据实际情况采取适当的措施来满足多版本管理的需求是非常重要的。 6. 参考文档update-alternatives 命令","link":"/linux/linux_update_alternatives.html"},{"title":"Msys2安装教程","text":"1. 前言之前一直是使用的Cygwin作为命令行终端, 后来好像是因为Cygwin上的git不兼容还是什么原因, 具体记不太清了, 就安装了git for windows后来终端也就切换到了git bash, 使用了很长一段时间, 后面发现git for window安装不了额外的软件, 使用完整的Linux命令行都是在虚拟机上完成的, 也就一直这样别扭的用着. 今天发现一个可用在windows上使用bash并可以安装额外软件包的方法,特地写文章纪念一下. 2. Msys2的历史Cygwin最初由Cygnus Solutions开发, 于1995年发布. 它最初是为了在Windows上运行GNU工具集而创建的, Cygnus Solutions为Windows创建了一个POSIX的运行时库, 这套运行时库可以允许类Unix软件被编译然后运行在Windows上面. 这是一项了不起的成就, 它方便开发人员可以花最小的代价将Unix程序移植到Windows上面. 当然Cygnus Solutions还做了另外一项开创性的贡献让Unix开发人员可以使用GNU工具开发Windows应用. 感兴趣的可以深入了解一下. MinGW的全称叫做(Minimalist GNU for Windows), MinGW在Cygwin基础上做了进一步的创新, MinGW为开发者提供呢一个轻量级的开发环境, 如果说Cygwin使用运行时库在Windows上模拟了一整套Unix系统调用, 这样GNU工具不用修改或少量修改就能运行在Windows上. 那么MinGW的贡献就是为GNU程序提供了一套编译,Debug和打包工具,相当于提供了一整套开发环境, 这样GNU源代码通过这些工具打包后, 可以直接调用Windows的API运行在Windows上, 而不依赖运行时. 这样使得整个架构更轻量级. MSYS的全称叫做(Minimal System) 是一个在Windows上运行的类Unix环境和命令行接口, 它基于MinGW, 并提供了一个更完整的Unix环境和命令行接口. MSYS还提供了一组工具和库, 运行开发人员使用开源工具和库构建Windows应用程序. MSYS使用的是一个名为MinGW-get的包管理器. Msys2是Msys的一个后继项目, 它提供了一个更现代的Unix环境和命令行接口, 包括许多常见的类Unix工具和库. 与Msys不同, Msys2使用了一个名为pacman的软件包管理器, 它类似于Arch Linux中使用的pacman. git for windows是基于Msys2 开发的, 如果不需要Git GUI, 完全可以用Msys2替代它了. 3. 安装我选择的版本是msys2-x86_64-20230318.exe 下载安装程序（官网首页有）：官网 或 CSDN：https://download.csdn.net/download/ymzhu385/45988277 运行安装程序。MSYS2 需要 64 位 Windows 7 或更新版本。 输入所需的安装路径 下载的位置很多, 可以使用 完成后，勾选Run MSYS2 now。 4. 配置由于计划将 msys2 作为基本的命令行工具，但是在实际使用过程中，发现其无法调用 window 下面的程序，包括 python，ruby 等，由此推测其环境变量中未包含系统环境变量，导致敲命令的时候，程序无法识别到。 解决方案：添加一个新的 Windows 环境变量 MSYS2_PATH_TYPE=inherit。 具体如何添加, 可以参考这篇文章MSYS2使用windows环境变量 5. 安装额外软件包先安装git, 这样就可以替代git for windows了. 123pacman -S git 再安装一个我喜欢的文件传输工具rsync 123pacman -S rsync 再装个ansible, 简直不要太香了. 有人说Ansible不能安装在Windows下面, 这种说法是不准确的. 实际可以通过msys2进行安装, 这一种安装方式是Ansible官网上也没有介绍的. 有了Ansible意味着在Windows上可以以命令行的方式管理Linux主机了. 123pacman -S ansible 6. Msys2与Cmder整合打开Cmder导航到settings=&gt;Startup=&gt;Tasks. 新建一个task, 给task命名例如Bash::Msys2 Task parameters不用填写 在Commands一栏填入例如如下内容, 路径按照自己的安装路径酌情修改 1set CHERE_INVOKING=1 &amp; C:\\tools\\msys2\\usr\\bin\\bash.exe --login -i -new_console:C:&quot;C:\\tools\\msys2\\msys2.ico&quot; 保存, 如果要将Msys2作为默认终端, 勾选Default task for new console再次保存. 注意:win11 cmder 打开 远程 vim 有时会出现 空白屏幕, 打字不显示的 bug解决办法: Debug -&gt; Properties… -&gt; 选项 -&gt; 使用旧版控制台(UI)(需要重新启动，影响所有控制台)参考: https://github.com/Maximus5/ConEmu/issues/2384 7. pacman命令详解安装软包 123pacman -S package_name 删除软件包 1pacman -R package_name 删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系： 1pacman -Rs package_name 查询软件包 pacman -Ss package 安装一个’本地’包（不从源里） 1pacman -U /path/to/package/package_name-version.pkg.tar.gz 安装一个’远程’包（不从源里） 1pacman -U http://url/package_name-version.pkg.tar.gz 8. 更新最近尝试了一下WSL, 发现它是在Windows上使用Linux最方便的方式. 如果说Cygwin, MinGW, Msys, Msys2是民间组织在弥合Windows和Linux的鸿沟,那么WSL则是Microsoft官方主动向Linux”投诚”. 曾经Microsoft对Linux是非常仇视的态度, 将Linux视为”恶性肿瘤”, 如今Microsoft也开始主动拥抱Linux了, 不仅在自己的云产品上拥抱Linux, 在自家的核心产品Windows上也开始拥抱Linux了. 如果需要安装配置WSL可以参考我的博客鹏叔的博客空间 - Windows下搭建WSL Linux开发环境. 另外本文原文位于Msys2安装教程, 需要最近更新及反馈问题请访问原文. 9. 参考文章Windows下使用Git+rsync构建文件同步工具 git bash 下 pacman 环境配置 搭建msys2基础开发平台 pacman命令详解","link":"/linux/msys2_installation.html"},{"title":"snap命令详解","text":"1. snap简介Snap 是一个软件部署和软件包管理系统，由 Canonical 公司开发，最初用于 Ubuntu 移动操作系统。Snap 包称为“snap”，工具名为“snapd”，可在多种 Linux 发行版上运行，完成发行上游主导的软件部署。该系统的设计面向手机、云、物联网和台式机。 Snap软件类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用snap包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间。 Snap 包具有以下优点： 跨平台：Snap 包可以在不同的 Linux 发行版上运行，而不需要进行任何修改。 安全：Snap 包可以使用安全的签名来验证其完整性和来源。 易于管理：Snap 包可以使用 snapd 工具进行集中管理。 Snap 包可以用于安装各种类型的应用程序，包括桌面应用程序、服务、游戏、工具和媒体播放器。 以下是一些使用 Snap 包的优势： 简化安装：Snap 包可以通过一个简单的命令进行安装，无需手动下载和解压缩。 自动更新：Snap 包会自动更新到最新版本，无需用户干预。 隔离：Snap 包与系统的其他部分隔离，可以防止相互影响。 Snap 包是 Linux 软件部署和软件包管理的一种新方法。它具有跨平台、安全、易于管理等优势，可以简化软件的安装、更新和管理。 2. Snap 的工作原理如下 开发者将应用程序编译为 Snap 包。Snap 包是一个自给自足的软件包，包含了应用程序的代码、依赖项、配置文件和数据。 用户使用 snapd 工具来安装 Snap 包。Snapd 工具会从 Snap 存储库中下载 Snap 包，并将其安装到系统中。 用户可以使用 snapd 工具来更新 Snap 包。Snapd 工具会自动检查 Snap 存储库中的更新，并将更新安装到系统中。 Snap 包的工作原理可以分为以下几个步骤： 编译：开发者使用 Snapcraft 工具来编译应用程序为 Snap 包。Snapcraft 工具会自动将应用程序的依赖项打包到 Snap 包中。 下载：用户使用 snap 命令来下载 Snap 包。Snap 命令会从 Snap 存储库中下载 Snap 包。 安装：Snapd 工具会将 Snap 包安装到系统中。Snapd 工具会创建一个独立的 Snap 容器来运行 Snap 包。 更新：Snapd 工具会自动检查 Snap 存储库中的更新。如果有更新，Snapd 工具会将更新安装到系统中。 Snap 包的隔离是通过 Snap 容器来实现的。Snap 容器是一个独立的操作系统环境，包含了 Snap 包所需的所有资源。Snap 包与系统的其他部分隔离，可以防止相互影响。 Snap 包的安全性是通过签名机制来实现的。Snap 包会使用安全的签名来验证其完整性和来源。用户可以通过验证签名来确保 Snap 包是来自可信任的来源。 Snap 包的跨平台性是通过 Snap 工具来实现的。Snapd 工具可以安装在多种 Linux 发行版上。Snap 包可以通过 Snapd 工具在不同的 Linux 发行版上运行。 总而言之，Snap 是一个具有跨平台、安全、易于管理等优势的软件部署和软件包管理系统。它可以简化软件的安装、更新和管理。 2.1. Snap 容器Snap 容器是 Snap 包的运行环境。它是一个独立的操作系统环境，包含了 Snap 包所需的所有资源。Snap 包与系统的其他部分隔离，可以防止相互影响。 Snap 容器的工作原理如下： 当用户安装 Snap 包时，Snapd 工具会创建一个 Snap 容器。Snap 容器是一个独立的文件系统，包含了 Snap 包的代码、依赖项、配置文件和数据。 Snap 容器会运行在一个由 Snapd 工具管理的隔离环境中。该环境与系统的其他部分隔离，可以防止相互影响。 Snap 容器的隔离是通过多个机制来实现的，包括： 文件系统隔离：Snap 容器使用自己的文件系统，与系统的其他部分隔离。 网络隔离：Snap 容器可以使用自己的网络连接，与系统的其他部分隔离。 进程隔离：Snap 容器中的进程与系统的其他部分隔离。 Snap 容器的安全性是通过以下机制来实现的： 签名机制：Snap 包会使用安全的签名来验证其完整性和来源。 隔离机制：Snap 容器与系统的其他部分隔离，可以防止相互影响。 Snap 容器的跨平台性是通过以下机制来实现的： Snapd 工具：Snapd 工具可以安装在多种 Linux 发行版上。 Snap 包：Snap 包可以使用 Snapd 工具在不同的 Linux 发行版上运行。 总而言之，Snap 容器是具有安全、隔离、跨平台等优势的软件运行环境。它可以为 Snap 包提供一个安全、稳定、可靠的运行环境。 3. snap常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 查看版本snap version# 查找软件snap find &quot;media player&quot;# 查看软件信息snap info vlc# 安装软件snap install vlc # 默认使用stable channelsnap install vlc --channel=edge # 指定 channelsnap switch vlc --channel=stable # 切换channel# snap 安装软件目录在 `/snap/bin`，该目录已加入 `$PATH`，因此可以直接在命令行运行相应的程序。# 列出所有已安装的软件snap listsnap list --all vlc # 列出所有已安装的版本# 更新已安装的软件snap refresh vlc# 回滚软件版本，snap默认会保留2各版本snap revert vlc# 启用/禁用软件snap enable/disable vlc# 删除软件snap remove vlc # 有些系统会缓存31天snap remove vlc --purge # 彻底清除# 后台服务列表snap services# 启动、停止、重启后台服务snap restart lxdsnap restart lxd.daemonsnap start lxd.daemonsnap start --enable lxd.daemonsnap stop lxd.daemonsnap stop --disable lxd.daemon# 查看后台服务日志snap logs lxdsnap logs lxd -f # 持续监控# 通过snap安装包安装软件, dangerous意味着snap未经过签名snap install demo-snap_0.1_amd64.snap --dangerous --devmode 4. 参考文档Linux软件包管理工具 Snap 常用命令","link":"/linux/snap_commands.html"},{"title":"CentOS7搭建NAS文件共享存储","text":"1. 前言1.1. 网络存储技术网络存储技术大概可以分为3种： DAS：直连式存储（Direct Attached Storage），直接与主机相连的存储设备。它依赖于服务器，本身是硬件的堆叠，不带有任何存储操作系统。现在常见的DAS设备：硬盘座带上 N个硬盘。 NAS：网络连接式存储（Network Attached Storage），存储设备直连网络，NAS设备和DAS设备不同在于，NAS设备一般带有存储操作系统。 SAN：存储网络（Storage Area Network），可以说是一种网络基础设施。SAN和NAS的区别主要在于：SAN针对海量、面向数据块的数据传输，而NAS则提供文件级的数据访问功能。 2. NAS网络附加存储（Network Attached Storage，NAS）是连接到一个局域网的基于IP的文件共享设备。NAS设备是专用的、高性能的、高速的、单一用途的文件服务和存储系统。NAS设备使用自己的操作系统和集成的硬件、软件组件，满足特定的文件服务需求。NAS设备在通用服务器的基础上进行了优化，比如文件服务功能、存储、检索、访问应用程序管理的客户端文件。 在过去几十年里，IT江湖从来都是门派林立，纷争不断。如果按照Operating System (下面简称OS), 大概可以分Windows派，Linux派，还有FreeBSD派。这几大门派信徒众多，教规又各不相同，所以经常造成矛盾。比如说，你要共享一个文件系统，Windows派喜欢用CIFS访问，Linux派习惯用NFS访问，近年来如日中天的苹果派(FreeBSD)们则用AFP。为了伺候好这些门派，NAS就需要支持多种共享协议。 2.1. NAS设备包含如下组件 NAS引擎(CPU和内存等) 一个或多个网络接口卡（NIC），提供网络连接。如千兆以太网卡、万兆以太网卡 一个优化的操作系统用于NAS功能管理 文件共享协议NFS和CIFS 采用工业标准存储协议的磁盘资源，如ATA、SCSI、FC 用来访问NAS设备的客户端。 2.2. NAS支持的协议介绍 CIFS (Common Internet File System protocol)工作在OSI模型的应用/表示层，常用于微软操作系统，但是与平台无关。CIFS运行在TCP/ IP上，使用DNS（域名服务）进行名称解析 CIFS其中包含的状态协议提供如下两个功能： （1）在客户端应用程序具备恢复连接功能时，可以自动恢复连接和重新打开被中断的文件。 （2）在客户端应用程序不具备自动连接功能时，用户则必须重新建立CIFS连接 NFS (Network File System protocol) NFS的全称是Network File System，即网络文件系统。它使一台电脑可以通过网络访问另外一台电脑上的共享，使用起来就如同本地文件系统一样方便。 NFS的开发者就是曾经名震江湖的SUN公司，它已经在2009年被甲骨文收入门下。SUN把NFS的第一个版本NFSv1藏在深闺，就像古墓里的小龙女，从不露面。在江湖上开始流行的是第二版NFSv2了。NFSv2很好用，但是问题也不少，比如它不支持大于2GB的文件，但这在90年代之前还不是大问题。令人费解的是，虽然NFSv3在1995年就面世了，但到今天还有人坚持用NFSv2。其实NFS可以工作在任何OS上。只不过因为OS门派之别，一般只在Linux环境中使用。目前广泛应用的版本还是NFSv3,我们有机会再另文讨论NFSv4。下图展示了多台客户端通过NFS对NAS的访问。 NAS在这里充当了NFS服务器的角色，而Linux，Solaris和AIX则是NFS客户机。 AFP（Apple Filing Protocol ）AFP是一种专门为 MAC OS X 系统提供文件共享服务的协议，通过开源的 Netatalk 实现 AFP 共享。mac os 物理接口是 雷电 thounderbolt ,协议也是 AFP. 3. NFS服务详解NFS的功能很多，不同的功能对应着不同的daemon。比如一定要有的nfsd和mountd，还有可选的lockd和statd。每个daemon都需要占用一些端口，但有些daemon是可选的，也许用户根本不会启用它们。所以，NFS并没有给每个NFS daemon保留固定端口(除了nfsd)。而是在系统启动时给需要启用的NFS daemon分配端口，然后把这些端口号告诉RPC daemon。RPC daemon的端口号是固定的111，每个NFS客户机都知道怎么联系它。当客户机需要连接NFS的某个daemon时，就不得不先咨询RPC daemon，获得该NFS daemon对应的端口号，然后再发送NFS请求。 3.1. NFS连接的建立过程我第一次看到RPC daemon的工作原理，就想起交大管浴室的老头。他的固定地址是门房(相当于端口111)，每个要洗澡的学生(NFS客户机)都知道怎么找到他，他会给你一个带号码的钥匙(端口号)，有了这个号码，你就可以找到相应的格子(NFS daemon)放衣服了。 物理视图交互视图 首先服务器端启动RPC服务，并启动portmapper监听在RPC服务的111端口 服务器端启动NFS服务，并向portmapper注册端口信息 客户端启动RPC（portmapper服务），向服务端的RPC(portmapper)服务请求服务端的NFS端口 服务端的RPC(portmapper)服务反馈NFS端口信息给客户端。 客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输。 3.2. NFS各服务介绍3.2.1. portmapper (rpcbind)它响应RPC服务的请求和与请求的RPC服务建立连接.入口服务portmapper，它一般监听在111端口，起的作用有点类似现代的服务注册与发现的功能——客户端首先连上它，询问nfs、mountd、nlockmgr等服务监听的端口，有了端口号后才能与对应的服务打交道。 portmapper 和 rpcbind的关系 portmapper从nfs v3,4版本开始叫做 rpcbind。 通过下面的命令可以看到portmap或者叫rpcbind中记录的内容： 3.2.2. nfs最主要的NFS服务提供程序，这个daemon主要的功能就是管理客户端是否能够使用服务器文件系统挂载信息，其中还包含判断这个登录用户的ID。 3.2.3. rpc.mountd这个daemon主要功能则是管理NFS的文件系统。当client端顺利通过rpc.nfsd登入主机后，在它可以使用NFS服务器提供规定文件之前，还会经过文件使用权限的认证程序。它会去读取NFS的配置 文件/etc/exports来对比客户端的权限，当通过这一关之后，client端也就取得使用NFS文件的权限。 3.2.4. rpc.statd(可选)这个daemon可以用来检查文件的一致性，若发生因为客户端同时使用同一个文件造成文件损坏时，rpc.statd可以用来检测并尝试恢复该文件 4. NAS服务器安装了解以上一些概念后我们可以着手安装支持NFS协议的NAS服务器. 对于支持CIFS,和AFP协议的NAS服务器不在本教程范围内. 4.1. 安装软件4.1.1. 服务端安装nfs-utils、rcpbind软件包这里以Centos操作系统为例 1yum -y install nfs-utils rpcbind 4.2. 配置NAS4.2.1. 配置nfs服务端口配置文件位于 /etc/sysconfig/nfs 123456789101112#设置各种*port=...参数# TCP port rpc.lockd should listen on.LOCKD_TCPPORT=32803# UDP port rpc.lockd should listen on.LOCKD_UDPPORT=32769# Port rpc.statd should listen on.STATD_PORT=662# Outgoing port statd should used. The default port is randomSTATD_OUTGOING_PORT=2020 既然涉及到端口, 就要确保防火墙没有屏蔽以上端口, 否则的话, 客户端和服务器端无法建立连接. 下表列举了一些NFS服务器的端口： 端口号 服务 32803/32769 rpc.lockd 662 status 111 portmapper 20048 mountd 2049 nfs/nfs_acl 4.2.2. 配置文件共享创建共享目录： 12mkdir /sharedchmod 777 /shared 注意:初次配置NAS 建议将权限设置为777, 有助于顺利测试后续的挂载, 测试读取,创建,删除,修改文件, 但是这样设置是有安全风险的, 后续熟悉了用户身份映射再回来设置合适的权限. 另外此处我以root用户身份创建的/shared目录, 所有共享目录的owner也是root, 后续等弄明白了身份映射, 也建议回头把owner改为合适的owner. 当前阶段因为权限设置为了777, Owner也不是重点, 不影响将整个流程走通. 设置共享文件权限 123sudo vi /etc/exports#添加如下内容/shared 192.168.0.0/16(rw,root_squash,all_squash,sync,anonuid=1000,anongid=1000) 加载NFS配置, 使权限生效 1sudo exportfs -r 4.2.2.1. 权限说明 初次看到这么一长串其实挺令人费解的, 这些都是什么鬼, 除了rw比较熟悉一点,猜也能猜出来是可读写以外, 其他都是一头雾水. 这里其实不必太纠结, 直接设置为最开放的权限 /shared *(rw) 继续往后走好了, 后续也不会遇到一些莫名其妙的问题, 把流程走通最重要, 后续再回头来将设置精细, 尤其是初次配置NAS, 这样设置可以避免很多坑, 以免将自己弄得很沮丧. 当你回头来调参数的时候,就需要了解以下内容了. 第一点: NAS 客户端是不需要登陆即可访问共享目录的, 哪服务器端如何知道访问者是谁,访问者该拥有多大权限的呢? 答案就是通过ip地址和客户端操作系统当前用户id, 和组id , 通过IP控制是否能访问NAS服务, 通过用户ID控制能访问什么文件, 有多大权限, 当然这种简单的权限控制模型会有缺陷, 要做到相对安全也要看个人的配置能力,以及对NFS的理解程度. 这里我在/etc/exports文件中指定的是一个网段192.168.0.0/16, 什么意思呢? 也就是这个网段的用户可以访问NAS上的共享目录, 当然也可以按单个ip地址配置, 可以将网段替换为ip地址, 这样就只有指定ip地址的用户可以访问共享目录这样就精细化了很多, 当然 ip地址是容易伪装, 替换, 以及变化的, 这就是NAS 权限控制比较理想化的地方, 如果是在局域网内,就看管理员如何控制好ip地址的分配, 路由设置等水平了, 所以安不安全要看管理员的水平. 这里也可以配置为通配符, 例如 *, 任何ip过来的用户都可以访问. 刚刚讲到了 ip 地址是NAS 权限控制的重要因子, 另外客户端uid, gid 也是权限控制的重要因子, NAS很好的利用了Linux的权限管理模型, 对熟悉Linux/Unix的系统的用户也降低了学习难度. 首先假设这里配置是no_root_squash, no_all_squash, 这两个选项是什么意思? 先简单介绍这两个选项的作用, 就是不要做身份映射, 简单来说就是, 如果客户端当前是 root用户, 那么他访问共享目录的身份就是root, (当然是不是 root 用户是取决于他的用户id, 而不是用户名, 我们知道所有的linux root 用户的ID都是0, 所属组ID是0, 这里为了便于描述使用用户名代表root用户) , 如果是普通用户 例如zhangsan (uid:999), 那么他操作共享目录的身份就是zhangsan, 那么张三有什么样的权限呢? 还记得我们创建共享目录的时候设置了什么样的访问权限吗? chmod 777 /shared, 张三不是owner, 不属于root组, 张三应该属于others(其他用户) , others对该目录拥有读写执行权限. 假设我们创建共享目录的时候是这样 chmod 770 /shared, 那么张三是没有任何权限的, 对目录中的文件及文件夹不能进行任何操作. 这就是我为什么在创建共享目录的时候建议大家先授予目录777权限, 权限似乎大的吓人, 但是后续就会发现它的好处, 因为我们在客户端配置,测试的时候, 往往可能就是其他用户, 不是root, 也不属于root用户组, 尤其在windows上访问NAS. 从以上的描述, 不知道各位看官有没有发现一个问题或者叫漏洞( 我担心在本已很复杂的逻辑,再引入一个复杂的问题, 会让人晕掉,所以前面只字未提, 现在另起一段来讨论这个问题). 这里先假设客户端有个叫zhangsan(uid:999) 的用户, 服务器端也有zhangsan(uid:999) 的用户, 那很好啊,客户端的张三就像服务器端的张三一样读或写共享目录.接下来的问题就复杂一些了, 假设服务器端压根就没有 zhangsan(uid:999) 的用户, 连uid为999的用户都没有, 那会怎样? 大家可以把流程走通后自己测试一下, 我已经测试过了, 张三依然能访问目录, 而且当张三创建新文件的时候, 会创建一个uid:999的文件, 当我ls -lt 查看此文件的时候, 只能看到文件的 owner是999, 不会显示owner的名字, 如果再进一步使用服务器端用户访问此文件, 如果服务器端的 umask 是0022 除了root 没有一个用户能查看,修改或删除它. 这样其实带来一个好处, 只有客户端用户能访问他所创建的文件, 如果我们严格限制服务器端的 root权限, 理想状况下能很好的保护客户端用户的隐私. 另起一段, 让事情再复杂一些, 假设服务器上没有zhangsan(uid:999) 这个用户, 只有有李四lisi(uid:999) 这个用户, 那么会怎样? 此时, 张三创建的文件, 会显示 owner 是李四(lisi), 如果这个文件里面有张三的隐私的话, 那么张三的隐私有可能被泄露, 如果是钱的哈, 有可能被转走. 这很不安全,NAS为我们留下了一个巨大的安全漏洞, 也给我们提供了解决办法, 那么怎么防止这一点呢, linux 也可以做到, 这就需要研究ACL权限控制了, 这里不做展开. 以上不算最严重的情况, 毕竟服务器端, 恶意篡改的可能性相对比较小, 也容易控制. 下面这种情况就比较糟糕了, 假设现在有多个客户端可以访问共享目录, 这些客户机上分别有 李四 lisi(uid:999) 王五 wangwu(uid:999), 赵六zhaoliu(uid:999) , 那么他们都能看到彼此创建的文件, 如果是隐私或保密数据, 那将是是糟糕的不能再糟糕的一件事情. 难道隐私数据就不能放在NAS上吗? 之前说了, 这取决于管理员的配置水平, NAS权限配置可以精细到单个ip级别, 不同的ip只能访问到不同的目录, ip+uid 可以让用户彼此隔离开来, 或者引入LDAP, 单点登录, 让不同的用户拥有不同的uid也能防止重复的问题, 而且可以很好的结合LDAP身份验证功能. 但是任何事物都有两面性, 假设架设NAS的目的就是为了分享, 为了协同工作, 那么这种设置又能很容易地达到目的. 所以NAS的权限管理可以很灵活, 也可以做到很严谨, 也可能很糟糕, 取决于使用目的以及管理水平. 讲了这么多, 才讲完了no_root_squash, no_all_squash 两个选项, 是不是超级复杂? 这就完了吗? 当然还没有完, 因为权限控制问题本身就很复杂, 在任何一个系统中都是逻辑最复杂最混乱的一块. 当我们试图解决客户端uid重复的时候, 有没有发现一个新的问题, 问题一, 如果按ip+uid 唯一映射共享目录, 可以做到很好的隔离, 但是配置文件会膨胀的非常快, 会相当混乱, 维护起来会相当困难, 复杂性转移到了配置管理了, 有没有? 问题二, 如果采用LDAP, 客户端uid可以实现唯一, 但是我们知道任何客户端的东西都可能被恶意篡改, 难免有不怀好意的用户, 那么我们必须把控制权掌握在自己手中, 不给恶意使用者留下机会. 那要怎么办呢? 这里就是身份映射闪亮登场的时候了. 为什么需要身份映射. 刚刚说了, 在以隐私保护,数据安全为导向的权限设置中,最大的威胁是uid重复. 这里我们引入了LDAP, 也就引入了身份验证, 也尽量避免uid重复, 但是防止不了伪造. 我们也知道NAS 没有引入身份验证的功能, 尽量保持简便灵活. 既然没有引入身份验证, 理论上是不能很好的做到数据隔离的, 更何况我们也有数据共享的必要,协作的必要. 引入身份验证可能使得协助,共享变得困难,复杂. 既然不能保证全体用户的隔离, 我们还是能保证部分敏感用户是隔离的. 假设我们以保护张三的隐私为最高优先级, 那么王五赵六的为次优先级. 那么我们就可以把王五赵六映射为nfsnobody, 张三的映射到全服务器上唯一的一个用户上, 这样就避免了张三与其他用户uid冲突的问题, 服务器端严格限制张三对于的uid的权限, 除了root可以访问,尽量不让其他用户访问张三的隐私数据. 当然如果root用户要作恶, 技术手段是很难防止的了得, 只有通过行政手段,法律措施, 规章制度来保证. 这应该就是引入 root_squash, all_squash, anonuid, anongid的目的, 要搞懂这些选项, 先要弄懂这几个单词的含义很重要, squash 这里采用的是压扁的意思, 想象一下网络上的用户(赵钱孙李,周吴郑王) 像潮水一般地向NAS涌来, 在进入nas服务之前, 将他们压缩,压扁成一个用户nfsnobody(nfs小人物) 当我们在服务器上安装nfs-utils的时候,默认就会创建一个nfsnobody用户, 如果我们不想使用nfsnobody, 或者一个nfsnobody根本不够用, 我们可以使用 anonuid 指定映射身份. root_squansh 表示无论那个客户端来的root压扁成nfsnobody, all_squash 表示无论哪个客户端来的普通用户压扁成服务器上的nfs小人物, 那么大人物是谁? 就是那些以真实身份访问服务器的用户, 他们的隐私应该得到更好的保护. anonuid 中的anon 就是anonym匿名或无名的缩写(a是否定前缀, nonym跟name同源, 相当于中文的无名), uid 则对于 linux uid (user id), 这样这些选项就容易理解, 不容易配错了. sync选项与权限无关,是用来控制内存数据和硬盘数据是否同步, 要深入了解这个选项, 就要进一步了解Linux 的IO模型, 网络传输协议了, 此处不做展开. 4.2.3. 配置NFS相关服务 设置开机启动 1234systemctl enable rpcbindsystemctl enable nfssystemctl enable nfs-locksystemctl enable nfs-idmap 启动服务 12345systemctl start rpcbindsystemctl start nfssystemctl start nfs-locksystemctl start nfs-idmap 4.3. 查看NAS状态4.3.1. 查看服务端口占用，以便开着防火墙的时候设置我们在使用rpcinfor -p 查看nfs的服务时, 会看到nfs注册了以下服务. 1234567891011121314151617181920212223242526272829$ rpcinfo -pprogram vers proto port service100000 4 tcp 111 portmapper100000 3 tcp 111 portmapper100000 2 tcp 111 portmapper100000 4 udp 111 portmapper100000 3 udp 111 portmapper100000 2 udp 111 portmapper100005 1 udp 20048 mountd100005 1 tcp 20048 mountd100005 2 udp 20048 mountd100005 2 tcp 20048 mountd100005 3 udp 20048 mountd100005 3 tcp 20048 mountd100024 1 udp 662 status100024 1 tcp 662 status100003 3 tcp 2049 nfs100003 4 tcp 2049 nfs100227 3 tcp 2049 nfs_acl100003 3 udp 2049 nfs100003 4 udp 2049 nfs100227 3 udp 2049 nfs_acl100021 1 udp 32769 nlockmgr100021 3 udp 32769 nlockmgr100021 4 udp 32769 nlockmgr100021 1 tcp 32803 nlockmgr100021 3 tcp 32803 nlockmgr100021 4 tcp 32803 nlockmgr 可以看到, rpcbind 监听在111端口, nfs监听在2049 端口. 目前支持的nsf协议有版本v1,2,3,4.假设我们现在以vi编辑器打开并修改某个以nfs方式挂载至客户机的文件t的文件test.txt客户端portmap 首先向服务器端的111端口发起请求, 询问nfs服务的端口号, 服务端portmap会反馈2049, 客户端立即通过2049端口与服务端建立链接.建立链接后, 服务端进一步发送访问test.txt的请求, 服务段经过nfs_acl鉴权, 如果用户有权限访问, 則放行请求, 否则提示权限不足, 由于是写文件, 需要通过nlockmgr获得文件锁, 否则等待锁释放. 4.4. NAS文件名字符集问题说明前面分析了, 客户端uid不一致可能和服务器端不一致, 会带来很多安全问题. 下面讨论一下客户端与服务器端字符集不一致可能导致的问题. 客户端的字符集可能千奇百怪, 服务器端只能设置一种字符集, 如何以不变应万变呢? 首先我们要搞清楚文件在计算机中是如何存储的, 也不用太深入, 起码要弄明白两个概念, inode, block. 我们经常会见到乱码的问题, 尤其是文件名, 当然如果内容是文本文件, 当使用文本编辑器打开的时候也会遇到乱码的问题, 如果是binary文件, 给机器读取的,到是不必太过担心. 下面我们来分析一下, 为什么会遇到乱码问题. 文件名是存储在inode中的, 二进制数据在传输的过程中, 理论上是不会改变的, 如果客户端是GBK编码的二进制信息, 服务器收到的后会原样保存, 如果客户端和服务器端字符编码不一致, 这时候服务器端可能看起来就是乱码. 这种情况下, 只是NAS 管理员看到文件名很迷糊, 客户端没影响, 这不影响客户的使用, 但是影响管理员的管理工作, 试想如果管理员要给文件移动一个位置, 面对一堆乱码, 确实是很头疼的一件事. 这里让问题再复杂一些, 假设现在有两个客户端同时能访问, 编辑同一个共享文件, 他们的编码方式还不一样, 那么甲保存的文件名, 乙看起来可能就是乱码. 乙修改后甲看起来就是乱码, 如果两个人脾气不好, 有可能打起来, 如果两人都比较温和内向, 也有可能心生怨恨. 这里个人觉得没有什么很好的办法彻底解决乱码的问题, 只有一些折中的方案, 第一点, 尽量不要使用中文命名文件, 不是万不得已尽量不要使用中文来命名文件. 第二点, 服务器端和客户端尽量使用utf8编码, 毕竟他支持的中文字符要全面, 也支持其他各国文字, 唯一的缺点是部分中文字符需要四个字节来存储, 大部分中文常用字符也需要二到三个字节来存储, 考虑到现在计算机的存储相对便宜, cpu的速度很快, 大多数情况都不饱和, 如果你的系统对存储,对性能要求不是十分的苛刻, 服务器端尽量使用utf8, 做到对尽量多的字符提供支持. 客户端如果能统一编码方式为utf8那是最好, 如果不能只能告诉客户端很抱歉, 我们只能做到这种地步了, 最多能在提供一个工具在客户端转码吧, 毕竟utf8编码还可以嗅探出编码格式, 如果是其他编码格式, 可能无能为力. 如果你有更好的解决方案, 欢迎在下方留言. inode 存储了如下信息: inode包含文件的元信息，具体来说有以下内容： 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 链接数，即有多少文件名指向这个inode 文件数据block的位置 例如我们使用stat命令查看一个文件的inode信息, 我特意创建了一个中文命名的文件, 现在假设服务器上使用的是utf-8编码, 客户端是GBK编码, 那么客户端看到的文件名就可能是乱码. 123456789$ stat 测试.txtFile: ‘测试.txt’Size: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 25h/37d Inode: 250655 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2020-11-18 02:36:02.309190000 +0800Modify: 2020-11-18 02:36:02.309190000 +0800Change: 2020-11-18 02:36:02.309190000 +0800Birth: - 5. NFS客户端安装与设置5.1. linux客户端 安装必要软件 12yum -y install nfs-utilsshowmount -e 192.168.1.13 //192.168.1.13 为NAS服务器ip 临时挂载 创建目录，修改权限 1234# 创建挂载点:mkdir /mnt/datachmod 777 /mnt/data //此处权限需要根据实际情况调整, 777权限过于开放:mount -t nfs 192.168.1.13:/shared /mnt/data 查看挂载： 12345678910$df -h文件系统 容量 已用 可用 已用% 挂载点devtmpfs 898M 0 898M 0% /devtmpfs 910M 0 910M 0% /dev/shmtmpfs 910M 9.6M 901M 2% /runtmpfs 910M 0 910M 0% /sys/fs/cgroup/dev/mapper/centos-root 47G 8.5G 39G 18% //dev/sda1 1014M 150M 865M 15% /boottmpfs 182M 0 182M 0% /run/user/0192.168.1.13:/shared 27G 2.4G 25G 9% /mnt/data 卸载方法 1umount /mnt/data 设置开机自动挂载 修改/etc/fstab, 添加一条 192.168.1.13:/shared /data nfs defaults,_rnetdev 1 1 备注：第1个1表示备份文件系统，第2个1表示从/分区的顺序开始fsck磁盘检测，0表示不检测。 _rnetdev 表示主机无法挂载直接跳过，避免无法挂载导致主机无法启动 5.2. windows客户端Windows下面默认没有mount，需要添加功能。 比如Windows 10：(备注: windows 10家庭版除外,家庭版不带nfs功能, 需要专业版或企业版 ) 对于Windows家庭版, 也没必要花钱去升级为专业版, 有很多变通的方法可以在Windows家庭版上使用nfs. 例如可以启用WSL(Windows for Linux subsystem), 或者开启hyper-v 安装Linux虚拟机, 当然windows 10家庭版开启heyper-v还是有一定难度的. 或者安装VMware安装Linux虚拟机, 再挂载nfs. 关注我的博客主站, 左侧导航栏有搜索按钮, 搜索WSL, vmware, 将获得相应帮助. 设置-&gt;应用-&gt;程序和功能-&gt;启用或关闭Windows功能：勾选上NFS服务 很多博客都讲了windows上如何挂载 但是没有讲如何取消挂载 删除可以使用图形界面取消, 也可以使用umount 命令 例如: 用法: umount [-f] &lt;-a | drive_letters | network_mounts&gt; 1umount G: -a 删除所有 NFS 网络装入点-f 强制删除 NFS 网络装入点 5.3. 遇到的坑clnt_create: RPC: Port mapper failure – Timed out STATD_OUTGOING_PORT=2020 原因:端口被防火墙屏蔽 解决办法: 设置防火墙,接收来自nfs各端口的上行请求 6. 相关文章本技术博客原创文章位于鹏叔的技术博客 - CentOS7搭建NAS文件共享存储, 要获取最近更新请访问原文. 更多技术博客请访问: 鹏叔的技术博客 7. 扩展阅读NFS 协议 Mount 过程揭秘 8. 参考文档CentOS7搭建NAS文件共享存储 NFS服务的用户身份映射 NAS之NFS原理 NAS的字符编码 Unicode NAS原理简介 NFS 协议 Mount 过程揭秘","link":"/linux/nas_installation_on_linux.html"},{"title":"使用Terraform在ESXI上创建虚拟机","text":"1. 前言ESXi 是一种用于创建和管理虚拟机（VM）的系统管理程序。然而，手动创建和管理多个虚拟机可能非常耗时且容易出错。Terraform 是一个开源 IaC 工具，可以在 ESXi 中自动创建和管理虚拟机。在本教程中，我们将学习如何使用 Terraform 在 ESXi 中创建多个虚拟机。 2. 为什么使用 TerraformTerraform 是一种基础设施即代码工具，允许您将基础设施定义为代码，可以在团队成员之间进行版本控制、审查和共享。使用 Terraform，您可以以一致和可复制的方式自动化创建和管理基础设施资源（包括 VM）的过程。Terraform 还提供了一种定义资源之间依赖关系的方法，以便可以按正确的顺序创建资源。 3. 前置条件VMware ESXi 环境Terraform 安装在您的本地机器上Terraform 和 ESXi 的基本知识 4. 创建一个新的 Terraform 配置文件使用 Terraform 在 ESXi 中创建虚拟机的第一步是创建一个新的 Terraform 配置文件。打开您最喜欢的文本编辑器，创建一个名为“main.tf”的新文件。 5. 配置 vSphere providervSphere provider 允许 Terraform 与 ESXi 进行交互。将以下代码添加到 main.tf 文件中 1234567provider &quot;vsphere&quot; { user = &quot;your_vSphere_username&quot; password = &quot;your_vSphere_password&quot; vsphere_server = &quot;your_vSphere_server&quot; allow_unverified_ssl = true} 记得将“your_vSphere_username”、“your_vSphere_password”和“your_vSpher_server”替换为 vSphere 帐户详细信息。allow_unverified_ssl: 如何你的 esxi 服务器没有设置 ssl 证书, 这里需要设置为 false. 6. 创建新的虚拟机将以下代码添加到 main.tf 文件以创建新的虚拟机： 12345678910111213141516171819202122232425262728293031323334353637383940#Data Sourcesdata &quot;vsphere_datacenter&quot; &quot;dc&quot; { name = &quot;LukeLab&quot;}data &quot;vsphere_datastore&quot; &quot;datastore&quot; { name = &quot;datastore1&quot; datacenter_id = &quot;${data.vsphere_datacenter.dc.id}&quot;}data &quot;vsphere_resource_pool&quot; &quot;pool&quot; {}data &quot;vsphere_network&quot; &quot;network&quot; { name = &quot;VM Network&quot; datacenter_id = &quot;${data.vsphere_datacenter.dc.id}&quot;}resource &quot;vsphere_virtual_machine&quot; &quot;example&quot; { name = &quot;example-vm&quot; resource_pool_id = &quot;${data.vsphere_resource_pool.pool.id}&quot; datastore_id = &quot;${data.vsphere_datastore.datastore.id}&quot; num_cpus = 2 memory = 2048 guest_id = &quot;otherLinux64Guest&quot; network_interface { network_id = &quot;${data.vsphere_network.network.id}&quot; adapter_type = &quot;vmxnet3&quot; } disk { label = &quot;disk0&quot; size = 20 eagerly_scrub = false thin_provisioned = true } wait_for_guest_net_timeout = 0 wait_for_guest_ip_timeout = 0} 这里 datastore_id 和 resource_pool_id 采用查询 EXSI 的方式获得将“example-vm”替换为您要为虚拟机命名的名称，将“VM Network”替换为要将虚拟机连接到的网络名。由于初始创建 VM 没有安装 vmware tools,所以获取不到 ip 地址, 此处将 wait_for_guest_net_timeout 和 wait_for_guest_ip_timeout 都设置为 0 7. 初始化并应用 Terraform 配置通过在终端中运行以下命令初始化 Terraform 配置： 1terraform init 然后，通过运行以下命令应用 Terraform 配置： 1terraform apply Terraform 在 ESXi 中创建虚拟机之前，系统将提示您确认更改。键入“yes”，然后按回车键继续。 8. 验证虚拟机是否已创建Terraform 完成应用配置后，您可以通过登录 vSphere 客户端并导航到“虚拟机”选项卡来验证虚拟机是否是在 ESXi 中创建的。 9. 总结Terraform 是一个强大的工具，可以极大地简化创建和管理基础设施资源的过程。在本教程中，我们介绍了如何使用 Terraform 在 ESXi 中创建虚拟机。通过以下步骤，您现在应该对如何使用 Terraform 创建基础设施资源有了基本的了解。 10. 参考文档Creating VM In ESXi Using Terraform: A Step-By-Step Guide Use terraform to deploy a VM in EXSI","link":"/linux/terraform_vm_exsi.html"},{"title":"Ubuntu服务器安装图形化界面","text":"1. 前言最近在阿里云上创建云主机, 主要是需要使用浏览某些网站, 说实在的我只需要浏览器就够用了, 但是无奈阿里云提供了桌面的镜像只有Windows的几个版本.而使用windows得镜像要比Linux得镜像贵好几倍, 一来是服务器硬件资源要求较Linux高, 而来Windows镜像都是需要License费用或者额外购买License的.于是考虑在创建Linux云主机后, 安装一个Linux桌面系统, 果然让我实验成功了, 特写此文, 以防遗忘, 另外给后来人以方便. 2. 更新和升级软件包首先，因为你将要做一些系统级的修改，因此先进行更新和升级以确保我们系统的包是最新的 1sudo apt update &amp;&amp; sudo apt upgrade 3. 安装Ubuntu桌面1sudo apt install ubuntu-desktop 4. 重启1reboot 完成 5. 参考文档如何在 Ubuntu 服务器上安装桌面环境（GUI）","link":"/linux/ubuntu_install_desktop.html"},{"title":"Tmux使用说明","text":"1. Tmux的作者Tmux的作者是Nicholas Marriott, 网上关于Nicholas Marriott的介绍很少, 但是本人对创建如此复杂而功能强大的Tmux的开源开发者十分感兴趣, 希望知道的能补充一些关于Tmux的信息. 2. Tmux 是什么？Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与称为一次”会话”（session） 。口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话不管有没有运行完。登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候. 3. 为什么需要安装tmux我偏爱 tmux 而非其他的终端工具有几个原因：会话处理：从会话分离和附加到会话帮助我进行上下文切换和远程工作平台独立性：我可以在我的 Macbook、我的 Linux 笔记本、云服务器、windows下的Cygwin, Raspberry Pis、BeagleBones 等上使用 tmux。可定制：有很多方法可以定制我的 tmux 环境的外观和行为。 我可以使用一个简单的点文件跨不同平台同步街头信誉：你不想让别人称你为跛脚，是吗？ 3.1. Tmux中的重要概念在Tmux逻辑中，需要分清楚Server &gt; Session &gt; Window &gt; Pane这个大小和层级顺序是极其重要的，直接关系到工作效率：Server：是整个tmux的后台服务。有时候更改配置不生效，就要使用tmux kill-server来重启tmux。Session：是tmux的会话。我之前就错把这个session当成窗口用，造成了很多不便里。一般只要保存一个session就足够了。Window：相当于一个工作区，包含很多分屏，可以针对每种任务分一个Window。如下载一个Window，编程一个window。Pane：是在Window里面的小分屏。最常用也最好用了解了这个逻辑后，整个Tmux的使用和配置也就清晰了。使用 Tmux 的时候千万不要去背指令，所有的指令都可以在 .tmux.conf 配置文件中绑定自己顺手的快捷键，也可以配置开启鼠标。 3.2. Tmux 的作用Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离. 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口”接入”已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。 类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。 4. 安装Tmux12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 5. 基本用法5.1. 启动与退出安装完成后，在命令行下键入tmux命令，就进入了 Tmux 窗口。 1tmux 上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。 5.2. 前缀键Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。然后，按下 ESC 键或q键，就可以退出帮助。 6. session管理6.1. 新建会话第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。使用编号区分会话，不太直观，更好的方法是为会话起名。 1tmux new -s &lt;session-name&gt; 上面命令新建一个指定名称的会话。快捷键: Ctrl+b :new&lt;回车&gt; 6.2. 分离window和session在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。 1tmux detach 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。快捷键: Ctrl+b d 6.3. 查看sessiontmux ls命令可以查看当前所有的 Tmux 会话。 123$ tmux ls# or$ tmux list-session 也可以使用快捷键Ctrl+b s快速查看session,并使用方向键切换会话，非常方便．快捷键: Ctrl+b :ls 6.4. 接入会话tmux attach命令用于重新接入某个已存在的会话。 12345# 使用会话编号$ tmux attach -t 0# 使用会话名称$ tmux attach -t &lt;session-name&gt; 6.5. 关闭会话tmux kill-session命令用于杀死某个会话。 12345# 使用会话编号$ tmux kill-session -t 0# 使用会话名称$ tmux kill-session -t &lt;session-name&gt; 6.6. 切换会话tmux switch命令用于切换会话。 12345# 使用会话编号$ tmux switch -t 0# 使用会话名称$ tmux switch -t &lt;session-name&gt; 6.7. 重命名会话tmux rename-session命令用于重命名会话。 1tmux rename-session -t 0 &lt;new-name&gt; 也可以使用Ctrl+b $：快速重命名当前会话。 6.8. 会话管理快捷键汇总下面是一些会话相关的快捷键。 快捷键 描述 Ctrl+b : 进入命令行模式，可以用ls等命令。 Ctrl+b :new&lt;回车&gt; 启动新会话。 Ctrl+b d 分离当前会话。 Ctrl+b D 选择要断开的会话。 Ctrl+b ctrl+z 起当前会话。 Ctrl+b r 重载当前会话。 Ctrl+b s 列出所有会话。 Ctrl+b $ 重命名当前会话。 7. 窗格管理Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。 7.1. 分割窗格tmux split-window命令用来分割窗格。 垂直分割窗口 Ctrl+b &quot; 12# 划分上下两个窗格$ tmux split-window 水平分割窗口, 快捷键Ctrl+b % 12# 划分左右两个窗格$ tmux split-window -h 7.2. 切换窗格tmux select-pane命令用来移动光标位置。可以使用命令，也可以使用会计见以下up, down, left, right表示键盘方向键切换到上方窗格 快捷键Ctrl+b Ctrl+up 12# 光标切换到上方窗格$ tmux select-pane -U 切换到下方窗格 快捷键Ctrl+b Ctrl+down 12# 光标切换到上方窗格$ tmux select-pane -D 切换到左侧窗格 快捷键Ctrl+b Ctrl+left 12# 光标切换到左边窗格$ tmux select-pane -L 切换到左侧窗格 快捷键Ctrl+b Ctrl+right 12# 光标切换到右边窗格$ tmux select-pane -R 也可以使用快捷键循环切换窗口Ctrl+b ;：光标切换到上一个窗格。Ctrl+b o：光标切换到下一个窗格。 8. 交换窗格位置tmux swap-pane命令用来交换窗格位置 1234# 当前窗格上移$ tmux swap-pane -U# 当前窗格下移$ tmux swap-pane -D 8.1. 窗格管理快捷键下面是一些窗格管理的快捷键。 快捷键 描述 Ctrl+b “ 划分上下两个窗格。 Ctrl+b % 划分左右两个窗格。 Ctrl+b &lt;arrow key&gt; 光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗 Ctrl+b ; 光标切换到上一个窗格。 Ctrl+b o 光标切换到下一个窗格。 Ctrl+b { 当前窗格与上一个窗格交换位置。 Ctrl+b } 当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o 所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o 所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x 关闭当前窗格。 Ctrl+b ! 将当前窗格拆分为一个独立窗口。 Ctrl+b z 当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+&lt;arrow key&gt; 按箭头方向调整窗格大小。 Ctrl+b q 显示窗格编号。 9. 窗口管理9.1. 新建窗口tmux new-window命令用来创建新窗口。 1234$ tmux new-window# 新建一个指定名称的窗口$ tmux new-window -n &lt;window-name&gt; 9.2. 切换窗口tmux select-window命令用来切换窗口。 12345# 切换到指定编号的窗口$ tmux select-window -t &lt;window-number&gt;# 切换到指定名称的窗口$ tmux select-window -t &lt;window-name&gt; 9.3. 重命名窗口tmux rename-window命令用于为当前窗口起名（或重命名）。 1tmux rename-window &lt;new-name&gt; 9.4. 窗口管理快捷键下面是一些窗口操作的快捷键。 快捷键 描述 Ctrl+b c 创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p 切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n 切换到下一个窗口。 Ctrl+b &lt;number&gt; 切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。 Ctrl+b w 从列表中选择窗口。 Ctrl+b , 窗口重命名。 9.5. 其他命令下面是一些其他命令。 1234567891011121314# 列出所有快捷键，及其对应的 Tmux 命令$ tmux list-keys# 列出所有 Tmux 命令及其参数$ tmux list-commands# 查看某个子命令帮助$ tmux # 列出当前所有 Tmux 会话的信息$ tmux info# 重新加载当前的 Tmux 配置$ tmux source-file ~/.tmux.conf 10. 定制自己的tmux以上讲了那么多快捷键, 其实在日常使用中可能会用不到, 所以不用记. 使用Tmux就有这样的好处, 如果快捷键难记, 那么我们就改掉它, 改成顺手的,习惯的.tmux默认会读取用户home目录下一个叫.tmux.conf的文件,定制自己的tmux主要是修改这个配置文件. 首先我们要修改的就是prefix键, 默认的profix键是Ctrol+b, 这个组合虽然可以避免和常用的快捷键冲突,但是使用起来也很别扭, 有点像弹钢琴时练习跨八度指法练习, 长期使用对手指和手腕的健康不好. 如果你也有同样的感受, 可以使用如下配置将它改掉. 1234# remap prefix from 'C-b' to 'C-a'unbind C-bset-option -g prefix C-abind-key C-a send-prefix 第二个需要修改的是水平窗口分割和垂直窗口分割, 则两个功能默认的快捷键是双引号和百分号, 我实在无法将双引号和百分号与水平和垂直联系起来, 当我在写这篇文章的时候我也区分不开到底是使用双引号还是百分号去做垂直分割, 虽然我已经使用了很多次了, 每次我都要瞄一眼文档, 或者错了再重试另一个. 但是请记住捣腾这些工具的目的, 就是追求效率, 所以对于我来说, 这两个常用功能的快捷键是一定要改掉的. 这里使用 ‘|’ 表示水平分割, ‘-‘ 表示垂直风格, 至于为什么选择这两个键, 我想不用做过多解释了, 它就像尖刀在屏幕上画了两这样两条线, 改完后还用记吗? 如果你比喜欢上面的方式, 如果你英文较好, 可以使用h代表horizontal水平的, v代表vertical垂直的, 也可以拼音h 横, c垂直, 这里尽量不用s, s表示session, 已经被占用了. 12345# split panes using | and -bind | split-window -hbind - split-window -vunbind '&quot;'unbind % 第三个需要修改的窗口切换快捷键默认的快捷键严重影响效率, 默认的快捷键是先按一下ctrl+b, 再按ctr加方向键, 窗口多了的情况下,也不用太多大于3个, 使用起来就特别别扭, 达不到所想即所得的效果, 当你的大脑在频繁的出错, 频繁ctrl+b ctrl+方向重试的过程中, 一定是很沮丧的. 对于一个对用户体验有要求的用户来说, 这种方式离开丝滑感觉相差太远了, 即使你使用tmux另一组快捷键,使用数字选择窗格, 也要去思考应该选第几个窗格, 也是对脑力的浪费. 这里我修改了配置使用alt+方向来切换窗格. 下面的M表示alt键. Left, Right, Up, Down为左右上下方向键. 12345# switch panes using Alt-arrow without prefixbind -n M-Left select-pane -Lbind -n M-Right select-pane -Rbind -n M-Up select-pane -Ubind -n M-Down select-pane -D 第四个要修改的是enable 鼠标功能, 默认鼠标的行为是被关闭的对于tmux 2.1 以上版本 只要一项配置就能enable所有的鼠标行为 12# Enable mouse mode (tmux 2.1 and above)set -g mouse on 对于tmux 2.1以下版本还需要一项一项去配置 1234# Enable mouse control (clickable windows, panes, resizable panes)set -g mouse-select-window onset -g mouse-select-pane onset -g mouse-resize-pane on 第五 刷新配置刷新配置使用快捷键Ctrl + b : 然后在左下方文章会出现命令行输入框,输入命令 source-file ~/.tmux.conf如果你经常需要更新配置可以将其配置为快捷键, 这样以后你使用prefix键Ctrl+a r就可以更新配置了. 12# reload config file (change file location to your the tmux.conf you want to use) bind r source-file ~/.tmux.conf 第六 为了方便拷贝, 我把以上说讲到的配置汇总在下方, 这样只要copy之后就能直接使用.文件名: ~/.tmux.conf内容: 12345678910111213141516171819202122232425262728293031# remap prefix from 'C-b' to 'C-a'unbind C-bset-option -g prefix C-abind-key C-a send-prefix # split panes using | and -bind | split-window -hbind - split-window -vunbind '&quot;'unbind % # switch panes using Alt-arrow without prefixbind -n M-Left select-pane -Lbind -n M-Right select-pane -Rbind -n M-Up select-pane -Ubind -n M-Down select-pane -D# Enable mouse mode (tmux 2.1 and above)set -g mouse on# 复制模式下, 可以设置为vi或emacs快捷键# 也可以设置emacs 默认为emacs# 进入复制模式使用prefix [set -g mode-keys vi # Enable mouse control (clickable windows, panes, resizable panes)# set -g mouse-select-window on# set -g mouse-select-pane on# set -g mouse-resize-pane on# reload config file (change file location to your the tmux.conf you want to use)bind r source-file ~/.tmux.conf 11. tmux的复制粘贴在 tmux 2.1 中，开启鼠标支持，在.tmux.conf中添加一行配置 12#开启鼠标支持set-option -g mouse on 复制 按住shift键,然后拖动鼠标复制要选择的内容，然后按下ctrl+shift+c,复制到系统剪贴板粘贴 按下ctrl+shift+v 粘贴系统剪贴板中的内容到tmux中需要注意的是ctrl+shift+v是在终端设置的粘贴快捷键ctrl+shift+c是在终端设置的复制快捷键需要根据你的终端配置的复制粘贴快捷键来进行操作 11.1. 复制模式复制模式步骤：我的控制键为：C-b1、 C-b [ 进入复制模式2、 参考上表移动鼠标到要复制的区域，移动鼠标时可用vim的搜索功能”/“,”?”3、 安空格键开始选择复制区域4、 选择完成后安enter键退出5、 C-b ] 粘贴 12. 设置打开终端即打开 tmux创建init_tmux.sh，并在 ~/.bashrc 中调用该脚本就可以了 123456789101112131415161718192021222324#!/bin/bash# 检查tmux是否安装if [ -z &quot;$TMUX&quot; ]; then # 检查session 是否存在 tmux has-session -t session_name # 如果不存在, 则创建session, 并初始化window, panes if [ $? -ne 0 ]; then tmux new-session -s session_name -n window_name -d tmux send-keys -t session_name:0 &quot;cd path_for_panel_0&quot; C-m # session_name:0.0 第一个0代表0号windown, 第二个0代表0号pane # -h 水平分割 -p 40 分割屏幕的40%给新窗口 tmux split-window -h -p 40 -t session_name:0.0 # C-m 为ctrl + m 相当于敲下回车键 tmux send-keys -t session_name &quot;cd path_for_panel_1&quot; C-m # session_name:0.1 0代表0号windown, 1代表1号pane tmux split-window -v -t session_name:0.1 tmux send-keys -t session_name &quot;cdphiloenglish &amp;&amp; cd webapp&quot; C-m tmux select-window -t session_name:0 tmux select-pane -t session_name:0.1 -L fi tmux attach -t session_namefi 13. 后记本文原文位于鹏叔的技术博客 - Tmux使用说明, 获取最近更新, 请访问原文. 14. 参考文档Tmux 使用教程 Tmux 配置：打造最适合自己的终端复用工具 Making tmux Pretty and Usable tmux 帮助手册 使用tmux改进终端体验 tmux的复制粘贴","link":"/linux/tmux.html"},{"title":"快速注册 Vultr 账号以及创建 Vultr VPS","text":"Vultr 作为很多人的入门 VPS，有着良好的口碑，尤其在建站方面，稳定。Vultr 提供众多应用一键安装模板，但是由于英文界面，加上新手很多新手不知道如何去操作，这里写下详细新手图文教程。另外请持续关注博客，鹏叔将利用这波优惠，探索一些新花样。 Vultr 目前正在做活动，新用户访问https://www.vultr.com进行注册，可以获得为期一个月金额300美金的试用金，不过可能过了这段时间就没有了。 1. 300 美金试用金可以玩些什么？ 可以用来 Vultr 干些啥？ 可以创建 Computer，关键他的 CPU 还是独占的，不是共享的; Cloud GPU, AI 爱好者的福音; 可以创建kubernetes 集群; 还能玩Serverless; CDN; 数据库，对象存储，块存储。 在来看看价格： 1U1G 才 6 美金/月， 1U2G 12 美金/月， 2U2G 18 美金/月, 关键是它还送 4TB 的带宽，这比国内的云厂商良心多了，懂的都懂。 不考虑赠送因素，请在评论区告诉我这个价格在国内是什么水平！ 先创建一个 1U2G VPS, 12 美金/月 创建一个 4 节点的 K8s 集群，每个节点 2U2G 大概 72 美金/每月。 再来个对象存储，6 美金/每月 1T 存储加 1 TB 的流量。 再来个负载均衡器，20 美金/每月，3 个节点做高可用负载均衡器。还剩$190，继续 再来个 CDN, 10 美金的基本使用费加额外带宽的动态费用。 就感觉数据库存储服务有点贵，不过这个在 VPS 上自己搭建就好了，这里有教程Linux 上安装 PostgreSQL。 2. 如何注册 Vultr？访问https://www.vultr.com，输入邮箱、密码，点击“Create account”按钮。（密码需要至少一个大写字母一个小写字母，长度 10 位数以上。） 进入邮箱，会收到一封来自 Vultr support team support@vultr.com的验证邮件，拷贝验证码，再回到 Vultr 注册页面进行验证。 1234567891011Dear Customer,Here is the security code needed to log into your Vultr account:d6c398b8。。。。-- Vultr Support Team -- 注册完成后进入账号设置页面，设置账号，主要分三个步骤，如下图所示，首先绑定信用卡，然后完善用户信息，最后就可以开始创建实例了。 进入设置界面，完成第一步“Add a Payment Method &amp; Pre-Fund Your Account”也就是绑定信用卡之后就可以看到赠送的 300 美金试用金到账。 访问 account =&gt; make a payment 就可以看到 300 美金 到账 从上图可以看到，Vultr 不仅支持信用卡付款，还支持 Paypal, 加密货币，Alipay, Wire Transfer, 礼品代码等。 3. 更新 Profile更新 profile, 填写个人信息，地址，公司信息 4. 创建 VPS点击左边”Products”，再点击右侧”Deploy +” 进入创建实例界面。 选择“Cloud Compute - Shared CPU”。 选择服务器规格。 自动备份功能每月会收费 2.4 刀，建议关闭；选择”Enable IPV6”，然后点击“Deploy Now”按钮。 5. 管理 VPS你会看到服务器正在运行，点击实例最后面的“…”，在弹出窗口中选择“Server Details”。 进入服务器信息页面，会看到包含 IP 地址、用户名及密码等信息。 6. 登录 VPSWindows系统上可以使用 X-shell 工具，或任何本机存在的 shell 终端, 或者 putty 连接服务器。 Linux系统直接打开命令行终端远程连接vps即可。","link":"/linux/vultr_account_creation.html"},{"title":"Material Design 基础 - Component behavior","text":"1. 前言本页描述组件在布局中的行为，包括与网格以及断点的关系。 2. Position术语UI元素在每个分界点范围内的行为方式不同。UI元素、组件和表面在网格中的位置用以下术语描述。 Position term Definition Above; below The y position of an element In front of; behind The z position of an element Left; right; center The x position of an element Top; bottom The y position of an element relative to a container or screen edge Vertically centered The x and y position of an element centered relative to a container or the screen edges Sticky An element that scrolls with the UI and locks at a certain point in the scroll range Floating A fixed element positioned in front of scrolling content Leading edge The edge of a screen or layout that written content begins from. For example, in LTR languages such as English, this is usually the left edge of a screen Trailing edge The edge of a screen or layout where written content ends 2.1. 组件自适应(Component adaptation)组件适配描述了视觉呈现（填充、大小、布局或对齐）的变化，或者将一个组件切换到另一个更适合设备大小和用例的组件。 2.2. 视觉呈现(Visual presentation)视觉呈现是最常见的适应方法。这种适应会影响内容和对象在屏幕上的大小和位置，以及它们之间的关系。例如，移动设备上的文本列表可以调整边距、垂直间距或密度，以便更好地适应平板电脑等更大的屏幕。 2.3. 大小限制(Size constraints)Material组件具有容器尺寸、边距和填充的最小值和最大值。有关每个组件的尺寸约束，请访问“组件”部分。例如，对于大屏幕，Snackbar的最大宽度为600dp。当布局从移动屏幕扩展到大屏幕时，这些最小值和最大值允许对组件的视觉显示进行持续更改。缩放布局时，零部件可以在尺寸约束范围内具有固定宽度或响应宽度。无论屏幕大小如何，具有固定宽度的元素都保持相同的宽度。 具有响应宽度的元素随着屏幕大小的变化而膨胀和收缩。 2.4. 内部构成(Internal Composition)缩放组件时，请定义其内部图元相对于容器的位置和对齐方式。例如，当按钮水平展开时，图标按钮内的图标和文本标签保持彼此固定并保持居中。 对于更复杂的组件，如应用程序栏，可以将内部元素分组并锚定到容器中的多个点。例如，菜单图标和徽标可以分组并定位到前缘，而搜索栏定位到中心，动作图标定位到后缘。 组件的内部组成应符合其显示设备的人体工程学需求。例如，移动设备上的水平定向卡可以在更大的屏幕上转换为更方形的卡。这种改编使图像更加突出，并允许更大的字体风格，以提高可读性。 2.5. 组件交换随着屏幕尺寸的不同，布局也会发生变化，具有类似功能的组件也可以互换。这使得可以调整布局，以便对界面的人机工程学和功能质量进行大规模更改。例如，底部导航栏可以与平板电脑上的导航栏交换，也可以与大屏幕上的导航抽屉交换。 组件也可以切换类型。例如，手机上的全屏对话框可以与大屏幕上的简单对话框交换。这种组件更改保持了对话框的功能，同时也利用了屏幕空间，通过显示底层内容来保留用户的上下文。 更换部件时要小心，确保可互换部件在功能上是等效的。例如，不要用按钮换芯片。在列表项和卡片之间切换时要小心。部件交换应始终为用户提供功能和人体工程学的目的。 2.6. 响应模式布局中组件的排列也可以随着屏幕大小的变化而调整。通过重新定位组件或根据可用屏幕空间隐藏/显示信息，可以实现这种自适应。 2.7. 显示或隐藏当在更大的断点处有更多可用空间时，可以显示被较小屏幕隐藏的UI部分。 2.8. 重新定位一个界面及其组成部分可以回流或重新定位，以利用额外的屏幕空间。重新定位也是一种解决不同屏幕尺寸上不断变化的人体工程学和输入方法的方法。 3. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 4. 参考文档Material System - Component behavior","link":"/material/Component_behavior.html"},{"title":"Material Design 基础 - Elevation（标高）","text":"1. Elevation（标高）Elevation（标高）是沿 z 轴的两个Surface之间的相对距离。 2. 测量标高Material Design中的标高为Material surfaces之间的距离。从一个Material surface的前部到另一个Material surface前面的距离沿 z 轴以与dps(density-independent pixels)为单位进行测量，并使用阴影进行描绘（默认情况下）. 3. elevation系统所有Material surfaces和组件都具有标高值。 不同标高的surfaces执行以下操作： 允许surfaces在其他surfaces的前面和后面移动，例如内容在app bars后面滚动 反映空间关系，例如浮动操作按钮的阴影如何指示它与卡片集合分开 将注意力集中在最上层的surface上，例如对话框暂时出现在其他Surface的前面 可以使用阴影或其他视觉提示（如Surface填充或不透明度）来描绘标高。 注意：不同的surface填充也可以用来描绘标高而不仅仅是阴影.不同的透明度也可以用来描绘标高而不仅仅是阴影. 4. 静止标高静止标高是默认情况下为组件指定的起始标高值。组件从静止标高移动以响应用户或系统事件。所有Material组件都具有对于每种类型的组件都相同的静止标高。例如，所有卡片彼此具有相同的静止标高，并且对话框具有与其他对话框相同的静止标高。 5. 静止标高和环境静止标高因环境、平台或应用程序而异。移动设备上的静止标高旨在提供视觉提示（如阴影），以指示组件何时是交互式的。相比之下，桌面上的静止标高较浅，因为其他提示（如悬停状态）在组件交互时会进行通信。例如，桌面上 0dp 标高的卡片用描边勾勒轮廓。 6. 更改标高组件可以更改标高以响应用户输入或系统事件。发生这种情况时，组件将移动到预设的动态标高偏移，这是组件在非静止状态时移动到的默认标高。 每种类型的元件之间的动态标高偏移相同。例如，所有卡片都使用与其他卡片相同的偏移量，并且所有浮动操作按钮都使用与其他浮动操作按钮相同的偏移量。 一旦用户输入（或系统事件）完成或取消，组件就会迅速返回到其静止标高。 7. 标高干扰当元件在其静止标高和动态标高偏移之间移动时，它不应与其他元件碰撞。 为了避免这些类型的碰撞，组件可以移开。例如，如果增加卡片的高度会将其定位为通过浮动操作按钮，则该按钮可能会在碰撞发生之前消失或移出屏幕。 你还可以设计应用的布局以避免冲突，例如将浮动操作按钮放在卡片旁边，而不是直接放在卡片上方。 8. 描绘标高要成功描绘标高，surfaces必须显示： Surface边缘，使Surface与周围环境形成对比与其他Surface 重叠，无论是静止还是运动与其他Surface 的距离 8.1. Surface边缘边缘有助于表达Material surfaces的触觉质量。它们显示一个图面的结束位置，另一个surface通过将 UI 的不同部分分隔为可识别的组件来开始。例如，应用栏的边缘显示它与网格列表是分开的，从而向用户传达网格列表独立于应用栏滚动。 默认情况下，材质surfaces使用阴影来指示边缘。其他方法可用于指示边，例如： 赋予Surface不同的颜色为Surface提供不同的透明度 边必须在Surface之间产生足够的对比度（通过达到或超过可访问的对比度），以便将它们视为彼此分开。 8.2. Surface重叠当一个Surface部分或完全重叠另一个Surface时，它表示两个Surface占据不同的标高（但不是它们之间的差异程度或数量）。较高标高处的Surface显示在较低标高处的Surface的前面，这意味着它们位于沿 z 轴的不同标高处。默认情况下，Surface可能会相互重叠，或者由于运动而导致其在 UI 中的位置而重叠。 当Surface具有不同的不透明度或彼此对比度不足时，可能会很难分辨哪个Surface在另一个Surface的前面。通过确保明确定义Surface边，避免模棱两可的重叠。 阴影显示Surface边缘、Surface重叠和标高。 不同的Surface颜色显示Surface边缘和重叠，但不显示标高距离感。 “不透明度”显示Surface边和重叠，但不显示标高距离感。 8.3. 距离感Surface之间的标高差程度可以使用遮罩背景或使用阴影来表示。 遮罩当背景在 UI 中被遮罩化时，它表示其上方的内容处于较高高度。遮罩的背景表示大而未量化的高程。 阴影阴影可以以其他技术无法表示的方式表示表面之间的高程程度。 阴影的大小和柔和度或扩散量都表示两个表面之间的距离程度。例如，阴影较小且锐利的曲面表示曲面与其后面的曲面非常接近。更大、更柔和的阴影表示更多的距离。 阴影大小和扩散的细微差异传达了： 两个曲面之间的详细距离度非重叠表面之间的高程差 8.4. 运动和标高运动可以使用以下方法强调标高： 阴影变化阴影大小和柔和度的变化强调了高程的变化。 显示重叠一个曲面可能会在动画时部分或完全重叠，以显示哪个曲面在另一个曲面的前面。 推动共享相同高程的表面可以在其路径中移动表面。 缩放向上或向下缩放表面的大小可以强调高程变化。 视差不同高程处以不同速度移动的多个表面可以创建深度感，并将焦点放在前景内容上。 组合动作技巧组合动作技巧可以通过结合动作技巧来强调标高。 9. 标高层次内容与其他内容的关系取决于它们位于相似还是不同的海拔高度。 9.1. 不同标高层次的内容位于上层的标高通常意味着: 包含更重要的内容 集中注意力，例如对话 控制其后面的表面，例如应用程序栏中的操作 9.2. 共面曲面上的内容将曲面放置在同一标高处会使它们共面，并可能表明它们包含彼此同等重要的内容。例如，一个集合中的所有卡片都具有同等的重要性。 不表达标高的曲面可以显示为共面。对于不表示标高的曲面，可以通过其内容以及通过调整其水平和垂直布局位置以建议其相对层次来传达层次差异。 10. 默认标高所有元素都具有静止标高和动态标高偏移的默认值。某些构件的标高高于其他构件，从而在所有组件之间建立了一致的标高顺序。例如，对话框总是出现在所有其他组件的前面。 下表列出了静止标高和动态标高偏移的默认值。 默认标高值表 组件 默认标高值(dp) Dialog 24 Modal bottom sheet Modal side sheet 16 Navigation drawer 16 Floating action button (FAB - pressed) 12 Standard bottom sheet Standard side sheet 8 Bottom navigation bar 8 Bottom app bar 8 Menus and sub menus 8 Card (when picked up) 8 Contained button (pressed state) 8 Floating action button (FAB - resting elevation) Snackbar 6 Top app bar (scrolled state) 4 Top app bar (resting elevation) 0 or 4 Refresh indicator Search bar (scrolled state) 3 Contained button (resting elevation) 2 Search bar (resting elevation) 1 Card (resting elevation) 1 Switch 1 Text button 0 Standard side sheet 0 Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 11. 参考文档Material System - Environment Elevation","link":"/material/Elevation.html"},{"title":"Material Design基础 - 响应式布局网格","text":"1. 响应式布局网格Material Design的响应式布局网格可根据屏幕大小和方向进行调整，确保布局的一致性。 1.1. Columns, gutters, and margins响应式布局网格由三个元素组成：Columns, gutters, 和 margins。 1.2. Columns内容放置在屏幕上包含列的区域。 在响应式布局中，列宽是用百分比定义的，而不是固定值。这允许内容适应任何屏幕大小。网格中显示的列数由 分界点范围决定， 分界点范围是一个预先确定的屏幕大小范围。 分界点可以与手机、平板电脑或其他屏幕类型相对应。 1.3. guttersgutters是帮助分隔内容的列之间的空间。gutters宽度是根据 分界点范围的变化的固定值。为了更好地适应给定的屏幕大小，gutters宽度可以在不同的屏幕宽度范围改变。较宽的gutter更适合更大的屏幕，因为它们在column之间创造了更多的开放空间。 1.4. MarginsMargins是内容与屏幕左右边缘之间的空间。在每个 分界点范围使用固定值或缩放值定义边距宽度。为了更好地适应屏幕，边距宽度可以在不同的 分界点处改变。更宽的边距更适合更大的屏幕，因为它们会在内容周围产生更多的空白。 1.5. Grid customization布局网格可以调整，以满足产品和多种设备尺寸的需要。 1.6. Customizing gutters可以调整gutters，以在布局的column之间创建更多或更少的空间。 1.7. Horizontal grids可以为水平滚动的触摸屏用户界面定制材质设计布局网格。柱、水槽和边距是从左到右而不是从上到下布置的。屏幕的高度决定了水平网格中的列数。在非触摸和web平台上，水平滚动的UI并不常见。 水平网格的位置可以适应不同的高度，在顶部为应用程序栏或其他UI区域留出空间。 1.8. 分界点 分界点是由特定布局要求确定的屏幕大小阈值。在给定的分界点范围内，布局会根据屏幕大小和方向进行调整。material设计提供了基于4列、8列和12列网格的响应性布局，可用于不同的屏幕、设备和方向。每个分界点范围确定列数，以及每个显示大小的建议边距和gutters。 1.9. 分界点系统响应式布局网格主要用于组织布局Body区域中的内容和组件。Understanding layout中详细介绍了布局区域。根据不同的屏幕大小或方向缩放布局时，响应网格会调整边距和主体宽度以及布局中的列数。 Screen size Margin Body Layout columns Extra-small (phone) 0-599dp 16dp Scaling 4 Small (tablet) 600-904 32dp Scaling 8 905-1239 Scaling 840dp 12 Medium (laptop) 1240-1439 200dp Scaling 12 Large (desktop) 1440+ Scaling 1040 12 在Extra-small breakpoint中，边距的基线值为16dp。身体对尺寸的增加仍有反应。当到达下一个更大的断点（600dp宽）时，glutter增加到32dp。当机身宽度达到840dp时，边缘变得灵活，最大边缘宽度增加到200dp。达到最大宽度后，body区域再次变得灵敏，继续水平缩放。在较大的断点处，body区域可以保持最大宽度，而边距可以再次水平缩放。 2. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 3. 参考文档Material System - responsive layout grid","link":"/material/Responsive_layout_grid.html"},{"title":"Material Design基础 - spacing methods","text":"1. spacing methodsspacing methods使用基线网格、关键线、填充和增量间距来调整比率、容器和触摸目标。 1.1. 基准网格1.1.1. 8dp网格所有组件都与移动设备、平板电脑和台式机的8dp方形基线网格对齐。 1.1.2. 4dp网格组件中的图标、type和某些元素可以与4dp网格对齐。 1.2. 间距方法间距方法比响应式布局网格更精细。间距方法是一组关于如何在layout和组件中放置元素的规则。 1.2.1. paddingpadding是组件和元素之间的空间.padding指的是UI元素之间的空间。padding是关键线的另一种间距方法，以8dp或4dp为增量进行测量。padding可以垂直和水平测量，不需要跨越布局的整个高度。 1.2.2. DimensionsDimensions描述了构件的宽度和高度。Dimensions是指构件的宽度和高度。某些组件（如应用程序栏或列表）仅列出元素的高度。这些元件的高度应与8dp网格对齐。它们的宽度没有指定，因为它响应于视口宽度。 1.2.3. AlignmentAlignment在组件中放置元素。 1.2.4. 关键线关键线是一种对齐工具，可以在布局网格之外一致地放置元素。它们是垂直线，显示元素不与网格对齐时放置的位置。关键线由每个元素与屏幕边缘的距离决定，并以8dp的增量测量。关键线可以在布局中的元素之间创建更多或更少的空间。它们可以根据断点范围进行调整。 1.3. Containers and ratios1.3.1. Containers容器是用来表示封闭区域的形状。容器可以保存图像、图标或曲面等UI元素。容器可以是刚性的，并限制其中元素的大小或裁剪。或者，它们可以是灵活的，并且可以扩展以支持它们所持有的内容的大小。 1.3.2. Aspect ratios纵横比是元素宽度与高度的比例。纵横比写为宽度：高度。要保持布局的一致性，请在图像、曲面和屏幕大小等元素上使用一致的纵横比。建议在整个UI中使用以下纵横比：16:9；3:2; 4:3; 1:1; 3:4; 2:3 1.3.3. Flexible ratios灵活的比例大小由布局网格决定：容器宽度由屏幕布局决定，并会增大以填充最大可用空间容器高度由容器中图像的高度决定使用灵活的比例，让内容形式决定容器的高度。 1.3.4. Responsive cropping要相应地显示图像，请定义如何在不同的断点范围内裁剪图像。在不同的断点范围内，裁剪可以：保持一个固定的比率适应不同的比率固定图像高度 保持一个比率 - 图像大小可以在分界点范围内保持一个固定比率。适应不同的比率 - 图像比率也可以通过适应不同的断点范围而改变。固定图像高度 - 图像大小可以在断点范围内保持固定的高度和流体宽度。 1.3.5. 触碰目标触摸目标适用于接收触摸和非触摸输入的任何设备。为了平衡信息密度和可用性，触摸目标应至少为48 x 48 dp，目标之间的空间至少为8 dp。 2. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 3. 参考文档Material System - layout spacing method","link":"/material/Spacing_methods.html"},{"title":"Material Design 基础 - Applying density","text":"1. 前言Material设计为提高密度改善用户体验的用例提供高密度间距指导。 2. 用法这些指南描述了如何以及何时应用密度。 2.1. 原则2.1.1. 可扫描密集的UI提高了查看和浏览大量内容的便利性。 2.1.2. 优先考虑密集的UI通过减少操作之间的空间来帮助用户集中精力。 2.1.3. 可见的增加密度可以在单个屏幕上容纳更多内容和动作。 2.2. 组件密度指南2.2.1. 怎样使用组件密度Material密度指南是了解何时以及为什么应用密度可以改善用户体验的资源。在代码的支持下，Material组件密度可以在刻度上进行一致调整。组件密度中解释了使用密度标度的指导，平台支持可在组件密度实施指南中找到。 2.2.2. 何时使用组件密度用户与组件的交互方式应决定是否增加UI中的密度。当用户查看和交互大量信息时，高密度组件可以改善体验。通过在屏幕上提供更多内容，增加列表、表格和长表单的密度，使信息更易于扫描、查看和比较。 2.2.3. 何时不应该使用组件密度任务和基于警报的组件不应增加密度。 2.2.3.1. 重点任务不要增加涉及重点任务的组件的密度，例如与下拉菜单或选择器交互。增加日期选择器等组件的密度会限制可点击空间，从而降低可用性。 2.2.3.2. 警报和消息不要增加Alert或消息组件的密度，例如snackbar或对话框。增加警报的密度会降低它们吸引用户注意力的效率。在对话框的例子中，当密度增加时，消息的可读性和突出性会受到影响。 2.3. 布局2.3.1. 网格和组件密度保持组件密度和网格布局之间的平衡。要创建可扫描的内容组，请结合使用密度较低的网格布局和高密度组件。组件的密度越大，边距和边沟宽度就应该越大。将密集的布局网格与密集的组件相结合，可以让用户更难区分内容组。 2.3.2. 将密度应用于组件不应单独调整组件密度。相反，要始终如一地应用密度，以创建一个内聚组件集。当你调整一个组件的密度时，考虑一下这一变化将如何影响应用程序中的其他组件。下面的工具演示了材质组件随三种密度设置（默认、舒适和紧凑）的变化。 2.3.3. 密度标尺密度比例允许您在需要时控制单个组件的密度。“密度比例”已编号，从组件的默认密度0开始。随着空间的减少，比例会移到负数（-1，-2，-3），从而产生更高的密度。每个增量表示组件高度减少4dps。 不要从“密度比例”中选择破坏组件的数字。 2.3.4. 间距法当组件的密度增加时，填充和对齐保持一致，但尺寸会发生变化。增加时不要更改组件的填充. padding增加密度时，不要改变组件的填充。组件填充会影响高度，减少填充会对用户交互产生负面影响。 Dimensions增加零部件密度时更改尺寸。构件尺寸会影响构件或图元的长度和高度。 Alignment 使用中心规格来对齐零部件容器中的图元。中心对齐元件允许在不需要额外对齐元件的情况下调整元件高度 2.3.5. 分隔多个元素当多个元素在一个组件内垂直堆叠时，使用4dp增量将它们分开。将已分组的元素置于组件容器的中心。 2.3.6. 可达性触摸目标适用于接收触摸和非触摸输入的任何设备。为了平衡信息密度和可用性，默认密度组件的触摸目标应至少为48 x 48 dp，每个目标之间至少有8 dp的空间。注意：在iOS上，44 x 44 dp是建议的触摸目标。 2.4. 排版2.4.1. 线条高度行高是文本行之间的间距。线条高度可以作为在排版布局中创建密度的一种方式。 3. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design","link":"/material/applying_density.html"},{"title":"更好的大屏幕设计","text":"Material You 如何支持美观、高效的平板电脑和可折叠体验? 近年来，我们看到了更大屏幕的增长趋势。这在一定程度上是由于平板电脑、大型智能手机和台式机的日益普及。 在今年的 Google I/O 大会上，Material Design正在深入研究针对设计师和开发人员的大屏幕设计的最新指南。请关注我们的演讲并继续阅读，了解 Material如何帮助您应对针对多种设备进行设计的挑战和机遇，以满足应用程序用户不断增长的需求。 1. 设计基础：窗户尺寸类别大屏幕设计的最大挑战之一是创建既具有视觉吸引力又用户友好的布局，而无需针对每种外形尺寸完全重新设计应用程序。因此，我们没有针对不断增加的屏幕尺寸进行设计，而是创建了窗口大小类来确保布局在各种设备上无缝适配。 窗口尺寸分为三种：紧凑型(compact width &lt; 600dp)、中型(medium 600dp&lt;= width &lt; 840dp)和扩展型 (expended width &gt;= 840dp) 对于更复杂的布局场景，您还可以考虑合并宽度和高度类。但是，对于大多数应用程序，尤其是那些具有垂直滚动 UI 的应用程序，三个窗口宽度大小类别可以满足您的需求。要了解更多信息，请参阅Android 的窗口类大小文档。 2. 布局解析典型的应用程序布局由两部分组成：导航和正文。 紧凑型设备使用导航栏，中型设备可以使用导航栏，扩展设备可以利用导航抽屉 当需要平衡您的设计与人体工程学等用户需求时，为您的屏幕选择最佳的导航组件是重要的一步。 窗格(Panes)最适合组织应用程序主体的需要。窗格有助于组织内容并为组件创建清晰的包含结构。它们可以是固定的，也可以是灵活的；它们可以容纳持久性组件，例如顶部应用程序栏或搜索栏，以及特定于上下文的元素，例如图像、文本、列表、卡片和按钮。 窗格中的内容可以对齐并显示在多列中。列是窗格独有的，不在窗口级别使用，从而允许对窗格内的布局进行更精细的控制。详细了解 Material Design 如何定义布局的各个部分. 3. 硬件新硬件总是令人兴奋，但也带来了处理新的、特殊用例的挑战。Material的更新指南着眼于您的设计如何适应一系列硬件规格，同时减少自定义和调整布局的工作。 一个看似棘手的硬件因素的例子出现在带有中心铰链的折叠设备上，该铰链将屏幕分为两半。对于某些折叠设备，该区域没有显示屏幕，因此屏幕将作为两个不同的窗格运行。打开可折叠设备时，应用程序应在几秒钟内自动从前屏幕转换到展开屏幕。 显示屏切口（例如前置摄像头）也是需要考虑的约束示例，因为这可能会阻碍某些屏幕设计。在这些场景中，它有助于偏移主体区域，以确保 UI 的任何部分都不会被遮挡。 4. 展望大屏幕Material的未来Material Design未来如何规划大屏设计和开发，是Material You视觉语言的延续。我们的目标是继续发布基于 M3 精神的充满活力的自适应元素，以实现大屏幕体验。 请继续关注I/O 2023，了解 Material Design 的一些正在进行的工作想法！ 5. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design","link":"/material/better_design_for_big_screen.html"},{"title":"Material Design简介","text":"1. 介绍Material 是 Google 创建的一个设计系统，旨在帮助团队为 Android、iOS、Flutter 和 Web 构建高质量的数字体验。 2. 原则2.1. 材料是隐喻Material design 的灵感来自物理世界及其纹理，包括它们如何反射光线和投射阴影。Material surfaces 重新构想了纸张和墨水的介质。 Bold, graphic, intentional材质设计由印刷设计方法（排版、网格、空间、比例、颜色和图像）指导，以创建让观看者沉浸在体验中的层次结构、意义和焦点。 Motion provides meaningMotion 通过微妙的反馈和连贯的过渡来集中注意力并保持连续性。当元素出现在屏幕上时，它们会通过交互来转换和重新组织环境，从而生成新的转换。 3. 组件Material 组件是用于创建用户界面的交互式构建基块，并包括一个内置状态系统，用于传达聚焦、选择、激活、错误、悬停、按下、拖动和禁用状态。组件库可用于 Android、iOS、Flutter 和 Web。组件可满足一系列接口需求，包括： 显示：使用卡片、列表和工作表等组件放置和组织内容。 导航：允许用户使用导航抽屉和选项卡等组件在产品中移动。 操作：允许用户使用浮动操作按钮等组件执行任务。 输入：允许用户使用文本字段、chips和选择控件等组件输入信息或进行选择。 通信：使用snackbars、横幅和对话框等组件提醒用户注意关键信息和消息。 3.1. 组件参考资料 组件指南涵盖用法、行为和规范的组件指南 适用于 Android、iOS、Web 和 Flutter 的开发人员文档和代码 参考资料页面上有 Figma 格式的可下载设计文件 4. 主题Material 主题可让您轻松自定义 Material 设计以匹配品牌的外观和感觉，并具有用于自定义颜色、版式样式和拐角形状的内置支持和指导。可以轻松修改按钮等 Material 组件的颜色、排版和形状，以匹配您的品牌。 4.1. 主题参考资料Material 主题指南使用 Material 主题的 app 样例 5. 颜色Material 的颜色系统 是将颜色应用于 UI 的有组织的方法。全局颜色样式具有语义名称和组件中定义的用法 - 主要、次要（品牌颜色）、表面、背景和错误。 每种颜色还具有互补色，用于放置在其“之上”的元素，以促进一致性和可访问的对比度。 6. 排版Material 设计type scale 提供了 13 种版式样式涵盖从标题到正文文本和题注的所有内容 。每种样式在界面中都有明确的含义和预期应用。 可以修改重要属性（如字体、字体粗细和字母大小写）以匹配您的品牌和设计。 7. 形状应用形状样式有助于引导注意力或识别组件、传达其状态以及表达您的品牌。 所有材料组件都根据其大小（小、中、大）分组到形状类别中。这些全局样式提供了一种快速更改类似大小的组件的形状的方法。 您可以使用形状自定义工具 生成自己的形状样式。 8. 相关阅读 Material Design 3 介绍 Material 3 基础 更好的大屏幕设计 Material Design 基础 - Surfaces Material Design 基础 - Elevation（标高） Material Design 基础 - 光线和阴影 Material Design 基础 - 颜色 Material Design 基础 - spacing methods Material Design 基础 - Applying density Material Design 基础 - 响应式布局网格 Material Design 基础 - Pixel Density Material Design 基础 - Component behavior Material Design 基础 - 导航 Material Design 基础 - Layout Material Design 基础 - 文字排版 Angular Material 实现 typeahead 简单示例 9. 参考文档Material System material-dashboard-pro-angular2","link":"/material/introduction.html"},{"title":"Material Design 基础 - Layout","text":"1. 理解layoutmaterial设计布局使用统一的元素和间距，以鼓励在多种平台、环境和屏幕尺寸之间的一致性。 1.1. 原则 Predictable(可预测的) 使用直观且可预测的布局，并具有一致的UI区域和空间组织。 Consistent(一致的) 布局应始终使用网格、关键线和填充。 Responsive(响应的) 布局是自适应的。它们对用户、设备和屏幕元素的输入做出反应。 1.2. 布局解剖学布局区域是互动体验的基础。它们是布局的构建块，由共享类似功能的元素和组件组成。布局区域还可以对较小的容器（如卡片）进行分组。 大屏幕布局有三个主要区域： App bars Navigation Body 在创建响应性布局系统时，为主体和边距建立最小和最大尺寸，以及允许每个区域适应不同形状因素的缩放行为是很有帮助的。以下指南描述了材料的基线尺寸和行为。 1.2.1. Body区域Body区域用于显示应用程序中的大部分内容。它通常包含列表、卡片、按钮和图像等组件。 Body区域对三个参数使用缩放值： 垂直和水平尺寸 列数 边距 在非常小的断点处，边距的值为16dp。随着版面尺寸的增加，主体部分相对于屏幕宽度展开。当到达第一个断点（小；600dp宽）时，裕度增加到32dp。 当机身宽度达到840dp时，边距增加到最大宽度200dp。达到最大宽度后，身体部位再次变得灵敏，继续水平缩放。 1.2.2. 响应式布局栅格响应栅格由column、槽和边距组成，为Body区域内的元素布局提供了方便的结构。组件、图像和文本与柱网对齐，以确保屏幕大小和方向的布局符合逻辑且一致。 随着Body区域大小的增大或减小，轴网柱的数量也会随之变化。 设备断点的建议网格行为 Screen size Margin Body Layout columns Extra-small (phone) 0-599dp 16dp Fluid 4 Small (tablet) 600-904 32dp Fluid 8 905-1239 Fluid 840dp 12 Medium (laptop) 1240-1439 200dp Fluid 12 Large (desktop) 1440+ Fluid 1040 12 更多关于响应式布局栅格介绍, 请点击这里. 1.2.3. 导航区域导航区域包含导航组件和元素，例如导航抽屉或导航滑轨。它帮助用户在应用程序中的目的地之间导航，或访问重要操作。 1.2.4. App bar1.2.4.1. Visual grouping在布局中创建顺序的第一步是视觉分组。布局中具有类似内容或功能的元素可以组合在一起，并使用开放空间、排版和分隔符与其他元素分离。 1.2.4.2. Containment在视觉分组之后，下一个要考虑的组是通过共享上下文关联的任何元素，例如图像及其标题或支持信息。这些上下文相关的元素可以使用包容的概念进行分组。Containment是通过在视觉分组之间建立边界来实现的。方法1：隐式包容意味着通过将相关元素拉近来减少它们周围的开放空间。同时，这个分组之外的空间被增加，以创建一个清晰的概念边界。方法2：或者，可以通过向一组相关图元添加轮廓或标高来创建显式包含。例如，从图像及其标题或支持文本创建一张卡片，使这两个元素通过卡片的提升边界更容易定义为一个组。 在组成包含文本的元素或组件时，请确保每个容器使用响应性尺寸标注，以便文本可以轻松缩放并保持可读性。 1.2.4.3. 文本缩放Material Design建议文本的理想行长为40-60个字符，以便在缩放包含文本的元素时保持可读性。文本的理想行长为40-60个字符。这在缩放包含文本的元素（如卡片）时保持了可读性。当元素包含文本时，页边距和排版属性应该响应，以确保文本行在水平布局中不会过长。如果需要更长的行长，可以考虑调整行高以提高可读性。 1.2.4.4. 锚定和约束缩放组件或布局容器时，请考虑它们的位置和对齐方式应如何缩放。随着父容器的缩放，内部元素可以定位到左侧、右侧或中心。内部元件也可以保持固定位置，例如在浮动操作按钮或导航抽屉。部件的内部组成应符合其所在设备的人体工程学需求。例如，移动设备上的 horizontally-oriented card可以适应更大屏幕上的方形卡。这种变化使图像更加突出，并允许更大的字体样式来提高可读性。对于图标按钮，按钮内的图标和文本标签可以保持相互固定，在水平缩放时保持在按钮内的中心位置。 1.2.4.5. Material measurements为了确保材料设计布局在视觉上保持平衡，大多数测量与8dp对齐，8dp对应于间距和总体布局。组件的大小以8dp为增量，确保每个屏幕的视觉一致。较小的元素（如图标）可以与4dp网格对齐，而排版可以落在4dp基线网格上，这意味着每一行的排版基线与其相邻行之间的间隔为4dp。 2. 资源Figma上的材料设计工具包中有使用上述断点、柱网和边距模板的指南。可以从Material Design社区页面下载。 3. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 4. 参考文档understanding material layout","link":"/material/layout.html"},{"title":"Material Design基础 - 光线和阴影","text":"1. 光线和阴影material surface阻挡光源时会投射阴影。 在material设计环境中，虚拟灯光照亮UI。关键灯光创建更清晰的方向性阴影，称为关键光阴影。环境光从各个角度出现，以创建漫射的柔和阴影，称为环境光阴影。 2. 光源material环境中的阴影由关键灯光和环境光投射。在Android和iOS开发中，当光源被z轴上不同位置的材质表面阻挡时，会出现阴影。在web上，仅通过操纵y轴来描绘阴影。 3. 阴影阴影提供有关深度、移动方向和surface边缘的提示。surface的阴影由其标高和与其他surface的关系决定。 3.1. 用法因为阴影表示曲面之间的高度，所以必须在整个产品中始终使用阴影。 阴影大小反映标高高度。较高标高的曲面有较大的阴影，而较低标高的曲面有较小的阴影。 3.2. Shadows &amp; Motion阴影为曲面的移动方向以及曲面之间的距离是增大还是减小提供了有用的提示。当曲面改变形状或比例，但其标高保持不变时，其阴影不应改变。当曲面更改其标高时，其阴影应该更改。 4. 研究Material Design对15名低视力参与者进行了36次采访，以更好地了解阴影和轮廓如何影响个体识别和与组件互动的能力。 研究结果包括： 阴影和轮廓只是影响用户识别能力的元素的许多属性之一。影响元素识别能力的其他属性包括字体特征、标高、颜色、周围元素之间的布局以及使用上下文。 使用阴影和轮廓可以提高扫描页面时查找组件的难度和速度。 在组件周围使用阴影或笔划轮廓可以提高确定是否可以与组件交互的能力。 5. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 6. 参考文档Material System - layout Light and shadows","link":"/material/light_shadow.html"},{"title":"Material Design 3介绍","text":"1. 什么是Material Design？Material Design 是由 Google 设计师和开发人员构建和支持的设计系统。Material.io包含针对 Android、Flutter 和 Web 的深入 UX 指南和 UI 组件实现。 Material于2014年推出，多年来不断发展。材料设计1（M1）：第一代Material Design于2014年推出，存档并可访问：https://Material.io/archive/guidelines。材料设计2（M2）：2018年推出的第二代材料设计引入了Material主题和Material组件。Material Design 3（M3）：2021年推出的第三代Material包括Material You功能，支持个性化、自适应和富有表现力的体验 - 从动态颜色和增强的无障碍功能，到大屏幕布局和设计Tokens的基础。Material You：新的Material视觉风格和一系列功能，满足个人用户的个人和表达需求，是Material Design 3的一部分 最新版本 Material 3 支持个性化、响应式和富有表现力的体验 - 从动态颜色和增强的可访问性，到大屏幕布局和Design tokens的基础。 UX 基础 颜色、类型和形状等基础是 Material 中的可定制系统 开源代码 多平台代码可以更快地构建漂亮的产品 教程、案例研究和新闻 关注 Material 的博客以获取更新、深入探讨等信息 2. 使用Material Design在 Material.io 上，设计系统由三个主要部分组成：基础、样式和组件。每个部分都包含设计指南和工具可帮助您定制Material Design以及使用Material Design构建应用。 基础和定制 无障碍、布局、交互状态、设计令牌等 样式 应用颜色、类型、图标、动效和形状的系统 组件 可定制的 UI 元素，从菜单到按钮再到对话框 3. 设计设计指南、规格和工具，以简化从 Figma 到成品的工作。 样式和定制 自适应布局 Figma 设计套件 4. 开发最新的Material组件、教程、案例研究和文档。 Android Flutter Web 5. Material Design 系列文章Material 3 基础 最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 6. 参考文档material 3 get started","link":"/material/material3_introduction.html"},{"title":"Material Design 基础 - 颜色","text":"1. 颜色系统Material设计颜色系统可以帮助您创建反映您的品牌或风格的颜色主题。 1.1. 颜色用法和调色板Material设计颜色系统可帮助您以有意义的方式将颜色应用于 UI。在此系统中，您可以选择主要颜色和次要颜色来代表您的品牌。然后，每种颜色的深色和浅色变体可以以不同的方式应用于 UI。 1.2. 颜色和主题颜色主题设计为和谐，确保文本可访问，并将 UI 元素和surfaces彼此区分开来。 “质感设计”调色板工具或 2014 材质设计调色板可用于帮助您选择颜色。 1.2.1. 原则 层次颜色指示哪些元素是交互式的，它们与其他元素的关系以及它们的突出程度。重要元素应该最突出。 清晰文本和重要元素（如图标）在彩色背景上显示时应符合易读性标准。 表达性在令人难忘的时刻展示品牌色彩，强化您的品牌风格。 1.3. 基线材质颜色主题Material设计采用内置的基线主题设计，可以按原样使用，直接开箱即用。 这包括以下各项的默认颜色： 原色和次色原色和次色的变体其他 UI 颜色，例如背景、曲面、错误、版式和图标的颜色。所有这些颜色都可以针对你的应用进行自定义。 1.3.1. 原色原色是在应用的屏幕和组件中最常显示的颜色。您的原色可用于制作颜色… 原色是在应用的屏幕和组件中最常显示的颜色。 深色和浅色主要变体你的原色可用于为应用制作颜色主题，包括深色和浅色原色变体。 区分 UI 元素若要在 UI 元素（如系统栏的顶部应用栏）之间创建对比度，可以使用原色的浅色或深色变体。还可以使用它们来区分组件中的元素，例如浮动操作按钮的图标与其圆形容器。 1.3.2. 辅助颜色辅助颜色提供了更多方法来强调和区分您的产品。具有辅助颜色是可选的，应谨慎应用于 UI 的选择部分。 如果您没有辅助颜色，则原色也可用于强调元素。 辅助颜色最适合： 浮动操作按钮选择控件，如滑块和开关突出显示所选文本进度条链接和标题深色和浅色次要变体就像原色一样，辅助颜色可以有深色和浅色变体。颜色主题可以使用每种颜色的原色、辅助颜色以及深色和浅色变体。 1.3.3. Surface, background, and error colors表面、背景和错误颜色通常不代表品牌： 表面颜色会影响组件（如卡片、图纸和菜单）的表面。背景色显示在可滚动内容的后面。基线背景和表面颜色#FFFFFF。错误颜色表示组件中的错误，例如文本字段中的文本无效。基线误差颜色#B00020。 1.3.4. Typography and iconography colors“on” color应用图面使用调色板中特定类别的颜色，例如原色。每当元素（如文本或图标）出现在这些曲面的前面时，这些元素应使用设计为清晰易读的颜色来对抗它们后面的颜色。 此类别的颜色称为“on” color，指的是它们对出现在使用以下颜色的曲面之上的元素进行着色：原色、辅助颜色、表面颜色、背景色或错误颜色。当一种颜色出现在原色的“上”之上时，它被称为“on” top of a primary color。它们使用前缀为“on”的原始颜色类别（如原色）进行标记。 “on” color主要应用于文本、图像和描边。有时，它们被应用于表面。 “on” color的默认值为 #FFFFFF 和 #000000。 1.3.5. 可访问的颜色为确保浅色或深色文本后面的背景可访问，背景可以使用主色和辅助颜色的浅色或深色变体。 或者，这些颜色可用于显示在浅色和深色背景前面的排版。 1.3.6. 色样(color swatch)色样是从一系列相似颜色中选择的颜色的样本。 复选框指示文本颜色在背景前面是否清晰可辨： 白色复选标记指示白色文本在背景颜色上清晰可见的时间 黑色复选标记表示黑色文本在背景颜色上清晰可见的时间 使用白色文本的应用必须具有可针对白色文本访问的背景。这些白色复选标记指示何时可以在各种背景色色板上访问白色文本。 使用黑色文本的应用必须具有可针对黑色访问的背景。这些黑色复选标记指示何时可以使用各种背景色色板访问黑色文本。 1.3.7. 替代颜色Material设计颜色系统支持替代颜色，这些颜色用作品牌原色和次色的替代颜色（它们构成主题的附加颜色）。替代颜色可用于区分 UI 的不同部分。 替代颜色最适合： 具有浅色和深色主题的应用在不同版块中具有不同主题的应用属于一套产品的应用应谨慎使用替代颜色，因为它们可能难以与现有颜色主题一起实现。 1.3.8. 浅色和深色主题某些应用同时具有浅色和深色主题。为了保持元素的可见性和文本的易读性，您可以为深色和浅色主题调整不同的配色方案。 1.3.9. 主题的替代颜色替代颜色可用于主题应用的不同部分。 1.3.10. 用于数据可视化的其他颜色应用可以使用其他颜色来传达主颜色主题之外的类别。它们仍然是您完整调色板的一部分。 1.3.11. 用于拾取颜色的工具材质调色板生成器可用于为您输入的任何颜色生成调色板。色调、色度和亮度通过一种算法进行调整，该算法可创建可用且美观的调色板。 输入颜色可以根据主输入颜色生成调色板，以及所需调色板相对于原色应是相似、互补还是三元。 或者，该工具可以基于任何原色和辅助颜色生成展开的调色板。 用于辅助功能的颜色变化这些调色板提供了使用主色和次色的其他方法。它们包括较亮和较暗的选项，用于分隔表面，并提供符合辅助功能标准的颜色。 1.3.12. 2014 Material Design调色板这些调色板最初由Material Design于2014年创建，由设计为和谐地协同工作的颜色组成，可用于开发您的品牌调色板。要生成您自己的和谐调色板，请使用调色板生成工具。 2. 将颜色应用于 UI颜色以一致且有意义的方式应用于 UI 元素和组件。以下指南描述了颜色应用非常重要的各种UI组件和元素。 2.1. 应用颜色的原则 一致的颜色应该在整个用户界面中一致应用，并与它所代表的品牌兼容。 不同的颜色应该在元素之间产生区别，并在元素之间形成足够的对比度。 意图明确的颜色应该有目的地使用，因为它可以以多种方式传达意义，例如元素之间的关系和等级。 2.1.1. 顶部和底部应用栏颜色应用于顶部和底部应用栏的方式可帮助用户识别它们并了解它们与周围元素的关系。 2.1.2. 标识应用栏顶部和底部应用栏使用应用的原色。系统栏可以使用原色的深色或浅色变体将系统内容与顶部应用栏内容分开。 应用栏上使用原色，系统栏上使用深色原色。若要强调应用栏与其他图面之间的差异，请在附近的组件（如浮动操作按钮 （FAB））上使用辅助颜色。 当应用程序的顶部或底部应用程序栏颜色与背景颜色相同时，它们会混合在一起，强调应用程序的内容而不是其结构。 2.1.3. 背景背景有正面和背面。要区分这两个图层，基线后层颜色是原色，基线前层是白色。 2.1.4. 表单和表面工作表和曲面（如底部工作表、导航抽屉、菜单、对话框和卡片）的基线颜色为白色。这些组件可以合并颜色以在其他表面之间创建对比度。对比度可以使表面边缘变得明显，从而指示表面重叠时的标高差异。 2.1.5. Modal sheets在临时显示在屏幕上的曲面（如导航抽屉和底页）上使用对比色。通常，这些表面是白色的，但你可以使用应用的主要或次要颜色。 2.1.6. Cards卡片的基线颜色为白色。这种颜色可以定制以表达品牌或提高易读性。卡片文本和图标也可以使用颜色主题来提高易读性。 3. 颜色用法4. 颜色层次在“Material中，颜色将注意力吸引到屏幕上的特定元素上。当元素的颜色与其周围环境形成对比时，该元素会脱颖而出，因此用户可以判断它很重要。由于颜色主题各不相同 - 从粗体和明亮，到单色或柔和 - 有不同的方法来指示哪些元素更重要。 例如，当黑色图标放置在白色背景上时，它们会脱颖而出。当多色卡片放置在单色旁边时，会引起人们对自身的注意。 4.1. 表面对比度要引起对重要事件的注意，请在元素之间使用更强的颜色对比度。 4.2. 颜色和形状视觉重点放在同时改变颜色和形状的元素上。使用这种强调来表示已选择或需要立即注意的内容。 4.3. 限制颜色通过限制在应用中使用颜色，接收颜色的区域（如文本、图像和按钮等单个元素）将获得更多关注。 由于本产品的内容是多色的，黑色浮动动作按钮与鲜艳的色彩形成鲜明对比，使其更加明显。 灰度调色板最适合让摄影和文本脱颖而出。 5. 品牌您的品牌可以使用颜色来强调其存在感。品牌颜色可以在关键时刻使用，以将这些颜色与特定操作和信息相关联的方式使用。 品牌色彩应用可以是大胆而傲慢的，微妙而精致的，或者介于两者之间的任何地方。你的品牌对颜色的个人方法应反映在你的应用中。 5.1. 大胆使用颜色希望传达能量和兴奋感的品牌通常以大胆的方式使用颜色。他们的应用程序应反映相同的方法，同时保持内容的易读性和整体可用性。 即使是具有更微妙的色彩方法的品牌也可以大胆的使用色彩。 5.2. onboarding载入期间使用的颜色可以将内容与品牌联系起来。 5.3. 功能发现新功能可以突出显示，以确保用户通过使用颜色来引导用户关注来看到它们。 6. 颜色的微妙使用品牌可以以微妙的方式使用颜色，无论这意味着传达复杂性，强调内容还是以其他方式适合内容。使用具有微妙色彩的颜色时，请确保交互式区域和状态更改保持可识别且易于查看。 6.1. 占位符 UI加载屏幕内容时将显示占位符 UI。在此处包含品牌颜色可向用户保证，在加载应用时，他们仍在应用中。 6.2. 进度指标进度指示器是一个微妙但强大的地方，可以整合品牌颜色，因为它们将应用程序的功能与品牌联系起来。 6.3. 状态更改状态的变化可以巧妙地加强品牌的存在。 7. 意义颜色可以传达不同UI元素的含义。例如，天气应用可能显示指示当前天气状况的颜色，导航应用可能显示显示交通状况的颜色，道路颜色为红色或绿色 7.1. 一致性和上下文颜色应在产品中一致使用，以便某些颜色始终意味着同样的事情，即使上下文发生变化。还应注意具有当地或文化意义的颜色。例如，警报在某些区域性中通常显示为红色，但在其他区域性中则不然。 7.2. 状态颜色可以提供有关应用、其组件和元素的状态的信息。这包括： 元素或组件的当前状态，例如按钮是启用还是禁用对应用程序、组件或元素的状态更改在指示状态变化时，颜色应该很明显，因为可能会错过颜色的细微差异。最好以多种方式指示状态更改，例如显示图标或移动元素的位置。 7.3. 标识交互若要强调特定交互，请相对于用户未交互的内容，对用户与之交互的内容使用强烈的颜色对比。 7.4. 指示选择要强调所选元素，请在这些元素上使用强烈的颜色对比度。此列表中的电子邮件使用品牌颜色来指示所选的电子邮件,… 8. 文本易读性颜色在文本易读性中起着重要作用。 8.1. WCAG 标准所有文本都应清晰易读，并符合无障碍标准 The Web Content Accessibility Guidelines （WCAG 2.0） 级别 AA 要求普通文本的文本和背景之间的颜色对比度为 4.5：1，大文本的颜色对比度为 3：1。 若要了解有关颜色、对比度和辅助功能设计的详细信息，请阅读Material Design Accessibility。 8.2. 文本背景8.2.1. 彩色背景上的文本建议在浅色背景上使用黑色文本，在深色背景上使用白色文本。如果你的应用同时具有浅色和深色主题，请确保文本以与每个主题形成对比色。 彩色背景或版式还会更改有关文本不透明度和不同文本状态的规则。 8.2.2. 使用文本不透明度(opacity)不要在彩色背景上使用灰色文本和图标，而是通过显示不透明度较低的白色或黑色文本来创建更好的对比度。 例如，在绿色背景上以 75% 不透明度显示的黑色文本会使文本呈现黑色外观，并带有绿色提示。 或者，您可以通过执行以下操作来计算文本的颜色： 将颜色黑色放置在绿色背景前面，以降低的不透明度确定生成的深绿色的十六进制值将该颜色的十六进制值用于文本在这种情况下，如果文本后面的曲面变色，则还必须更新十六进制颜色。在彩色表面上使用透明版本的黑色以保持易读性。 8.2.3. 浅色背景上的深色文本浅色背景上的深色文本（此处显示为 #000000，#FFFFFF）应用以下不透明度级别： 高强调文本的不透明度为 87%中等加重文本和提示文本的不透明度为 60%禁用文本的不透明度为 38% 8.3. 彩色文本和背景应谨慎使用彩色文本以引起注意并进行选择性强调。理想情况下，应为标题、按钮和链接等文本元素保留彩色文本。 使用Material color tool可以确定文本上使用的某些前景色是否符合背景色的辅助功能标准。 8.4. 文本类型8.4.1. 帮助文本帮助程序文本提供有关字段输入的上下文，例如如何使用输入。它可以采用品牌颜色，但应根据WCAG标准确定清晰易读。 例如，浅色背景上的帮助程序文本可以应用以下不透明度级别和默认十六进制： 高重音辅助工具：此文本使用十六进制值 #000000，不透明度为 87%默认颜色帮助程序文本：此文本使用十六进制值 #000000，不透明度为 60%默认错误帮助程序文本：此文本使用十六进制值 #B00020 100% 不透明度 8.4.2. 选择文本为了反映品牌，选择文本可以使用主要或次要颜色的强调文字。选择文本应与所选颜色相对清晰，并且… 选择文本应与所选颜色相对清晰，并且所选颜色应与背景色形成对比。或者，您可以显示轮廓、运动、复选标记图标或其他文本处理以指示选择文本。 有关对比度的更多信息（或尝试使用颜色对比度分析仪），请访问 webaim.org。 8.4.3. 图标和其他符号图标和其他元素不需要满足WCAG易读性标准，但应尽可能可见，以指示功能或传达信息。 例如，深色图标 （#000000） 或浅色背景（#FFFFFF）上的其他元素可以应用以下不透明度级别： 活动图标的不透明度为 87%非活动图标的不透明度为 60%禁用图标的不透明度为 38% 9. 深色主题深色主题是主要显示深色表面的低光 UI。 9.1. 深色主题用法深色主题在大多数 UI 中显示深色表面。它被设计为默认（或浅色）主题的补充模式。 深色主题会降低设备屏幕发出的亮度，同时仍满足最低色彩对比度。它们通过减少眼睛疲劳，根据当前照明条件调整亮度以及促进在黑暗环境中使用屏幕来帮助改善视觉人体工程学 - 同时节省电池电量。受益于OLED屏幕的设备在一天中的任何时间关闭黑色像素的功能。 9.2. 深色主题原则 用灰色变暗 使用深灰色（而不是黑色）来表示深度范围更广的环境中的标高和空间。 Color with accents 在深色主题 UI 中应用有限的颜色，因此大部分空间仍然保持深色表面。 节约能源 在需要能源效率的产品（例如带有OLED屏幕的设备）中，通过减少亮像素的使用来节省电池寿命。 9.3. 深色主题属性Material设计深色主题由以下属性定义： 对比度：深色表面和 100% 白色正文文本的对比度至少为 15.8：1深度：在较高的标高级别，组件通过显示较浅的表面颜色来表示深度不饱和度：原色不饱和，因此它们在所有标高级别上都通过了 Web 内容无障碍指南 （WCAG） AA 标准，即至少为 4.5：1（与正文文本一起使用时）颜色限制：大型表面使用深色表面颜色，颜色强调色有限（浅色、不饱和色和亮色饱和色） 9.4. 深色主题刨析深色主题 UI 主要使用深色表面，颜色强调色稀疏。它们发出的光水平较低，同时保持了高标准的可用性。 Background (0dp elevation surface overlay) Surface (with 1dp elevation surface overlay) Primary Secondary On background On Surface On Primary On Secondary 9.5. 深色主题行为可以使用显示的控件打开（或关闭）深色主题： 突出显示，使用图标切换打开或关闭主题降低突出度，在菜单或应用程序的设置中放置一个开关 10. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 11. 参考文档Text legibility Material Design color system","link":"/material/material_color.html"},{"title":"Material Design 基础 - 导航","text":"1. 说明导航允许用户在应用程序中移动。 1.1. 导航类型导航是在应用程序的屏幕之间移动以完成任务的行为。它是通过几种方式实现的：专用导航组件、将导航行为嵌入内容以及平台功能。 1.2. 航行方向根据应用程序的信息架构，用户可以向以下三个导航方向之一移动： Lateral navigation指的是在同一层级的屏幕之间移动。应用程序的主要导航组件应提供对其层次结构顶层所有目的地的访问。 Forward navigation指的是在连续层次、流程中的步骤或应用程序之间的屏幕之间移动。正向导航将导航行为嵌入容器（如卡片、列表或图像）、按钮、链接或使用搜索。 Reverse navigation指的是按时间顺序（在一个应用程序内或跨不同应用程序）或层次结构（在一个应用程序内）向后移动屏幕。平台约定决定了应用程序中反向导航的确切行为。 1.3. 侧边导航(Lateral navigation)Lateral navigation是指在同一层级的屏幕之间移动。它可以访问不同的应用目的地和功能，或在一组相关项目之间旋转。 1.4. Destinations and hierarchy应用程序的主要导航组件应提供对其层次结构顶层所有目的地的访问。具有两个或多个顶级目的地的应用程序可以通过导航抽屉、底部导航栏或选项卡提供Lateral navigation。 Component Use for # destinations Devices Navigation drawer Top-level destinations 5+ Mobile, Tablet, Desktop Bottom navigation bar Top-level destinations 3-5 Mobile Tabs Any level of hierarchy 2+ Mobile, Tablet, Desktop 导航抽屉适用于五个或五个以上的顶级目的地，可以跨设备大小使用，以获得一致的导航体验。 底部导航栏提供了对移动设备上3-5个顶级目的地的访问。它们在屏幕上的位置、可见性和持久性允许在目的地之间快速旋转。 TAB可用于应用程序层次结构的任何级别，以跨屏幕大小显示两个或多个对等数据集。 当tabs与顶级导航组件（如导航抽屉）配对使用时，tabs可以在应用的层次结构中启用额外的横向导航。 1.5. 前向导航(Forward navigation)前向导航指的是在屏幕之间完成任务的三种移动方式之一：在应用程序的层次结构中向下，以访问更深层次的内容，从父屏幕（层次结构的较高级别）到子屏幕（层次结构的较低级别）顺序地通过一个流，或一系列有序的屏幕，如结账过程直接从应用程序中的一个屏幕到任何其他屏幕，例如从主屏幕到应用程序层次结构中的深层屏幕 1.5.1. 实现前向导航Lateral navigation使用专用的导航组件，而正向导航通常通过各种组件嵌入到屏幕内容中。前向导航可通过以下方式实现：内容容器，如卡片、列表或图像列表前进到另一个屏幕的按钮在一个或多个屏幕上进行应用内搜索内容中的链接 1.6. 反向导航(Reverse navigation)反向导航指屏幕之间的向后移动。它可以按用户最近的屏幕历史记录的时间顺序移动，或向上移动应用程序的层次结构。 1.6.1. 逆时间导航(Reverse chronological navigation)逆时间导航是指在用户最近查看的屏幕历史记录中按相反顺序导航。它可以在一个应用程序内的屏幕之间或多个应用程序之间移动。例如，web浏览器上的“后退”按钮是一种逆时间导航的形式。这种类型的导航通常由操作系统或平台提供。各个平台定义了它的行为方式以及用户如何访问该功能。 1.6.2. 向上导航(Upward navigation)向上导航允许用户在单个应用的层次结构中向上导航一个级别，直到到达应用的主屏幕或顶级屏幕。例如，顶部应用栏中的向上箭头是向上反向导航的一种形式。 应为应用中的所有子屏幕实现向上导航，并遵循平台指南。Android 和 Web 应用应使用“Material Up”操作，而 iOS 应用应使用 iOS 导航栏中的后退按钮。 1.6.3. 考虑应用的设计和功能应考虑应用目标平台中的两种反向导航。要优化用户反向导航时的体验， 请执行以下操作： 将用户返回到其先前的屏幕位置和状态（如垂直滚动位置），以加快信息调用和任务恢复。 如果屏幕的先前状态不再可用，例如，出于隐私目的清除了表单中的信息，则提供清晰的消息。 在层次结构中，清楚地指示子屏幕与其上方屏幕的关系。例如，如果用户直接移动到应用中的子屏幕，他们应该能够识别他们可以向上导航到的父屏幕。 2. 导航过渡当用户在屏幕之间移动（如从主屏幕移动到详细信息屏幕）时，会发生导航过渡。 2.1. 关于导航过渡2.1.1. 导航和运动导航过渡使用运动在应用中的两个屏幕之间引导用户。它们通过表达应用的层次结构来帮助用户定位自己，使用移动来指示元素之间的相互关系。 例如，当元素展开以填充整个屏幕时，展开行为表示新屏幕是子元素。它从中展开的屏幕是其父元素。 2.1.2. 层次结构层次转换将用户在应用程序的层次结构中向上或向下移动一级，而对等转换将用户移动到同级（层次相同的屏幕）之间。 2.1.2.1. 层次转换层次过渡反映用户在应用中向上或向下移动一个级别。彼此相邻级别的屏幕彼此具有父级和子级关系，其中父级位于比其子级更高的层次结构级别。 2.1.2.2. 父子转换在父屏幕中，嵌入的子元素在触摸时抬起，并使用容器转换过渡模式就地展开。该运动既将焦点吸引到子屏幕（这是交互的目的地），又加强了父屏幕和子屏幕之间的关系。 2.1.2.3. 同级转换Peer transitions 发生在同一层级的屏幕之间。同级转换发生在共享父级的对等方之间，而顶级对等方转换仅用于在主要目的地之间切换。 2.1.2.4. Sibling transitions共享同一父级的屏幕（如相册中的照片、个人资料的各个部分或流程中的步骤）协同移动，以加强它们之间的关系。对等屏幕从一侧滑入，而其同级屏幕则从相反的方向移出屏幕。 2.1.3. 顶层过渡在应用的顶层，目标通常分为主要任务（并且任务之间可能彼此不相关）。这些屏幕使用淡入淡出过渡模式就地过渡。 3. 搜索搜索允许用户快速查找应用内容。 3.1. 用法搜索允许用户在应用中快速查找内容。基本搜索使用户能够将查询输入到搜索文本字段中以查看相关结果。 可以扩展搜索查询输入法，以包括历史建议、查询自动完成和语音输入。 3.2. 持久搜索当搜索是应用的主要焦点时，请使用持久搜索。搜索文本字段显示在搜索栏内，随时可以接收焦点。 3.2.1. 持久搜索用法当用户聚焦在搜索输入框时，搜索体验将扩展以填充整个屏幕。（可选）历史搜索建议可以显示在文本字段下方。用户可以键入查询或从建议中进行选择。按返回后，将提交搜索。搜索结果显示在搜索栏下方。若要从搜索框中释放焦点并关闭搜索建议，用户点击向上箭头。 3.3. 可扩展搜索当搜索不是应用的主要焦点时，请使用展开搜索。可扩展搜索在工具栏中显示搜索图标，而不是打开的搜索文本框。 3.3.1. 可扩展搜索用法用户点击搜索图标（在工具栏中）以将其转换为重点搜索栏。当用户键入时，历史搜索建议可以显示在搜索栏下方。输入查询或选择建议后，按 Return 键将提交搜索。结果显示在搜索栏下方，并在搜索栏下方滚动。 显示结果时，搜索文本字段仍然可见，但不在焦点中。点击向上箭头可从搜索中释放焦点，关闭建议和屏幕键盘，并将工具栏返回到其原始状态。 4. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 5. 参考文档Understanding navigationNavigation transitionsSearch","link":"/material/material_navigation.html"},{"title":"Material 3 基础","text":"Material foundations是任何优秀用户界面的基础，从无障碍标准到布局和交互的基本模式。 1. 自适应设计1.1. 了解布局1.1.1. 布局概述 使用布局将注意力引导到用户想要采取的操作 使布局适应紧凑型、中等型和扩展型窗口尺寸等级 从既定的规范布局构建 考虑间距和布局的各个部分如何协同工作 适用于 Android 和 Web的Material布局指南 布局术语 1: 列(column) 窗格中的一个或多个垂直内容块 2: 铰链(fold) 在可折叠设备上，屏幕的灵活区域，或者在双屏设备上，分隔两个显示屏的铰链 3: 外边距(margin) 屏幕边缘与其内部任何元素之间的空间 4: 窗格(Pane) 一种布局容器，可在单个应用程序中容纳其他组件和元素。窗格可以是：固定的、灵活的、浮动的或半永久的 5: 间隔(spacer) 两个窗格之间的空间 6: 窗口(Window) 1.2. 最近更新创建新布局时，请从规范布局而不是布局网格开始。这有助于确保您的布局可以跨设备和外形尺寸进行扩展。 窗口尺寸等级是Material推荐的的断点设置。Material Design建议您为三个窗口大小类创建布局：紧凑型(compact)、中等型(medium)和展开型(expanded)。 1.2.1. 间距1.2.1.1. 分组 分组是一种连接共享上下文的相关元素的方法，例如用标题分组的图像。它在视觉上关联元素并建立边界以区分不相关的元素。 通过在图片下面加上一个标题，这幅作品展示了一个明确的群体。 显式分组 显式分组使用视觉边界（如轮廓、分隔符和阴影）对封闭区域中的相关元素进行分组。显式分组还可以指示项目是交互式的，例如包含在分隔符之间的列表项目，或者显示图像及其标题的卡片。 该卡片中的元素被明确分组。 隐式分组 隐式分组使用贴近和开放空间（而不是线条和阴影）对相关项目进行分组。例如，紧跟着子标题的标题和缩略图图像通过接近度隐式地分组在一起，并通过开放空间与其他标题子标题缩略图组分离。 轮播图中的图片按其接近程度进行分组。 1.2.1.2. 外边距边距是窗口区域的边缘和该窗口区域内的元素之间的空间。 边距宽度是使用每个窗口大小类的固定值或缩放值定义的。为了更好地适应窗口，页边宽度可以根据不同的屏幕尺寸变化。更宽的边距更适合较大的屏幕，因为它们在内容周围创造了更多的开放空间。请参阅每个窗口级别的宽度度量：紧凑型、中型和扩展型。 空白将屏幕边缘与屏幕上的元素分隔开 1.2.1.3. 间隔(spacer)间隔是指布局中两个窗格之间的空间。间隔大约24dp宽。 间隔将两个窗格彼此分开。 1.2.1.4. 内边距(padding)内边距是指UI元素之间的空间。内边距可以垂直和水平测量，不需要跨越布局的整个高度或宽度。内边距以4dp为增量进行度量。 内边距将标题与上面的图像分隔开 1.2.1.5. 像素密度一英寸屏幕上存在的像素数称为像素密度。高密度屏幕的每英寸像素数比低密度屏幕多。因此，相同像素尺寸的UI元素在低密度屏幕上看起来更大，在高密度屏幕上显得更小。 要计算屏幕密度，可以使用以下公式： 屏幕密度=以像素为单位的屏幕宽度（或高度）/以英寸为单位的屏幕宽度（或高度） 高密度UI元素 低密度UI元素 1.2.1.6. 密度无关像素密度无关像素，写作 dp（发音为“dips”），是灵活的单位，可以在任何屏幕上缩放以具有统一的尺寸。 它们提供了一种灵活的方式来适应跨设备的设计。 Material UI 使用密度无关像素在不同密度的屏幕上一致地显示元素。 1dp等于160个物理像素的屏幕上的宽度。 计算dp: 1dp=（像素宽度*160）/屏幕密度 dp = (width in pixels * 160) / screen density Screen physical width Screen density Screen width in pixels Screen width in dp 1.5 in 120(px/inch) 180px 240dp 1.5 in 160(px/inch) 240px 240dp 1.5 in 240(px/inch) 360px 240dp 1.2.2. 信息密度布局的间距尺寸（包括边距、间隔符和填充）可以更改以增加或减少其信息密度。当用户需要快速扫描、查看或比较大量信息（如数据表中的信息）时，高密度布局非常有用。增加列表、表格和长表单的布局密度可以展示更多内容在屏幕上。 当用户需要扫描屏幕上的大量信息时，请考虑使用更高密度的信息设计 然而，密集布局可能不太容易操作，因为交互式元素尺寸较小，因此在增加信息密度时要小心。 注意: 避免将可选目标元素尺寸减少到48x48dp以下 1.2.3. 密度标尺（Density scale）密度标尺允许您在需要时控制单个组件的内部间距。密度标尺是用数字编号的，从组件的默认密度的0开始。随着空间的减少，比例将变成负数（-1、-2、-3），从而创建更高的密度。每个减少一个刻度表示组件间距减少4dp。 按钮提供多种密度，以最适合设计需求 当多个图元在一个构件中垂直堆叠时，请使用4dp增量来分隔它们。将分组元素在组件容器中居中。 不要将密度应用于交互组件。它们应保持最小48x48dp，即使它们的视觉元素较小。 1.2.4. 布局部件大多数布局都有两个区域： 导航(Navigation) 主体(Body) 1.2.4.1. 导航区域导航区域包含主导航组件和元素，例如： 导航抽屉 导航栏杆 导航栏 此部分中的元素帮助人们在应用程序中的目标之间导航或访问重要操作。 三种不同的导航组件适用于各种设备大小和环境 1.2.4.2. 主体区域主体区域包含应用程序中的大多数内容，包括： 图像 文本 列表 卡片 按钮 应用程序栏 搜索栏 主体区域中的内容被分组到一个或多个窗格中。 主体区域是导航区域之外的区域。 1.2.4.3. 窗格窗格是指正文区域内的内容分组。所有应用程序内容都在一个或多个窗格中。布局区域和窗格的排列和相对大小将根据设备的窗口大小类别而变化：紧凑：1个窗格中：1个（推荐）或2个窗格展开：1或2个窗格（推荐） 第一窗格 第二窗格 窗格类型: fixed：固定宽度（360 dp） flexible：响应可用空间，可以增长和收缩 第一窗格(固定窗格) 第二窗格(弹性窗格) 窗格不同于窗口，窗格是指包含应用程序的frame。多窗口视图是一种系统UI功能，用于同时显示多个应用程序。参考Android多窗口支持指南 1.2.4.4. 布局单窗格布局使用一个弹性窗格。 两窗格布局通常使用一个固定窗格和一个弹性窗格，它们可以以最适合内容的任何顺序出现。 另一种两窗格布局称为分割窗格，它使用两个等于屏幕宽度 50% 的灵活窗格。此布局最适合可折叠设备。 1.2.4.5. 应用栏(App bars)窗格可以包括顶部应用栏和底部应用栏。 窗格内的应用程序栏的示例 顶部应用栏中的任何嵌套操作都应根据可用宽度隐藏或显示。 显示了两个操作的紧凑窗口 显示了五个操作的扩展窗口 当布局从一个窗格过渡到两个窗格时，请避免在窗格之间移动元素。 在窗口级别之间切换时，不要将元素移动到不同的UI对象 1.2.4.6. 列(Column)窗格中的内容可以显示在多列中以分割和对齐内容。 列是窗格独有的，不要在窗口级别使用。 使用一个窗格，像News这样的应用程序使用多个内容列来创建其布局 1.2.5. 硬件与布局窗口级别为通用布局决策提供了基础，但也需要考虑针对特定显示设备的布局策略。 1.2.5.1. 显示器切口显示器切口是一些设备上延伸到显示器表面的区域。它允许边缘到边缘的体验，同时为设备屏幕上的重要传感器提供空间。应用程序可以围绕显示器切口或其他功能进行扩展，但UI的某些部分可能会被遮挡。 移动设备的内容安全区域，位于前置摄像头的显示屏切口周围 1.2.5.2. 可折叠设备可折叠设备使用折叠机制来折叠和展开。 设计布局时，需要考虑它们的独特特征。 可折叠设备的折叠区域将屏幕分为水平或垂直两部分。 折叠部分可以是屏幕的灵活区域，也可以是双屏设备上分隔两个显示屏的铰链。 尽管有些用户可能会感觉到屏幕表面的触感差异，但几乎看不到灵活的折叠。 内容可以很容易地跨过折叠区域。 折叠通常位于设备屏幕的中央，可以提供无缝体验。 在具有物理铰链的设备上，将屏幕设计为两个不同的部分（单独的窗口区域或窗格）允许组合在铰链和屏幕上很好地工作。 物理铰链将两部分分开。此区域中没有显示部件. 1.2.5.2.1. 设备状态可折叠设备可以有多种物理状态：折叠、平放和桌面。 折叠 折叠状态可以包括前屏幕，其通常适合紧凑的窗口尺寸类别，就像手机竖屏一样。 可折叠设备的前屏幕 平放 打开平面状态是指完全打开的屏幕，通常将窗口尺寸级别增加到中等或扩展。 平放设备可以横向或纵向使用。 在纵向打开状态下，较长的设备边缘是垂直的，而较短的边缘是水平的。 在横向打开状态下，较长的设备边缘是水平的，而垂直边缘较短。 桌面 桌面是指形成大致90度角的半开状态，设备的一半放在表面上。这种姿势类似于笔记本电脑。铰链附近的UI控件可能很难让用户访问，超过铰链的文本可能很难阅读。 如果存在相机硬件，则桌面设备最好放置在没有任何突出硬件元素的一侧。 1.2.5.2.2. 交互 应用连续性 在可折叠设备上运行时，应用程序可以自动从一个屏幕转换到另一个屏幕。 转换后，应用程序应恢复到相同的状态和位置，并且当前任务应无缝继续。 大屏兼容性测试。 当可折叠设备切换设备状态时，新闻应用会在紧凑和扩展的窗口级别中显示内容。 滚动和多个窗格 根据您的应用程序使用窗格的方式，折叠设计的滚动行为可能会在展开设计中发生变化。 如果展开窗格，您可以决定整个窗口是否一起滚动，或者每一侧（每个窗格）独立滚动。 如果您的设计有多个窗格，则每个窗格都可以作为独立的可滚动区域运行。 1.3. 应用布局1.3.1. 窗口尺寸等级不同尺寸和方向的设备需要不同的布局。例如，新闻应用程序在移动设备上可能只有一列文本，但在较大的桌面设备上显示多列。这种布局变化利用了设备功能和用户预期。 窗口尺寸等级是一些固定的断点，即布局需要更改以匹配可用空间、使用习惯和人体工程学的窗口尺寸。Material Design将所有设备划分为三中窗口尺寸类别：紧凑型(compact)、中型(medium)或扩展型(expanded)。 Material Design将重点放在关注窗口尺寸，而不是针对不断增加的显示设备进行设计，从而确保布局适用于各种设备。 紧凑型(compact) 中型(medium) 扩展型(expanded) 窗户等级（宽度） 断点（dp） 常用设备 紧凑型 宽度 &lt; 600 手机纵向显示 中型 600 &lt;= 宽度 &lt; 840 纵向平板电脑 折叠设备（纵向展开） 扩展型 宽度 &gt;= 840 手机横向 平板 电脑横向 折叠设备（横向展开） 桌面 窗口大小类别也可用于高度，这在设计非常小的设备时非常有用，因为即使横向方向也具有紧凑的宽度。在这种情况下，应该用导航栏来呈现一个内容窗格。 但是，大多数布局都包含垂直滚动内容，因此只需调整到可用宽度即可 针对尺寸等级而不是针对特定设备进行设计，因为： 可用窗口空间量是动态的，并根据用户行为而变化，例如多窗口模式或展开可折叠设备。设备根据方向分为不同的窗口大小类别。 1.3.2. 跨窗口级别设计每个产品视图应具有三种布局，每种布局对应三种窗口大小类别。 建议使用不同的组件在三种布局中执行相同的功能。 窗类 窗格 导航 沟通 行动 紧凑型 1 导航栏、模态导航抽屉 简单对话框、全屏对话框 底部导航 中等的 1（推荐）或 2 导航栏、模态导航抽屉 简单的对话框 菜单 扩展 1 或 2（推荐） 导航导轨、模态或标准导航抽屉 简单的对话框 菜单 首先针对一个窗口类大小进行设计，然后通过问自己以下五个问题来调整下一个类大小的布局： 应该显示什么？ 隐藏在较小屏幕上的 UI 部分可以在中等和扩展布局中显示。 例如，在紧凑型设备上，导航抽屉默认折叠并通过菜单按钮访问；在扩展设备（例如大型平板电脑或笔记本电脑）上，默认情况下可以打开导航抽屉以显示更多操作和功能。 对于显示其他窗格也是如此，例如当扩展的设备有空间同时显示收件箱窗格和包含所选电子邮件的窗格时。额外的屏幕并不仅仅意味着把同样的东西做得更大。 屏幕应该如何划分？ 将屏幕划分为布局窗格时，请考虑窗口尺寸类别。 使用单个窗格的组合最适合紧凑型和中型窗口尺寸类别，而两个窗格最适合扩展窗口尺寸类别。 还要考虑内容和交互需求。 例如，在中等窗口类中可以有两个窗格，但可能不会产生最可用的体验。复杂的列表项可能会导致很难在两个紧凑窗格中舒适地查看内容。 然而，受益于项目之间快速导航的低密度内容可能效果很好。 单窗格布局可以将注意力集中在一个操作或视图上，为特定目标创建一个无干扰的环境，例如： 玩游戏 看电影 视频通话 创意应用 哪些应该调整大小？ 在紧凑型屏幕上较小的 UI 部分在中型和扩展屏幕上可能会变大。例如，移动设备上的水平方向的卡片在较大的平板电脑上可能会变得更方形。在较大的屏幕上也可以增加窗格的大小，并且可以重新排列其元素以更好地利用空间。请参阅应该重新定位什么？了解更多信息。 考虑调整大小： 牌 饲料 列表 窗格 调整元素大小可以使图像更加突出，或者为更大的版式样式腾出空间，从而增强可读性。这种类型的适应会影响屏幕上内容和对象的规模以及它们之间的关系。例如，移动设备上的文本列表可以调整边距、垂直间距和密度，以更好地适应平板电脑等中等窗口类设备。 在每个窗口类别中，文本的理想行长是 40-60 个字符。调整包含文本的元素大小时，请使用边距和版式属性（例如行高、字体粗细和版式大小）将行保持在 40-60 个字符以内。 哪些应该调整位置？ UI 及其组件可以重排或重新定位，以利用扩展屏幕和调整大小的窗格上的额外空间。重新定位也是满足因设备尺寸而变化的人体工程学和输入需求的一种方法，例如将操作从紧凑型屏幕的底部转移到中型和扩展屏幕的前缘。这种方法类似于网络上的响应式设计。 考虑： 重新定位卡片 添加第二列内容 创建更复杂的照片布局 引入更多负空间 确保导航和交互元素的可达性 当父容器缩放时，内部元素可以锚定到左侧、右侧或中心。内部元素也可以保持固定位置，如导航抽屉内的浮动操作按钮 (FAB) 的示例所示。 对于按钮，按钮容器内的图标和文本标签可以保持彼此锚定，在按钮容器水平缩放时保持居中。 应该换什么？ 随着窗口尺寸类别的布局发生变化，具有相似功能的组件也可以互换。这使得调整布局以适应界面的人体工程学和功能质量的大规模变化成为可能。例如，紧凑布局中的底部导航栏可以与中等布局中的导航栏和扩展布局中的导航抽屉交换。 更换组件时请务必小心，确保可互换组件的功能相同。例如，请勿将按钮换成Chips。在列表项和卡片之间进行更改时要小心。 组件交换应始终为用户提供功能性和人体工程学目的。 1.3.3. 通用可更换组件 组件类型 紧凑型 中等 扩展 导航 导航栏 导航轨道 导航轨道 导航 模态导航抽屉 模态导航抽屉 模态或标准导航抽屉 沟通 简单或全屏对话框 简单的对话框 简单的对话框 补充选择 底部导航 菜单 菜单 1.4. 规范布局使用三种规范布局作为组织应用程序中常见元素的起点。 每个布局都考虑了常见的用例和组件，以满足应用程序如何适应窗口类大小和断点的期望和用户需求。 1.4.1. 要点共有三种规范布局：列表详细信息、支持窗格、内容摘要(feed) 每个规范布局都具有紧凑型、中型和扩展窗口尺寸类别的配置 1.4.2. 布局共有三种规范布局：列表详细信息、支持窗格、内容摘要(feed) 内容摘要 使用内容摘要布局在可配置的网格中排列卡片等内容元素，以便快速、方便地查看大量内容。 列表详情 使用列表详细信息布局显示可探索的项目列表以及每个项目的补充信息（项目详细信息）。此布局将应用程序窗口分为两个并排的窗格。 支撑板 使用支持窗格布局将应用程序内容组织到主要和次要显示区域。主显示区域占据应用程序窗口的大部分（通常约为三分之二）并包含主要内容。辅助显示区域是一个面板，它占据应用程序窗口的其余部分并显示支持主要内容的内容。 2. 定制Material2.1. 动态色彩让个人设备感觉个性化Material 3 为品牌颜色和个人颜色偏好融合为独一无二的体验开辟了新的可能性。颜色系统满足了对颜色的需求，以反映应用程序的设计敏感性，同时也尊重个人为自己选择的设置。 通过启用动态颜色，应用程序可以保留定义和区分产品的颜色，同时还使用户可以更好地控制对他们来说最重要的样式。 2.1.1. 应用品牌色彩系统借助动态颜色和 M3配色方案，您的应用程序的颜色会自动适应并与用户设置集成。 M3支持自定义参数的系统应用，以帮助定义和维护传达您品牌的风格。 颜色系统自动处理关键调整，提供无障碍的颜色对比度、易读性、交互状态和组件结构。动态颜色也适用于自定义（非Material）组件。 应用可以采用基线方案、用户生成的动态颜色或自定义颜色中的一系列颜色 2.1.2. 使用色彩系统要利用个性化功能，您需要使用 M3 颜色系统构建自定义配色方案。 为了使您的应用程序尊重用户的设备和应用程序级设置，您将实现一个用户生成的配色方案可以映射到的自定义主题. 此外，使用自定义主题可确保您的应用程序为未启用动态颜色的用户提供备用配色方案。 用户生成的配色方案可以作用于使用自定义主题的应用 2.1.2.1. 设置和教程动态颜色既可以是用户设置的主体也是开发人员配置的主体。您可以有选择地应用动态颜色以配合您的品牌配色方案。而用户可以通过应用程序中的个人资料或帐户屏幕设置用户的配色方案设置，从而为应用程序中的个人空间添加个性。 2.1.2.1.1. 品牌参数设置您现有的品牌参数可以与 Material Design 集成，以便在您的产品中保持一致的应用您还可以从材料设计开始，为项目创建一个新的、完整的颜色系统 2.1.2.2. 动态色彩教程动态颜色代码实验室是一个实践演练，有助于可视化设计和品牌颜色如何与动态颜色相互作用。它可以帮助您进入下一步，使用Figma 的 Material Theme Builder插件将颜色应用到您的设计中。 2.1.2.3. 材质主题生成器通过内置代码导出，Material Theme Builder Figma 插件可以轻松可视化您的设计、迁移到 M3 颜色系统并利用动态颜色。 Material Theme Builder 创建可以导出为多种代码格式的颜色和类型标记。Design Token是创建和维护样式值来源的重要工具。Figma 插件以 Figma 样式的形式创建令牌，以与现有的模型、品牌风格指南甚至设计系统连接。 Material Design Token可在格式化主题文件中使用，包括设计系统包 (DSP)。DSP 是一种表示设计系统信息的跨平台文件格式。了解有关设计令牌的更多信息。 2.1.3. 定制配色方案无论您是打算重用已建立的品牌颜色系统还是尚未定义自己的品牌颜色，Material Theme Builder都可以帮助创建自定义颜色体验。 在 Material Theme Builder中，您可以通过识别或者输入一种或多种颜色即可来定义您的配色方案。第二种或第三种颜色是可选的，并且会影响最终的配色方案。 将应用程序颜色映射到自定义方案的源颜色, 可以调整M3中动态颜色的角色和逻辑。 品牌颜色可以是单一颜色或者具有一系列色调的完整品牌调色板添加到工具中，从而在整个应用程序中提供一致、全面的颜色表达。 如果您的应用使用单一品牌颜色或有限的品牌调色板，您可以输入主要品牌颜色作为自定义配色方案的源颜色。输入的颜色将用于生成一整套方案，为您提供互补色调以完善方案。 2.1.3.1. 颜色角色根据 UI 中的用途，关键颜色被分配映射到组件中的元素的角色。具有角色分配的五个基本颜色组是： 主要颜色 第二颜色 第三颜色 中性颜色 中性颜色变体 输入颜色会生成一个色调调色板，用于填充所需的颜色角色范围，例如primary(主要颜色), on-primary(主要颜色对比色), 和 primary container(主要颜色底色)。了解有关使用颜色角色的更多信息. 3. 设计令牌设计令牌是所有 UI 元素的构建块。设计、工具和代码中使用相同的标记。 设计令牌指向颜色、字体和尺寸等样式值 使用设计令牌而不是硬编码值 每个令牌都根据其使用方式或位置进行命名（例如：md.fab.container.color设置 FAB 的容器颜色） 即使令牌的最终值发生更改，其名称和用途仍保持不变 Material Design 具有三种设计令牌：引用、系统和组件 设计令牌确保在设计文件和代码中使用相同的样式值. 3.1. 要点 令牌是一种与平台无关的格式，但它们可以在特定于平台的代码中使用 令牌分为三种：引用、系统和组件。Material Design 目前使用参考和系统令牌；组件设计令牌正在开发中。 令牌有助于保持设计系统的一致性。 3.2. 什么是设计令牌？设计令牌代表构成设计系统视觉风格的小型、重复的设计决策。令牌用不言自明的名称替换静态值，例如颜色的十六进制代码。 Material Design 令牌由两部分组成： 类似代码的名称，例如md.ref.palette.secondary90 关联值，例如#E8DEF8 令牌的值可以是以下几种之一：颜色、字体、尺寸值，甚至另一个令牌。 令牌 md.ref.palette.secondary200，箭头指向淡紫色色样 #ECB07E 设计令牌有意义地将风格选择联系起来，否则这些风格选择将缺乏明确的关系。 例如，如果设计师的模型和工程师的实现都引用称为辅助容器颜色的相同令牌，则设计和工程可以确信在这两个地方将使用相同的颜色。即使分配给令牌的颜色值更新，这种一致性仍然存在。 3.3. 为什么设计令牌很重要？令牌使设计系统能够拥有单一的数据来源。它们提供了一种用于记录和跟踪风格选择和更改的存储库。 当使用令牌进行设计和实现时，样式更新将在整个产品或产品套件中一致传播。 由于令牌是可重用且目的驱动的，因此它们可以定义系统范围内的主题和上下文更新以供使用。例如，令牌可用于系统地应用高对比度配色方案以提高可视性，或更改字体比例以使小文本在大屏幕上清晰可见。 随着设计系统的发展，某些值将发生变化。设计标记可以帮助您跟踪更改，并确保跨产品的持续一致性 3.4. 令牌和Material Design过去，Material Design 风格是通过指南、设计文件、工具和特定于平台的组件库来传达的。 借助设计令牌，您现在可以下载、自定义和应用 Material Design 样式，并将它们集成到您的设计和开发过程中。 令牌允许以与框架无关且可共享的格式记录设计决策。 设计令牌为设计选择提供了一个中央存储库，为工程师和设计者提供了各种集成点。 3.5. 确定设计令牌是否适合您?令牌在以下情况下最有帮助和最有效： 您计划更新产品的设计或构建新产品 您的设计系统应用于多个产品或平台 您希望将来轻松维护或更新样式 您想要充分利用 Material Design，包括动态颜色等功能 在以下情况下，令牌可能不太有用： 您现有的应用程序使用硬编码值，这些值在未来 1-2​​ 年内不会更改 你的产品没有设计系统 3.6. 如何读取令牌3.6.1. 令牌表格3.6.1.1. 样式在Material的指导方针中，您可以找到列出颜色和排版令牌的表格。令牌参考表可用于查找材质的颜色、字体、字体大小、字体粗细等默认值。这些表映射角色、系统令牌、引用令牌和存储的默认值之间的关系。 文章中的样式令牌表示例 3.6.1.2. 组件规格您还可以在组件规格的“规格”部分找到设计令牌。 这些表格显示了一个图表及其附带数据： 状态：组件的交互状态，例如启用、悬停或按下。 元素：给定标记或值应用到的组件的部件，例如按钮容器或标签文本。 组件属性：令牌或值所应用的样式方面，例如颜色或字体。 角色：系统令牌的昵称（例如：辅助容器颜色；一级标题）。 令牌或值：定义设计属性的信息，存储令牌或硬编码。 3.6.1.3. 使用令牌表格示例：要查找Filled Button的文本标签的默认颜色，请首先导航到常用按钮指南页面的规格选项卡。 接下来，找到显示[Filled}(https://philoenglish.com/query/Filled) Button颜色值的表，并查找elements下列出的文本标签。 令牌列中标签文本颜色的令牌就是您要查找的令牌。 3.6.2. 读取令牌名称令牌名称的各部分由句点和中划线分隔，从最一般的信息（md）到最具体的信息。 设计系统中的所有标记名称都以系统名称开头，例如md表示Material design 令牌类型的缩写：ref表示引用令牌；sys表示系统令牌；comp用于组件令牌 令牌名称以描述性名称结尾，用于传达令牌的角色 A.表示设计体系。“md”代表材料设计 B.表示令牌类型：引用、系统或组件 C.传达设计属性和令牌的目的 3.6.3. 令牌类型材料中有三种标记： 引用令牌 具有关联值的所有可用标记 系统令牌 赋予设计系统其特征的决策和角色，从颜色和排版，到立面和形状 组件标记 分配给组件中元素的设计属性，例如按钮图标的颜色 有了三种令牌，团队可以全局更新设计决策或将更改应用于单个组件。 3.6.3.1. 引用令牌引用令牌以md.ref开头。这些令牌包含设计系统中可用的所有样式选项。它们通常指向静态值，例如颜色的十六进制代码或类型的字体和粗细。常见用途包括： 颜色十六进制值 字体 字体粗细 引用令牌也可以指向其他引用令牌；它们不会根据用户或设备上下文而改变。Material design的参考标记列表为一致的颜色、字体、尺寸等提供了基准。 3.6.3.2. 系统令牌子系统标记以md.sys开头。 这些决策使特定主题或上下文的设计语言系统化。 系统令牌定义引用令牌在UI中的用途。 在应用主题化时，系统标记可以根据上下文指向不同的引用标记，例如亮主题或暗黑主题。只要可能，系统令牌应该指向引用令牌，而不是静态值。 3.6.3.3. 组件令牌所有组件标记都以md.comp开头。 组件标记表示组成组件的元素和值，例如容器、标签文本、图标和状态。 只要可能，组件标记应该指向系统或引用标记，而不是硬编码，如十六进制代码。 虽然一些组件样式选择不会表示为标记，但只要设计选择应用于具有类似用途的多个组件，就应该使用标记。 注：材料设计组件令牌目前正在开发中。 3.6.4. 上下文：不同的默认值根据一组条件，标记可以指向不同的值。这些条件称为上下文，覆盖值称为上下文值。不同上下文的示例包括：设备形状因素、暗主题、密集布局和从右向左的书写系统。您可以将上下文视为一种标记。如果标记值用暗主题标记，则它将覆盖暗主题上下文中的默认标记值。 3.7. 如何使用设计令牌3.7.1. 下载Material基线令牌Material Design 的基线主题包括设计令牌和默认值。将主题下载为设计系统包 (DSP)，以便在您自己的设计和产品代码中进行自定义、协作和使用。了解 DSP JSON 格式 3.7.2. 在 Figma 中使用令牌首先，从社区页面安装Material Theme Builder Figma 插件。 3.7.2.1. 生成令牌 打开 Figma 并导航至：插件&gt; Material Theme Builder &gt;打开插件 选择“开始” ，这将默认创建具有基线值的Material主题。颜色和文本样式将开始填充右侧设计面板。完全生成令牌后，您的画板将包含浅色和深色配色方案的色调调色板，以及默认的字体比例。 您的令牌现在表示为Figma样式，可以在您的整个设计中使用 3.7.2.2. 通过 DSP 导入令牌 打开 Figma 并导航至：插件&gt; Material Theme Builder &gt;打开插件 打开主题下拉列表并选择导入DSP 从文件列表中选择令牌DSP文件。颜色和文本样式将开始填充右侧设计面板。当您的标记完全导入后，您的画板将包含浅色和深色配色方案的色调调色板，以及默认的字体比例。 您的令牌现在表示为Figma样式，可以在您的整个设计中使用 3.7.2.3. 更新令牌值 使用 Material Theme Builder Figma 插件（仅更新颜色） 打开 Figma 并导航至：插件&gt; Material Theme Builder &gt;打开插件 选择“自定义”后，选择颜色。更新的颜色和文本样式将开始填充右侧设计面板。 您更新的令牌现在表示为Figma 样式，可以在您的整个设计中使用 使用 Figma 样式 在 Figma 中，导航到定义标记化样式的文件。快捷方式：右键单击右侧边栏中的样式，然后选择转到样式定义。 在右侧边栏中，将鼠标悬停在要更新的样式上，然后在出现调整图标时选择它。或者，右键单击样式选择器中的样式并选择“编辑样式”。 使用编辑样式面板更改令牌名称、描述、属性等。完成后关闭面板。 3.7.2.4. 在产品模型中使用令牌无需手动设置布局中元素的颜色或版式，而是应用代表您的设计标记的Figma 样式。这有助于确保开发人员正确理解并应用您的设计选择。 3.7.2.5. 将令牌与 Material Design Kit 结合使用 在 Figma 中复制 Material Design 套件 导航到插件&gt; Material Theme Builder &gt;打开插件 选择组件后，选择 swap。这会将基线材质标记样式值与您自己生成的标记样式值交换。 3.7.2.6. 导出令牌 打开 Figma 并导航至：插件&gt; Material Theme Builder &gt;打开插件 导航至“导出”选项卡。选择要导出的格式（Android、Jetpack Compose、DSP） 命名您的 .zip 文件并选择“保存” 4. 交互状态4.1. 概述状态显示组件或 UI 元素的交互状态 各状态有两个视觉指示器来确保可访问性 状态可以与选择相结合（例如选择和悬停） 跨组件一致地应用状态 启用状态 启用状态表示组件或元素可交互。 禁用状态 禁用状态表示组件或元素无法操作。 悬停状态 当用户将光标放在交互元素上方时，就会出现悬停状态。 聚焦状态 当用户使用键盘或语音等输入方法突出显示某个元素时，就会出现聚焦状态。 已激活状态 激活状态传达突出显示的元素，无论是由用户启动还是默认启动。 按下状态 按下状态表示用户轻击。 拖动状态 当用户按下并移动元素时，元素进入拖动状态。 4.2. 状态层状态层是元素上的半透明覆盖层，用于指示其状态。状态层提供了一种通过使用不透明度来可视化状态的系统方法。一层可以应用于整个元素或圆形形状，并且在给定时间只能应用一个状态层。 要从启用样式转换为有状态样式需要添加状态层。 状态层是每个状态具有固定不透明度的覆盖层，并使用与内容相同的颜色。 例如，如果启用的样式对容器使用辅助容器颜色，对内容使用辅助容器颜色，则状态层将是使用辅助容器颜色的覆盖。 如果启用的样式使用容器的表面角色和内容的原色角色，则状态层将是使用原色的覆盖层。 容器 状态层 内容 状态层的大小为 40dp，而交互元素的大小为 48dp。 状态层 交互元素 4.2.1. “on”颜色默认情况下，组件的状态层颜色源自其内容，即图标的颜色或标签文本的颜色（如果不存在图标）。 颜色是内容使用的颜色角色。每个容器颜色都有其对应的颜色。 例如，如果容器颜色是辅助容器，则内容将使用辅助容器颜色角色。 表面层的顺序显示状态层（2）位于 容器（1）和内容（3）层之间 4.2.2. 状态层令牌和值状态层对每个状态的不透明度使用固定百分比。状态图层使用内容使用的颜色（通常是背景颜色）及其各自状态的不透明度百分比。 四种叠加状态及其值： 悬停状态+8%不透明度 聚焦状态+10%不透明度 按下状态+10%不透明度 拖动状态+16%不透明度 4.2.3. 激活状态与使用状态层的悬停、焦点、按下和拖动状态不同，激活组件的容器和内容直接改变颜色。 激活的组件使用组件容器的辅助容器颜色，并将内容颜色更改为辅助容器上的颜色。 4.3. 应用状态4.3.1. 启用状态启用状态表示组件或元素可交互。启用状态使用每个交互式组件的默认样式。 4.3.2. 禁用状态禁用状态（也称为不可操作状态）表示组件或元素不可交互。通过将启用状态的不透明度降低至38%表示不可操作状态。 不可操作状态还可以通过颜色变化和降低高度来表明它们不具有交互性。 禁用和不可操作状态不需要满足对比度要求。 大多数操作、选择和输入组件 都会继承不可操作状态： ✓ 按钮(Button) ✓ 卡片(Card) ✓ Chips ✓ 列表项(List items) ✓ 选择组件(Selection components) ✓ 文本字段(TextField) 通信、容器、导航或某些操作组件不会继承不可操作状态： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 对话框(Dialogs) ✗ 浮动操作按钮 (FAB) ✗ 菜单(Menus) ✗ 导航栏、抽屉和导轨(Navigation bar, drawer, and rail) ✗ 表格(Sheets) ✗ 选项卡(Tabs) ✗ 工具提示(Tooltips) 4.3.2.1. 禁用状态行为不可操作的组件无法聚焦、拖动或按下，并且在点击或悬停时不会更改状态。 组合组件中可能存在零个、一个或多个不可操作的元素。 4.3.3. 悬停状态悬停状态由用户使用光标暂停在交互元素上来启动。 悬停状态的lower-emphasis表面覆盖层可以应用于整个组件、组件内的元素，或者作为组件的一部分上的圆形形状。 悬停状态由操作、选择和输入组件继承： ✓ 按钮(Buttons) ✓ 卡片(Cards) ✓ 复选框(Checkbox) ✓ Chips ✓ 日期和时间选择器(Date and time pickers) ✓ 列表项(List items) ✓ 滑块(Slider) ✓ 开关(Switch) ✓ 文本字段(Text fields) 悬停状态不会被通信、容器或导航组件继承： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 对话框(Dialogs) ✗ 菜单(Menus) ✗ 导航栏、抽屉和导轨(Navigation bar, drawer, and rail) ✗ 表格(Sheets) ✗ 选项卡(Tabs) 4.3.3.1. 悬停行为悬停状态由用户使用光标暂停在交互元素上来启用。 悬停状态可以与聚焦、激活、选择或按下状态组合。 布局中一次只能有一个元素处于悬停状态。 4.3.4. 聚焦状态当用户使用键盘或语音突出显示某个元素时，会传达聚焦状态。焦点状态适用于所有交互组件。 用于聚焦状态的较高强调的表面覆盖可以应用于整个组件、组件内的元素，或者作为组件的一部分上的圆形形状。 焦点状态由操作、选择和输入组件继承： ✓ 按钮(Buttons) ✓ 卡片(Cards) ✓ 复选框(Checkbox) ✓ Chips ✓ 日期和时间选择器(Date and time pickers) ✓ 列表项(List items) ✓ 选择控件(Selection controls) ✓ 文本字段(Text fields) 大多数通信、容器或导航组件都不会继承焦点状态： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 横幅(Banner) ✗ 卡片(Cards) ✗ 对话框(Dialogs) ✗ 导航栏、抽屉和导轨(Navigation bar, drawer, and rail) ✗ 表格(Sheets) 4.3.4.1. 聚焦行为用户通过按键盘上的 Tab 键（或等效键）来启用焦点状态。 焦点状态可以与悬停、激活或选定状态结合起来表示。 布局中一次只能有一个焦点状态。 4.3.5. 激活状态激活状态指示当前正在查看一组选项中的哪个项目。它们可以通过默认启动，也可以由用户选择使用点击、光标、键盘或语音输入等输入方法启动。 激活状态具有更高的重要性，并通过应用于组件内的元素或片段的覆盖、颜色变化或其他视觉处理来表示。 激活状态与选定状态不同，因为它传达突出显示的目的地。 某些导航组件中的项目会继承激活状态： ✓ 导航栏、抽屉和导轨(Navigation bar, drawer, and rail) ✓ 选项卡(Tabs) 激活状态不会被操作、通信、容器、选择或输入组件继承： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 按钮(Buttons) ✗ 复选框(Checkboxes) ✗ Chips ✗ 对话框(Dialogs) ✗ 表格(Sheets) ✗ 滑块(Sliders) ✗ 开关(Switch) ✗ 文本字段(Text fields) 4.3.5.1. 激活行为激活状态可以与悬停和焦点状态结合起来表示。 在一组选项中，一次只能存在一个选项处于激活状态。 4.3.6. 按下状态按下状态传达用户通过光标、键盘或语音输入发起的点击或点击。此状态适用于所有交互组件。 按下状态会触发构图变化，应予以高度重视。 波纹覆盖表示按下状态。它可以应用于整个组件或组件内的元素，或者作为组件部分上的圆形形状。 某些组件（例如按钮或卡片）可以继承标高以表示按下状态。 按下状态由操作、选择和一些包含组件继承 ： ✓ 按钮(Buttons) ✓ 卡片(Cards) ✓ 复选框(Checkboxes) ✓ Chips ✓ 列表项(List items) ✓ 文本字段(Text fields) 按下状态不会被通信、导航或某些遏制组件继承： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 底部导航(Bottom navigation) ✗ 对话框(Dialogs) ✗ 菜单(Menus) ✗ 表格(Sheets) ✗ 选项卡(Tabs) 4.3.6.1. 按下行为按下状态由用户键盘或交互元素上的语音输入启动。 按下状态可以与悬停、聚焦、激活或选定状态组合。 布局中一次可能只有一个按下状态。 4.3.7. 拖拽状态当用户按下并移动元素或组件时，就会出现拖动状态。拖动状态应该不那么重要，以避免分散用户的注意力。 拖动状态使用较低的强调叠加。它可以应用于整个组件或组件内的元素。 某些组件（例如列表项、卡片或卡片）可以继承标高以表示拖动状态。 拖动状态由一些包含和选择组件继承 ： ✓ 卡片(Cards) ✓ Chips ✓ 列表项目(List items) ✓ 滑块(Sliders) 拖动状态不会被操作、通信、导航或某些包含组件继承： ✗ 应用栏(App bars) ✗ 徽章(Badges) ✗ 按钮(Buttons) ✗ 对话框(Dialogs) ✗ 菜单(Menus) ✗ 导航栏、抽屉和导轨(Navigation bar, drawer, and rail) 4.3.7.1. 拖拽行为当用户使用点击或单击等输入方法触摸并按住元素时，会启动拖动状态。 布局中一次可能只有一个拖动状态。 5. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 6. 参考文档Material Design foundations","link":"/material/material3_foundations.html"},{"title":"Angular Material实现typeahead简单示例","text":"1. 前言项目中需要一个输入提示框, 之前是使用ng-bootstrap实现的. 但是由于系统框架完全迁移到了material design. 所以所有bootstrap的依赖项都要迁移到angular material design. 如果您的web表单有一个包含许多选项的下拉列表，那么您可能希望通过提前键入来简化用户的生活。幸运的是，Angular Material组件可以让你很容易地做到这一点。在本指南中，我将向您展示如何实现这一点。 顺便说一句：如果你不熟悉typeahead(提前输入)，这是一种在下拉列表中过滤结果的方法。用户刚开始在字段中键入字符，列表将缩小为仅以用户键入的字符开头的选项。typeahead是一种用户友好的输入方式，因为用户不必在看似无穷无尽的列表中滚动才能找到他们想要的内容。 2. 创建Angular项目1234# 创建项目， 跳过依赖安装 typeahead 为项目名称ng new typeahead-app --skip-install# 或者ng new typeahead-app 3. 添加依赖3.1. 添加 Angular Material 和 Angular CDK 模块 说明: cdk是 angular官方的一个 Component Dev Kit.顾名思义。他就是帮助你开发组件的。包含以下内容 123456cd typeahead-appnpm install --save @angular/material@~13.3.0 @angular/cdk@~13.3.0 @angular/core@~13.3.0 @angular/common@~13.3.0## 或者cd typeahead-appng add @angular/material@~13.3.0 4. 安装依赖包123456npm install##或者 如果你处在墙内, 建议使用下面这种方式安装依赖包以获得较快的下载速度cnpm install 5. 添加预构建的Angular Material主题当我们安装Angular Material时，一些预构建的主题会自动安装。可用的预建主题是 indigo-pink deeppurple-amber purple-green pink-bluegrey 将主题添加到全局style.css 123@import '~@angular/material/prebuilt-themes/indigo-pink.css'; 6. 导入模块首先，我们需要导入MatFormFieldModule和MatSelectModule。因此，让我们更新app.module.ts。让我们遵循以下步骤： src/app/app.module.ts 1234567891011121314151617181920212223242526import { NgModule } from '@angular/core';import { BrowserModule } from '@angular/platform-browser';import { FormsModule, ReactiveFormsModule } from '@angular/forms';import { MatSelectModule } from '@angular/material/select';import { MatFormFieldModule } from '@angular/material/form-field';import { MatAutocompleteModule } from '@angular/material/autocomplete';import { AppComponent } from './app.component';@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, ReactiveFormsModule, MatSelectModule, MatAutocompleteModule, MatFormFieldModule ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 7. 创建typeahead input由于我个人偏好, 我喜欢由简单到深入的讲解一个功能, 这里将整个功能的实现过程分为以下几个步骤.第一步: 实现一个带下拉列表并具有过滤功能的输入框, 但是列表项的内容为预先hardcode在代码中的.第二步: 将hardcode的列表项, 替换为远程服务器抓取的内容第三步: 优化输入框, 给列表项添加更多样式. 7.1. 第一步: 实现一个带下拉列表并具有过滤功能的输入框src/app/app.component.html 12345678910111213&lt;form class=&quot;example-form&quot;&gt; &lt;mat-form-field class=&quot;example-full-width&quot; appearance=&quot;fill&quot;&gt; &lt;mat-label&gt;Number&lt;/mat-label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Pick one&quot; aria-label=&quot;Number&quot; matInput [formControl]=&quot;myControl&quot; [matAutocomplete]=&quot;auto&quot;&gt; &lt;mat-autocomplete #auto=&quot;matAutocomplete&quot;&gt; &lt;mat-option *ngFor=&quot;let option of filteredOptions | async&quot; [value]=&quot;option&quot;&gt; {{option}} &lt;/mat-option&gt; &lt;/mat-autocomplete&gt; &lt;/mat-form-field&gt;&lt;/form&gt; src\\app\\app.component.ts 123456789101112131415161718192021222324252627282930313233import { Component } from '@angular/core';import { FormControl } from '@angular/forms';import { Observable } from 'rxjs';import { map, startWith } from 'rxjs/operators';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { myControl = new FormControl(); options: string[] = ['One', 'Two', 'Three']; title = 'typeahead-app'; filteredOptions: Observable&lt;string[]&gt;; ngOnInit() { this.filteredOptions = this.myControl.valueChanges.pipe( startWith(''), map(value =&gt; this._filter(value)), ); } private _filter(value: string): string[] { const filterValue = value.toLowerCase(); return this.options.filter(option =&gt; { return option.toLowerCase().includes(filterValue) }); }} 说明: 这里主要涉及到两个主要的控件, 一个是input(matInput)输入框和一个autocomplete panel. input输入框通过matAutocomplete属性值”auto”关联到一个id为auto的autocomplete panel. 而input通过 formControl属性定义的formcontrol控件用于感知数据的变化. 感知到输入变化后通过filter方法来实现数据过滤, 而最改变滤autocomplete panel中的选项. matInput是一个指令，允许浏览器原生的&lt;input&gt;元素与&lt;mat-form-field&gt;配合在一起工作 &lt;mat-form-field&gt;是一个组件，用于包装多个Material组件，并应用常用文本字段样式，如下划线、浮动标签和提示消息。 formControl 是来自Reactive Form的一个一个属性, Reactive Form提供了一种模型驱动的方法来处理值随时间变化的表单输入。 这里的 #auto=”matAutocomplete” 可以简写为一个#auto 即定义一个变量名为auto 的local variable, 而省略其类型matAutocomplete, 关于template variable的详细解释可以参考这篇文章 7.2. 第二步: 列表项远程获取7.2.1. 首先快速搭建一个web api服务, 来模拟提供远程数据 新建api项目 执行npm init 初始化package.json 123mkdir webapicd webapinpm init -y 添加依赖包 1npm install express cors request --save 新建index.js 添加配置 index.js 1234567891011121314151617181920212223 /* 引入express框架 */const express = require('express');const app = express();/* 引入cors */const cors = require('cors');app.use(cors());app.use(express.json());app.use(express.urlencoded({ extended: false }));/* 监听端口 */app.listen(8585, () =&gt; { console.log('——————————服务已启动——————————');})app.get('/', (req, res) =&gt; { res.send('&lt;p style=&quot;color:red&quot;&gt;服务已启动&lt;/p&gt;');})app.get('/api/getOptions', (req, res) =&gt; { res.json([{name: &quot;test1&quot;, value:&quot;value&quot;},{name: &quot;test2&quot;, value:&quot;value2&quot;}])}) 启动api server 12$node index.js——————————服务已启动—————————— 在浏览器中访问ApiServer打开页面访问 : http://localhost:8585/api/getOptions页面返回 1[{&quot;name&quot;:&quot;test1&quot;,&quot;value&quot;:&quot;value&quot;},{&quot;name&quot;:&quot;test2&quot;,&quot;value&quot;:&quot;value2&quot;}] 至此, 一个简单的远程Api server已经完成 7.2.2. 修改app.components.ts从远程加载列表选项修改app/app.components.ts 引入依赖httpclient, 并在构造器中注入httpclient实例. 123456import { HttpClient } from '@angular/common/http';constructor(private http: HttpClient) { } 在页面创建时加载远程获取的options. 1234this.http.get&lt;Option[]&gt;(&quot;http://localhost:8585/api/getOptions&quot;).subscribe( data =&gt; this.options = data); 这里远程返回的是一个option对象, 所以要定义一个option类进行接收. 并修改options和filteredOptions类型为. 所以在html template上也要做相应修改.{{option.name}} 1234options: Option[]=[];filteredOptions: Observable&lt;Option[]&gt;; app/option.model.ts 12345export class Option { name: string; value: String;} 完整代码如下src/app/app.component.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243import { Component } from '@angular/core';import { FormControl } from '@angular/forms';import { Observable } from 'rxjs';import { map, startWith, } from 'rxjs/operators';import { HttpClient } from '@angular/common/http';import { Option } from './option.model'@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']})export class AppComponent { myControl = new FormControl(&quot;&quot;); options: Option[]=[]; title = 'typeahead-app'; filteredOptions: Observable&lt;Option[]&gt;; constructor(private http: HttpClient) { } ngOnInit() { this.http.get&lt;Option[]&gt;(&quot;http://localhost:8585/api/getOptions&quot;).subscribe( data =&gt; this.options = data ); this.filteredOptions = this.myControl.valueChanges.pipe( startWith(''), map(value =&gt; this._filter(value)), ); } private _filter(value: string): Option[] { const filterValue = value.toLowerCase(); return this.options.filter(option =&gt; { return option.name.toLowerCase().includes(filterValue) }); }} 至此, 下拉选项即为远程获取的内容 7.3. 第三步: 优化输入框, 给列表项添加更多样式7.3.1. 高亮第一个下拉选项给 mat-autocomplete 元素添加autoActiveFirstOption 属性 7.3.2. 给选项添加图标接下来, 我想在每个选项前显示一个图标. 当然这在本项目上没有什么实际意义, 主要是为了获得一种增强视觉效果的能力. 从后端到前台我们需要做如下修改. 服务器端, 我们需要修改api接口, 让其返回的option选项中包含图标名称. 前端我们修养引入引入material icon相关配置 在html template上进行一些优化, 让其显示相应图标 7.3.2.1. 首先修改修改api接口, 让其返回的图标名称回到我们的webapi项目, 修改index.js.添加iconName 123app.get('/api/getOptions', (req, res) =&gt; { res.json([{name: &quot;test1&quot;, value:&quot;value&quot;, iconName:&quot;home&quot;},{name: &quot;test2&quot;, value:&quot;value2&quot;, iconName:&quot;person&quot;}])}) 重启服务让其生效 1node index.js 7.3.2.2. 引入material icon相关模块, 并添加Material Icons样式首先在根模块app/app.module.ts中引入MatIconModule模块并添加到imports区域. 引入material icon 样式修改app/index.html, 添加样式单 1&lt;link href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot; rel=&quot;stylesheet&quot;&gt; 7.3.3. 修改html template, 让其显示图标1234567891011121314&lt;form class=&quot;example-form&quot;&gt; &lt;mat-form-field class=&quot;example-full-width&quot; appearance=&quot;fill&quot;&gt; &lt;mat-label&gt;Number&lt;/mat-label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Pick one&quot; aria-label=&quot;Number&quot; matInput [formControl]=&quot;myControl&quot; [matAutocomplete]=&quot;auto&quot;&gt; &lt;mat-autocomplete autoActiveFirstOption #auto&gt; &lt;mat-option *ngFor=&quot;let option of filteredOptions | async&quot; [value]=&quot;option.name&quot;&gt; &lt;mat-icon&gt;{{option.iconName}}&lt;/mat-icon&gt; &lt;span&gt;{{option.name}}&lt;/span&gt; &lt;/mat-option&gt; &lt;/mat-autocomplete&gt; &lt;/mat-form-field&gt;&lt;/form&gt; 8. 启动项目进入项目主目录, 启动项目观察效果. 当然你要可以在每个阶段性任务完成后, 启动项目查看效果. 1ng serve --open --port 4203 9. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 10. 参考文档Angular Material: How to Add a Type-Ahead Dropdown on a Web Form Angular Material Select Dropdown with Search Example How TO - Autocomplete 快速搭建web服务器提供api服务","link":"/material/material_typeahead.html"},{"title":"Material Design基础 - Pixel Density","text":"1. 像素密度(Pixel Density)一英寸屏幕上存在的像素数称为像素密度。 屏幕像素密度和分辨率因平台而异。 1.1. 屏幕密度变化高密度屏幕的每英寸像素数比低密度屏幕的多。因此，相同像素尺寸的UI元素在低密度屏幕上显示得更大，而在高密度屏幕上显示得更小。 1.2. 屏幕密度(screen density)要计算屏幕密度，可以使用以下等式：屏幕密度=以像素为单位的屏幕宽度（或高度）/以英寸为单位的屏幕宽度（或高度） 1.3. 密度无关性(Density independence)密度独立性指的是在不同密度的屏幕上统一显示UI元素。 1.4. 密度无关的像素(Density-independent pixels)密度无关的像素，写为dp（发音为“dips”），是一种灵活的单元，可以在任何屏幕上缩放以获得统一的尺寸。它们提供了一种灵活的方式来适应跨平台的设计。Material UI使用与密度无关的像素在不同密度的屏幕上一致地显示元素。 1.5. Android上的像素密度开发Android应用程序时，使用dp在不同密度的屏幕上均匀显示元素。 1.5.1. Dps和屏幕密度1dp等于屏幕密度为160的一个物理像素。要计算dp：dp=（像素宽度*160）/屏幕密度 Screen physical width Screen density Screen width in pixels Screen width in dps 1.5 in 120 180px 240dp 1.5 in 160 240px 240dp 1.5 in 240 360px 240dp 1.5.2. 可缩放像素（Scalable pixels (sp)）可缩放像素（sp）的功能与密度无关像素（dp）相同，但用于字体。sp的默认值与dp的默认值相同。sp和dp之间的主要区别在于sp保留用户的字体设置。具有更大的无障碍文本设置的用户将看到字体大小与其文本大小首选项匹配。 1.6. ios上的像素密度iOS使用逻辑分辨率确定密度，该分辨率以点为单位测量密度。 1.6.1. 逻辑分辨率 (Logical resolution)对于逻辑分辨率，使用本机比例因子缩放点，该因子映射到设备的本机分辨率（以像素为单位）。例如，在为iPhone X设计时，您将设计375 X 812点的逻辑分辨率。渲染时，图形硬件会对元素进行处理，以填充iPhone X的1125 X 2436像素屏幕。 1.6.2. iOS的单位为iOS设计时，使用点（pts）了解更多信息：苹果iOS在显示器上的文档PaintCode的iPhone分辨率指南 1.7. web上的像素密度1.7.1. 逻辑分辨率使用设备的逻辑分辨率，该分辨率与设备的屏幕分辨率成比例。 1.7.2. web单位在为web设计时，将dp替换为px（像素） 2. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 3. 参考文档Material System - layout pixel density","link":"/material/pixel_density.html"},{"title":"Material Design基础 - Surfaces","text":"1. Material SurfacesMaterial设计具有三个维度的特质，这些品质反映在其对表面(Surfaces)、深度和阴影的使用中。 1.1. Material environment在真实世界中，物体可以堆叠或相互接触，但不能相互传递。它们投射阴影并反射光线。 Material设计在Material UI 中如何显示和移动曲面来反映这些品质。表面以及它们在三维空间中的移动方式以类似于它们在物理世界中移动的方式进行通信。此空间模型还可以跨应用程序一致地应用。 1.2. 深度（Depth）Material UI 显示在使用光、曲面和投射阴影表示的三维 （3D） 空间的环境中。Material环境中的所有元素都以不同的深度沿 z 轴水平、垂直移动。深度是通过在沿正 z 轴向viewer延伸的各个点处放置元素来描述的。 在 Web系统， UI 通过操作 y 轴来表达 3D 空间。 1.3. Material 属性Material Surfaces在整个Material设计中具有一致、不可更改的特征和行为， 1.3.1. 维度Material 组件具有不同的x和y尺寸（以dp测量）和均匀的厚度（1dp）。 1.3.2. 阴影Material surfaces在不同高度投射阴影。 1.3.3. 分辨率Material具有无限的分辨率。 1.3.4. 内容（content）内容在Material以任何形状和颜色显示。内容不会增加材质的厚度。内容的表达不是单独的图层。 Material可以显示任何形状和颜色。内容的行为可以独立于Material，但仅限于Material的范围内。 内容的行为可以独立于surfaces的行为。 内容行为可能取决于Material的行为。 1.3.5. 物理属性Material是固体。用户输入和交互无法通过材料。 多个Material元素不能同时占据空间中的同一点。 Material不能穿过其他Material。例如，更改elevation时，一个材质曲面不能穿过另一个材质曲面。 Material的行为不像气体。 Material不像液体或凝胶那样是流动的，尽管它可能显示具有这些特性的内容。 1.3.6. Transforming MaterialMaterial可以改变形状。 Material可以更改不透明度。 Material仅沿其平面生长和收缩。 Material在 UI 的depth内弯曲或折叠。 Material表面可以连接在一起成为单个材料表面。 拆分时，Material可以重新加入。例如，如果从曲面中移除一部分材质，则曲面将再次变为完整。 1.3.7. MovementMaterial可以在环境中的任何地方自发产生或消除。Material可以沿任意轴移动。Material表面可以协调其运动。沿 z 轴的Material运动通常是用户交互的结果。 1.3.8. 属性基本Material表面 基本Material表面为不透明白色，厚度为 1dp，并投射阴影。Material设计中的所有 UI 元素都是通过修改此表面而产生的。行为 Material曲面可以以某种方式表现：曲面可以划分为显示不同类型行为的区域。 Material表面可以以某种方式表现： 刚性surfaces在所有交互作用中保持相同的大小。 可拉伸surfaces可以沿一条或多条边增大或收缩，直至达到尺寸限制，然后表现为刚性曲面。 可平移surfaces在整个交互过程中保持相同的大小。他们可以在该区域内滚动时显示其他内容，直到达到内容限制。当达到此限制时，它们在该滚动方向上表现为刚性曲面。 1.3.9. 组合surfacesurfaces可以划分为显示不同类型行为的区域。 单个urface可以包含多个可平移表面，例如独立于可滚动列表进行平移的嵌入地图 。 卡片可以拉伸以显示独立于其他卡片内容滚动的区域。 1.3.10. 可拉伸的surfaces可拉伸的surface可以在达到极限之前被拉伸，此时整个表面变得刚性。曲面可以垂直拉伸、水平拉伸或双向拉伸。 通常，用户与surface的交互会将其拉伸到一个方向。例如，点击“更多详细信息”可能会导致卡片垂直增长并显示其他内容。 1.3.11. 表面位置和移动（x/y）surfaces可以保持在 x 轴和 y 轴上的固定位置，也可以沿任何方向移动。 surfaces运动可以限制在单个轴上，允许一次沿单个轴移动，或允许同时沿两个轴(x/y轴)移动。 surfaces可以彼此独立移动，或者它们的移动可以影响或依赖于其他surfaces的移动。 依赖关系可以基于各种机制，例如当另一个surface膨胀时，附近的surfaces移动，或者在视差下移动的surfaces之间的运动比例。 1.3.12. Surface 透明度Material Surface可以是透明的、半透明的或不透明的。 透明和半透明表面上的文本可能需要背景处理以保持易读性。 透明曲面缺少清晰的边缘，因此很难确定曲面的起点和终点以及属于哪个曲面内容。 1.3.13. 纱幕（scrim）纱幕是以使表面上的内容不那么突出。它们有助于将用户的注意力引导到屏幕的其他重要部分。 纱幕可以以多种方式应用，包括： 使surface及其内容变暗或变亮。 减少表面及其内容物的不透明度。 一次在屏幕上显示多个表面可以显示纱幕。纱幕可以出现在任何立面上，无论是在前景中还是在背景中。 2. Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 3. 参考文档Material System - environment surfaces","link":"/material/surfaces.html"},{"title":"本地编译并启动 element-web","text":"Element-web（以前称为Vector和Riot）是一个使用Matrix React SDK构建的Matrix web客户端。 上一篇文章使用 Dendrite 搭建 Matrix Homeserver, 我们讲述了安装Matrix HomeServer的过程。 本文主要讲述如何在本地将其编译成docker镜像，并启动Element-web. 两种结合起来一个完整的聊天软件就建立起来了。 下载 element-web123git clone https://github.com/element-hq/element-web.git element-web 创建docker 镜像12345cd element-webgit checkout mastersudo docker build . 启动镜像查看编译好的镜像 12345$sudo docker image lsREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; dbf813e1740d 19 minutes ago 75.5MB 找到镜像的IMAGE ID， 使用镜像ID启动element-web 容器 123sudo docker run -p 80:80 dbf813e1740d 浏览器访问element-web浏览器访问http://localhost 参考文档Installing Element Web","link":"/matrix/build_element-web_on_local.html"},{"title":"Material Design 基础 - 文字排版","text":"1. 文字系统 （The type system）使用排版尽可能清晰有效地呈现您的设计和内容。 1.1. 文字类型标尺(Type scale)质感设计的文字类型标尺包括一系列对比样式可满足产品及其内容的需求。 文字类型标尺是文字系统支持的十三种样式的组合。它包含可重用的文本类别，每个类别都有预期的应用和含义。 1.2. 文字类型标尺生成器文字类型标尺生成器是用于创建类型刻度和相应代码的工具, 该生成器由Google字体 提供支持。您选择的任何字体都会根据Material排版指南自动调整大小和优化，以提高可读性。 在文字类型标尺中选择一个类别以查看字体的详细信息。通过右侧的菜单调整字体选择。 1.3. 文字类型标尺样例此示例文字刻度将 Roboto 字体用于所有标题、字幕、正文和字幕，从而创建具有凝聚力的排版体验。层次结构通过字体粗细（浅、中、常规）、大小、字母间距和大小写的差异来传达。 Scale Catagory 字体(Typeface) 粗细(weight) 字号(Size) 大小写 字母间距(Letter spacing) H1 Roboto Light Sentence -1.5 H2 Roboto Light Sentence -0.5 H3 Roboto Regular Sentence 0 H4 Roboto Regular Sentence 0.25 H5 Roboto Regular Sentence 0 H6 Roboto Medium Sentence 0.15 Subtitle 1 Roboto Regular Sentence 0.15 Subtitle 2 Roboto Medium Sentence 0.1 Body 1 Roboto Regular Sentence 0.5 Body 2 Roboto Regular Sentence 0.25 BUTTON Roboto Medium All caps 1.25 Caption Roboto Regular Sentence 0.4 OVERLINE Roboto Regular All caps 1.5 字母间距值与Sketch兼容, Sketch 是用于数字设计的一体化平台 — 具有协作设计工具、原型设计和开发人员交接. 1.4. 字体大小单位以下单位用于在 Android、iOS 和 Web 上表示字体大小。 平台 Android iOS Web 字体单位 sp pt rem 转换率 1.0 1.0 0.0625 (1/16) 转换示例 Android iOS Web 10sp 10pt 0.625rem 12sp 12pt 0.75rem 24sp 24pt 1.5rem 60sp 60pt 3.75rem Web 浏览器根据根元素大小计算 REM（root em 大小）。现代 Web 浏览器的默认值为 16px，因此转换为 SP_SIZE/16 = rem。 1.5. 字母间距以下单位用于 UI 中的字母间距。 Platform Android iOS Web 字母间距单位 em pt rem 转换率 (Sketch字距 / 字体大小 (sp)) = 字母间距 1.0 (Sketch字距 / 字体大小(px)) = 字母间距 字母间距转换示例 Android iOS Web (.2 tracking / 16sp font size) = 0.0125 em -0.1 pt (.2 tracking / 16px font size) = 0.0125 rem 2. 应用文字类型标尺文字类型标尺在组件和整体布局中显示为文本。文字属性可以对字体、字体、大小写、大小和字母间距使用自定义值。 2.1. 标题（headlines）在文字类型标尺中，标题的范围从 1 到 6。标题是屏幕上最大的文本，保留用于简短的重要文本或数字。 对于标题，您可以选择富有表现力的字体，例如艺术字、手写或脚本样式。这些非常规的字体设计具有有助于吸引眼球的细节和复杂性。 2.2. 子标题(subtitles)子标题比标题小。它们通常保留给长度较短的中等重点文本。serif或sans serif字体适用于字幕。对于字幕，使用富有表现力的字体（包括艺术字、手写字体和脚本样式）时要小心,由于字体较小， 可读性会变差。 2.3. 正文正文文本的范围为 1-2，通常用于长格式书写，因为它适用于小文本大小。对于较长的文本部分，建议使用serif或sans serif字体。不要使用富有表现力的字体，包括艺术字、手写字体作为正文。 2.4. 说明文字和上划线文本说明文字和上划线文本（上面有一行的文本）是最小的字体大小。它们很少用于注释图像或引入标题。不要使用富有表现力的字体，包括艺术字、手写字体作为说明文字和上划线文本。 2.5. 按钮文本按钮文本是不同类型的按钮（如文本、轮廓和包含的按钮）以及选项卡、对话框和卡片中使用的号召性用语。按钮文本通常使用sans serif字体的全大写字母形式。 不要使用富有表现力的字体作为按钮文本，包括艺术字、手写和脚本样式。 3. 理解排版3.1. 文字属性字体是字母的集合。每个字母都是唯一的，某些形状在字母之间共享。字体表示字母集合中的共享模式。 根据其样式、易读性和可读性选择的字体在遵循排版设计的基本原则时最为有效。 字母形状部件的名称: aperture光圈, ascender, baseline基线, cap height, descender, leading行距, letter-spacing 字母间距, sans serif, serif, stem词干, stroke笔画, x-height (x 高度) 3.2. 基线(baseline)基线是文本行所依赖的不可见行。在质感设计中，基线是测量文本和元素之间垂直距离的重要规范。无论是使用 pt / sp 作为字体的单位，文本的基线都必须位于 4dp 网格上。行高必须是可被 4 整除的值才能维持4dp基线网格。 3.2.1. 从基线测量指定与 UI 元素与基线的距离。基线值与软件无关，因此它们适用于任何设计程序，并与网格一起使用。在 Android 和 iOS 上，代码可以从基线相关的规范转换为填充。对于 Web，使用 Sass 或 CSS 自动执行计算。 3.3. 大写字母高度（Cap height）大写字母高度是指从基线开始测量字体中大写字母（如 M 或 I）的高度。圆形和尖头大写字母（如 S 和 A）通过绘制在大写字母高度上方的轻微过冲进行光学调整，以达到相同尺寸的效果。每种字体都有一个独特的大写高度。 3.4. X高度X高度是指字体中小写 x 的高度，x 是字体中一个非常特色的字母，他是左右对称， 而且有中心点，占比均衡的之母， 它表示字体中每个字形的高矮。 具有高 x 高度的字体在小字体下具有更好的易读性，因为每个字母中的空白区域更清晰。 3.5. 顶线和底线(Ascenders 和 descenders)顶线是字体盒子的上边缘，在某些小写字母中向上垂直笔画，其延伸范围向上超出了大写字母高度线直达顶线。底线是字体盒子的下边缘，有些字母的笔画底部笔画会会超出基线直达底线。在某些情况下，当线条高度（基线之间的垂直距离）太紧时，可能会发生顶线越过上一行底线的现象。 3.6. 字体粗细(Weight)粗细是指字体笔划的相对粗细。字体可以有很多Weight;典型字体一般会有4-6种粗细不同的字体。常用粗细: 细 常规 中等 粗体 4. 字体分类4.1. 衬线体(Serif)名词解释: 衬线字体，意思是在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。另外，无衬线体在中文通常称为黑体.无衬线体是无衬线字体，没有这些额外的装饰，而且笔画的粗细差不多。用途: 在传统印刷中，衬线字体用于正文印刷，因为它被认为比无衬线体更易于阅读，是比较正统的。相对的，无衬线体用于短篇和标题等，能够引起读者注意，或者提供一种轻松的气氛。一般来说，人们倾向在长篇文章中使用衬线字体，如书籍、报纸和杂志等等。虽然在欧洲比北美更经常使用无衬线体，但在正式场合衬线字体还是使用最多的类型。 印刷制品更多趋向使用衬线字体以方便阅读，但是在计算机领域中倾向使用无衬线字体以方便在显示器上显示。此外，衬线字体從審美角度較為正式優美，然從眼睛的感受並不及不採用襯線的黑體字，因為襯線體在筆劃上有過多的點綴（筆劃末端的小三角）很容易造成視覺疲勞（尤其是顯示在螢幕上時）。出于上述原因，大部分网页使用无衬线字体。因此，Windows Vista中的中文預設字体已经从原来的衬线字体（宋体或细明体）改变成了无衬线字体（微软雅黑或微软正黑体）。另外，为了更好解决衬线字体的显示问题，新的反锯齿和次像素显示（如ClearType）等技术开始广泛运用。但是目前最一般的显示器解析度也不过每英寸100像素，这是屏幕显示衬线体可读性的瓶颈所在。 衬线字体分为以下几种类型: 旧体衬线体（英語:old style） 类似于墨水书写，带有: 粗描边和薄描边之间的对比度低笔画中的对角线应力小写上升器上的倾斜衬线 *过渡衬线体（Transitional）具有: 粗描边和薄描边之间的高对比度中高 x 高笔画中的垂直应力带括号的衬线 Didone或新古典主义衬线具有: 厚描边和薄笔触之间的对比度非常高笔画中的垂直应力“球”末端行程。 Slab衬线具有: 重衬线笔画粗细变化不明显最少或无包围曝光 4.2. 无衬线体(sans serif)没有衬线的字体被称为无衬线字体，来自法语单词“sans”，意思是“没有”。完全抛弃装饰衬线，只剩下主干，造型简明有力，更具现代感，起源也很晚。适用于标题、广告，瞬间的识别性高。无衬线可归类为以下几种类型: 早期的无衬线体（Grotesk，哥德体）:厚描边和薄描边之间的对比度低，垂直或无可观察到的应力人文无衬线体:厚薄笔触之间的中等对比度，倾斜的应力几何:厚描边和薄描边之间的对比度低，具有垂直应力和圆形圆形 4.3. 等宽字体(Monospace)等宽字体显示具有相同宽度的所有字符。 4.4. 手写体手写字体是非常规的，具有自然的手写感觉。这些通常在类型刻度中用作 H1 - H6。它们具有以下形式: 黑色字母:高对比度，窄，具有直线和棱角分明的曲线草体:复制书法写作风格（更正式）手写:复制手写内容（不太正式） 4.5. 艺术体仅适用于在较大点大小下使用的所有分类类型的杂项类别。显示字体通常在文字刻度中用作 H1 - H6。 5. 可读性可读性由字体中的字符决定，可读性是指阅读单词或文本块的难易程度，这受字体样式的影响。 5.1. 字母间距 Letter-spacing字母间距（Letter-spacing）也称为tracking，是指对一段文本中字母之间的间距。较大的文字大小（如标题）使用更紧密的字母间距来提高可读性并减少字母之间对于较小的文字大小，较宽松的字母间距可以提高可读性，因为字母之间的空间越大，每个字母形状之间的对比度就越大。所有大写字母的文本（即使是小字体）都因其增加了字母间距而提高了可读性。 5.2. 表格数字在值可能经常更改的表或位置中使用表格数字（也称为等宽数字），而不是比例数字。表格数字使值保持光学对齐，以便更好地扫描。 5.3. 行长（Line Length）正文文本的行长度通常在 40 到 60 个字符之间。在行长较宽的区域（如桌面），包含最多 120 个字符的较长行需要将行高从 20sp 增加到 24sp。对于英文正文文本，理想的行长度为每行 40-60 个字符。短行英语文本的理想行长为每行 20-40 个字符。 5.4. 行高(Line Height)行高（也称为行距）控制文本块中基线之间的间距量。文本的行高与其文字大小成正比。 5.5. 段落间距(Paragraph spacing)将段落间距保持在文字大小的 .75x 和 1.25x 之间。 5.6. 类型对齐方式文字对齐方式控制文本在其显示空间中的对齐方式。有三种类型对齐方式: 左对齐:当文本与左边距对齐时右对齐:当文本与右边距对齐时居中对齐:当文本与设置文本的区域的中心对齐时 5.6.1. 左对齐左对齐文本是从左到右的语言（如英语）的最常见设置。 5.6.2. 右对齐右对齐文本是从右向左书写的语言（如阿拉伯语和希伯来语）最常用的设置。从左到右的语言可以使用右对齐的文本，尽管它最适合区分布局中的短版式元素（如侧注释），并且不建议用于长副本。 5.6.3. 居中对齐居中文本最适合用于区分布局中的短版式元素（如拉引号），不建议用于长副本。 6. 系统字体系统字体预安装在您的计算机或设备上。它们通常具有广泛的语言支持，并且开发人员无需支付许可成本。在应用字体中使用系统默认字体可将平台的一致性与应用的外观结合起来。但是，由于它们出现在设备上的许多位置，因此它们可能不会脱颖而出。 6.1. 使用系统字体本机系统字体应用于大型文本块和低于 14sp 的任何文本。 Roboto是Android的默认系统字体。对于 Android 和 Web 产品以外的平台，请使用该平台上首选的系统字体。例如，iOS应用程序应使用Apple的San Francisco字体。 7. 语言支持语言大小和显示样式因字符集是类似英语、高还是密集而异。 7.1. 语言注意事项7.2. 字形（glyphs）每种书面语言都使用自己的一组字符，称为字形glyphs。 如果你的 UI 使用多种语言，则你的版式布局应因语言而异。语言具有不同的平均单词长度和高度，这会影响它在 UI 中的显示方式 7.3. 长度不同语言的字长可能会有很大差异，即使是那些使用类似字形的语言，如英语和德语。 英语通常比其他欧洲语言短。例如，德语有许多较长的复合词，需要更多的行或行间距。 7.4. 对齐某些书写系统（如阿拉伯语和希伯来语）显示字符时从右到左显示。在相同的字体大小下，这些字体可能看起来比拉丁语字体小，需要调整行距和对齐方式，以便版式在所有语言的 UI 中都能正常工作。 7.5. 高度许多书写系统需要比英语更多的垂直空间，因此您的 UI 应为这些不同的系统提供足够的垂直空间。 7.6. 立式排版垂直排版虽然很少使用，但可以垂直而不是水平显示字符。 中国、日本和韩国的排版通常是等宽的，这意味着每个字母占用的空间与其他字母相同。它通常从左到右，从上到下设置。它也可以垂直设置:从上到下和从右到左。 7.7. 语言选项当每种语言使用不同的书写系统时，可能需要在同一 UI 中使用多个字体来显示多语言内容。 书写系统可分为三类: 类似英语（English-like）高（Tall）密集（Dense） 7.7.1. 类似英语的字体西欧，中欧和东欧以及非洲大部分地区的语言通常用拉丁字母书写。越南语是一个值得注意的例外，因为它使用拉丁书写系统的本地化形式，但其重音字形可能比西欧语言中的字形高得多。希腊语和西里尔文的书写系统与拉丁语非常相似。 7.7.2. 高字体需要额外行高以容纳较大字形的语言脚本，包括南亚、东南亚和中东语言，如阿拉伯语、印地语、泰卢固语、泰语和越南语。 7.7.3. 密集字体需要额外行高以容纳较大字形（包括中文、日语和朝鲜语）的语言文字。 7.8. Noto指导Noto 是 Roboto 未涵盖的所有语言的默认字体。它源自Droid，旨在通过兼容的高度和笔触厚度跨语言和脚本实现视觉和谐。该系列在 Unicode 版本 6.0 中定义了 93 个脚本。 7.9. 密集脚本注意事项Noto中文、日文和韩文 （CJK） 有七种与 Roboto 匹配的权重，其权重设置与英语相同。小于标题样式的文字大小应调整拉丁文字标尺。 7.10. 廋高文字注意事项Noto 支持南亚、东南亚和中东语言（包括阿拉伯语、印地语和泰语）中使用的高字。请使用常规粗细，因为中粗在 Noto 中不可用。避免使用粗体重量，因为粗体太重。 小于标题样式的文字大小应调整拉丁文字刻度。 较高的脚本行高度略大于基于拉丁语的字符。 7.11. 语言类别参考为了便于国际化，谷歌将语言分为三类:类似英语，高大和密集。 类似英语:拉丁语（越南语除外）、希腊语、西里尔文、希伯来语、亚美尼亚语和格鲁吉亚语。 高:需要额外行高以容纳较大字形的语言脚本，包括南亚、东南亚和中东语言，如阿拉伯语、印地语、泰卢固语、泰语和越南语。 密集:需要额外行高以适应较大字形但指标与高脚本不同的语言脚本。包括中文、日文和韩文。 Material Design 系列文章最新更新以及更多Material Design相关文章请访问 鹏叔的技术博客-Material Design 8. 参考文档成也排版败也排版:一个选择的过程The type system排版术语How to Properly Adjust Font Settings in Sketch衬线体","link":"/material/typography.html"},{"title":"使用 Dendrite 搭建 Matrix Homeserver","text":"Dendrite 是 Matrix 协议的一个开源实现，旨在提供一个轻量级、可扩展且易于部署的 Matrix 服务器。Matrix 是一个开源的通信协议和开放标准，用于构建去中心化的实时通信系统。它支持多种类型的通信，包括文本消息、语音通话、视频通话以及文件共享等。Dendrite 作为 Matrix 生态系统中的一个重要组件，为开发者和运营商提供了构建自己通信服务的工具。 1. 构建 dendrite12345git clone git@github.com:matrix-org/dendrite.gitcd dendritego build -o bin/ ./cmd/... 2. 准备数据库2.1. 创建角色创建一个 Dendrite 可用于连接数据库的角色，并在出现提示时选择一个新密码。 123sudo -u postgres createuser -P dendrite 2.2. 创建数据库使用上面的角色创建数据库 dendrite 123sudo -u postgres createdb -O dendrite -E UTF-8 dendrite 2.3. 连接字符串postgresql://dendrite:pass@localhost/dendrite?sslmode=disable 3. 生成签名密钥所有 Matrix 主服务器都需要一个签名私钥，用于验证联合请求和事件。 该 generate-keys 实用程序可用于生成私钥。假设 Dendrite 是使用 构建的go build -o bin/ ./cmd/...，您应该在 bin 文件夹中找到 generate-keys 该实用程序。 要生成 Matrix 签名私钥： 123# Generate a Matrix signing key for federation (required)$ ./bin/generate-keys --private-key matrix_key.pem 生成的 matrix_key.pem 文件是您的新签名密钥。 重要提醒：您必须将此密钥视为高度敏感和私密的密钥，因此切勿与任何人共享。任何人都不得以任何理由向您索要此密钥，即使是为了调试有问题的 Dendrite 服务器。确保安全备份此密钥。如果您将来想在同一域名上重新安装 Dendrite 或任何其他 Matrix 主服务器，则可能需要此密钥。如果您丢失此密钥，则可能无法加入房间。 4. 配置 DendriteYAML 配置文件用于配置 Dendrite。Dendrite 存储库的顶层有一个示例配置文件： dendrite-sample.yaml您需要复制示例，例如 dendrite.yaml。 12345# Copy and modify the config file - you'll need to set a server name and paths to the keys# at the very least, along with setting up the database connection strings.$ cp dendrite-sample.yaml dendrite.yaml 然后根据您的安装进行定制。至少，您需要填充以下部分： 服务器名称 首先，您需要配置 Matrix 主服务器的服务器名称。该名称必须与您在配置域名委派时选择的域名相匹配。 在 global 部分中，将设置 server_name 为您的委托域名： 12345global: # ... server_name: example.com 服务器签名密钥 接下来，您应该告诉 Dendrite 在哪里找到您的服务器签名密钥。 在 global 部分中，将 设置 private_key 为服务器签名密钥的路径： 123global: # ... private_key: /path/to/matrix_key.pem 使用全局连接池的数据库连接 如果要对单个 PostgreSQL 数据库使用单个连接池，则必须取消注释并配置 database 该 global 部分内的部分： 1234567global: # ... database: connection_string: postgres://user:pass@hostname/database?sslmode=disable max_open_conns: 90 max_idle_conns: 5 conn_max_lifetime: -1 5. 启动 dendrite完成所有准备和安装步骤后，您可以通过执行二进制文件来开始 Dendrite 部署 dendrite： 123456789101112# Generate a self-signed certificate (optional, but a valid TLS certificate is normally# needed for Matrix federation/clients to work properly!)$ ./bin/generate-keys --tls-cert server.crt --tls-key server.key# Build and run the server:$ ./bin/dendrite --tls-cert server.crt --tls-key server.key --config dendrite.yaml# Create an user account (add -admin for an admin user).# Specify the localpart only, e.g. 'alice' for '@alice:domain.com'$ ./bin/create-account --config dendrite.yaml --username alice 默认情况下，Dendrite 将在端口 8008 上监听 HTTP。如果要更改 Dendrite 监听的地址或端口，可以使用-http-bind-address 和-https-bind-address 命令行参数： 1234./bin/dendrite --tls-cert server.crt --tls-key server.key \\ -really-enable-open-registration \\ --config dendrite.yaml \\ 因为是测试运行dendrite,所以带了really-enable-open-registration选项，省去一些复杂的配置。在正式环境中，不要这样做，尽量把相应的配置补上，将really-enable-open-registration选项去除掉。 让dendrite监听在指定端口的方法如下： 1234567./bin/dendrite --tls-cert server.crt --tls-key server.key \\ -really-enable-open-registration \\ --config dendrite.yaml \\ -http-bind-address 1.2.3.4:12345 \\ -https-bind-address 1.2.3.4:54321 安装 matrix 客户端测试使用 element web 进行验证 浏览器打开 https://app.element.io 修改 Homeserver 为http://localhost:8008 点击注册 注册成功后登陆， 创建房间。 update on 2024/08/10: 也可本地编译element-web，通过本地的element-web作为客户端访问Matrix Homeserver troubleshooting问题 1： 1FATA[0000] Shared secret registration is not enabled, enable it by setting a shared secret in the config: 'client_api.registration_shared_secret' 6. 参考文档Docke 搭建 Matrix Synapse Homeserver Building/Installing Dendrite Preparing database storage Configuring Dendrite matrix-js-sdk","link":"/matrix/setup_matrix_homeserver.html"},{"title":"使用WireGuard内网穿透","text":"1. 前言WireGuard 是由 Jason Donenfeld 等人用 C 语言编写的一个开源 威屁恩 协议，被视为下一代 威屁恩 协议，旨在解决许多困扰 IPSec/IKEv2、Open威屁恩 或 L2TP 等其他 威屁恩 协议的问题。它与 Tinc 和 MeshBird 等现代 威屁恩 产品有一些相似之处，即加密技术先进、配置简单。从 2020 年 1 月开始，它已经并入了 Linux 内核的 5.6 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。 1.1. WireGuard 优点配置精简，可直接使用默认值只需最少的密钥管理工作，每个主机只需要 1 个公钥和 1 个私钥。就像普通的以太网接口一样，以 Linux 内核模块的形式运行，资源占用小。能够将部分流量或所有流量通过 威屁恩 传送到局域网内的任意主机。能够在网络故障恢复之后自动重连，戳到了其他 威屁恩 的痛处。比目前主流的 威屁恩 协议，连接速度要更快，延迟更低。使用了更先进的加密技术，具有前向加密和抗降级攻击的能力。支持任何类型的二层网络通信，例如 ARP、DHCP 和 ICMP，而不仅仅是 TCP/HTTP。可以运行在主机中为容器之间提供通信，也可以运行在容器中为主机之间提供通信。 1.2. WireGuard 工作原理中继服务器工作原理中继服务器（Bounce Server）和普通的对等节点一样，它能够在 NAT 后面的 威屁恩 客户端之间充当中继服务器，可以将收到的任何 威屁恩 子网流量转发到正确的对等节点。事实上 WireGuard 并不关心流量是如何转发的，这个由系统内核和 iptables 规则处理。 如果所有的对等节点都是公网可达的，则不需要考虑中继服务器，只有当有对等节点位于 NAT 后面时才需要考虑。 在 WireGuard 里，客户端和服务端基本是平等的，差别只是谁主动连接谁而已。双方都会监听一个 UDP 端口，谁主动连接，谁就是客户端。主动连接的客户端需要指定对端的公网地址和端口，被动连接的服务端不需要指定其他对等节点的地址和端口。如果客户端和服务端都位于 NAT 后面，需要加一个中继服务器，客户端和服务端都指定中继服务器作为对等节点，它们的通信流量会先进入中继服务器，然后再转发到对端。 WireGuard 是支持漫游的，也就是说，双方不管谁的地址变动了，WireGuard 在看到对方从新地址说话的时候，就会记住它的新地址（跟 mosh 一样，不过是双向的）。所以双方要是一直保持在线，并且通信足够频繁的话（比如配置 persistent-keepalive），两边的 IP 都不固定也不影响的。 2. 安装wireguard2.1. 前提条件需要有公网IP, VPS, 而且公网IP需要直接绑定在VPS上,公网IP绑定在网关, 然后通过端口转发, 配置不能成功, 因为中继服务器必须知道对端的公网IP, 如果中继服务器放在网关后面, 对端IP对中继服务器来说已经不可见. 系 统: centos 7.x内核要求: &gt; 3.10 (uname -r) 三种安装方式, 根据具体情况任选其一 2.2. 安装方法 1: a signed module is available as built-in to CentOS’s kernel-plus12345sudo yum install yum-utils epel-releasesudo yum-config-manager --setopt=centosplus.includepkgs=kernel-plus --enablerepo=centosplus --savesudo sed -e 's/^DEFAULTKERNEL=kernel$/DEFAULTKERNEL=kernel-plus/' -i /etc/sysconfig/kernelsudo yum install kernel-plus wireguard-toolssudo reboot 2.3. 安装方法 2: users wishing to stick with the standard kernel may use ELRepo’s pre-built module1234sudo yum install epel-release elrepo-releasesudo yum install yum-plugin-elreposudo yum install kmod-wireguard wireguard-toolssudo reboot 2.4. 安装方法 3: users running non-standard kernels may wish to use the DKMS package instead1234sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmsudo curl -o /etc/yum.repos.d/jdoss-wireguard-epel-7.repo https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.reposudo yum install wireguard-dkms wireguard-toolssudo reboot 3. 服务器端配置3.1. 首先为wireguard节点创建密钥对12345678910111213141516## 进入wireguard的配置文件目录cd /etc/wireguard## 设置umask自动为私钥加上合适的权限umask 077# 为节点1生成私钥wg genkey &gt; node1_priv_key# 为节点1生成公钥wg pubkey &lt; node1_priv_key &gt; node1_pub_key## 查看公钥和私钥cat node1_priv_key &amp;&amp; cat node1_pub_key 创建wireguard节点1配置文件 /etc/wireguard/wg0.conf 12345678910111213[Interface]Address = 192.168.2.100DNS = 114.114.114.114PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADEPostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADEListenPort = 8888PrivateKey = private_key from node1_priv_key # 将上一步生成的private_key拷贝过来[Peer]PublicKey = zy3IkHgq6SdM ## Peer节点的公钥AllowedIPs = 192.168.2.101/32 说明:Address为wireguard新生成的网卡的IP地址;PostUp为wireguard服务启动后的执行的命令, 即一些iptables规则PostDown为wireguard服务关闭时需要清理的规则其中的参数eth0为网卡名称, 需要根据节点的实际情况替换ListenPort 可用为任意可用的端口, 只有中继服务器（Bounce Server）才需要配置, 其它节点不需要配置, 它主要是为了内网穿透时UDP打洞使用.服务启动后将监听在udp端口, 所以防火墙需要放开对应的UDP端口而不是TCP端口[Peer] 用来配置对端信息例如Node2PublicKey 为Node2的公钥AllowedIPs 为节点Node2的ip(单台主机) 或Node2节点的网段, 可参考为节点1生成密钥对 3.2. 启动node1123## 启动wireguardwg-quick up wg0 查查启动是否成功, 启动成功后, 使用ifconfig查看, 应该会多出一块wg0的网卡. 使用wg命令可用查看到wireguard的当前状态. 如果要重启, 使用如下命令组合 123456## 关闭wireguardwg-quick down wg0## 启动wireguardwg-quick up wg0 3.3. 设置为开机启动123systemctl enable wg-quick@wg0 通过服务启动wireguard 123systemctl start wg-quick@wg0 查看服务状态 123systemctl start wg-quick@wg0 查看日志 123journalctl -u wg-quick@wg0 3.4. 配置node2在配置node2之前需要在节点2上安装wireguard, 方法参照前面介绍的安装方法 说明, 我的节点都是Linux主机, 而且是redhat系列主机在windows, 安装方法稍有不同, 具体请参考官网的安装指南 创建配置文件/etc/wireguard/wg0.conf 1234567891011[Interface]Address = 192.168.2.40PrivateKey = node2_private_keyDNS = 114.114.114.114# 服务端配置[Peer]PublicKey = node1_public_keyAllowedIPs = 192.168.2.0/24Endpoint = 1.1.1.1:8888 ## 1.1.1.1代表公网IPPersistentKeepalive = 25 说明: Address 是Node2的地址, 和之前配置的Node1处在同一个网段PrivateKey: 为node2节点的私钥DNS: DNS服务器IPPublicKey: 为Node1的公钥AllowedIPs: Node1节点所处网段, 如果只允许Node1节点连接该节点可用指定Node1的IPEndpoint: 1.1.1.1 为公网IP, 替换成你自己的公网IPPersistentKeepalive: keepalive 时间, 单位秒, 这是断线后自动重连的关键. 3.5. 在Node2上启动wireguard启动wireguard的方法跟在Node1上启动wireguard的方法一样 123wg-quick up wg0 设置为开机启动 123systemctl enable wg-quick@wg0 4. 关联阅读frp内网穿透 更多网络相关请访问鹏叔的技术博客 - network 本文原文位于鹏叔的技术博客 - 使用WireGuard内网穿透, 需要获得最近更新及反馈问题请访问原文. 5. 参考文档WireGuard 官网 使用NPS搭建内网(穿透(保姆级教程) Centos 7 安装 Wireguard WireGuard 教程：WireGuard 的工作原理 基于Wireguard组网技术的内网穿透教程","link":"/network/Internal_network_penetration.html"},{"title":"解决GitHub访问不了的方法","text":"一直用的 GitHub，突然一下子不能访问了，最后发现是 DNS 解析的 IP 地址出了问题，按照以下方法修改又能访问 github 了。 最后发现是DNS解析被污染了，解析到了无法访问的ip地址，通过ipaddress等网站查询到正确的地址，采用本地解析的方式，最终解决了问题。 关于DNS解析污染参考这篇文章 在本地 host 文件中添加映射，步骤如下 用文本编辑器打开 hosts 文件，Windows 系统位于 C:\\Windows\\System32\\drivers\\etc\\hosts ，Linux 系统 /etc/hosts (其他系统请自行查阅) 打开http://tool.chinaz.com/dns (opens new window)或者 https://www.ipaddress.com (opens new window)， 这是两个查询域名映射关系的工具，我一般用后者 查询 github.com, raw.githubusercontent.com, github.global.ssl.fastly.net 和 assets-cdn.github.com 两个地址，以及其他请求失败的地址，获取 IP 反复多查几次，选择一个比较稳定，延迟较低的 TTL 按如下方式添加到 Host 文件 刷新 DNS 缓存，命令如下。 如果DNS解析正确了，但是依然访问不了，可能是IP被block了，此时方法一，多试几个ip, 运气好可能有一两个可以用的。方法二，需要借助魔法，魔法可以到我的首页去找，只能帮到这里了。 获取魔法可以到鹏叔的技术博客首页使用关键字“魔法”查找 123456789# Windows 清除DNS缓存内容ipconfig /flushdns# Windows 显示DNS缓存内容ipconfig /displaydns# Linux 系统systemctl restart nscd 最后，贴下我的 Host 文件，直接复制就可以使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Github# 13.229.188.59 github.com# 151.101.109.194 github.global.ssl.fastly.net140.82.112.3 github.com140.82.113.3 github.com151.101.1.194 github.global.ssl.fastly.net151.101.65.194 github.global.ssl.fastly.net151.101.129.194 github.global.ssl.fastly.net151.101.185.194 github.global.ssl.fastly.net151.101.100.133 assets-cdn.github.com192.30.253.119 gist.github.com199.232.4.133 assets-cdn.github.com199.232.68.133 raw.githubusercontent.com185.199.108.133 raw.githubusercontent.com185.199.109.133 raw.githubusercontent.com185.199.110.133 raw.githubusercontent.com185.199.111.133 raw.githubusercontent.com# StackOverFlow151.101.1.69 cdn.sstatic.net151.101.129.69 cdn.sstatic.net151.101.65.69 cdn.sstatic.net151.101.193.69 cdn.sstatic.net151.101.129.69 cdn.sstatic.net151.101.1.69 cdn.sstatic.net151.101.193.69 cdn.sstatic.net151.101.65.69 cdn.sstatic.net192.168.2.58 host.docker.internal192.168.2.58 gateway.docker.internal192.168.1.105 host.docker.internal192.168.1.105 gateway.docker.internal# Added by Docker Desktop192.168.2.65 host.docker.internal192.168.2.65 gateway.docker.internal# To allow the same kube context to work on the host and the container:127.0.0.1 kubernetes.docker.internal# End of section172.17.205.241 windows10.microdone.cn 参考文档解决 GitHub 访问不了的方法","link":"/network/dns_pollution_issue.html"},{"title":"frp内网穿透","text":"1. 前言frp 是一个开源、简洁易用、高性能的内网穿透和反向代理软件，支持 tcp, udp, http, https等协议。frp 项目官网是 https://github.com/fatedier/frp frp工作原理 服务端运行，监听一个主端口，等待客户端的连接； 客户端连接到服务端的主端口，同时告诉服务端要监听的端口和转发类型； 服务端fork新的进程监听客户端指定的端口； 外网用户连接到服务器端指定的端口，服务端通过和客户端的连接将数据转发到客户端； 客户端进程再将数据转发到本地服务，从而实现内网对外暴露服务的能力。 2. 前置条件想要配置frp穿透，首先必须先要有一台具有外网ip(即：可以从因特网访问)的服务器。配置教程主要分为两个部分，一是服务器端(外网服务器)的配置；二是客户端(内网服务器)配置。 3. 安装并配置frp服务器下载安装程序, 当前(2023/05/02)最新版本为0.48.0版本 123wget -O /tmp/frp_0.48.0_linux_amd64.tar.gz https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 解压frp压缩包 1tar -zxvf /tmp/frp_0.48.0_linux_amd64.tar.gz -C /usr/local 解压后文件目录结构如下 12345678910$ tree /usr/local/frp_0.48.0_linux_amd64//usr/local/frp_0.48.0_linux_amd64/├── frpc├── frpc_full.ini├── frpc.ini├── frps├── frps_full.ini├── frps.ini└── LICENSE 以frpc(c代表客户端client)开头的文件都是与frp客户端相关的可执行文件和配置, 如果只是配置frp服务器端可以将这些文件删除. 以frps开头的文件是frp服务端程序, 其中frps_full.ini里包含了frps完整的配置项, 而frps.ini是一个基础的配置, 未在配置文件中出现的选项都会使用默认值. 也即如果你完全精通了frp那么可以使用frps_full.ini逐项配置或调优, 如果你只是初入门frp, 建议使用frps.ini里面仅列出了用户必须修改或调整的选项. 同时创建两个软链接, 这样我们就不用将frps的安装目录添加到Path, 因为/usr/bin默认就在PATH路径中 12345ln -s /usr/local/frp_0.48.0_linux_amd64/frps /usr/bin/frpsmkdir -p /etc/frpln -s /usr/local/frp_0.48.0_linux_amd64/frps.ini /etc/frp/frps.ini 修改服务器端配置 vi frps.ini 123456789101112131415161718[common]# frp监听的端口，默认是7000，可以改成其他的bind_port = 7000# 授权码，请改成更复杂的token = 52010 # 这个token之后在客户端会用到# frp管理后台端口，请按自己需求更改dashboard_port = 7500# frp管理后台用户名和密码，请改成自己的dashboard_user = admindashboard_pwd = adminenable_prometheus = true# frp日志配置log_file = /var/log/frps.loglog_level = infolog_max_days = 3 此时可以使用命令行启动frp server了 123/usr/bin/frps -c /etc/frp/frps.ini 如果要设置为开机启动, 还需要自己准备service文件, 可以参考如下配置 vi /usr/lib/systemd/system/frps.service 123456789101112131415[Unit]Description=Frp Server Service # 服务描述After=network.target # frps 将会在 network.service 启动完毕之后再启动[Service]Type=simple # 不论进程是否启动成功，systemctl start 都执行成功User=nobody # 设置进程在执行时使用的用户Restart=on-failure # on-failure 表示仅在服务进程异常退出时重启RestartSec=5s # 设置在重启服务前暂停多长时间ExecStart=/usr/bin/frps -c /etc/frp/frps.ini # 在启动该服务时需要执行的命令行[Install]WantedBy=multi-user.target # 用于 systemctl enable 时创建软连接 设置开机启动 123systemctl enable frps 启动frp server 123456# 启动服务systemctl start frps# 查看服务状态systemctl status frps 4. 安装并配置frp客户端客户端安装在需要穿透内网的电脑上 安装过程与frp类似, 针对不同的操作系统有不同的安装包, 下载一个与想要穿透的主机操作系统匹配 123wget -O /tmp/frp_0.48.0_linux_amd64.tar.gz https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 解压frp压缩包 1tar -zxvf /tmp/frp_0.48.0_linux_amd64.tar.gz -C /usr/local 同时创建两个软链接, 这样我们就不用将frpc的安装目录添加到Path环境变量, 因为/usr/bin默认就在PATH路径中 12345ln -s /usr/local/frp_0.48.0_linux_amd64/frpc /usr/bin/frpcmkdir -p /etc/frpln -s /usr/local/frp_0.48.0_linux_amd64/frpc.ini /etc/frp/frpc.ini 修改客户端配置 vi /usr/local/frp_0.48.0_linux_amd64/frpc.ini 1234567891011server_addr = your_public_ip # 公网ipserver_port = 8000 # frp服务器监听端口token = 52010[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 # 来自远程端口6000的tcp请求将被转发到此客户端的22端口 此时可以使用命令行启动frp 客户端了 123/usr/bin/frpc -c /etc/frp/frpc.ini 如果要设置开机启动, 那么需要准备一个service文件并安装和启动它 vi /usr/lib/systemd/system/frpc.service 123456789101112131415[Unit]Description=Frp client Service # 服务描述After=network.target # frps 将会在 network.service 启动完毕之后再启动[Service]Type=simple # 不论进程是否启动成功，systemctl start 都执行成功User=nobody # 设置进程在执行时使用的用户Restart=on-failure # on-failure 表示仅在服务进程异常退出时重启RestartSec=5s # 设置在重启服务前暂停多长时间ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini # 在启动该服务时需要执行的命令行[Install]WantedBy=multi-user.target # 用于 systemctl enable 时创建软连接 5. 测试穿透是否配置成功在正式开始测试之前 服务器端防火墙需要放行7000, 7500, 6000端口 123456789# 放行外网连接服务器6000端口sudo firewall-cmd --permanent --add-port=6000/tcp# 放行frp 服务端口sudo firewall-cmd --permanent --add-port=7000/tcp# 放行frp dashboard端口sudo firewall-cmd --permanent --add-port=7500/tcp# 刷新防火墙配置sudo firewall-cmd --reload 测试成功后的效果, 访问公网ip:6000端口会被导向内网的主机的ssh服务上从而达到使用公网ip访问内网服务的效果 1ssh -p 6000 root@public_ip 客户端防火墙需放行22端口 6. 相关阅读frp内网穿透 更多网络相关请访问鹏叔的技术博客 - network 本文原文位于鹏叔的博客空间 - frp内网穿透, 若要获取最近更新, 请访问原文! 7. 参考文档frp配置内网穿透教程（超详细使用 systemd 管理 frp 服务","link":"/network/frp_install.html"},{"title":"Windows 上安装与配置 v2rayA","text":"本教程详细讲解了如何在 Windows 操作系统上安装并配置 v2rayA 这款科学上网软件。 对于Linux和Macos系统，可以参考这篇文章 2024最新 v2rayA 安装与配置教程 1. 安装 v2rayA在 Windows 操作系统上, 可以选择手动下载安装程序，根据安装向导进行安装，也可以使用 powershell 命令进行安装，详细过程如下。 1.1. 方式一： 手动安装v2rayA从v2rayA github release下载安装包，下载完成后双击安装程序按照安装向导进行安装。 1.2. 方式二：脚本安装v2rayA1234567# 打开powershell, 普通用户权限即可, 执行以下命令下载v2rayA安装文件，安装文件将会被保存在用户的下载目录下# 执行下载命令会弹出警告框，因为下载的是.exe文件，点击允许即可开始下载。powershell -c &quot;invoke-webrequest -uri https://ghproxy.net/https://github.com/v2rayA/v2rayA/releases/download/v2.2.4.6/installer_windows_inno_x64_2.2.4.6.exe -outfile Downloads\\installer_windows_inno_x64_2.2.4.6.exe&quot;# 下载完成后，开始安装Start-Process -FilePath &quot;Downloads\\installer_windows_inno_x64_2.2.4.6.exe&quot; -ArgumentList &quot;/silent&quot; 2. 如何使用 v2rayA？使用 v2rayA 分为以下步骤： 首先通过 v2rayA web 管理界面创建一个用于管理 v2rayA 的账号; 然后从机场服务商那里获得订阅，并导入订阅; 最后连接并启动节点。 完成这些即可畅通无阻的访问外网了。 2.1. 打开 v2rayA web 管理界面在浏览器中打开 v2rayA web 管理界面 http://localhost:2017/ 说明：如果 v2rayA 正常启动（启动有时需要等待几分钟）则会监听在 2017 端口，所有操作系统 v2rayA 管理方式都是一致的， 都是通过 WEB 界面进行管理。如访问 http://localhost:2017/ 2.2. 创建管理账号 在第一次进入页面时，你需要创建一个管理员账号，请妥善保管你的用户名密码。如果遗忘，可以使用 v2raya --reset-password 命令重置密码，重置前先停止v2raya。 2.3. 获取机场订阅 url可以从如下机场服务商列表中获取订阅或节点： 从以上机场服务商列表， 选择一个机场服务商，然后注册账号，购买订阅，最后在“我的订阅界面”可以获取到订阅url。 说明： 如果要使用 ChatGPT, 需要注意以下两点 a) 选择机场服务提供商时选择支持 ChatGPT 的服务提供商例如: 星辰 VPN 或者 可乐云，这种资源目前非常稀缺，实测以上机场服务商列表中“星辰 VPN”的多数节点(截至 2024-08-06)支持得很好，可乐云的多数节点对Chatgpt支持较好（截至 2024-07-20）。b) v2ray web 设置 =》透明代理/系统代理实现方式 =》需要设置为 tproxy（透明代理） 2.4. 导入订阅 url 或 节点 url根据以上指引获取到订阅 url 或节点 url 后，就可以导入订阅了，详细步骤参考以下截图。 点击导入按钮进入订阅或节点导入界面 可以选择导入订阅，导入订阅地址如下图所示： 订阅 URL 类似这样子: https://xxx.xxxx.com/api_version2/xxxxxxxx?sub=3&amp;extend=1 2.5. 连接节点连接节点 更新成功后，节点将显示在相应订阅的节点列表标签页。如上图所示成功导入了一个订阅后的界面。 切换到节点列表标签页，点击相应节点后面的“连接”按钮，可同时连接一个或多个节点，这也是 V2Ray 和 v2rayA 强大的地方。 说明： 虽然可以同时连接多个节点，但是这里不建议选择过多的节点，6 个以内为佳。 2.6. 启动节点导航到 SERVER 或订阅服务器 TAB 页，选择一个或多个节点后，启动该服务器。 连接成功后节点变为蓝色，如下图所示： 技巧与提示： 步骤 1，勾选一个或多个节点，此时界面上会出现 Ping 和 HTTP 按钮，点击相应按钮测试服务器ping值，以及http延时，以便快速找到可用节点。 步骤 2， 选择节点，在每个节点右侧有一个“选择”按钮，点击“选择”按钮选中节点，此时节点呈现柚红色，因为还未启动它们。 步骤 3，在页面左上角有个“就绪”按钮点击该按钮启动节点，节点呈现蓝色表示启动成功。 如果未呈现蓝色即未启动成功，请点击页面右上角点击日志查看问题详情。 节点呈现蓝色是能成功连接外网的基本要求，也即如果不是蓝色肯定连接不了外网，节点呈现蓝色后，还要检查其他要求包括：Ping值是否正常 和 HTTP 延迟是否正常，配置是否合理等。 2.7. 检查设置有时候节点已经正常启动已经呈现蓝色，但是仍然不能正常访问某些网站，这可能与具体设置有关系。此时可以参照下图推荐的设置进行调整，基本能成功访问。 说明： 如何理解这里的配置选项？ 首先了解端口分流规则。 v2rayA 是对 v2ray-core的一层包装，v2ray-core 的分流规则非常强大也非常复杂， 非专业人士很难理解这些规则。 v2rayA 在 v2ray-core 的复杂的分流规则的基础上，抽象出了两条基本规则，一条是大陆白名单模式，一条是GFWList模式，这两条规则基本能满足90%的科学上网需求， 如果需要更复杂的分流规则，v2rayA保留了routingA规则，几乎和v2ray-core的规则完全匹配，这样既简化了配置，又保持了v2ray的强大与灵活。 大陆白名单模式 和 GFWList模式的主要差别是，GFWList模式，仅根据被墙的域名名单判断应该走proxy（代理）还是 direct（直连） 大陆白名单模式会根据域名对应的ip获取到国家属性，如果是CN(中国)则直连，否则都走代理。所以使用v2rayA需要两个文件，一个是geosite.dat一个是geoip.dat这两个文件。 两者各有优劣，GFWList模式的优势是性能稍好，它少一次域名解析的过程和一次提取国别属性的运算，性能上有些许优势，它的劣势是使用者在访问国外网站时，不知道自己使用的是代理还是直连，有时以为自己在使用代理实际是直连。 使用大陆白名单模式的优势是访问国外的网站统一使用代理，不存在代理和直连混淆的状况， 但是由于多一次域名解析， 可能存在dns泄漏的问题， 所以在dns配置时一定要选择合适的选项， 后面会讲到。 然后要了解透明代理/系统代理实现方式 透明代理和系统代理都会将源ip修改为所使用的代理的ip, 而redirect则会保留请求的源 ip. 所以两者明显的差别是在访问外网时， 目标网站看到的ip地址不同，这点可以使用&lt;whoer.com&gt;来检测， 通过调整代理实现方式， 切换节点来观察ip的变化。 当访问一些对ip地址地域要求的网站时，可以通过调整代理实现方式来改变访问网站时的ip地址. 透明代理/系统代理 选项 这条是设定在何种情况下使用透明代理/系统代理， 具体规则含义可以参照端口分流规则。 防止 DNS 污染 其实不仅仅是防止dns污染，如果分流和代理模式选择了 大陆白名单时， 还要防止dns泄漏，关于什么是dns泄漏 以及dns污染，可以自行科普。 如果在使用了大陆白名单模式时，最好使用转发DNS请求，这样DNS请求是通过代理解析的，而不是通过本机dns服务器解析，从而避免泄漏。 这点可以使用 https://ipleak.net/ 或 https://whoer.com/ 检测， 当使用tproxy或者system proxy时， 如果一些被墙的网站有来自china的解析解析结果时，表示ip泄漏的风险。 其他选项比较容易理解，这里暂时不做过多解释。 3. 验证设置是否成功？打开浏览器访问https://www.google.com, 如果能成功访问则表示连接成功. 至此在单台主机上已经可以科学上网了，下面是一些进阶用法，如有需要可以参考。 4. 进阶用法4.1. 配置代理如果在局域网内，不仅本机可以访问外网，而且可以作为代理服务器让局域网内其他设备访问外网。 由于默认情况下 v2rayA 会通过核心开放 20170(socks5), 20171(http), 20172(带分流规则的 http) 端口。可以在设置=&gt;地址与端口 页面修改端口. 如果是需要为局域网中的其他机器提供代理，请在设置中打开“局域网共享”，并检查防火墙开放情况。开启防火墙参考前面章节 - 开启远程管理 使用代理的方法比较简单，只需要添加如下两个环境变量即可。 在 windows 操作系统上, 打开环境变量配置界面，添加如两个环境变量。 12http_proxy=&quot;http://server_ip:20171&quot;https_proxy=&quot;http://server_ip:20171&quot; 4.1.1. 透明代理 这种方法是 v2rayA 推荐的方法。它相比于其他方法具有诸多优势，v2rayA 可以一键开启透明代理，为几乎所有程序提供代理服务。 在设置中选择透明代理的分流方式，以及实现方式，然后保存即可。 注意，如需选择 GFWList，需要下载对应的规则库，请点击右上角的更新以完成下载。 4.1.2. 系统代理系统代理可为主动支持代理的程序提供代理服务。在不同的桌面环境中设置的位置不尽相同，请通过搜索引擎自行搜索。 5. 特别说明工具本无善恶, 正与邪取决与使用工具的人, 主体是人. 请将工具用于正道, 切莫用于邪道给自己带来灾殃. 最后如果你能成功访问某 tube, 一篇关于安全方面的知识的值得首先了解一下. 转载会给您带来不必要的麻烦, 所以本文禁止转载. function jsfun(url) { window.open(url,'_blank'); } let url = 'https://i.airplanehub.xyz/' let out_li = ' \\\\\\\\\\\\\\\\&ensp;机&ensp;场&ensp;服&ensp;务&ensp;商&ensp;列&ensp;表 &ensp; (click me) ' document.getElementById('airport_node_list').innerHTML = out_li;","link":"/network/install_v2rayA_on_Windows.html"},{"title":"如何在 Almalinux 上为 Nginx 安装TLS&#x2F;SSL证书并开启自动续订","text":"Let’s Encrypt 是一家证书颁发机构 (CA)，它提供了一种获取和安装免费 TLS/SSL 证书的简便方法，从而在 Web 服务器上启用加密 HTTPS。它通过提供软件客户端 Certbot 来简化流程，该客户端尝试自动执行大多数（如果不是全部）所需步骤。目前，在 Apache 和 Nginx 上，获取和安装证书的整个过程都是完全自动化的。 在本教程中，我们将使用 Certbot 为 Almalinux 9 上的 Nginx 获取免费的 SSL 证书，并将证书设置为自动更新。 1. 先决条件要遵循本教程，您需要： 一台安装了 Almalinux 9 的服务器或者虚拟机，包括启用 sudo 的非 root 用户。如果您还未获取该条件，可以参考以下文章安装一台运行 Almalinux 的设备Almalinux 安装与使用 注册域名。您可以从 Namesilo.com 购买域名，使用 Freenom 免费获取域名，或使用您选择的域名注册商。 为您的服务器设置以下两个 DNS 记录， 通篇以域名 example.com 为例。 一条 A 记录可以将 example.com 解析为您服务器的公网 IP 地址。 一条 A 记录可以将 www.example.com 解析为您服务器的公网 IP 地址。 2. 安装 Certbot使用 Let’s Encrypt 获取 SSL 证书的第一步是在您的服务器上安装 Certbot 软件。 使用 dnf 安装 Certbot 及其 Nginx 插件： 123sudo dnf install certbot python3-certbot-nginx Certbot 现在可以使用了，但为了使它能够自动为 Nginx 配置 SSL，我们需要验证一些 Nginx 的配置。 3. 确认 Nginx 的配置Certbot 需要能够在 Nginx 配置中找到正确的 server 区块，才能自动配置 SSL。具体来说，它通过查找 nginx 配置中 server_name 指令，找到与需要申请证书的域来确定 server 区块。 如果您按照 Nginx 安装教程中的服务器块设置步骤进行操作，那么您应该已经为您的域名配置了一个 server 区块，并且已经正确设置了 server_name 指令。 要检查，请使用您喜欢的文本编辑器打开您的域的配置文件， 找到现有的 server_name 行。它应该如下所示： /etc/nginx/sites-available/example.com 1server_name example.com www.example.com; 如果是，请退出编辑器并继续下一步。 Certbot 现在可以找到正确的 server 块并自动更新它。 接下来，让我们更新防火墙以允许 HTTPS 流量。 4. 允许 HTTPS 通过防火墙1sudo firewall-cmd --list-all 确保 80 端口和 443 端口正常开启。 接下来，让我们运行 Certbot 并获取我们的证书。 5. 获取 SSL 证书 并配置 NginxCertbot 提供了多种通过插件获取 SSL 证书的方法。Nginx 插件将负责重新配置 Nginx 并在必要时重新加载配置。要使用此插件，请输入以下内容： 123sudo certbot --nginx -d example.com -d www.example.com certbot 将于与 nginx 插件一起运行，为由选项-d指定的域名获取有效的证书。 如果是首次运行 certbot，系统将提示您输入电子邮件地址并同意服务条款。完成后，certbot 将与 Let’s Encrypt 服务器通信，然后运行质询以验证您是否对您申请证书的域有控制权。 如果成功，certbot 将会询问您如何配置 HTTPS 设置。 1234567891011OutputPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you're confident your site works on HTTPS. You can undo thischange by editing your web server's configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate number [1-2] then [enter] (press 'c' to cancel): 选择您的选择然后点击 ENTER。配置将被更新，并且 Nginx 将重新加载以获取新设置。certbot 将出现一条消息，告知您该过程已成功以及您的证书存储在哪里： 12345678910111213141516OutputIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/example.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/example.com/privkey.pem Your cert will expire on 2020-08-18. To obtain a new or tweaked version of this certificate in the future, simply run certbot again with the &quot;certonly&quot; option. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 您的证书已下载、安装并加载。在浏览器中重新加载您的网站，并注意浏览器的安全指示器。它应该通常带有锁定图标表明该网站已得到妥善保护。 如果您使用SSL Labs 服务器测试该网站, 应该能够获得 A 级。 如果安装证书过程中有错误，可以修复错误后再运行如下命令，进行配置， 直到成功。 1certbot install --cert-name example.com 6. 验证 Certbot 自动续订Let’s Encrypt 的证书有效期仅为 90 天。这是为了鼓励用户自动执行证书续订流程。certbot 我们安装的软件包通过添加 systemd 计时器 来帮我们处理这个问题，该计时器每天运行两次，并自动续订任何在 30 天内到期的证书。 您可以使用以下命令查询计时器的状态 systemctl： 123456789$ sudo systemctl status certbot.timerOutput● certbot.timer - Run certbot twice daily Loaded: loaded (/lib/systemd/system/certbot.timer; enabled; vendor preset: enabled) Active: active (waiting) since Mon 2020-05-04 20:04:36 UTC; 2 weeks 1 days ago Trigger: Thu 2020-05-21 05:22:32 UTC; 9h left Triggers: ● certbot.service 要测试更新过程，您可以进行如下试运行 certbot： 123sudo certbot renew --dry-run 如果您没有看到任何错误，则一切就绪。必要时，Certbot 将更新您的证书并重新加载 Nginx 以获取更改。如果自动更新过程失败，Let’s Encrypt 将向您指定的电子邮件发送一条消息，在您的证书即将过期时提醒您。 7. 参考文档How To Secure Nginx with Let’s Encrypt on Ubuntu 20.04","link":"/network/secure_nginx_with_let_s_encrypt_on_almalinux.html"},{"title":"2024 科学上网秘籍：v2rayA 安装与配置指南 for Windows、Linux、Macos、Android","text":"本教程详细讲解了如何在 Windows, debian 系列和 redhat 系列 Linux 操作系统, 以及 Macos 系统上安装并配置 v2rayA 这款科学上网、魔法上网软件。 由于本文涵盖的范围较广，虽然已经做了精简，篇幅仍然偏长。Windows 上安装 v2rayA 相对简单，用户可以直接使用精简版教程 Windows 上安装与配置 v2rayA。 Android 用户可以使用教程 Android 手机上安装与配置 v2rayNG 实际安装与配置过程中，可以快速略过某些与您的当前操作系统不相关的操作步骤。 1. V2Ray 介绍在正式开始安装之前我们先简要介绍一下 v2rayA 以及其核心 v2ray，以便有一些基本了解，方便理解后续安装和配置过程。如果您对 v2ray 已有了解，完全可以跳过本节，进入下一章节。 V2Ray 是一个支持多种协议的代理上网软件。 它可以使用多种协议进行数据传输，包括 VMess、Trojan、Shadowsocks 等。 是 Victoria Raymond 以及其社区团队开发的 Project V 下的代理上网软件。 Project V 是一个工具集合，号称可以帮助其使用者打造专属的基础通信网络。 Project V 的核心工具称为 V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。 V2Ray 可以单独运行，也可以和其它工具配合，以提供简便的操作流程。 开发过程主要使用 Go 语言，Core 采用 MIT 许可证并开放源代码。 VMess 是 V2Ray 的核心协议, 也是 V2Ray 的默认协议，是 V2Ray 的主要开发方向。 VMess 具有较高的性能、安全性和抗封锁能力。 1.1. 什么是梯子？梯子又叫做机场是一种网络服务商，专门提供翻墙服务、科学上网或者魔法上网服务，如 Shadowsocks、V2ray、Trojan、Hysteria 等翻墙协议的节点服务器。 之所以又称它们为机场，是因为这些服务最初使用的 Shadowsocks (简称 SS) 和 ShadowsocksR (简称 SSR) 协议，其客户端图标是一架纸飞机。 用户通过将这些节点服务器订阅文件输入到飞机（即 Shadowsocks 客户端）中，从而实现绕过网络封锁达到魔法上网的目的。 目前，大多数机场能够提供针对 GWF 防火墙的全协议节点服务，但它们在速度、安全性和稳定性方面存在差异。 总的来说，机场提供了一种特殊的、加密的上网方式，相对比 VPN 更适合中国大陆科学上网和翻墙使用，梯子工具长期提供外网加速器。 1.2. v2rayA 与 VPN 的关系v2rayA 和 VPN 都是可以用于保护您的在线隐私和安全的工具。但是，它们的工作方式不同，并且具有不同的优势和劣势。 VPN 是虚拟专用网络，它本来是一种组网技术，这种组网技术正好可以用于绕过防火墙的限制。可以将其划归于第二代翻墙技术。 而 Shadowsocks, ShadowsocksR 以及 v2ray 则是因防火墙而生的，其本质上是一种代理上网技术。相较于传统 VPN，它能更好消除数据包中的特征，从而绕过主动或被动 censorship，提供更强的隐私保护。在复杂的网络环境下（如大规模的封锁或干扰）表现更好，可以将其划归于第三代翻墙技术。 虽然同属于第三代翻墙技术， v2ray 这位后起之秀相较于 Shadowsocks 拥有更广泛的协议支持，更高的隐私安全。限于篇幅原因这里不具体展开。 1.3. V2Ray 与 v2rayA 的关系v2rayA 是一个基于 V2Ray 内核的客户端软件，它支持 Windows、Mac、Linux 等平台。 v2rayA 的功能非常强大，可以根据用户的需求进行自定义配置。 1.4. V2Ray 与 Xray 的关系2020 年 11 月，因为开源许可证等原因 XTLS 被 V2Ray 社区从 V2ray core 移除， VLESS 及 XTLS 的作者和支持者基于 V2Ray 另行组建了 Project X 组织。 开发了基于 V2Ray 的衍生版本 Xray。该软件完全兼容 V2Ray 的配置文件和传输协议。 1.5. V2Fly 与 V2Ray 的关系由开源社区 v2ray/v2ray-core 原作者失踪后，其他维护者没有完整权限。 为了方便维护，社区创建了新的 organization：github.com/v2fly。 2. 安装 v2rayA安装与配置过程分为以下几个步骤: 首先安装 v2ray 内核 然后安装 v2rayA(客户端)， 配置 v2rayA 配置以及连接机场节点。 对于 Windows 系统，安装和配置步骤更精简一些。如果您的操作系统是 Windows， 可以直接跳转到精简版安装教程 Windows 上安装与配置 v2rayA 2.1. 安装 v2ray-core 内核（windows 系统可跳过此步骤）因为 Windows v2rayA Installer 自带了 v2ray 内核，对于 Windows 系统可以跳过内核安装这一步骤。 对于 Linux 和 macOS 操作系统则仍然需要先安装 v2ray-core 内核 下载过程中如果遇到 github 不能访问的情况，方法 1：可以通过 github 代理 https://ghproxy.net/ 下载方法 2: 可尝试使用文章-解决 GitHub 访问不了的方法中介绍的方法。 2.1.1. Linux 上下载并安装 v2ray 内核（Debian 和 Redhat 系列 linux 通用）12345678910111213141516## 下载v2ray-core，并保存到tmp目录$ wget -O /tmp/v2ray-linux-64.zip https://ghproxy.net/https://github.com/v2fly/v2ray-core/releases/download/v5.13.0/v2ray-linux-64.zip# 核对文件的指纹信息, 如果与以下输出一致则表示，否则请谨慎安装。# 指纹信息可以在https://github.com/v2fly/v2ray-core/releases/download/v5.13.0/v2ray-linux-64.zip.dgst中找到$ openssl dgst -SHA2-256 /tmp/v2ray-linux-64.zipSHA2-256(/tmp/v2ray-linux-64.zip)= 0341c1bf809afd42016d748e2e7e68a9b3c6aad501529794ad56a877a7ba75aa# 将其解压到/usr/local/v2ray-core， 需要root权限sudo unzip /tmp/v2ray-linux-64.zip -d /usr/local/v2ray-core# 将.dat文件拷贝到/usr/local/share/v2ray/sudo mkdir -p /usr/local/share/v2ray/sudo mv /usr/local/v2ray-core/*dat /usr/local/share/v2ray/ 2.1.2. Macos 上下载并安装 v2ray 内核123456789101112131415161718# （Macos only）下载v2ray-core，并保存到tmp目录$ sudo curl -L https://ghproxy.net/https://github.com/v2fly/v2ray-core/releases/download/v5.13.0/v2ray-macos-64.zip -o /tmp/v2ray-macos-64.zip# 核对文件的指纹信息, 如果与以下输出一致则表示，否则请谨慎安装。# 权威指纹信息可以在github release download 同级目录下找到。$ openssl dgst -SHA2-256 /tmp/v2ray-macos-64.zip SHA2-256(/tmp/v2ray-macos-64.zip)= ba136059e5d8957f103124e6f6ad3a7fd9bcd74a9c3818bc4950350a770f4467# 解压缩并将文件拷贝到/usr/local下的相应目录unzip /tmp/v2ray-macos-64.zip -d /tmp/v2ray-coresudo mv /tmp/v2ray-core/v2ray /usr/local/bin/sudo mv /tmp/v2ray-core/*dat /usr/local/share/v2ray/# 授予v2ray可执行权限sudo chmod 755 /usr/local/bin/v2ray 2.2. 安装 v2rayA针对不同的操作系统，请参考不同的安装步骤。 2.2.1. Windows 上安装 v2rayA在 Windows 操作系统上, 可以手动安装也可以使用脚本进行安装，详细过程如下。 2.2.1.1. 手动安装 v2rayA从v2rayA github release下载安装包，下载完成后双击安装程序按照安装向导进行安装。 2.2.1.2. 脚本安装 v2rayA1234567# 打开powershell, 普通用户权限即可, 执行以下命令下载 v2rayA 安装文件，安装文件将会被保存在用户的下载目录下# 执行下载命令会弹出警告框，因为下载的是.exe文件，点击允许即可开始下载。powershell -c &quot;invoke-webrequest -uri https://ghproxy.net/https://github.com/v2rayA/v2rayA/releases/download/v2.2.4.6/installer_windows_inno_x64_2.2.4.6.exe -outfile Downloads\\installer_windows_inno_x64_2.2.4.6.exe&quot;# 下载完成后，开始安装Start-Process -FilePath &quot;Downloads\\installer_windows_inno_x64_2.2.4.6.exe&quot; -ArgumentList &quot;/silent&quot; 2.2.2. MacOS 上下载并安装 v2rayA对于 MacOS 操作系统 123456789101112# 下载v2rayasudo curl -L https://ghproxy.net/https://github.com/v2rayA/v2rayA/releases/download/v2.2.4.6/v2raya_darwin_x64_2.2.4.6 -o /usr/local/bin/v2raya# 核对文件的指纹信息, 如果与以下输出一致则表示，否则请谨慎安装。# 权威指纹信息可以在github release download 同级目录下找到。$ openssl dgst -SHA2-256 /usr/local/bin/v2rayaSHA2-256(/tmp/v2raya_darwin.zip)= 345797f7e93c2f71822f648018098110674d1511f95c0088717e6b2518669748# 授予v2raya可执行权限sudo chmod 755 /usr/local/bin/v2raya 2.2.3. Linux Debian 系列下载并安装 v2rayA对于 debian 系列发行版（Ubuntu, Mint, MX, Kubuntu, Zorin 等等） 使用命令行安装： 12345678910111213# 下载debian安装包, 针对不同的硬件架构以下下载命令稍做调整即可.# 所有安装包可以在这里找到https://github.com/v2rayA/v2rayA/releases/wget -O /tmp/installer_debian_x64_2.2.4.6.deb https://ghproxy.net/https://github.com/v2rayA/v2rayA/releases/download/v2.2.4.6/installer_debian_x64_2.2.4.6.deb# 核对文件的指纹信息, 如果与以下输出一致则表示，否则请谨慎安装。# 权威指纹信息可以在github release download 同级目录下找到。$openssl dgst -SHA2-256 /tmp/installer_debian_x64_2.2.4.6.deb SHA2-256(/tmp/installer_debian_x64_2.2.4.6.deb)= 3a143ca17cace0c14d21f7322f5df4d1f12bee600e762b416f46ca08a1aa0772# 安装v2rayAsudo apt install /tmp/installer_debian_x64_2.2.4.6.deb 2.2.4. Linux Redhat 系列下载并安装 v2rayA对于 Redhat 系列发行版（Centos, Fedora, AlmaLinux, Rocky Linux 等） 123456789101112# 使用wget下载v2rayA rpm包wget -O /tmp/installer_redhat_x64_2.2.4.6.rpm https://ghproxy.net/https://github.com/v2rayA/v2rayA/releases/download/v2.2.4.6/installer_redhat_x64_2.2.4.6.rpm# 核对文件的指纹信息, 如果与以下输出一致则表示，否则请谨慎安装。# 指纹信息可以在github release download 同级目录下找到。$ openssl dgst -SHA2-256 /tmp/installer_redhat_x64_2.2.4.6.rpm SHA2-256(/tmp/installer_redhat_x64_2.2.4.6.rpm)= 0c06a3f6aa45e455e9bc24dd3db6e4cfafcba2f95323f1fc898b5303089dbae8# 安装 v2rayAsudo rpm -i /tmp/installer_redhat_x64_2.2.4.6.rpm 2.2.5. Android 手机上安装与配置 v2rayNGAndroid 上安装 v2ray 客户端，可参考这篇文章Android 手机上安装与配置 v2rayNG 3. 配置 v2rayA （windows 可跳过此步骤）因为在 Windows 上，安装程序默认设置了 v2rayA 与内核的关联，所以可以跳过以下配置过程 3.1. 配置 v2rayA修改/etc/default/v2raya配置文件让 v2rayA 使用 v2ray-core 123sudo vi /etc/default/v2raya 123456# 将V2rayA和v2ray-core关联起来# 添加配置两行配置V2RAYA_V2RAY_BIN=/usr/local/v2ray-core/v2rayV2RAYA_V2RAY_CONFDIR=/usr/local/v2ray-core 3.2. 设置开机启动3.2.1. Windows 操作系统上设置 V2rayA 开机自启windows 可跳过此步骤, Window v2rayA Installer 安装过程中已经自动完成了这些设置 3.2.2. Linux 操作系统上设置 V2rayA 开机自启1234567# --now 参数表示设置为开机启动并立即启动v2rayasudo systemctl enable --now v2raya# 查看服务状态systemctl status v2raya 3.2.3. MacOS 上启动 V2rayA手动启动 v2rayA 如下 1v2raya --lite 选项说明 –lite: 非 root 用户只能在 lite 模式下启动 v2rayA, 如果是 root 用户可以不带该选项 4. 如何使用 v2rayA？使用 v2rayA 分为以下步骤： 首先通过 v2rayA web 管理界面创建一个用于管理 v2rayA 的账号; 然后从机场服务商那里获得订阅，并导入订阅; 最后连接并启动节点。 完成这些即可畅通无阻的访问外网了。 4.1. 登陆 v2rayA web 管理界面在浏览器中打开 v2rayA web 管理界面 http://localhost:2017/ 说明： 如果 v2rayA 正常启动（启动有时需要等待几分钟）则会监听在 2017 端口，在所有操作系统上 v2rayA 管理方式都是一致的， 都是通过 WEB 界面进行管理。通过浏览器访问 http://localhost:2017/ 许多服务器是没有安装 Linux 桌面的，无法在主机上使用浏览器进行访问，此时需要远程管理 v2raya，开启远程管理参考本文 进阶用法 -&gt; 开启远程管理章节。 Macos 上不要用 safari 浏览器打开可换其它浏览器,例如使用 chrome 打开，v2rayA GUI 对 safari 支持不太好，可能会出现白屏的情况。 4.2. 创建管理账号 在第一次进入页面时，你需要创建一个管理员账号，请妥善保管你的用户名密码。 如果遗忘，可以使用 sudo v2raya --reset-password 命令重置密码, 重置前先停止 v2raya，详细用法请查看 Troubleshooting - 问题 2。 4.3. 获取机场订阅 url可以从如下机场服务商列表中获取订阅或节点。 从以上机场服务商列表， 选择一个机场服务商，然后注册账号，购买订阅，最后在“我的订阅界面”可以获取到订阅 url。 说明： 如果要使用 ChatGPT, 需要注意以下两点 a) 选择机场服务提供商时选择支持 ChatGPT 的服务提供商例如: 星辰 VPN 或者 可乐云，这种资源目前非常稀缺，实测以上机场服务商列表中“星辰 VPN”的多数节点(截至 2024-08-06)支持得很好，可乐云的多数节点对 Chatgpt 支持较好（截至 2024-07-20）。 b) v2ray web 设置 =》透明代理/系统代理实现方式 =》需要设置为 tproxy（透明代理） 参考章节 4.7. 检查设置。 4.4. 导入订阅 url 或 节点 url根据前面指引获取到订阅 url 后，就可以导入订阅了，详细步骤参考以下截图。 点击导入按钮进入订阅或节点导入界面，推荐使用导入订阅的方式，比较简单方便。 一个订阅下有若干个节点，也可以选择逐个导入一个或多个节点。另外如果是自建服务器，一般不会有订阅 url, 此时可以选择以节点方式导入。 导入订阅如下图所示： 订阅 URL 类似这样子: https://xxx.xxxx.com/api_version2/xxxxxxxx?sub=3&amp;extend=1 4.5. 连接节点一个订阅多数情况下会包含多个分布在全球各地的不同节点，一旦订阅成功导入后就会获取到相关节点的信息。 此时根据自己的需求，选择其中的几个作为连接节点。 更新成功后，节点将显示在相应订阅的节点列表标签页。如上图所示成功导入了一个订阅后的界面。 切换到节点列表标签页，点击相应节点后面的“连接”按钮，可同时连接一个或多个节点，这也是 v2ray 和 V2rayA 与其他代理上网方式相比强大的地方。 说明： 虽然可以同时连接多个节点，但是这里不建议选择过多的节点，6 个以内为佳。 4.6. 启动节点导航到 SERVER 或订阅服务器 TAB 页，选择一个或多个节点后，启动该服务器。 连接成功后节点变为蓝色，如下图所示： 技巧与提示： 步骤 1，勾选一个或多个节点，此时界面上会出现 Ping 和 HTTP 按钮，点击相应按钮测试服务器 ping 值，以及 http 延时，以便快速找到可用节点。 步骤 2， 选择节点，在每个节点右侧有一个选择按钮，点击选择按钮选中节点，此时节点呈现柚红色，因为还未启动它们。 步骤 3，在页面左上角有个“就绪”按钮点击该按钮启动节点，节点呈现蓝色表示启动成功。 如果未呈现蓝色即未启动成功，请点击页面右上角点击日志查看问题详情。 另外查看评论区网友遇到过的问题，或许对一些疑难杂症会有所帮助。 节点呈现蓝色是能成功连接外网的基本要求，也即如果不是蓝色肯定连接不了外网，节点呈现蓝色后，还要检查其他要求包括：Ping 值是否正常 和 HTTP 延迟是否正常，设置是否合理等。 4.7. 检查设置有时候节点已经正常启动已经呈现蓝色，但是仍然不能正常访问某些网站，这可能与具体设置有关系。此时可以参照下图推荐的设置进行调整，基本能成功访问。 如果仍然有不能成功访问外网，可以查看一下日志信息，看是否有错误信息。详细的错误日志可以点击网页上的日志按钮查看, 也可以在/var/log/v2raya/下面可以找到日志。 有时会因为缓存原因，设置修改后不会立即生效，这时可以重启一下网卡，或者重启一下 v2rayA 服务。 说明： 如何理解这里的配置选项？ 首先了解端口分流规则。 v2rayA 是对 v2ray-core的一层包装，v2ray-core 的分流规则非常强大也非常复杂， 非专业人士很难理解这些规则。 v2rayA 在 v2ray-core 的复杂的分流规则的基础上，抽象出了两条基本规则，一条是大陆白名单模式，一条是GFWList模式，这两条规则基本能满足90%的科学上网需求， 如果需要更复杂的分流规则，v2rayA保留了routingA规则，几乎和v2ray-core的规则完全匹配，这样既简化了配置，又保持了v2ray的强大与灵活。 大陆白名单模式 和 GFWList模式的主要差别是，GFWList模式，仅根据被墙的域名名单判断应该走proxy（代理）还是 direct（直连） 大陆白名单模式会根据域名对应的ip获取到国家属性，如果是CN(中国)则直连，否则都走代理。所以使用v2rayA需要两个文件，一个是geosite.dat一个是geoip.dat这两个文件。 两者各有优劣，GFWList模式的优势是性能稍好，它少一次域名解析的过程和一次提取国别属性的运算，性能上有些许优势，它的劣势是使用者在访问国外网站时，不知道自己使用的是代理还是直连，有时以为自己在使用代理实际是直连。 使用大陆白名单模式的优势是访问国外的网站统一使用代理，不存在代理和直连混淆的状况， 但是由于多一次域名解析， 可能存在dns泄漏的问题， 所以在dns配置时一定要选择合适的选项， 后面会讲到。 然后要了解透明代理/系统代理实现方式 透明代理和系统代理都会将源ip修改为所使用的代理的ip, 而redirect则会保留请求的源 ip. 所以两者明显的差别是在访问外网时， 目标网站看到的ip地址不同，这点可以使用&lt;whoer.com&gt;来检测， 通过调整代理实现方式， 切换节点来观察ip的变化。 当访问一些对ip地址地域要求的网站时，可以通过调整代理实现方式来改变访问网站时的ip地址. 透明代理/系统代理 选项 这条是设定在何种情况下使用透明代理/系统代理， 具体规则含义可以参照端口分流规则。 防止 DNS 污染 其实不仅仅是防止dns污染，如果分流和代理模式选择了 大陆白名单时， 还要防止dns泄漏，关于什么是dns泄漏 以及dns污染，可以自行科普。 如果在使用了大陆白名单模式时，最好使用转发DNS请求，这样DNS请求是通过代理解析的，而不是通过本机dns服务器解析，从而避免泄漏。 这点可以使用 https://ipleak.net/ 或 https://whoer.com/ 检测， 当使用tproxy或者system proxy时， 如果一些被墙的网站有来自china的解析解析结果时，表示ip泄漏的风险。 其他选项比较容易理解，这里暂时不做过多解释。 5. 验证设置是否成功？如果是 Linux 桌面, 可以打开浏览器访问https://www.google.com, 如果能成功访问则表示连接成功. 如果是在命令行下, 可以运行如下命令访问 google. 如果能看到从 google 传输过来的内容, 则表示成功. 12345# 使用命令访问googlecurl https://www.google.com 至此在单台主机上已经可以科学上网了，下面是一些进阶用法，如有需要可以参考。 6. 进阶用法6.1. 开启远程管理（可选）如果要远程管理 v2rayA 服务，需要放行 2017 端口，如果不需要远程管理 v2ray 可以忽略本节以下设置。 远程端口以及 ip 依然在 vi /etc/default/v2raya 中配置 12# 修改varaya 监听地址和端口V2RAYA_ADDRESS=0.0.0.0:2017 执行以下命令检查防火墙设置 123456789101112131415# 检查防火墙是否开启firewall-cmd --state# 查看当前开放的端口firewall-cmd --list-ports# 放行v2raya端口sudo firewall-cmd --permanent --add-port=2017/tcp# 刷新防火墙配置sudo firewall-cmd --reload# 查看v2raya服务是否监听在端口上netstat -tunlp | grep 2017# 或者使用lsof命令lsof -i -nP | grep v2raya 6.2. 配置代理如果在局域网内，不仅本机可以访问外网，而且 V2rayA 经过配置后，可以作为代理服务器让局域网内其他设备访问外网。此时 V2rayA 又可以化身为一台代理服务器为其他电脑客户端提供代理（其他电脑无需安装v2rayA, 或任何v2ray客户端， 使用系统自带的http，https或者socks代理功能即可）。 默认情况下 v2rayA 会通过v2ray内核开放 20170(socks5), 20171(http), 20172(带分流规则的 http) 端口作为代理端口（可以在 v2rayA 设置=&gt;地址与端口 页面查看或修改端口）。 如果是需要为局域网中的其他机器提供代理，打开 v2rayA web，在设置中开启“开启端口分享”，并检查防火墙端口放行情况。开启防火墙请参考前面章节 - 开启远程管理 其他电脑使用代理的方法比较简单，只需要在被代理机器上添加如下两个环境变量即可。 在 linux 或 Macos 操作系统上, 找到环境配置文件，添加如下两行配置. 以 bash 为例，修改~/.bashrc, 添加如下两行配置, 其他 shell 可以自行科普 shell 环境变量配置。 1234567891011# 修改bash的配置文件# vi ~/.bashrc# 将如下两行添加到配置文件.bashrc中export http_proxy=&quot;http://server_ip:20171&quot;export https_proxy=&quot;http://server_ip:20171&quot;# 配置好以后，在命令行终端运行如下命令，更新配置。# source ~/.bashrc# 最后使用查看配置是否生效, 查看 http_proxy和https_proxy 两个变量的值是否正确# echo $http_proxy# echo $https_proxy 在 windows 操作系统上, 打开 Windows 环境变量配置界面，添加如两个环境变量。 12http_proxy=&quot;http://server_ip:20171&quot;https_proxy=&quot;http://server_ip:20171&quot; 6.2.1. 透明代理 这种方法是 v2rayA 推荐的方法。它相比于其他方法具有诸多优势，v2rayA 可以一键开启透明代理，为几乎所有程序提供代理服务。 在设置中选择透明代理的分流方式，以及实现方式，然后保存即可。 注意，如需选择 GFWList，需要下载对应的规则库，请点击右上角的更新以完成下载。 6.2.2. 系统代理系统代理可为主动支持代理的程序提供代理服务。在不同的桌面环境中设置的位置不尽相同，请通过搜索引擎自行搜索。 7. Troubleshooting7.1. 问题 1: 检测到 geosite.dat, geoip.dat 文件或 v2ray-core 可能未正确安装，请检查 问题描述 访问 http://your_server_ip:2017/时, 系统弹出提示”检测到 geosite.dat, geoip.dat 文件或 v2ray-core 可能未正确安装，请检查” 问题分析: “geosite.dat”：提供一个预定义好的 「全球域名」 列表;“geoip.dat” ：提供一个预定义好的 「全球 ip-地区」 列表. 第一种可能性是可能是根本没有安装任何 v2ray-core, 由于 v2rayA 的 linux 版本和 macos 版本都是不带 v2ray 内核的，如果没有安装内核可能会出现以上错误。 第二种情况，geosite.dat, geoip.dat 文件没有放到正确的位置。 由于 v2rayA 不同的版本之间，运行在不同的系统上面，读取配置文件的位置有所不同，也会出现找不到这两个文件的情况。 解决办法是查看错误日志。手动拷贝这两个文件到相应位置。 解决方案 参照安装 v2ray-core 章节将 v2ray-core 安装配置好 再次访问 v2ray web ui, 错误消失. 如果仍然有问题，可以将安装 v2ray core 时自带了一份 geosite.dat, geoip.dat 文件，只是不是最新数据，但是仍然可用，将其拷贝到相应位置即可。 最新数据位于https://github.com/v2rayA/dist-v2ray-rules-dat可以直接下载也可以通过 github 代理 https://ghproxy.net/ 下载 7.2. 问题 2： 忘记了 v2rayA 的用户名和密码怎么办？重置密码 12345678# 关闭v2raya服务sudo systemctl stop v2raya# 重置密码sudo v2raya --reset-password# 启动服务sudo systemctl start v2raya 8. 特别说明工具本无善恶, 正与邪取决与使用工具的人, 主体是人. 请将工具用于正道, 切莫用于邪道给自己带来灾殃. 最后如果你能成功访问某 tube, 一篇关于安全方面的知识的值得首先了解一下. 转载会给您带来不必要的麻烦, 所以本文禁止转载. function jsfun(url) { window.open(url,'_blank'); } let url = 'https://i.airplanehub.xyz/' let out_li = ' \\\\\\\\\\\\\\\\&ensp;机&ensp;场&ensp;服&ensp;务&ensp;商&ensp;列&ensp;表 &ensp; (click me) ' document.getElementById('airport_node_list').innerHTML = out_li;","link":"/network/v2rayA_install.html"},{"title":"Android 上安装与配置 v2rayNG","text":"v2rayNG 是一款专为 Android 设计的 V2Ray 客户端应用程序，它提供了一个简洁易用的图形用户界面，使用户能够方便地在移动设备上配置和使用V2Ray代理服务。支持多种传输协议和网络协议，包括 VMess、VLESS、Shadowsocks、Socks 等，能够帮助用户绕过网络封锁，保护隐私和安全，提升网络访问体验。用户可以根据自己的需求选择合适的协议和代理方式来进行网络代理。适用于安卓手机及支持部分基于安卓系统的电视（TV）或者电视盒子。 本文将详细讲述如何在 Android 系统上快速安装、配置和使用 v2rayNG 这款科学上网应用。 1. 下载 v2rayNGv2rayNG 官网下载地址：https://github.com/2dust/v2rayNG/releases 或者手机打开浏览器，扫描下方二维码下载。 下载过程中如果遇到 github 不能访问的情况， 方法 1： 可以通过 https://ghproxy.net/ 代理下载下载 例如： https://ghproxy.net/https://github.com/2dust/v2rayNG/releases/download/1.8.15/v2rayNG_1.8.15.apk 如需下载其他版本，将链接中的版本号1.8.15替换成相应的版本号即可。 方法 2： 可尝试使用文章解决 GitHub 访问不了的方法中介绍的方法。在电脑上下载 apk 安装文件再传给手机。 2. 安装 v2rayNG下载完后获得文件为 v2rayNG_x.x.x.apk 文件，其中后缀 .apk 为安卓系统的安装包，x.x.x 代表版本号，然后点击安装即可。 目前很多品牌的手机都试图阻碍从非应用商店下载的软件安装，选择忽略提示信息，直接往下进行即可。 至此安装 v2rayNG 这款科学上网 APP 这一步骤已经完成，接下来我们将详细讲述如何配置 v2rayNG 这款魔法上网 App。 3. 配置 v2rayNG安装完成后桌面会出现 v2rayNG 的 logo, 打开该应用，进行配置。 3.1. 获取机场订阅 url可以从如下机场服务提供商列表中获取订阅或节点 从以上机场服务商列表， 选择一个机场服务商，然后注册账号，购买订阅，最后在“我的订阅界面”可以获取到订阅url。 说明： 如果要使用 ChatGPT, 需要注意以下两点 a) 选择机场服务提供商时选择支持 ChatGPT 的服务提供商例如: 星辰 VPN 或者 可乐云，这种资源目前非常稀缺，实测以上机场服务商列表中“星辰 VPN”的多数节点(截至 2024-08-06)支持得很好，可乐云的多数节点对Chatgpt支持较好（截至 2024-07-20）。b) v2ray web 设置 =》透明代理/系统代理实现方式 =》需要设置为 tproxy（透明代理）。 3.2. 配置 v2rayNG这里只介绍如何通过扫描二维码导入机场订阅 url，其它方式略显复杂，而且在手机上操作不方便，如需使用其他方式可以自行探索。 3.2.1. 如何获取机场订阅二维码？通常机场服务提供商都会提供含有订阅 url 的二维码，方便用户使用。 如果机场服务商没有提供订阅二维码，那么可以在获取到订阅 url 后，自己使用在线 “url 转二维码工具”生成二维码，例如https://cli.im/url就提供 url 转二维码功能。 3.2.2. 如何导入机场订阅二维码？打开 V2rayNG 科学上网 APP,进入主界面，如下图所示。然后点击软件主界面右上角的 ➕ 号按钮会出现功能选项，然后选择扫描二维码。 扫描电脑屏幕上的二维码或将上一步获取的二维码保存到手机，从手机相册打开二维码图片导入机场订阅信息，如下图所示。 扫描完成后订阅地址可以在“订阅设置”中看到订阅信息，如下图所示点击软件主界面左上角三道杠按钮，在弹出窗口进入系统设置界面，然后点击订阅设置，如下图所示。 3.2.3. 如何更新机场订阅获取机场节点？ 一个订阅多数情况下会包含多个分布在全球各地的不同节点，在 V2rayNG 魔法上网 APP 上，还需要手动操作才能获取到所有的机场节点。 最后也是最重要的一步，返回到软件主界面，然后点击最右上角的三束点按钮，在弹出界面选择更新订阅，如下图所示。 至此，通过订阅地址方式添加代理服务器就成功了，如果是通过订阅地址添加的节点服务器，会在当前节点的列表右上角显示刚才添加订阅设置时候输入的备注，如下图所示。 4. 如何使用 v2rayNG？4.1. 选择机场节点在软件的主界面中可以看到订阅下所有的机场节点，其中每一个机场节点最右边的竖条代表选定服务器的状态，其中无色代表未选中，黑色代表选中，如下图所示。单击节点可以选中或者取消选中机场节点。 每一条代理服务器的操作都可以在这里进行，右边三个图标分别代表分享节点服务器、编辑节点服务器、删除节服务器，如下图所示。 在选择节点时选择tcpping,和http延时较小的节点, 测试不通的节点不要选择，影响后续使用。延迟测试：点击右上角三个点，点击”测试全部配置Tcping”, 测试结果会显示在节点卡片上。 4.2. 启动机场节点点击软件主界面右小角的 V 字图标启动机场节点（连接上网代理服务器），首次配置会提示是否创建代理，点击确定启动，如下图所示。 在有多条代理服务器的时候，只需要直接点击想要链接的那条代理服务器，即可切换代理服务器，无论是未链接状态还是已链接状态，都可以进行切换。 4.3. 验证设置是否成功浏览器打开https://www.google.com, 如果能正常访问，表示设置成功。 或者浏览器打开某 tube, 看能否播放视频。 有时候，即使启动按钮变为橙色，也会出现访问不了的情况，此时可以： 换一些节点重试，主要检查一下节点的延迟，到机场服务提供上界面看一下节点状态; 参考 4.4 节列出的配置检查自己的配置信息； 查看日志是否有任何错误提示，可参考“ 4.5. 问题排查” 排查问题。 4.4. 其它设置其它设置，供参考 4.5. 问题排查如果出现连接不上的情况，可以查看日志。 5. 相关阅读本文时 v2ray 系列安装配置教程之一，其他系统例如：Windows, Macos, Linux 上安装与配置 v2ray 可以参考： 2024 最新 v2rayA 安装与配置教程 | 鹏叔的技术博客 function jsfun(url) { window.open(url,'_blank'); } let url = 'https://i.airplanehub.xyz/' let out_li = ' \\\\\\\\\\\\\\\\&ensp;机&ensp;场&ensp;服&ensp;务&ensp;商&ensp;列&ensp;表 &ensp; (click me) ' document.getElementById('airport_node_list').innerHTML = out_li;","link":"/network/v2rayNG_install_and_config.html"},{"title":"v2rayN 安装与配置","text":"1. 前言v2rayN 是一款基于 V2RAY 协议的 Windows 客户端软件, 用于科学上网和保护用户隐私. 它可以通过多种协议和代理方式连接到服务器, 包括 HTTP, HTTPS, Socks, Shadowsocks, VMess 等. V2rayN 提供了简单易用. 在 Windows 操作系统上可以安装 v2ray 客户端有两种选择 一是 v2rayN 第二个是 v2rayA, v2rayA 是一个支持全局透明代理的 V2Ray 客户端，同时兼容 SS、SSR、Trojan(trojan-go)、PingTunnel 协议。 windows 上可参考 Windows 上安装与配置 v2rayA 在 Linux 上安装 v2rayA. v2rayA 的安装可以参考2024 最新 v2rayA 安装与配置教程 | 鹏叔的技术博客. Android 安卓手机建议安装 v2rayNG, 安装过程可参考Android 手机上安装与配置 v2rayNG | 鹏叔的技术博客 2. 安装 v2rayN 客户端v2rayN 提供了两个版本, 一个是带内核的版本, 一个是不带内核版本. 其中, 带内核的版本是自带内核的, 而不带内核的版本则需要用户自行下载和配置 V2Ray 内核. 因此, 两个版本的主要区别在于内核的安装和配置方式不同. 如果你是新手用户, 建议下载带内核的版本, 因为可以省去你自行下载和配置内核的麻烦. 如果你是有经验的用户, 可以选择下载不带内核的版本, 然后自行下载和配置内核. 无论选择哪个版本, 安装和配置步骤都是类似的. 点开下载地址，选择最新版本. 我下载的是当前带内核的最新版本v2rayN-6.25 解压文件到指定位置,例如: C:/software 在文件夹中找到 v2rayN.exe 打开就能启动程序了，如果嫌麻烦可以右键发送快捷方式到桌面， 如果遇到 windows 防火墙试图阻止程序运行, 请暂时关闭 Windows 的系统防护, 或者忽略警告, 继续运行. 下载过程中如果遇到 github 不能访问的情况， 方法 1：可以通过 github 代理 https://ghproxy.net/ 下载 例如： https://ghproxy.net/https://github.com/2dust/v2rayN/releases/download/6.25/v2rayN-With-Core.zip 方法 2: 可尝试使用文章-解决 GitHub 访问不了的方法中介绍的方法。 3. 如何连接服务器3.1. 获取机场订阅 url可以从如下机场服务提供商列表中获取订阅或节点： 从以上机场服务商列表， 选择一个机场服务商，然后注册账号，购买订阅，最后在“我的订阅界面”可以获取到订阅 url。 说明： 如果要使用 ChatGPT, 需要注意 a) 选择机场服务提供商时选择支持 ChatGPT 的服务提供商例如: 星辰 VPN 或者 可乐云，这种资源目前非常稀缺，实测以上机场服务商列表中“星辰 VPN”的多数节点(截至 2024-08-06)支持得很好，可乐云的多数节点对 Chatgpt 支持较好（截至 2024-07-20）。b) v2ray web 设置 =》透明代理/系统代理实现方式 =》需要设置为 tproxy（透明代理）。 3.2. 添加订阅分组设置获得到订阅地址后回到 v2rayN, 在工具栏上方 点击”订阅分组”=&gt;”订阅分组设置”, 打开订阅分组设置后, 点击添加按钮, 在弹出的输入界面, 填写别名, 输入可选地址 url(此处填写从机场获取的订阅地址), 其它选项保持默认, 如果不熟悉其它选型值得含意, 都保持默认值. 然后点击确定按钮保存. 这样一条订阅就添加成功. 订阅添加成功后, 点击”订阅分组”=&gt;”更新全部订阅(不通过代理)”, 即可获得该订阅提供得所有 servers. 3.3. 连接服务器在连接之前, 对各服务器进行一下测速. 在服务器列表中右击, 在弹出的菜单中选择”一键多线程测试延迟和速度” 然后选中延迟最小速度最快的服务器按回车键将服务器设置为活跃服务器(active server). 整个连接过程会有日志输出, 在界面下方信息栏, 如果看到类似如下日志信息表示连接成功. 12345678910111213配置成功[Trojan] 韩国节点3(hg3***xyz:5689)启动服务(6/4/2023 7:56:15 PM)...Xray 1.8.0 (Xray, Penetrates Everything.) Custom (go1.20.2 windows/amd64)....2023/06/04 19:56:15 Using default config: path_to_v2rayN-With-Core\\guiConfigs\\config.json2023/06/04 19:56:15 [Info] infra/conf/serial: Reading config: path_to_v2rayN-With-Core\\guiConfigs\\config.json2023/06/04 19:56:15 [Warning] core: Xray 1.8.0 started6/4/2023 7:56:16 PM 系统代理设置改变2023/06/04 19:56:16 127.0.0.1:43334 accepted //www.google.com:443 [http &gt;&gt; proxy]6/4/2023 7:56:17 PM 当前服务的真连接延迟: 142 ms 当看到”当前服务的真连接延迟: 142 ms” 表示连接成功,如果看到得是”当前服务的真连接延迟: -1 ms” 表示连接失败, 失败得原因可能是服务器不可用, 或者服务器限流, 或者是订阅过期, 试用期结束等等各种原因. 连接成功后打开某歌, 某 tube, 某 Gpt 或者某 book, 如果能正常访问则表示配置成功. 最后强调一点, 工具本无善恶, 正与邪取决与使用工具的人, 主体是人, 请将工具用于正道, 切莫用于邪道给自己带来灾殃. 最后如果你能成功访问某 tube, 一篇关于安全方面的知识的值得首先了解一下. 4. 优化安装完成后建议将 Core 类型设置为 v2fly_v5, 以获得更好的性能. 设置方法: 打开设置=&gt;Core 类型设置 将 VMess, Custom, Shadowsocks, socks, VLess, Trojan 都设置为 v2fly_v5 5. 关联阅读Windows 上安装与配置 v2rayA 2024 最新 v2rayA 安装与配置教程 Android 上安装与配置 v2rayNG frp 内网穿透 使用 WireGuard 内网穿透 function jsfun(url) { window.open(url,'_blank'); } let url = 'https://i.airplanehub.xyz/' let out_li = ' \\\\\\\\\\\\\\\\&ensp;机&ensp;场&ensp;服&ensp;务&ensp;商&ensp;列&ensp;表 &ensp; (click me) ' document.getElementById('airport_node_list').innerHTML = out_li;","link":"/network/v2rayN_usage.html"},{"title":"Vultr 上安装并配置一台 VMESS&#x2F;v2ray 服务器","text":"VMess 协议是由 V2Ray （科学上网软件）创立并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗审查的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 本文中采用Vultr VPS，一款性能优越、配置的VPS, 其拥有广泛的数据中心分布、丰富的功能和便捷的支付方式，成为众多用户的首选。无论是个人学习、小型项目还是大型企业应用，Vultr VPS 都能提供稳定可靠的服务支持。 拥有一台Vultr VPS可以做很多事情，例如： Vultr + Code-server 自建 Cloud IDE Vultr 部署 Wordpress 博客 Vultr 上快速搭建 kubernetes 集群 更多玩法等待您来解锁。 本文主要讲解在 Vultr VPS上，如何使用自动化脚本和手动两种方式，安装并配置一台 v2ray 服务器（也称为 vmess server）。以及如何通过v2rayA, v2rayN, v2RayNG连接 v2ray 服务器并访问google和chatGPT。 1. 注册 Vultr 账号访问https://www.vultr.com进入注册页面，输入邮箱、密码，点击“Create account”按钮。（密码需要至少一个大写字母一个小写字母，长度 10 位数以上。） Vultr 会给注册邮箱发一封验证邮件，进入邮箱，拷贝验证码，再回到 Vultr 注册页面进行验证。 注册完成后进入账号设置页面，设置账号，主要分三个步骤，如下图所示，首先绑定信用卡，然后完善用户信息，最后就可以开始创建实例了。 进入设置界面，完成第一步“Add a Payment Method &amp; Pre-Fund Your Account”也就是绑定信用卡之后就可以看到赠送的 300 美金试用金到账。 访问 account =&gt; make a payment 就可以看到 300 美金 到账 从上图可以看到，Vultr 不仅支持信用卡付款，还支持 Paypal, 加密货币，Alipay, Wire Transfer, 礼品代码等。 2. 更新 Profile更新 profile, 填写个人信息，地址，公司信息 3. 创建 VPS完成以上注册流程，我们就可以开始创建 VPS 了。 点击左边”Products”，再点击右侧”Deploy +” 进入创建实例界面。 选择“Cloud Compute - Shared CPU”。 选择 location，总共有 30 多个 location 可供选择。亚洲区域选择新加坡，首尔，东京，连接延迟都比较低。 选择操作系统的版本，操作系统版本可以选择 debian 系列的 linux, 或者 Redhat 系列的 linux 都可以，本教程都支持。 但是本教程实际使用的是 Almalinux 9.x 版本。 选择套餐，根据自己的喜好，本教程使用的是最低规格的服务器，1U1G, 价格是 6 美金/月。 可以看到，服务器配置是 1U1G, 存储是 25GB, 免费的网络流量是 2TB, 另外它会绑定两个公网 IP 地址，这些都是免费的。 选择 Additional features 自动备份功能每月会收费 1.2 刀，建议取消，我们只是部署一个 v2ray 代理服务器，存储的数据没有那么重要，出现问题，按照教程重新安装一遍即可，备份的钱没有必要花； 选择”Enable IPV6”，这样就拥有双 IP。 Limit user login 建议选上，这样比较安全，VPS 暴露在网上，经常会被黑客扫描，如果使用默认 root 用户，很容易受到攻击，成为肉鸡。默认的用户 root 权限太大，而且很容易被黑客知道，最好使用 Limit user login。 出于安全性考虑，SSH Key 如果会配置一定要配置上，篇幅有限，这里不做展开讲解了。 给 VPS 取一个容易区分的名字。 然后点击“Deploy Now”按钮。 4. 登陆 VPS 单击节点进入，进入 vps 详情界面，可以找到登陆 VPS 所需详细信息 Windows 系统上可以使用 X-shell 工具，或任何本机存在的 shell 终端, 或者 putty 连接 VPS。 Linux 系统直接打开命令行终端远程连接 VPS 即可。 5. VPS 时间校准对于 V2Ray，它的验证方式包含时间，就算是配置没有任何问题，如果时间不正确，也无法连接 V2Ray 服务器的，服务器会认为你这是不合法的请求。所以系统时间一定要正确，只要保证时间误差在 90 秒之内就没问题。 在联网情况下，直接启动 chronyd 系统服务，并设定为开机启动 12345$ sudo systemctl enable --now chronyd.service# 查看当前时间$ date -RThu, 05 Sep 2024 00:07:48 +0800 6. 下载并安装 v2ray server在 Linux 操作系统， V2Ray 的安装有脚本安装、手动安装、编译安装 3 种方式，选择其中一种即可，本指南提供使用使用脚本安装的方法 以及手动安装方法，推荐使用脚本安装，该脚本由 V2Ray 官方提供。该脚本仅可以在 Debian 系列或者支持 Systemd 的 Linux 操作系统使用。 6.1. 脚本安装 v2ray server （推荐）1234567891011121314151617curl --output /tmp/v2ray/https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.shsudo bash /tmp/v2ray/install-release.sh# 默认使用nobody运行v2ray,最好建一个专门的用户用于运行v2raysudo groupadd v2raysudo useradd -s /bin/false -g v2ray -d /home/v2ray v2ray# 将日志目录的owner修改为v2raysudo chown -R v2ray:v2ray /var/log/v2ray/# 将service中的user由nobody修改为v2raysudo sed -e &quot;s/^User.*$/User=v2ray/&quot; -i /etc/systemd/system/v2ray.servicesudo sed -e &quot;s/^User.*$/User=v2ray/&quot; -i /etc/systemd/system/v2ray@.servicesudo systemctl daemon-reload 6.2. 手动安装 v2ray server123456789101112131415161718192021222324252627282930313233343536373839404142# 创建v2ray用户和组，在新版本的v2ray中需要使用nobody用户来运行，# 但是实践中创建一个专有用户来运行v2ray更加安全# 以下命令创建一个新的 v2ray 用户，使其成为 v2ray 组的成员，并为其分配/home/v2ray 的主目录，并禁止登录该帐户。sudo groupadd v2raysudo useradd -s /bin/false -g v2ray -d /home/v2ray v2ray## 下载v2ray-core，并保存到tmp目录wget -O /tmp/v2ray-linux-64.zip https://github.com/v2fly/v2ray-core/releases/download/v5.16.1/v2ray-linux-64.zip# 将其解压到/tmp/v2ray-coreunzip /tmp/v2ray-linux-64.zip -d /tmp/v2ray-core# 将v2ray可执行文件拷贝到/usr/local/binsudo cp /tmp/v2ray-core/v2ray /usr/local/bin/v2ray# 将.dat文件拷贝到/usr/local/share/v2ray/sudo mkdir -p /usr/local/share/v2ray/sudo cp /tmp/v2ray-core/*dat /usr/local/share/v2ray/# 将配置文件拷贝到 /usr/local/etc/v2raysudo mkdir -p /usr/local/etc/v2raysudo cp /tmp/v2ray-core/config.json /usr/local/etc/v2ray# 创建日志文件sudo mkdir -p /var/log/v2ray/sudo touch /var/log/v2ray/access.logsudo touch /var/log/v2ray/error.log# 将日志目录的owner修改为v2raysudo chown -R v2ray:v2ray /var/log/v2ray/# 配置service# 将service文件拷贝到系统的service目录下sudo cp /tmp/v2ray-core/systemd/system/v2ray.service /etc/systemd/system/v2ray.servicesudo cp /tmp/v2ray-core/systemd/system/v2ray@.service /etc/systemd/system/v2ray@.service# 将service中的user由nobody修改为v2raysudo sed -e &quot;s/^User.*$/User=v2ray/&quot; -i /etc/systemd/system/v2ray.servicesudo sed -e &quot;s/^User.*$/User=v2ray/&quot; -i /etc/systemd/system/v2ray@.service 7. 配置 vmess 服务器1234# 修改配置文件sudo vi /usr/local/etc/v2ray/config.json 以下配置中， clients.id 需要替换为不同的uuid, 其他可以通用。 1234567891011121314151617181920212223242526272829303132// vi /usr/local/etc/v2ray/config.json{ &quot;log&quot;: { &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;, &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;, &quot;loglevel&quot;: &quot;warning&quot; }, &quot;inbound&quot;: { &quot;port&quot;: 21212, //指定一个v2ray监听端口 ，防火墙需要放行此端口， 请将端口修改，请不要偷懒，这对安全性非常重要 &quot;listen&quot;: &quot;0.0.0.0&quot;, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: { &quot;auth&quot;: null, &quot;udp&quot;: false, &quot;ip&quot;: null, &quot;clients&quot;: [ { &quot;id&quot;: &quot;7bcae0eb-dd43-4d58-a2c4-65028776c057&quot;, // &lt;= 请将uuid替换成新的uuid, 配置客户端也要用到, 请不要偷懒，这对安全性非常重要 &quot;alterId&quot;: 0, // 在最新版的vmess协议中，alterId必须设置为0, 否则存在被jing zhuan &quot;security&quot;: null } ] } }, &quot;outbounds&quot;: [ { &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: {} } ]} 原理简析： 根据上文给出的配置，在这里简单的介绍一下 V2Ray 的工作原理。 配置文件都由两部分内容组成： inbounds 和 outbounds。我们可以认为每一个 V2Ray 都是一个节点，inbound 是关于如何与上一个节点连接的配置，outbound 是关于如何与下一个节点连接的配置。对于V2Ray server节点，inbound 与客户端连接；outbound与目标网站连接。 在上例子中，服务器监听来自客户端访问21212的请求，两者采用vmess协议进行沟通。为了保证隐私安全，VMess 协议客户端使用 client id 进行加密， 所以客户端也需要配置相同的client id（后面客户端配置会讲到）服务器端收到数据包后使用client id 解密。解密后将数据包传递给outbond, outbound使用的是freedom协议，它会打开看用户的真实请求是。比如用户需要访问https://google.com,那么freedom协议就负责以https协议访问google,然后将获取的数据进行封装，交由inbound节点加密再返回给对端，也就是v2ray客户端。 8. 检验 v2ray server 配置检验 config 是否有任何格式或语法错误 1234$ sudo /usr/local/bin/v2ray test -config /usr/local/etc/v2ray/config.jsonV2Ray 5.16.1 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.22.2 linux/amd64)A unified platform for anti-censorship.Configuration OK. 9. 开启并立即启动 v2ray 服务123456789101112# 设置开机启动，并立即启动v2ray服务sudo systemctl enable --now v2ray.service# 查看服务是否启动成功systemctl status v2ray.service# 如果开启, 需放行21212端口，与/usr/local/etc/v2ray/config.json中端口配置一致sudo firewall-cmd --add-port=21212/tcp --permanentsudo firewall-cmd --reload 10. 配置 v2ray 客户端下面讲解如何配置 v2ray 客户端， 连接 v2ray 服务器。 10.1. 客户端安装可以参考Windows 上安装与配置 v2rayA。 Android 手机上安装与配置 v2rayNG 2024 最新 v2rayA 安装与配置教程 for Windows、Linux、Macos、Android v2rayN 安装与配置 10.2. v2ray 客户端配置 vmess 节点客户端以 v2rayA 为例，其他 v2ray 客户端，例如 v2rayN, v2rayNG 可以参考以下配置。 10.3. 连接 vmess 节点 连接节点 10.4. 验证设置是否成功？浏览器访问https://www.google.com, 如果能成功访问则表示连接成功. 10.5. 测试网络速度浏览器访问https://www.speedtest.net, 点击 go 按钮 上传速度 11.57Mbps, 下载速度 10.04Mbps, 已经相当可以了。 10.6. 测试能否访问 chatGPT测试一下，看这个公网 IP 能否访问 ChatGPT。IP 质量挺高，可以正常访问 chatGPT。关于IP质量可以到whoer.com查询。 备注： 要正常访问ChatGTP的所有功能，需要将代理模式设置为tproxy(透明代理)。 11. troubleshooting问题 1： main: failed to create server &gt; v2ray.com/core/app/log: failed to initialize access logger &gt; open /var/log/v2ray/access.log: permission denied 原因分析： 在 service 的定义文件中，运行 v2ray 定义的用户是 nobody,而 nobody 没有权限访问 /var/log/v2ray/access.log/etc/systemd/system/v2ray.service 12[Service]User=nobody 解决办法: 为 v2ray 单独创建一个用户和组，例如 v2ray 并将 service 中的 user 修改为 v2ray 将/var/log/v2ray/ 的目录的 owner 修改为 v2ray","link":"/network/v2ray_server_install.html"},{"title":"申请免费SSL证书","text":"1. 前言SSL证书（SSL Certificates）可以说是现在一个网站的标配，如果没有用SSL证书，浏览器上会显示不安全，导致一部分用户以为网站有问题。另外在微信小程序和iOS APP上，提供的API必须要用HTTS协议，否则不允许上架，所以掌握好SSL证书的配置是一个后端开发必备的技能。 在阿里云上，提供了每年可以申请一次的免费SSL证书，对于一些个人站点或者小公司的网站来说，确实是一个不错的选择。 2. 免费的SSL证书和付费的有什么区别？收费版的SSL证书和免费版的证书有什么区别？首先说下他们的相同点。 都是由信任的CA机构签发的。 都是有一定的加密算法，能保证数据安全传输的。 首先我们要知道，任何一个人，都可以给自己甚至别人签发SSL证书。但是这个世界上只有那么几家公司（比如Digicert（原Symantec，已更名）、Rapid、GlobalSign、Wosign、GeoTrust以及TrustAsia，甚至还有一些国产公司例如vTrus）被权威机构所认可，他们的CA根证书被集成到操作系统中了，只有CA根证书被集成到操作系统中，这个CA根证书下的子证书才能被浏览器认为是安全的。 收费版的SSL证书和免费版的证书有什么区别，主要体现在以下几点。 品牌不一样： 像DigiCert这样的公司，是全世界最被认可的公司，他们签发的证书，可激活互联网最受信任的诺顿安全签章，价格肯定会有所差别了。 身份审核不一样： 免费的CA证书只会验证域名信息，由系统自动签发完成，签发速度几乎是立即完成。付费的CA证书会对验证网站的真实性做严格的验证，可以这样说，有付费SSL证书签发的网站，几乎是不可能有问题的，因此可信度比较高，但是签发周期也比较长，一般要3-15个工作日。 安全保险不一样： 付费的CA证书大多都有保险，最高可享受175万美元的保额，也就是说你的网站在使用SSL证书通信期间，被黑客攻击了，那么是可以享受保险的。但是免费的CA证书是没有的。 签发的域名不一样： 付费的CA证书一般都可以签发好几个域名，但是免费的CA证书只能签发一个域名。 当然还有更多其他方面的不同，比如付费的CA证书加密算法方面会做得更加优秀等。但是如果只是一个个人站点，或者是小公司的网站，我们可以先用免费的CA证书来过渡。毕竟买一个付费的CA证书，最贵的一年也要1W多，少的也要1000多。 3. 颁发免费的SSL证书的机构提供免费SSL证书的机构有如下一些, 比如Let’s Encrypt, Cloudflare, Bluehost, SiteGround这些机构都提供免费的SSL证书, 国内的有阿里云, sslforfree.cn等机构. 值得注意的是这些机构提供的免费SSL证书都有一些限制, 有的在适用时间上, 有的在适用的domain的数量, 每一家申请需要的资料, 批准时间上都有所不同, 还有就是被认可的范围不同, 有些证书能被90%的浏览器或操作系统认可, 有些认可度较低, 需要详细了解后再从最适合自己的机构中申请. 以下以阿里云为例, 讲解如何获取免费的SSL证书. 4. 如何获取阿里云免费SSL证书4.1. 选择免费SSL证书进入到阿里云官网后，点击点击左侧菜单栏 =&gt; 产品与服务 =&gt; =&gt; 数据安全 =&gt; 数字证书管理服务(SSL证书) 打开 数字证书管理服务(SSL证书) 页面后, 在左侧菜单栏选择 SSL证书 =&gt; 选择免费证书tab 产品栏: 选择免费证书 购买数量: 选择20, 这个20代表可以给20个不同的域名签发证书 其它服务: 选择不需要 阅读并勾选协议 然后右下角会显示价格为0元，点击立即购买即可。 购买完成后创建证书案例上会显示”创建证书20/20”表示可以创建20个单域名证书. 4.2. 申请证书购买完证书后，还需要在控制台=&gt;证书管理服务-&gt;SSL证书, 点击创建证书，系统会自动创建一条DigiCert 免费版 SSL, 初始处于待申请状态. 点击证书申请按钮进入证书申请页面. 证书绑定域名: 输入你的完整域名 (请输入完整的单个域名，域名格式例如： ‘www.xxx.com'，IP证书仅Globalsign的OV单域名证书支持) 域名验证方式: 选择自动DNS方式 联系人: 创建并选择联系人 所在地: 输入所在地 密钥算法: RSA CSR生成方式: 选择合适的CSR生成方式 信息填写无误后点击申请. 申请成功后联系人会通过电话或邮箱收到通知. 4.3. DNS验证 登录域名管理控制台 如果域名在阿里云，请登录阿里云DNS控制台操作。如果您使用其他厂商的域名，请登录对应的域名管理控制台 在域名控制台添加DNS解析记录 请按以下提示，在您的域名控制台添加DNS解析配置 添加 记录类型为txt 主机记录为_dnsauth的域名解析记录, 如果域名是在阿里云购买的域名, 并且管理用户一致, 系统会自动帮助添加解析记录. 如果是其它情形, 请按提示指引添加域名解析配置. 接着点击下一步，再点击一个DNS验证， 然后就进入审核阶段。 因为是免费证书，整个签发过程都是由系统自动完成，因此在证书列表页面重新刷新一下页面，就能看到已签发的提示了。签发后即可下载证书使用了. 针对不同类型的服务器可以产品SSL证书安装章节进行配置. 4.4. SSL证书安装SSL证书申请下来后，还要配置到服务器上才能使用。不同的web服务器使用方法都有不同，详细的文档可以查看这篇文章在服务器安装SSL证书, 里面总结了现在市面上几乎所有web服务器安装SSL证书的教程。这里重点讲一下在nginx中如何安装证书 4.4.1 nginx中如何安装SSL证书步骤一：下载SSL证书 登录数字证书管理服务控制台。 在左侧导航栏，单击SSL 证书。 在SSL 证书页面，定位到目标证书，在操作列，单击下载。 在服务器类型为Nginx的操作列，单击下载。 解压缩已下载的SSL证书压缩包。 根据您在提交证书申请时选择的CSR生成方式，解压缩获得的文件不同，具体如下表所示 CSR生成方式 证书压缩包包含的文件 系统生成或选择已有的CSR 证书文件（PEM格式）：默认以证书ID_证书绑定域名命名。PEM格式的证书文件是采用Base64编码的文本文件。 私钥文件（KEY格式）：证书文件的密钥，默认以证书绑定域名命名。 手动填写 如果您填写的是通过数字证书管理服务控制台创建的CSR，下载后包含的证书文件与系统生成的一致。如果您填写的不是通过数字证书管理服务控制台创建的CSR，下载后只包括证书文件（PEM格式），不包含证书密码或私钥文件。您可以通过证书工具，将证书文件和您持有的证书密码或私钥文件转换成所需格式。转换证书格式的具体操作，请参见证书格式转换。 步骤二：在Nginx服务器安装证书 执行以下命令，在Nginx的conf目录下创建一个用于存放证书的目录。 12cd /usr/local/nginx/conf #进入Nginx默认配置文件目录。该目录为手动编译安装Nginx时的默认目录，如果您修改过默认安装目录或使用其他方式安装，请根据实际配置调整。mkdir cert #创建证书目录，命名为cert。 将证书文件和私钥文件上传到Nginx服务器的证书目录（/usr/local/nginx/conf/cert） 编辑Nginx配置文件nginx.conf，修改与证书相关的配置。 1vim /usr/local/nginx/conf/nginx.conf 参考如下示例进行配置 123456789101112131415161718192021222324252627282930 server { #HTTPS的默认访问端口443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 listen 443 ssl; #填写证书绑定的域名 server_name &lt;yourdomain&gt;; #填写证书文件名称 ssl_certificate cert/&lt;cert-file-name&gt;.pem; #填写证书私钥文件名称 ssl_certificate_key cert/&lt;cert-file-name&gt;.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #自定义设置使用的TLS协议的类型以及加密套件（以下为配置示例，请您自行评估是否需要配置） #TLS协议版本越高，HTTPS通信的安全性越高，但是相较于低版本TLS协议，高版本TLS协议对浏览器的兼容性较差。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示优先使用服务端加密套件。默认开启 ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; }} 5. 参考文章阿里云免费SSL证书白嫖指南","link":"/nginx/apply_ssl_certificate.html"},{"title":"nginx配置https","text":"1. 介绍HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。HTTPS 相比 HTTP 多了一层 SSL/TLS. SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 当客户端（例如Web浏览器）通过HTTPS向服务器发出请求时，服务器会响应一个数字证书，其中包含一个公钥。客户端然后使用此公钥加密一个随机对称密钥，该密钥用于加密在客户端和服务器之间发送的数据。这确保了数据不能被截获或被任何没有与服务器证书中的公钥相对应的私钥的人读取。 nginx 针对https提供ssl/tls配置功能的支持，这些功能由openssl库提供。nginx openssl模块在ngx_http_ssl_module实现，实际与openssl进行交互的模块还是在ngx_event_openssl以及ngx_event_openssl_stapling模块中。目前nginx可支持的ssl/tls版本如下: SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2 TLSv1.3，具体配置可支持的版本可以自由进行设置。openssl模块配置openssl的开启以及关闭，通常https配置的端口一般是443。 2. 前置条件 服务器已经安装nginx并且通过http可以正常访问。 不会安装nginx的可以参考下这篇文章：https://pengtech.net/nginx/nginx_installation.html 拥有ssl证书，没有的可以去阿里购买或者免费申请一年，或者使用息签发证书。 如果以上条件都满足了，接下来开始配置https 3. 第一步：Nginx的ssl模块安装如果你是按照上面的安装指南安装的nginx, 默认是安装了ssl模块的. 如果没有安装ssl模块需先安装ssl模块, 再进行后续的配置. 检查是否安装ssl模块的方法, 通过从终端运行以下命令来检查: 1nginx -V 2&gt;&amp;1 | grep -o with-http_ssl_module 如果输出了”with-http_ssl_module”, 则表示SSL模块已经安装, 否则没有安装. 4. 第二步：配置ssl证书将在阿里云或其它证书代理机构购买的证书下载下来, 解压缩下载好的证书(证书一般是pem或crt文件和key文件，这里名字可以随便改) 将下载好的证书上上传到服务器，我将证书放在了/usr/local/nginx/ssl文件夹. 修改/etc/nginx/conf.d/default.conf配置 123456789101112server { listen 443; server_name your_domain.com www.your_domain.com; ssl on; ssl_certificate /usr/local/nginx/ssl/nginx122.pem ssl_certificate_key /usr/local/nginx/ssl/private122.key location / { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:4000/; } } 另外需要将来自http的请求重定向至https server 123456server { listen 80; server_name your_domain.com www.your_domain.com; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent;} 5. 第三步：重启nginx123systemctl retart nginx 6. 参考文档Nginx配置Https（详细、完整） 阿里云免费SSL证书白嫖指南","link":"/nginx/nginx_config_https.html"},{"title":"nginx安装教程","text":"1. 介绍1.1. 什么是nginxNginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接， 并且cpu、内存等资源消耗却非常低，运行非常稳定。 1.2. 应用场景1、http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时， 需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载， 不会因为某台服务器负载高宕机而某台服务器闲置的情况. 2. 安装2.1. 安装环境说明OS: CentOS Linux release 7.7.1908 2.2. 建立nginx的yum仓库12345# for Centos 7wget http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmrpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm 12345678910111213141516171819202122# for almalinux 8# 手动添加yam源# vi /etc/yum.repos.d/nginx.repo# nginx-mainline 没有启用，如要启用将enabled设置为1[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=file:///etc/pki/rpm-gpg/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/nginx_signing.keymodule_hotfixes=true 2.3. 下载并安装nginx1yum install -y nginx 2.4. 启动nginx服务1systemctl start nginx nginx默认监听在80端口, 可以使用浏览器访问http://your_server_id测试nginx是否启动成功. 3. 配置默认的配置文件在 /etc/nginx 路径下，使用该配置已经可以正确地运行nginx；如需要自定义，修改其下的 nginx.conf 等文件即可。 如果对安全性要求不高的话, 建议关闭selinux 1、临时关闭：输入命令setenforce 0，重启系统后还会开启。2、永久关闭：输入命令vi /etc/selinux/config，将SELINUX=enforcing改为SELINUX=disabled，然后保存退出 4. 问题排查nginx的日志位于 /var/log/nginx 如果出现以下错误, 请查看该文章 nginx bind() to 0.0.0.0:**** failed (13: Permission denied) 原因是seLinux限制了http的端口 5. 参考文档CentOS 7 安装nginx Nginx配置文件详解","link":"/nginx/nginx_installation.html"},{"title":"Linux（ Almalinux 9）上安装 nginx安装教程","text":"1. 介绍1.1. 什么是 nginxNginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 nginx 能够支支撑 5 万并发链接， 并且 cpu、内存等资源消耗却非常低，运行非常稳定。 1.2. 应用场景1、http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时， 需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载， 不会因为某台服务器负载高宕机而某台服务器闲置的情况. 2. 安装2.1. 安装环境说明12cat /etc/almalinux-releaseAlmaLinux release 9.4 (Seafoam Ocelot) 2.2. 下载并安装 nginx如果要安装最新版本的 nginx 需要配置 nginx rpm 仓库。 但是 Almalinux 9 appstream 仓库中的版本也比较新，基本够用了。 1sudo dnf install -y nginx 2.3. 配置 Nginx默认的配置文件在 /etc/nginx 路径下，使用该配置已经可以正确地运行 nginx；如需要自定义，修改其下的 nginx.conf 等文件即可。 如果对安全性要求不高的话, 建议关闭 selinux 1、临时关闭：输入命令 setenforce 0，重启系统后还会开启。2、永久关闭：输入命令 vi /etc/selinux/config，将 SELINUX=enforcing 改为 SELINUX=disabled，然后保存退出 2.4. 修改防火墙设置123sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo systemctl reload firewalld 2.5. 将 nginx 设置为开机自启动并立即启动 nginx1sudo systemctl enable nginx nginx 默认监听在 80 端口, 可以使用浏览器访问http://your_server_id测试 nginx 是否启动成功. 3. 问题排查nginx 的日志位于 /var/log/nginx 如果出现以下错误, 请查看该文章 nginx bind() to 0.0.0.0:**** failed (13: Permission denied) 原因是 seLinux 限制了 http 的端口 4. 参考文档CentOS 7 安装 nginx Nginx 配置文件详解","link":"/nginx/nginx_installation_on_almalinux.html"},{"title":"Linux下通过Nginx日志分析网站访问情况","text":"1. 前言作为一位站长, 了解网站的访问情况是日常的重要内容, 以下就是关于通过Nginx日志了解访问情况的一些常用命令.这里罗列于此, 希望对您有所帮助, 更多关于开发, 运维, 以及产品方面的文章请访问鹏叔的技术博客, 该博客空间中涉及到的技术都是鹏叔在开发与维护网站过程中总结出来的. 2. 访问IP相关统计2.1. 统计IP访问量(PV)123awk '{print $7}' /var/log/nginx/access.log | wc -l 2.2. 独立IP访问统计(UV)123awk '{print $7}' /var/log/nginx/access.log | sort -n | uniq |wc -l 2.3. 查看某一时间段的IP访问量(4-5点)1grep '21/Jul/2023:0[4-5]' /var/log/nginx/access.log | awk '{print $1}' | sort -n | uniq | sort -nr |wc -l 2.4. 查看访问最频繁的前100个IP1awk '{print $1}' /var/log/nginx/access.log | sort -n | uniq -c | sort -nr | head -n 100 2.5. 查看访问次数在100次以上的IP1awk '{print $1}' /var/log/nginx/access.log | sort -n | uniq -c | awk '{if($1 &gt;100) print $0}' | sort -nr 2.6. 查看某个IP的详细访问情况，按访问频率排序123grep '127.0.0.1' /var/log/nginx/access.log | awk '{print $1,$7}' | uniq -c | sort -rn | head -n 100 3. 页面访问统计3.1. 查看访问最频繁的页面(top 50)1awk '{print $7}' /var/log/nginx/access.log | sort | uniq -c | sort -rn | head -n 50 3.2. 查看访问最频繁的页面(排除js, css, 字体等页面)(top 50)1grep -vE '.js|.woff2|.woff|.css|.ico' /var/log/nginx/access.log | awk '{print $7}' | sort | uniq -c | sort -rn | head -n 50 3.3. 查看页面访问次数超过100次的页面123cat /var/log/nginx/access.log | cut -d ' ' -f 7 | sort | uniq -c | awk '{if($1 &gt;100) print $0}' | less 3.4. 查看最近1000条记录中访问量最高的页面123tail -1000 /var/log/nginx/access.log | awk '{print $7}' | sort | uniq -c | sort -rn | less 4. 请求量统计4.1. 统计每秒的请求数，top100的时间点(精确到秒)123awk '{print $4}' /var/log/nginx/access.log | cut -c 14-21| sort | uniq -c | sort -rn| head -n 100 4.2. 统计每分钟的请求数，top100的时间点(精确到分钟)123awk '{print $4}' /var/log/nginx/access.log | cut -c 14-18| sort | uniq -c | sort -rn| head -n 100 4.3. 统计每小时的请求数，top10的时间点(精确到小时)123awk '{print $4}' /var/log/nginx/access.log | cut -c 14-15| sort | uniq -c | sort -rn| head -n 10 5. 性能分析前置条件：在nginx的log中最后一个字段加入$request_time 5.1. 列出传输时间超过3秒的页面，显示前20条1cat /var/log/nginx/access.log | awk '($NF&gt;3){print $7}' | sort -n | uniq -c | sort -nr | head -20 5.2. 列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条1cat /var/log/nginx/access.log | awk '($NF &gt; 1 &amp;&amp; $7~/\\.php/) {print $7}' | sort -n | uniq -c | sort -nr | head -100 6. TCP连接统计6.1. 查看当前TCP连接数1netstat -tan | grep &quot;ESTABLISHED&quot; | grep &quot;:80&quot; | wc -l 6.2. 用tcpdump嗅探80端口的最高访问123tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F &quot;.&quot; '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&quot;.&quot;}'| sort | uniq -c | sort -rn 7. 搜索引擎蜘蛛访问行为7.1. 查看有哪些搜索引擎蜘蛛来过1cat /var/log/nginx/access.log | grep sitemap 8. 相关文章更多Nginx相关文章请访问 鹏叔的技术博客 - nginx专题 9. 参考文档nginx 统计请求次数_Linux下通过Nginx日志分析网站访问情况的常用命令","link":"/nginx/nginx_log_analyze.html"},{"title":"如何创建Nodejs模块基础篇","text":"1. 背景介绍 本人写了一个音乐播放器程序，想把其中核心的部分发布成Nodejs模块，这样我无论是在web端，还是桌面端都能引用该核心模块，我想在web端实现一个网友播放器，桌面端利用Electron包装一下实现一个桌面版的播放器，这样同一套代码，多端就可以共用了．说干就干, 以下记录了nodejs创建一个模块． 2. 创建一个Nodejs模块 创建node非常简单就是创建一个js文件 但是对模块暴露对象的方式有要求, 详情参考CommonJS规范 by 阮一峰 3. 首先创建一个nodejs工程 创建用来包含工程文件的文件夹例如 1234# 创建用来存放工程的目录mkdir h5-audio-player# 进入目录cd h5-audio-player 初始化nodejs工程 使用npm init 命令来初始化项目，此时它会要求输入一下项目信息，根据自己的实际情况输入即可， 后续我们会介绍工程文件的各参数的含义，后续还有机会手动调整参数． 123456789101112131415161718192021222324252627$npm initpackage name: (audioplayer)version: (1.0.0) 0.1.0description: a javascript library or utility for creating audio player on web or server or mobile sideentry point: (index.js)test command:git repository:keywords: audioplayerauthor: eaglelicense: (ISC)About to write to your_proj_path/h5-audio-player/package.json:{&quot;name&quot;: &quot;audioplayer&quot;,&quot;version&quot;: &quot;0.1.0&quot;,&quot;description&quot;: &quot;a javascript library or utility for creating audio player on web or server or mobile side&quot;,&quot;main&quot;: &quot;index.js&quot;,&quot;scripts&quot;: {&quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;},&quot;keywords&quot;: [&quot;audioplayer&quot;],&quot;author&quot;: &quot;eagle&quot;,&quot;license&quot;: &quot;MIT&quot;}Is this OK? (yes) yes 初始化完成后, 项目的目录结构如下: 123$tree -L 2audioplayer└── package.json 可以看到初始化命令帮我们做的工作就是创建了一个package.json文件，里面包含了包名，版本等等信息，如果对package.json熟悉，手写或从其他项目拷贝一份来修改也是可以的，而且了解package.json相关的规范是我们开发nodejs项目必须要掌握的内容． 这里着重要强调一点的是license的选择，对于一个需要发布到npm库上的npm包，license的选择要非常慎重，这个不仅影响自己当前项目或相关联项目，也影响其他人的项目，甚至会涉及到违反知识产权保护的问题，这里推荐阅读开源协议介绍后再做修改．这里我选择的MIT协议，一个相对宽松的协议，目前项目暂时没有依赖第三方nodejs模块的，所以暂时不会受到第三方协议的影响，协议选择完全掌控在自己手里，我可以自己决定． 4. 创建自己的nodejs模块Node 应用由模块组成，采用 CommonJS 模块规范。这里放一个非常简单的例子, 首先创建一个greeting模块，也就是greeting.js文件，给世界请安，告诉这个世界我来了．另外还想让这个模块有点智慧，一出生就能算个加法，当然这个模块最终将比较有音乐天赋．greeting.js 123456789101112function greeting() { console.log(&quot;hello, world&quot;);}function add(a, b) { result = a + b; console.log(a + &quot; + &quot; + b + &quot; =&quot; + result); return result;}module.exports.greeting = greeting;module.exports.add = add; 然后修改package.json, 让main的值等于greeting.js, 这样我们在引入audioplayer的时候，node就会自动去找加载greeting.js,如果package.json中没有设定main属性或者main属性设置为index.js，node默认会去找audioplayer下的index.js并加载. 1&quot;main&quot;: &quot;greeting.js&quot;, 5. 添加README.md文件 为了使他人能找到你的nodejs模块，并获得较好的用户体验，我们建议在模块中包含一个README.md文件. README文件包含一下关于模块的描述信息，怎样安装，如何使用，有没有特殊的配置，以及其他一些有用的信息．当他人搜索到你的模块时，会觉得有帮助，愿意尝试使用你的js包． 6. 测试nodejs模块 发布之前最好测试一下即将发布的模块，这样可以减少因为一些小问题反复发布新版本的问题．下面介绍如何在发布之前进行测试 第一步: 创建一个测试项目 在模块处于同级的位置创建一个测试项目 1mkdir h5-audio-player_test 第二步：测试项目中安装即将发布的模块 这里要说明一点，由于我们的模块还没有真正发布到npm仓库，还不能使用模块名来安装模块 这里安装模块时需要使用模块所处位置的完整路径，或者相对路径 123456789$cd h5-audio-player_test$npm install ../h5-audio-player$tree h5-audio-player_test ├── node_modules │ └── h5-audio-player -&gt; ../../h5-audio-player ├── package-lock.json └── test.js 第三步：编写测试用例 在测试项目下创建一个test.js 1234var audioplayer = require('h5-audio-player');audioplayer.greeting();var sum =audioplayer.add(1, 2);console.log(sum) 第四步：运行测试用例 1234$node test.jshello, world1 + 2 =33 由于时间的关系，也是为了让用户容易理解如何创建nodejs，麻雀虽小五脏俱全，这里创建的nodejs模块和测试用例都非常简单，后续将实现一个非常复杂的案例，考虑到nodejs使用的方方面面，比较接近实战, 敬请期待． 7. 发布nodejs 模块 发布模块请参考我的博客文章如何发布一个nodejs模块 8. Nodejs 系列文章最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 9. 参考文档 在Nodejs中创建自己的模块 Contributing packages to the registry Commonjs规范与模块化 Commonjs规范及Node模块实现 (推荐) CommonJS规范 by 阮一峰 (推荐)","link":"/nodejs/how_to_create_a_node_module.html"},{"title":"如何发布一个nodejs模块","text":"1. 背景介绍本人写了一个音乐播放器程序，想把其中核心的部分发布成Nodejs模块，这样我无论是在web端，还是桌面端都能引用该核心模块，我想在web端实现一个网友播放器，桌面端利用Electron包装一下实现一个桌面版的播放器，这样同一套代码，多端就可以共用了．说干就干, 以下记录了nodejs发布的全过程． 2. Nodejs发表流程首先了解一下nodejs发表流程， 3. 注册npm用户这里有两种方式，两种方式任选一种： 方式一：到npm官网注册 官网网址为: https://www.npmjs.com/ 注册过程非常简单，如果你的邮箱能正常收件的话 打开官网首页后, 点击sign up按钮, 系统会导航到注册页面，输入用户名，输入密码点击创建用户即可． ~~ 似乎不用验证邮箱的有效性，当然为了账号安全，务必记住密码和确保邮箱是正确的．~~ 补充这里创建账号后一定要去邮箱检查有没有严重邮箱的邮件, 及时进行验证, 如果过了24小时再去验证就很麻烦了, 而且影响后续的publish命令的使用. 方式二：使用命令行注册 1234$ npm adduserUsername: your_namePassword: your_password #需要牢牢记住密码Email: (this IS public) #正确填写你的邮箱, 方便以后找回密码 注册完成后记住用户名密码，后续步骤需要用到． 4. 创建一个nodejs模块创建Nodejs模块可以参考我的博客文章如何创建Nodejs模块基础篇 5. 发布nodejs模块到npm中央仓库 说明：publish之前需要注意一点，是我们项目中的所有文件都需要上传到npm服务器，此时我们可以创建一个.npmignore文件忽略掉不需要上传的文件, .npmignore 可以被认为是一个黑名单即包含在.npmignore文件中的文件不发布，这样会带来一些麻烦，每增加一个源文件，都需要调整.npmignore文件，而调整文件这件事是很容易被忘记的，如果新增文件中包含了CI/CD等等的保密信息，有可能无意中发布出去，存在一定的安全风险. 所以这里最好使用白名单，或者白名单与黑名单结合．白名单需要在package.json的files上设置．例如 package.json 1234567&quot;files&quot;: [ &quot;package.json&quot;, &quot;greeting.js&quot;, &quot;audioplayer.js&quot;, &quot;README.md&quot;, &quot;index.js&quot; ] 全局安装 nrm 并切换到npm registry 12sudo cnpm install -g nrm nrm use npm 或者手动修改~/.npmrc 将registry改回到npm registry https://registry.npmjs.org/ 或者 命令行切换到npm registry 1npm config set registry https://registry.npmjs.org/ 首先在命令行中登录nodejs 12345$npm loginUsername: your_usename #输入用户名Password: your_password #输入用户名Email: (this IS public) your_email #输入邮箱Logged in as xxxxx on https://registry.npmjs.org/. 成功之后，npm会把认证信息存储在~/.npmrc中，可查看npm当前使用的用户： 1$npm whoami 开始发布 12345678910111213141516171819$npm publish npm notice npm notice 📦 h5-audio-player@0.1.0 npm notice === Tarball Contents === npm notice 13.1kB audioplayer.js npm notice 230B greeting.js npm notice 57B index.js npm notice 348B package.json npm notice 1.0kB README.md npm notice === Tarball Details === npm notice name: h5-audio-player npm notice version: 0.1.0 npm notice package size: 4.2 kB npm notice unpacked size: 14.8 kB npm notice shasum: f0719dcd923b9b6806e66c03e7aaf5409d16b00c npm notice integrity: sha512-3eKgKEQpgfMx0[...]ci2QctFZaH/PQ== npm notice total files: 5 npm notice + h5-audio-player@0.1.0 6. 验证发布是否成功 首先创建一个测试文件夹 然后切换回淘宝npm镜像 1234$mkdir test #建测试文件夹$cd test #进入测试项目$nrm use taobao #切换回淘宝npm镜像$cnpm install h5-audio-player@0.1.0 #安装刚刚发布的包 安装完成后项目的目录结构如下 12345678910$tree test test └── node_modules ├── h5-audio-player -&gt; _h5-audio-player@0.1.0@h5-audio-player └── _h5-audio-player@0.1.0@h5-audio-player ├── audioplayer.js ├── greeting.js ├── index.js ├── package.json └── README.md 执行测试用例 12345678910111213~/proj/test$nodeWelcome to Node.js v14.17.6.Type &quot;.help&quot; for more information.&gt; let player = require('h5-audio-player');undefined&gt; player.add(2, 3);2 + 3 =55&gt; player.greeting();hello, worldundefined&gt; .exit 7. 删除npm包 有些时候发现发布的包有bug或有安全风险，还可以进行删除，npm给我们留下了反悔的机会． 1234npm unpublish --force //强制删除npm unpublish packageName@1.0.0 //指定版本号npm deprecate //某些情况npm unpublish packageName --force //npm撤销（24小时内可以撤销） 8. 参考文章 有关 npm login 和publish 的疑惑 9. trouble shooting9.1. 登录npm服务器失败123456$npm loginUsername: xxxxPassword:Email: (this IS public) xxxxx@gmail.comnpm ERR! code E409npm ERR! 409 Conflict - PUT https://registry.npm.taobao.org/-/user/org.couchdb.user:xxx - [conflict] User xxxx already exists 原因分析：可以看出报错出现了taobao.org 这不是我想要的，我想要的是发表到npmjs.org详细原因可以参考这篇文章有关 npm login 和publish 的疑惑 解决方案有两个可以全局安装 nrm 123sudo cnpm install -g nrm nrm use taobaonrm use npm 9.2. 发布时提示24小时内不让上传403 Forbidden - PUT https://registry.npmjs.org/h5-audio-player - h5-audio-player cannot be republished until 24 hours have passed原因分析:出现这个原因是因为输入的邮箱📮没有校验,⚠️查看手机的邮箱的文件点击验证!!! 10. Nodejs 系列文章最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs","link":"/nodejs/how_to_publish_node_modules.html"},{"title":"安装并配置nodejs","text":"1. 安装 nodejsNode.js 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境。 1.1. 下载安装文件 官网：https://nodejs.org/en/ 版本信息: 20.12.2 下载地址: for windows:https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/v20.12.2/node-v20.12.2-x64.msi 建议保存到本地: %software%/nodejs/v20.12.2历史版本列表https://nodejs.org/dist for linux:node-v20.12.2 123wget -O /tmp/node-v20.12.2-linux-x64.tar.xz https://npmmirror.com/mirrors/node/v20.12.2/node-v20.12.2-linux-x64.tar.xz for macosnode-v20.12.2.pkg 123curl --proto '=https' --tlsv1.2 -o /tmp/node-v20.12.2.pkg https://npmmirror.com/mirrors/node/v20.12.2/node-v20.12.2.pkg 如果遇到 302 not found 问题, 建议手动下载文件后上传的 macOS 机器 1.2. 安装1.2.1. 安装步骤1.2.1.1. windows 操作系统双击安装文件, 点击下一步下一步, 按照安装指引进行. 1.2.1.2. linux 操作系统12# 解压sudo tar -xvf /tmp/node-v20.12.2-linux-x64.tar.xz -C /usr/local 1.2.1.3. macos 操作系统双击 node-v20.12.2.pkg 文件, 按照安装指引安装. 1.2.1.4. 设置环境变量(适用于 macOS 和 linux)更新软链接 123sudo ln -fs /usr/local/node-v20.12.2-linux-x64 /usr/bin/nodejs 将/usr/bin/nodejs/bin 添加到 path 环境变量, 这样做的好处是当升级或者切换版本时只需要更改软连接即可. 不需要修改环境变量. 新建/etc/profile.d/nodejs.sh 文件，内容如下 123export PATH=$PATH:/usr/bin/nodejs/bin 1.3. 配置由于不知名的原因, 国内访问 npm 仓库会很慢, 所以需要设置镜像, 淘宝为我们提供了很好的镜像源. 12345678910# 设置淘宝镜像npm config set registry https://registry.npmmirror.com# 或者使用华为镜像# npm config set registry https://mirrors.huaweicloud.com/repository/npm/# 或者使用腾讯镜像# npm config set registry http://mirrors.cloud.tencent.com/npm/// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 注：如果想还原 npm 仓库地址，只需再把地址配置成 npm 镜像就可以了 1npm config set registry https://registry.npmjs.org/ 1.4. 检测1.4.1. 检测版本1node -v 1.4.2. 运行 hello-world2. 安装 cnpm有些时候通过 npm 安装包由于网络的原因可能会失败, 所以只要是在国内做开发建议使用 cnpm 替代 npm, 该程序会首先从国内镜像站点(淘宝镜像)拉取依赖包.https://npm.taobao.org/ 安装 cnpm 命令如下 1sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 2.1. 检测是否安装成功1cnpm -v 3. 如何卸载 nodejs有时安装过程中遇到无法解决的问题, 或安装了不合适的版本需要重新安装, 此时需要卸载重装. 卸载可以参考以下步骤. 3.1. windows 上卸载 nodejs 开始-搜索: node – 点击 uninstall node.js, 或者 从卸载程序卸载程序和功能。 重新启动（或者您可能会从任务管理器中杀死所有与节点相关的进程）。 寻找这些文件夹并删除它们（及其内容）（如果还有）。根据您安装的版本，UAC 设置和 CPU 架构，这些可能或可能不存在： 12345C:\\Program Files (x86)\\NodejsC:\\Program Files\\Nodejs# 将C:\\Users\\{User}\\AppData\\Roaming\\npm（或%appdata%\\npm）C:\\Users\\{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） 检查您的%PATH%环境变量以确保没有引用 Nodejs 或 npm 存在。可以使用命令行, 打开环境变量配置界面, 进行检查 1rundll32 sysdm.cpl,EditEnvironmentVariables 如果仍然没有卸载，请 where node 在命令提示符下键入，您将看到它所在的位置 – 删除（也可能是父目录）。 重新启动，很好的措施。 3.2. 在 MacOS 上卸载 nodejs这是卸载 Node 最具挑战性的方法，因为您必须追踪许多不同的文件，并逐个手动删除它们。 单击 Dock 中的 Finder 图标，选择 Go(前往)菜单，然后转到文件夹。 在文本框中粘贴以下目录路径：/usr/local/bin 查找名为“node”的文件，并将它们移到垃圾桶中。 对以下目录重复这三个步骤，将每个路径粘贴到“转到文件夹”中的文本框中，并将带有“node”的文件拖动到垃圾箱中。 12345678910111213/usr/local/bin/usr/local/include/usr/local/share/man/man1//usr/local/lib/dtrace//usr/local/share/doc//usr/local/share/systemtap/tapset/ 在 Centos 上卸载 nodejs如果是按照本教程安装的 nodejs, 卸载过程包含以下几个步骤. 停止正在运行的程序 12systemctl stop nginxsystemctl stop pm2-root 删除软链接 1234567891011# 删除以下三个软连接, 并检查任何node相关的软连接, 例如pm2, ng等等# 检查相关软链接cd /usr/binls -lt | grep -i node# 删除nodejs相关软链接sudo rm /usr/bin/nodesudo rm /usr/bin/npmsudo rm /usr/bin/npx 删除软件 1sudo rm -rf /usr/local/node-v20.12.2-linux-x64 删除配置文件 1sudo rm ~/.npmrc 删除缓存文件 1sudo rm -rf ~/.npm 在 ubuntu 上卸载 nodejs 删除/usr/bin 下的软连接 1234567891011121314151617181920212223cd /usr/binls -lt| grep node# 将列出的nodejs相关的软连接都删除掉# 删除angular clirm -f ng# 删除npmrm -f npm# 删除noderm -f node# 删除npxrm -f npx# 删除typescript编译器rm -f tsc# 删除node-gyp-buildrm -f node-gyp-build# 删除 node-gyp-build-optionalrm -f node-gyp-build-optional# 删除 build-testrm -f build-test# 删除 pnpmrm -f pnpm 清除缓存 1rm -rf ~/.npm 删除安装目录 按照本教程安装的 nodejs 位于 /usr/local/node-vx.xx.x-linux-x64, 将其删除。 例如： 1rm -rf /usr/local/node-v18.16.1-linux-x64 4. 如何升级 Nodejs参考我的博客 - Nodejs 升级以及快速版本切换 5. Nodejs 系列文章最新更新以及更多 Nodejs 相关文章请访问 鹏叔的技术博客 - Nodejs 6. 参考文档npm 的卸载与安装流程 完全卸载 node npm npm 更换成淘宝镜像源以及 cnpm Node 快速切换版本、版本回退(降级)、版本更新(升级)","link":"/nodejs/install_and_config_nodejs.html"},{"title":"Linux下安装nodejs-源码安装","text":"大多数情况下我们都能够使用二进制文件安装nodejs, 各种包管理生态下, 以及各种操作系统环境下的安装方式, 在我往期的博客中都有介绍. 但是有些某些系统或环境下, 或者由于个人偏好, 还是需要通过源码安装nodejs, 那么此篇文章或许对您有帮助. 关于各种二进制文件形式安装可以参考我的博客 安装并配置nodejs | 鹏叔的技术博客 1. 环境说明linux 版本 12uname -aLinux 4.15.0-29deepin-generic #31 SMP Fri Jul 27 07:12:08 UTC 2018 x86_64 GNU/Linux Nodejs 版本：node-v14.17.5 2. 安装前准备安装必要的依赖包 123sudo apt-get install g++ 3. 下载源码下载 nodejs 源代码 1234567891011sudo mkdir -p /opt/nodejs/cd /opt/nodejs/sudo wget https://nodejs.org/dist/v14.17.5/node-v14.17.5.tar.gzsudo tar xvf node-v14.17.5.tar.gzcd node-v14.17.5sudo ./configuresudo makesudo make installsudo ln -s /usr/local/bin/node /usr/sbin/node 4. 验证是否安装成功12# 查看当前安装的Node的版本node -v 如果能正常打印版本信息, 说明安装成功! 5. 关联阅读安装并配置nodejs Nodejs升级以及快速版本切换 最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 6. troubleshooting当运行./configure 命令时，如果遇到 g++命令未找到错误，需要安装 g++后再继续执行./configure 1sudo apt-get install g++ 7. 参考文档Linux下安装nodejs-源码安装","link":"/nodejs/install_nodejs_via_source.html"},{"title":"Centos上安装nvm","text":"1. 前言Node Version Manager (NVM) 是一种广泛使用的工具，允许开发人员在单台计算机上管理 Node.js 的多个版本。它的重要性怎么强调都不为过，因为 Nodejs 应用程序有时可能是依赖特定版本运行，然而不同的项目可能需要不同的 Nodejs 版本。NVM 提供的灵活性确保了不同项目同时运行在同一台机的开发过程的顺利进行，允许开发人员在 Node 版本之间无缝切换。在 macOS 上，有多种安装 NVM 的方法，但最流行、最有效的方法之一是使用 Homebrew，这是 macOS 著名的包管理器。 本指南将引导您完成使用 yum 在 centOS 7.9 上安装 NVM 的详细步骤，让您轻松设置灵活的 Node.js 开发环境。 先决条件 需要安装 git 需要安装 curl 或者 wget 删除现有 Nodejs 版本可以参考我的博客安装并配置 nodejs尾部”在 Centos 上卸载 nodejs”章节所述的方法删除 Nodejs. 安装 nvm以管理员身份 123curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash# 或者wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash 由于网络阻塞的原因, 如果自动安装步骤运行不了, 可以手动步骤替代. 下载安装文件 在某台能下载安装文件的机器下载安装包, 并上传到服务器的/tmp 目录 安装文件位于https://github.com/nvm-sh/nvm/archive/refs/tags/v0.39.5.tar.gz 安装 1sudo tar -xvf /tmp/nvm-0.39.5.tar.gz -C /usr/local 配置 nvm在配置 nvm 之前, 我们要理解官网上的这句话 nvm is a version manager for node.js, designed to be installed per-user, and invoked per-shell. nvm works on any POSIX-compliant shell (sh, dash, ksh, zsh, bash), in particular on these platforms: unix, macOS, and windows WSL. 其中的 per user and invoked per-shell 非常重要. 当我们从手动安装 nodejs 的方式, 切换到 nvm 来管理的时候, 可能会不适应. 因为 nodejs 的安装是 per system 的, 就是安装一套 nodejs, 系统上的所有用户都可以公用, 而且大多数软件都是这种方式. 但是 nvm 在这方面有所颠覆, 它是 per user 的, 就是系统上有 10 个用户, 我们得分别使用nvm install x.y.z 十次. 如果我们不转变思想, 依然按照 per system 的理解去安装与配置 nodejs, 后面使用起来会遇到很多奇奇怪怪的问题. 当然 per user 这种方式有好处也有坏处, 好处是它能做到真正的软件的多版本共存, 当然多版本共存本来就是软件管理实践中一种新的尝试. 无论哪种新的实践, 初期都会有这样或者那样的问题. 缺点也是显而易见的, 就是占用系统空间比较多, 不仅 nodejs 本身会被安装多次, 就连 nodejs 依赖包也会重复多份, 这就有些夸张了. 毕竟 nvm 现在的版本号依然是 0.35.x 还没有到达 1.0 阶段. “per shell”也很好理解, 不同的 shell 进程可以使用各种独立的, 不同与其他 shell 的 nodejs 版本以及配置, 如果多版本能做到这种粒度, 在功能上已经非常完美了. 如果在性能上再有所改善, 例如让磁盘空间占用更小一点, 内存占用更小一点, cpu 性能损耗更小一些, 那就完美了. 开始配置接下来，在用户主目录中创建一个 .nvm 目录, 将来 nodejs 的各版本, 以及依赖包都会安装在这个目录下, 以实现用户隔离. 1mkdir ~/.nvm vim $HOME/.bash_profile 123456789101112export NVM_DIR=&quot;$HOME/.nvm&quot;# 配置 nvm 镜像, 加快下载nodejs的速度export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node# 加载nvm相关命令[ -s &quot;/usr/local/nvm-0.39.5/nvm.sh&quot; ] &amp;&amp; source &quot;/usr/local/nvm-0.39.5/nvm.sh&quot;# 加载nvm命令补全配置[ -s &quot;/usr/local/nvm-0.39.5/etc/bash_completion&quot; ] &amp;&amp; source &quot;/usr/local/nvm-0.39.5/bash_completion&quot;# 设置默认node版本nvm use 16 使用 NVM首先，查看可以安装哪些 Node 版本。要查看可用版本，请键入： 12nvm ls-remote 现在，您可以安装上面输出中列出的任何版本。您还可以使用别名，例如 node 表示最新版本，lts 表示最新 LTS 版本等。 123sudo nvm install node ## 安装最新版本# 或者sudo nvm install 17 ## 安装 Node.js 17.X 版本 安装后，可以验证安装的内容： 1nvm ls 如果您的系统上安装了多个版本，您可以随时将任何版本设置为默认版本。要将节点 18.X 设置为默认版本，只需使用： 123nvm use 17 同样，您可以安装其他版本（例如 Node 12、15 和 18 版本）并在它们之间切换。 更多 nvm 命令 12345678910111213141516171819# 查看帮助nvm --helpnvm uninstall 17# 使用特定版本的node运行脚本nvm run 6.10.3 app.js# 使用特定版本的node运行脚本并将path指向该版本的nodenvm exec 4.8.3 node app.js# 设置默认的node版本nvm alias default 16.14.2# 如果您只想返回使用系统版本的Node，则无需卸载NVM。# 在这种情况下，请运行命令nvm use system 配置 Nodejs由于不知名的原因, 国内访问 npm 仓库会很慢, 所以需要设置镜像, 淘宝为我们提供了很好的镜像源. 12345678910设置淘宝镜像npm config set registry https://registry.npmmirror.com# 或者使用华为镜像# npm config set registry https://mirrors.huaweicloud.com/repository/npm/# 或者使用腾讯镜像# npm config set registry http://mirrors.cloud.tencent.com/npm/// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 参考文档nvm github","link":"/nodejs/install_nvm_on_centos.html"},{"title":"MacOS上安装nvm","text":"1. 前言Node Version Manager (NVM) 是一种广泛使用的工具，允许开发人员在单台计算机上管理 Node.js 的多个版本。它的重要性怎么强调都不为过，因为 Nodejs 应用程序有时可能是依赖特定版本运行，然而不同的项目可能需要不同的 Nodejs 版本。NVM 提供的灵活性确保了不同项目同时运行在同一台机的开发过程的顺利进行，允许开发人员在 Node 版本之间无缝切换。在 macOS 上，有多种安装 NVM 的方法，但最流行、最有效的方法之一是使用 Homebrew，这是 macOS 著名的包管理器。 本指南将引导您完成使用 Homebrew 在 macOS 上安装 NVM 的详细步骤，让您轻松设置灵活的 Node.js 开发环境。 2. 先决条件 需要拥有管理员权限 如果尚未安装 Homebrew，可以参考我的博客Macos开发环境配置中关于配置Homebrew部分. 3. 删除现有Nodejs版本如果您的系统已经安装了节点，请先将其卸载。我的系统已经通过 Homebrew 安装了节点。所以先卸载它。如果尚未安装，请跳过。 1234brew uninstall --ignore-dependencies node brew uninstall --force node 如果是通过pkg安装包安装的, 可以参考我的博客安装并配置nodejs尾部”在MacOS上卸载nodejs”章节所述的方法删除Nodejs. 4. 在macOS上安装NVM在安装任何软件包之前，最好将 Homebrew 更新到最新. 1brew update 之后，您可以使用以下命令轻松安装 NVM： 1brew install nvm 接下来，在用户主目录中创建一个 .nvm 目录 1mkdir ~/.nvm 现在，配置所需的环境变量。在用户主目录中编辑以下配置文件 注意: 在配置nvm前, 先确定一下当前用户的Shell类型echo $SHELL, 如果是bash, 则按bash的配置方式, 如果是zsh则参照zsh的配置方式. 1vim ~/.bash_profile 将以下行添加到~/.bash_profile（或 ~/.zshrc 对于 macOS Catalina 或更新版本） 12345678# 配置NVM_DIRexport NVM_DIR=&quot;$HOME/.nvm&quot;# 加载nvm相关命令[ -s &quot;/usr/local/opt/nvm/nvm.sh&quot; ] &amp;&amp; \\. &quot;/usr/local/opt/nvm/nvm.sh&quot;# 加载nvm命令补全配置[ -s &quot;/usr/local/opt/nvm/etc/bash_completion&quot; ] &amp;&amp; \\. &quot;/usr/local/opt/nvm/etc/bash_completion&quot; 接下来，将变量加载到当前 shell 环境。从下次登录开始，它会自动加载。 123source ~/.bash_profile # 或源 ~/.zshrc 就是这样。NVM 已安装在您的 macOS 系统上。转到下一步，在 nvm 的帮助下安装 Node.js 版本。 5. 使用 NVM首先，查看可以安装哪些 Node 版本。要查看可用版本，请键入： 123nvm ls-remote 现在，您可以安装上面输出中列出的任何版本。您还可以使用别名，例如node表示最新版本，lts表示最新 LTS 版本等。 12345# 安装最新版本nodenvm install node ## 安装最新版本# 或者nvm install 17 ## 安装 Node.js 17.X 版本 安装后，可以验证安装的内容： 1nvm ls 如果您的系统上安装了多个版本，您可以随时将任何版本设置为默认版本。要将节点 17.X 设置为默认版本，只需使用： 12345678910# 在当前session中有效nvm use 17 # 要让版本切换永久有效nvm alias default 17# 或者使用指定版本的 nodejsnvm alias default v17.9.0 同样，您可以安装其他版本（例如 Node 12、15 和 18 版本）并在它们之间切换。 6. 配置Nodejs由于不知名的原因, 国内访问npm仓库会很慢, 所以需要设置镜像, 淘宝为我们提供了很好的镜像源. 12345678910设置淘宝镜像npm config set registry https://registry.npmmirror.com# 或者使用华为镜像# npm config set registry https://mirrors.huaweicloud.com/repository/npm/# 或者使用腾讯镜像# npm config set registry http://mirrors.cloud.tencent.com/npm/// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 7. 说明本文原文位于鹏叔的技术博客 - MacOS上安装nvm, 获取最近更新, 请访问原文. 最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 8. 总结拥有管理和在各种Node.js版本之间切换的能力对于现代web开发至关重要，而NVM提供了这种灵活性。通过在macOS上利用Homebrew，安装过程变得简化，使NVM比以往任何时候都更容易启动和运行。安装后，开发人员可以享受轻松的体验，无论其版本要求如何，都可以处理多个Node.js项目。本指南为您提供了使用Homebrew在macOS上安装NVM所需的所有知识。现在，你已经准备好处理任何Node.js项目了，因为你知道你有能力在指尖轻松管理和切换Node版本。 9. 参考文档How To Install NVM on macOS with Homebrew","link":"/nodejs/install_nvm_on_macos.html"},{"title":"Windows上安装nvm和nodejs","text":"1. 前言Node Version Manager (NVM) 是一种广泛使用的工具，允许开发人员在单台计算机上管理 Node.js 的多个版本。它的重要性怎么强调都不为过，因为 Nodejs 应用程序有时可能是依赖特定版本运行，然而不同的项目可能需要不同的 Nodejs 版本。NVM 提供的灵活性确保了不同项目同时运行在同一台机的开发过程的顺利进行，允许开发人员在 Node 版本之间无缝切换。在 windows 上，有多种安装 NVM 的方法，但最流行、最有效的方法之一是使用 Chocolatey，这是微软出品的包管理器。 本指南将引导您完成使用讲述在 windows 上安装 NVM 的详细步骤，让您轻松设置灵活的 Node.js 开发环境。 2. 先决条件 需要拥有管理员权限 如果尚未安装 Chocolatey，可以参考我的博客chocolatey安装和使用. 3. 删除现有Nodejs版本如果您的系统已经安装了节点，请先将其卸载。我的系统已经通过 Homebrew 安装了节点。所以先卸载它。如果尚未安装，请跳过。 1234choco uninstall node choco uninstall --force node 如果是通过windows软件安装包例如msi安装的, 可以参考我的博客安装并配置nodejs尾部 - 在Windows上卸载nodejs 章节所述的方法删除Nodejs. 4. 在Windows上安装NVM以管理员身份打开PowerShell, 执行如下命令就可以松安装 NVM： 123choco install nvm.install#或者choco install nvm.install --version 1.1.11 说明: 截至2023-11-01, 当前最新版本为1.1.11 安装过程需要一些魔法. 魔法可以从这里获得 Windows 上安装与配置 v2rayA。 2024 最新 v2rayA 安装与配置教程 for Windows、Macos、Linux、Android。 安装后的nvm可以在C:\\ProgramData\\nvm找到对应的可执行文件. 接下来普通用户的身份打开Powershell，在用户主目录中创建一个 .nvm 目录 1mkdir $HOME/.nvm 在.nvm目录下创建settings.txt, 内容如下 123456root: $HOME\\.nvmpath: $HOME\\.nvmarch: 64proxy: none 现在，配置所需的环境变量。在用户主目录中编辑以下配置文件 1notepad $PROFILE 这个命令会打开PowerShell配置文件(如果还没有创建, 则会提示是否创建新文件). 随后在文件中添加如下内容: 123456789# 配置NVM_HOME环境变量, nvm在管理Nodejs时依赖此变量指定的路径$env:NVM_HOME = &quot;$HOME\\.nvm&quot;[Environment]::SetEnvironmentVariable(&quot;NVM_HOME&quot;, $env:NVM_HOME, [EnvironmentVariableTarget]::User)# 将$HOME\\.nvm添加到执行文件查找路径$env:PATH += &quot;;C:\\ProgramData\\nvm;$HOME\\.nvm&quot;[Environment]::SetEnvironmentVariable(&quot;PATH&quot;, $env:PATH, [EnvironmentVariableTarget]::User) 重新打开powershell, 检查设置是否生效 1$ENV:NVM_HOME 如果报错execution policy的问题, 可以修改execution policy, 以管理员身份执行 Set-ExecutionPolicy RemoteSigned 5. 使用 NVM首先，查看可以安装哪些 Node 版本。要查看可用版本，请键入： 123nvm list available 现在，您可以安装上面输出中列出的任何版本。您还可以使用别名，例如node表示最新版本，lts表示最新 LTS 版本等。 123nvm install node ## 安装最新版本# 或者nvm install 17 ## 安装 Node.js 17.X 版本 安装后，可以验证安装的内容： 1nvm ls 如果您的系统上安装了多个版本，您可以随时将任何版本设置为默认版本。要将节点 18.X 设置为默认版本，只需使用： 123nvm use 17 同样，您可以安装其他版本（例如 Node 12、15 和 18 版本）并在它们之间切换。 6. 配置Nodejs由于不知名的原因, 国内访问npm仓库会很慢, 所以需要设置镜像, 淘宝为我们提供了很好的镜像源. 12345678910设置淘宝镜像npm config set registry https://registry.npmmirror.com# 或者使用华为镜像# npm config set registry https://mirrors.huaweicloud.com/repository/npm/# 或者使用腾讯镜像# npm config set registry http://mirrors.cloud.tencent.com/npm/// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express 7. troubleshooting问题1: 当安装任何一个版本时都出现”The system cannot find the path specified.” 12345$ nvm install 17 could not be found or does not exist. Exiting.Downloading node.js version 17.9.1 (64-bit)...Error while creating \\v17.9.1\\node.zip - open \\v17.9.1\\node.zip: The system cannot find the path specified.Could not download node.js v17.9.1 64-bit executable. 解放办法这是由于nvm读取不到配置项目root, 可以使用nvm root命令显示地指定 123nvm root &quot;$HOME\\.nvm&quot; 8. 说明本文原文位于鹏叔的技术博客 - Windows上安装nvm和nodejs, 获取最近更新, 请访问原文. 最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 9. 参考文档node版本管理神器nvm安装使用教程（Windows11版本）","link":"/nodejs/install_nvm_on_windows.html"},{"title":"从 NPM 迁移到 PNPM","text":"PNPM 一直被誉为 NPM 的更高性能和更可靠的替代品，旨在减少缓慢的构建时间并消除依赖项不匹配的问题。我主要研究 PNPM 作为一种加快 CI 管道完成时间的方法，以及在开发周期中使用更好的包管理器。 我在一个仍处于 alpha 开发阶段的项目上测试了这一点，因此可以承受任何因错误或其他问题而导致的潜在停机。在部署应用程序时，用 PNPM 替换包管理器不太可能导致任何重大更改，但如果应用程序已经上线，则绝对应该首先在测试环境中进行测试。 唯一的潜在问题是依赖不匹配，但我已在本博文中更详细地描述了这一点。 Get started PNPM 的安装指南可在此处找到。对于 JS 开发人员来说，最简单的方法可能是运行：npm install -g pnpm。 在要转换为 PNPM 的项目中，找到 node_modules 目录并将其删除。 将以下代码添加到项目的 package.json。这将阻止人们使用任何其他包管理器安装包。 1&quot;scripts&quot;: { &quot;preinstall&quot;: &quot;npx only-allow pnpm&quot;, ... } 在目录根目录中，创建一个名为的文件pnpm-workspace.yaml并添加以下内容 (Optinal)如果项目要使用pnpm workspace,则需要添加如下配置 123456packages: # include packages in subfolders (change as required) - 'apps/**' - 'packages/**' # if required, exclude directories - '!**/test/**' 在终端中运行pnpm import。这将根据当前的 yarn.lock 或 package-lock.json 创建一个 pnpm-lock.yaml 文件。 删除 yarn.lock 或 package-lock.json 文件。 通过运行pnpm i或使用 pnpm install 安装PNPM依赖项 如果你的 package.json 中有使用前缀的脚本npm run，则需要将其替换为pnpm 例如： pnpm test，而不是npm run test 重要的提示使用 NPM 或 Yarn 安装依赖项时，会创建一个“flat”node modules 目录。这意味着源代码可以访问未作为依赖项添加到项目的依赖项。PNPM 的工作方式不同，它使用符号链接仅将项目的直接依赖项添加到模块目录的根目录中。 例如，如果你有A一个导入包的包B import something from ‘B’ 但没有在项目的依赖项中明确指定依赖B，那么执行将失败。 这种新结构不仅提高了构建性能，还降低了项目中出现依赖性错误的可能性。 如果你确实遇到了需要扁平节点模块结构（比如 NPM 或 Yarn 创建的那种结构）的情况，PNPM 提供了一个解决方案： 1pnpm install --shamefully-hoist 尽管应尽可能避免这种情况，因为它违背了 PNPM 实现的设计模式。您可能需要使用此功能的一个示例是，您安装的依赖项未在package.json中明确指定。 使用pnpm进行构建第一次运行时，pnpm install您将在终端中看到一个进度图，如下图所示： 请注意，首次安装时“已重用”计数保持为 0。这是因为我们尚未创建 PNPM 可以引用的缓存。 一旦安装了所有依赖项，如果您pnpm install再次运行或添加新包pnpm add some-new-package -w，您将看到“重复使用”计数器现在正在上升。 这种缓存可显著加快安装过程，因为它可避免重新下载已获取的软件包。软件包也是同时下载，而不是逐个下载。 “在 pnpm 中，如果包已经安装在其他项目中，则总是会重复使用，从而节省大量磁盘空间，这使得它比 npm 更快、更高效。” PNPM 和 CI 管道我第一次研究使用 PNPM 作为替代包管理器的主要目的是加快我的 CI 管道的时间，即使对于不是特别复杂且没有端到端测试要运行的项目，该管道也经常需要 10 或 15 分钟。 考虑到这一点，这里有一个示例.gitlab-ci.yml文件，其中包含一个简单的部署脚本到 Gitlab page，展示了我如何使用 PNPM。 12345678910111213141516171819202122232425image: node:16.14.0before_script: - curl -f https://get.pnpm.io/v6.16.js | node - add --global pnpm@7 - npm config set store-path /root/.pnpm-store/v3 - npm config set registry &lt;nexus url&gt;pages: stage: deploy interruptible: true cache: key: $CI_COMMIT_REF_SLUG paths: - /root/.pnpm-store/v3 - public/ - ./node_modules policy: pull script: - pnpm install - pnpm build-storybook artifacts: paths: - public only: - master 您可以看到，在此before_script阶段，我们发出 CURL 请求来下载 PNPM。然后，我们将存储路径设置为新 PNPM 缓存存储的位置。 pnpm store path此路径可能因您的项目而异。我通过添加到我之前的 CI 脚本、运行管道，然后复制/粘贴它给我的路径，找到了正确的路径。 在此之后，我们确保注册表正在使用 Nexus 来安装包。 下一个重要部分是“缓存”部分。这很可能与您现有的设置类似，只是我们需要添加到“路径”： 前面提到的 PNPM 存储路径，例如/root/.pnpm-store/v3 ./node_modules 通常我们会.npm在路径数组中使用它，但现在可以将其删除。 我们利用缓存键$CI_COMMIT_REF_SLUG，它允许我们在同一分支（例如 master）中的作业之间共享缓存。初始运行后，当我们运行管道时，如果 PNPM 成功命中缓存，我们应该会看到“reused”计数器上升。 最后，在本script节中，我们运行新pnpm install命令，然后运行项目相关的命令，例如 build-storybook。 其他 PNPM 功能PNPM 的另一个有用功能是能够管理 Node 版本。我们很多人目前都使用nvm它，它的工作方式几乎相同。 一些例子： 安装 Node 的 LTS 版本：pnpm env use –global lts 安装node 16：pnpm env use –global 16 安装最新版本的 Node：pnpm env use –global latest 删除特定版本的 Node：pnpm env remove –global 14.0.0 与我们当前使用的流程相匹配的一个有用示例是.npmrc在项目根目录中有一个定义 Node 版本的文件： 1use-node-version=16.14.0 当我们运行 时pnpm start，它将从配置文件中获取此 Node 版本并将其用于我们的项目。能够使用我们的默认包管理器管理 Node 版本非常方便。 最后说明您可能需要将其添加.pnpm-store/**到您的.gitignore文件中。 PNPM的文档非常有用且非常详细。","link":"/nodejs/migrate_to_pnpm.html"},{"title":"npm create命令详解","text":"1. 前言今天使用npm create tauri-app时候发现npm不是简单的创建一个nodejs工程, 其还做了很多特定于tauri相关的操作, 顿时感到这个命令不单纯, 这个命令可能还能干很多活, 迅速燃起了研究的兴趣, 于是写下了这篇文章. 2. npm createnpm create实际上是npm init 的一个别名, npm init的语法如下: 123npm init &lt;initializer&gt; 所以回到我们前言中提到的npm create tauri-app, 这里的tauri-app是一个initializer. initializer是一个名为create-&lt;initializer&gt;的npm包，它将由npm-exec安装，然后执行包的main bin来创建或更新package.json并运行任何其他与初始化相关的操作。 init命令转换为相应的npm exec操作，如下所示： 1234567npm init foo -&gt; npm exec create-foonpm init @usr/foo -&gt; npm exec @usr/create-foonpm init @usr -&gt; npm exec @usr/createnpm init @usr@2.0.0 -&gt; npm exec @usr/create@2.0.0npm init @usr/foo@2.0.0 -&gt; npm exec @usr/create-foo@2.0.0 注意: 1, 如果用户已经全局安装了create-&lt;initializer&gt;包，那么npm init将使用该包。如果希望npm使用最新版本或其他特定版本，则必须指定它2, 如果不提供initializer 即npm init, 那么init将回退到legacy模式, 它会问你一堆问题，然后为你写一个package.json。它将尝试根据现有字段、依赖项和所选选项进行合理的猜测。 3. 指定initializer版本如果你想使用特定版本的initializer, 可以参考如下命令: 1234567npm init initializer@latest # 使用最新版本的initializer# 或者npm init initializer@1.2.3 # 使用1.2.3版本的initializer 4. 传递参数在使用initializer的过程中, 默认参数往往是不足够够的, 在交互模式下initializer可以通过提问的方式让用户输入参数.在无人值守的的情况下, 或者我们需要改变initializer更多默认行为的时候, 则需要通过命令行的将参数提供给initializer, 因为这里的主命令是npm或者npm init, initializer只是其中一个子命令, 这时需要通过npm将参数传递给initializer, 其语法格式如下: 1npm init initializer -- --hello 需要使用 -- 分割 npm参数与init参数. 为了更好地说明如何转发选项，这里有一个更为深入的示例，显示了传递给npm-cli和initializer的参数，以下两个命令是等效的： 123npm init foo -y --registry=&lt;url&gt; -- --hello -a#等效于npm exec -y --registry=&lt;url&gt; -- create-foo --hello -a 这里的-y --registry=&lt;url&gt;为npm exc的参数, 而--hello -a为create-foo这个initializer的参数. 至此npm create的基本用法讲解完了, 更多用法可以参考npm init文档 5. 相关文章本文原文位于鹏叔的技术博客 - npm create命令详解, 需要获得最近更新请访问原文. 更多nodejs相关文章请访问鹏叔的技术博客 - nodejs 6. 参考资料npm create 命令 npm-init","link":"/nodejs/npm_create_command.html"},{"title":"npm debug指南","text":"1. 前言本指南将帮助您开始调试Node.js应用程序和npm run-script脚本。 2. 开启npm debug开启npm debug的方式有多种. 1, 如果是使用node运行脚本, 那么在node后面加上–inspect选项即可开启debug模式. 2, 如果是使用npm运行run-script, 而且run-script中不包含node命令, 则可以使用–node-options=–inspect选项, 例如 1npm run buildDev --node-options=--inspect 当使用–inspect开关启动时，Node.js进程会侦听调试客户端。默认情况下，它将在主机和端口127.0.0.1:9229上侦听。每个进程还被分配了一个唯一的UUID。调试客户端必须知道并指定要连接的主机地址、端口和UUID。完整的URL看起来像ws://127.0.0.1:9229/0f2c936f-b1cd-4ac9-aab3-f63b0f33d55e。如果Node.js接收到SIGUSR1信号，它也将开始监听调试消息。（SIGUSR1在Windows上不可用。）在Node.js 7和更早版本中，这将激活旧版debug API。在Node.js 8及更高版本中，它将激活Inspector API。 3. 安全影响由于调试器可以完全访问Node.js执行环境，因此能够连接到此端口的恶意行为者可能能够代表Node.js进程执行任意代码。了解在公共和专用网络上公开调试器端口的安全含义非常重要。 如果调试器绑定到公网IP地址或0.0.0.0，则可以访问您的IP地址的任何客户端都可以无任何限制地连接到调试器，并且可以运行任意代码。默认情况下，节点–inspect绑定到127.0.0.1。如果您打算允许外部连接到调试器，则明确需要提供公共IP地址或0.0.0.0等。这样做可能会使您面临潜在的重大安全威胁。我们建议您确保适当的防火墙和访问控制措施到位，以防止安全暴露。有关如何安全地允许远程调试器客户端连接的一些建议，请参阅“启用远程调试方案”一节。 即使您将inspector端口绑定到127.0.0.1（默认值），在您的计算机上本地运行的任何应用程序都将具有不受限制的访问权限。这是为了让本地调试器能够方便地连接。 4. 浏览器、WebSockets和同源策略初始HTTP连接是获得唯一debugger session id所必需的。同源策略阻止网站建立此HTTP连接。为了增强抵御DNS重新绑定攻击的安全性，Node.js验证连接的http “Host”头部信息是否精确指定了IP地址或localhost。这些安全策略禁止通过主机名连接到远程调试服务器。您可以通过指定IP地址或使用ssh隧道来绕过此限制。 5. debug客户端连接虽然正规的名称叫inspector客户端, 但是我还是比较喜欢debug客户端这个名词, 因为不用引入额外的概念, debug客户端非常容易理解不用做过多解释. debug客户端有多种, 例如: Chrome DevTools 55+, Microsoft Edge, Visual Studio Code 1.10+, Visual Studio 2017+, JetBrains WebStorm 和其它 JetBrains IDEs, chrome-remote-interface, Gitpod, Eclipse IDE with Eclipse Wild Web Developer extension. 这里重点介绍如何使用Chrome DevTools进行debug 和vscode. 5.1. Chrome DevTools进行npm debug首先打开Chrome, 在输入网址的输入框中输入chrome://inspect, 然后点击Open dedicated DevTools for Node对话框, 在source tab页将要debug的包含源文件的文件夹添加到workspace, 设置好断点. 然后按前面介绍的开启npm debug的方式启动npm, 然后回到chrome://inspect界面, npm一旦启动会自动与Chrome DevTools建立连接. 当程序运行到断点位置会自动停下来, 后面就是我们熟悉的debug的过程了, 这里不做过多解释了. 以下是一些注意事项:在将源代码文件夹添加到workspace时, devtools将会依照以下规则将一些文件夹过滤掉 /node_modules/|/bower_components/|/\\.devtools|/\\.git/|/\\.sass-cache/|/\\.hg/|/\\.idea/|/\\.svn/|/\\.cache/|/\\.project/|/Thumbs.db$|/ehthumbs.db$|/Desktop.ini$|/\\$RECYCLE.BIN/ 有时候第三方依赖包我们也需要debug, 此时可以导航到devtools=&gt;settings 的workspace tab页将folder exclude pattern修改掉, 这样我们就可以node_modules下面的package了.更多设置请参考https://developer.chrome.com/docs/devtools/settings 5.1.1. vscode npm debug打开vscode左侧 run and debug视图, 点击左上方 run and debug下拉列表. 选中 add config (your project),或者用文本编辑器在项目的.vscode/launch.json文件中添加如下内容. 1234567891011{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;My Backend&quot;, &quot;command&quot;: &quot;npm run buildDev&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;node-terminal&quot; } ]} 注意: 将command替换为合适的commandcommands 可以在 package.json 的 “scripts” 节点找到 设置断点, 点击开始debug按钮(绿色三角图标) 6. Nodejs 系列文章最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 7. 参考文档debugging gettingstarted","link":"/nodejs/npm_debug.html"},{"title":"记一次npm run问题排查的详细过程","text":"1. 前言今天遇到一个特别难整的问题, 在执行npm run a_task 出错, 报错信息特别简单, 对于查找问题没有任何帮助. 尝试过几种方法来定位问题, 收效很差, 最后不得不祭出npm的大杀器npm debug来一探究竟. 首先我要说说我遇到的问题和我尝试了哪集中解决问题的方法, 也是我惯常解决问题的思路. 问题是这样的, 我在执行npm run buildDev时报如下错误, buildDev是一个自定义的npm任务. 其内容就是编译angular应用, 并进行prerendering一些页面. 具体内容如下ng build --configuration development &amp;&amp; ng run xxx_project:prerender --configuration development 1234567Prerendering routes to path_to_dist\\xxx\\browser complete.Service worker generation failed.EISDIR: illegal operation on a directory, readnpm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! xxx_project@1.0.0 buildDev: `ng build --configuration development &amp;&amp; ng run xxx_project:prerender --configuration development`npm ERR! Exit status 1 其报错特别简单EISDIR: illegal operation on a directory, read 对某个目录操作不合法. 为什么说特别简单, 特别没有帮助, 首先它不告诉你是哪个目录, 如何非法, 在哪一步非法. 这就是我遇到的问题. 接着聊聊我做了哪些方面的尝试 1.1. 尝试用搜索引擎了解问题和解决方案首先当然是根据报错信息一顿搜索, 百度, bing, 某歌. 搜索出来的答案五花八门, 有说是版本不兼容问题的, 有所是.npmrc配置问题的, 等等等. 而且我都做了尝试, 没有任何效果. 但是在搜索的过程中, 我清楚了一点, 如果我关闭应用的PWA功能就不会出现类似的错误. 所以问题应该是angular的prerendering 和 pwa模块可能存在兼容性问题, 也就是在生成ngsw-worker.js时候出错了. 1.2. 查询官方文档由于通过搜索以及探索, 发现了是prerendering 和 pwa兼容性问题, 我就去官网了解到底preredering和pwa一起运行有哪些注意事项. 官网上有独立介绍prerendering和PWA的文章, 但是两种结合使用方面的文章几乎没有. 也就是这两个模块应该是独立运行的, 应该不存在很强的关联性. 可能只是在prerendering的时候也需要执行service worker的过程, 碰巧遇到了service worker generation的bug. 于是我尝试其它过程例如ssr, build, serve等task的 service worker generation. 而这些任务的service worker generation都是正常的, 都能看到”Service worker generation completed” 打印信息. 参照官方文档, 我再次检查了prerendering的配置和pwa的配置, 确保没有漏到重要细节, 并对一些依赖包的版本进行了调整避免兼容性问题. 至此我仍然没有找打问题的具体原因, 但是对问题是如何发生的有了一些了解, 排除了各种配置问题, 将问题定性为bug. 1.3. 查看源码在有了一些对异常的认识之后, 在搜索与官网仍然找不到原因的情况下, 我只能开始着手研究源代码. 这里多啰嗦两句. 走到这一步的时候, 我脑海里面在想什么? 幸好我采用的是开源技术, 如果是闭源技术, 那么此时只能找客服了, 需要经过一个漫长的等待过程, 而且要将问题描述清楚需要很强的文字功底, 如果是国外的闭源产品, 可能还需要很强的英文基础. 而开源的产品我们可以着手研究源码, debug, 顺手一个PR就将问题永久解决了, 或者去github上去提issue. 这就是开源产品的生命力如此旺盛的原因. 在设计系统时, 错误处理部分一定要注意. 像这种错误太泛化, illegal operation on a directory 如果在”案发现场”(错误发生的地方),能将错误信息详细的保存非常的重要, 比如将a directory替换成一个具体的目录, 将不能读取的原因告知用户, 而不是一个简单的read, 让用户去猜测去. 说实在的我现在正在写的这边博文, 以及整个探索过程其实都是在浪费生命. 写博文也是为了让更少的人去继续浪费生命, 俗话说我不入地狱谁入地狱, 我入了地狱是为了让更少的人入地域, 而且一定要将地狱咒骂一番. 面对一个毫无帮助的错误信息, 感觉就是在做一次侦探的过程, 看起来很高大上实际上一点意义都没有, 它可能是因为开发人员的一次偷懒, 测试人员的不重视造成的. 尤其是底层依赖库, 如果吞掉了错误详细信息, 破坏了案发现场. 而二次开发者, 调用者很难去enhance错误消息. 幸运的是它还打印出了那么一条错误信息, 如果遇到哪种自以为是直接将错误信息吞没的库, 我想我现在心中有一万投草泥马飘过. 闲话少叙, 首先根据错误信息定位问题, 我首先根据Service worker generation failed 定位到是在@nguniversal/buiders/src/prerender下面 123456789101112if (browserOptions.serviceWorker) { spinner.start('Generating service worker...'); try { await (0, service_worker_1.augmentAppWithServiceWorker)(projectRoot, context.workspaceRoot, (0, core_1.normalize)(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath); } catch (error) { spinner.fail('Service worker generation failed.'); return { success: false, error: error.message }; } spinner.succeed('Service worker generation complete.');} 通过阅读源码, 发现这个prerender整合了pwa, 这也验证了在为什么在angular.json中将serviceWorker设置为false就不报错的原因. 接下来, 我在catch语句中打印了error的详细信息, 得到了如下错误信息 123456789[AsyncFunction: augmentAppWithServiceWorker]in nguniveral builder prerender[Error: EISDIR: illegal operation on a directory, read] { errno: -4068, code: 'EISDIR', syscall: 'read'} 依然没有获得更多信息, 只是通过errno 4068了解到使用某种第三方依赖包时会出现类似的状况. 所以可以肯定的是第三方库吞掉了错误的详细信息. 我再次通过illegal operation on a directory, read 错误信息搜索源码, 由于相关代码经过层层封装, 逻辑十分的绕, 所以我打算使用npm的debug功能深入到底层代码, 去一探究竟. 1.4. npm debug1.4.1. 配置npm debug打开vscode左侧 run and debug视图, 点击左上方 run and debug下拉列表. 选中 add config (your project),或者用文本编辑器在项目的.vscode/launch.json文件中添加如下内容. 1234567891011{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;My Backend&quot;, &quot;command&quot;: &quot;npm run buildDev&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;node-terminal&quot; } ]} 注意: 将command替换为合适的commandcommands 可以在 package.json 的 “scripts” 节点找到 设置断点, 点击开始debug按钮(绿色三角图标) 1.4.2. 问题排查经过debug发现是@nguniversal 和@angular-devkit/build-angular这个包的兼容性问题 @nguniversal调用augmentAppWithServiceWorker传入的是五个参数, 而@angular-devkit/build-angular接受的是4个参数, 而且参数位置发生了错位. 123await (0, service_worker_1.augmentAppWithServiceWorker)(projectRoot, context.workspaceRoot, (0, core_1.normalize)(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath); node_modules@angular-devkit\\build-angular\\src\\utils\\service-worker.js 123456789101112131415161718192021222324async function augmentAppWithServiceWorker(appRoot, outputPath, baseHref, ngswConfigPath) { const distPath = (0, core_1.getSystemPath)((0, core_1.normalize)(outputPath)); // Determine the configuration file path const configPath = ngswConfigPath ? (0, core_1.getSystemPath)((0, core_1.normalize)(ngswConfigPath)) : path.join((0, core_1.getSystemPath)(appRoot), 'ngsw-config.json'); // Read the configuration file let config; try { const configurationData = await fs_1.promises.readFile(configPath, 'utf-8'); config = JSON.parse(configurationData); } catch (error) { if (error.code === 'ENOENT') { throw new Error('Error: Expected to find an ngsw-config.json configuration file' + ` in the ${(0, core_1.getSystemPath)(appRoot)} folder. Either provide one or` + ' disable Service Worker in the angular.json configuration file.'); } else { throw error; } } 而错误EISDIR: illegal operation on a directory, read 是从fs_1.promises.readFile(configPath, 'utf-8')位置抛出来的.而fs_1实际就是node的一个核心包, 抛出了一个非常简单的错误, 而angular universal得出来非常偷懒, 直接使用了一个throw error, 1const fs_1 = require(&quot;fs&quot;); 而跟踪该文件得版本变化, 该函数被反复的修改, 接口参数反复变化, 参数位置任意调整, 丝毫没有考虑兼容性问题. 所以在像google这样的大公司里面, 也有很多素质很差的程序员. 经过比较发现在universal版本v13.0.0和v13.1.1之间augmentAppWithServiceWorker的参数发生了变化详细参考universal-compare 中文件modules/builders/src/prerender/index.ts的差异部分. 参考了universal的package.json文件, v13.1.1依赖的是”@angular-devkit/build-angular”: “13.3.4”, 而我当前使用的是&quot;@angular-devkit/build-angular&quot;: &quot;13.3.1&quot;, 由于依赖的Angular包较多, 不敢贸然升级Angular, 所以这里将universal降级为合适的版本13.1.0. 重新执行npm run buildDev 问题解决. 2. Nodejs 系列文章最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 3. 参考文章Can I add a debug script to NPM? VS Code - debug with npm run","link":"/nodejs/npm_run_debug.html"},{"title":"Nodejs升级以及快速版本切换","text":"1. 前言要升级 Nodejs 有多种方法, 方法一重新安装新版本; 方法二, 安装 nodejs 版本管理器 例如: n 或者 nvm. 方法一比较简单直接, 方法二可以在新旧版本之间切换, 非常符合需要同时支持多种版本 nodejs 的需求, 缺点是目前还不是正式版本, 目前还是 0.39.5 版本, 还没有到 1.0 版本, 遇到的奇奇怪怪的问题比较多, 不是特别成熟, 尤其是 Windows 上的 NVM. 在 Linux 或 Macos 上目前基本可用, 但是 Windows 不是太稳定. 2. 重新安装 nodejswindows 上重新安装 nodejs 从nodejs 官网下载最新版本或指定版本的 nodejs 执行安装程序, 依照安装向导指引安装 nodejs 安装完成后执行 node -v 验证 nodejs 新版本是否安装成功 linux 上重新安装 nodejs下载安装包 1wget -O /tmp/node-v20.12.2-linux-x64.tar.gz https://nodejs.org/dist/v20.12.2/node-v20.12.2-linux-x64.tar.gz 解压安装包 12# 解压sudo tar -zxvf /tmp/node-v20.12.2-linux-x64.tar.gz -C /usr/local 更新软链接 12345678# 删除旧的链接sudo unlink /usr/bin/nodejs# 创建新的链接sudo ln -fs /usr/local/node-v20.12.2-linux-x64 /usr/bin/nodejssudo ln -fs /usr/bin/nodejs/bin/npm /usr/bin/npmsudo ln -fs /usr/bin/nodejs/bin/node /usr/bin/node 将/usr/bin/nodejs/bin 添加到 path 环境变量, 这样做的好处是当升级或者切换版本时只需要更改软连接即可. 不需要修改环境变量. vi ~/.bashrc 123export PATH=$PATH:/usr/bin/nodejs/bin 之前安装的全局命令全部要重装一遍, 例如我安装了 gyp, pm2, angular, node-gyp-build, typescript 全局安装的命令需要重载, 例如 node-gyp-build, node-gyp-build-optional, node-gyp-build-test, pm2 12345sudo npm install -g typescript@5.3.2sudo npm install -g node-gyp-build@4.2.2sudo npm install -g pm2@5.3.0sudo npm install -g @angular/cli@17.3.2sudo npm install -g pnpm@9.6.0 如果没有创建软连接则创建软链接 1sudo ln -fs /usr/bin/nodejs/bin/ng /usr/bin/ng 检测版本 1node -v 3. Nodejs 系列文章最新更新以及更多 Nodejs 相关文章请访问 鹏叔的技术博客 - Nodejs 4. 参考文档Node 快速切换版本、版本回退(降级)、版本更新(升级)","link":"/nodejs/upgrade_nodejs.html"},{"title":"为什么我们应该使用pnpm?","text":"1. 前言原文: Why should we use pnpm? Author: Zoltan Kochan 译者：philoenglish.com 团队 关键字： pnpm, npm, yarn pnpm是 Node.js 的替代包管理器。它是 npm 的直接替代品，但速度更快、效率更高。 多快？快3倍！请参阅此处的基准。 为什么效率更高？当您安装软件包时，我们将其保存在您计算机上的全局存储中，然后我们从中创建硬链接而不是复制。对于模块的每个版本，磁盘上仅保留一个副本。例如，当使用npm或yarn时，如果您有100个使用lodash的包，则磁盘上将有100个lodash副本。Pnpm 可以让您节省千兆字节的磁盘空间！ 2. 为什么不使用yarn？说实话，当 Yarn 公开时我真的很失望。几个月来我为 pnpm 做出了大量贡献，却没有任何关于 Yarn 的消息。有关其开发的信息并未公开。 几天后，我意识到 Yarn 只是对 npm 的一个小小的改进。尽管它使安装速度更快并且具有一些不错的新功能，但它使用与 npm 相同的扁平node_modules结构（自版本 3 以来）。 扁平化的依赖树会带来一系列问题： 模块可以访问它们不依赖的包 展平依赖树的算法非常复杂 某些包必须复制到一个项目的node_modules文件夹中 此外，还有一些 Yarn 不打算解决的问题，例如磁盘空间使用问题。所以我决定继续投入时间到 pnpm，并取得了巨大的成功。截至目前（2017 年 3 月），pnpm 拥有 Yarn 相对于 npm 的所有附加功能： 安全。与 Yarn 一样，pnpm 有一个特殊文件，其中包含所有已安装包的校验和，用于在执行每个已安装包的代码之前验证其完整性。 离线模式。pnpm 将所有下载的软件包 tarball 保存在本地注册表镜像中。当包在本地可用时，它从不发出请求。通过该–offline参数，可以完全禁止HTTP请求。 速度。pnpm 不仅比 npm 快，而且比 Yarn 快。无论是冷缓存还是热缓存，它都比 Yarn 更快。Yarn 从缓存中复制文件，而 pnpm 只是从全局存储中链接它们。 3. 这是如何成为可能的正如我之前提到的，pnpm 不会展平依赖关系树。这样一来，pnpm 使用的算法就可以简单很多！这就是为什么可能只有 1 名开发人员就能跟上数十名 Yarn 贡献者的步伐。 那么，如果不是通过扁平化，pnpm 是如何构建node_modules目录的呢？为了理解它，我们应该回顾一下npm 版本 3 之前的node_modules文件夹是什么样子的。在npm@3之前，node_modules结构是可预测且干净的，因为node_modules中的每个依赖项都有自己的node_modules文件夹，其中指定了所有依赖项包.json。 12345678node_modules└─ foo ├─ index.js ├─ package.json └─ node_modules └─ bar ├─ index.js └─ package.json 这种方法有两个严重的问题： 包经常创建太深的依赖树，这导致 Windows 上的长目录路径问题当不同的依赖项需要包时，它们会被复制粘贴多次为了解决这些问题，npm 重新思考了node_modules结构并提出了扁平化。使用npm@3 ，node_modules结构现在如下所示： 123456789node_modules├─ foo| ├─ index.js| └─ package.json└─ bar ├─ index.js └─ package.json 有关 npm v3 依赖项解析的更多信息，请参阅npm v3 依赖项解析。 与 npm@3 不同，pnpm 尝试解决 npm@2 存在的问题，而不压平依赖关系树。在pnpm 创建的node_modules文件夹中，所有包都有自己的依赖项分组在一起，但目录树永远不会像 npm@2 那样深。pnpm 保持所有依赖关系平坦，但使用符号链接将它们分组在一起。 12345678910111213141516-&gt; - a symlink (or junction on Windows)node_modules├─ foo -&gt; .registry.npmjs.org/foo/1.0.0/node_modules/foo└─ .registry.npmjs.org ├─ foo/1.0.0/node_modules | ├─ bar -&gt; ../../bar/2.0.0/node_modules/bar | └─ foo | ├─ index.js | └─ package.json └─ bar/2.0.0/node_modules └─ bar ├─ index.js └─ package.json 要查看实时示例，请访问示例 pnpm 项目存储库。 尽管该示例对于小型项目来说似乎过于复杂，但对于较大的项目，该结构看起来比 npm/yarn 创建的结构更好。让我们看看它为什么有效。 首先，您可能已经注意到，node_modules根目录中的包只是一个符号链接。这很好，因为 Node.js 会忽略符号链接并执行真实路径。因此require(‘foo’)将执行该文件node_modules/.registry.npmjs.org/foo/1.0.0/node_modules/foo/index.js 而不是node_modules/foo/index.js 其次，所有已安装的软件包的目录中都没有自己的node_modules文件夹。那么foo如何require bar呢？让我们看一下包含foo包的文件夹： 1234567node_modules/.registry.npmjs.org/foo/1.0.0/node_modules├─ bar -&gt; ../../bar/2.0.0/node_modules/bar└─ foo ├─ index.js └─ package.json 如你看到的 foo（只是bar ）的依赖项已安装，但在目录结构中上一层。这两个包都位于名为node_modules的文件夹中foo可以require bar，因为 Node.js 在目录结构中查找模块，直到磁盘的根目录。并且foo也可以 require foo，因为它位于名为node_modules的文件夹中 （是的，这就是某些包所做的）。 4. 您是否会使用pnpm?如果我的观点说服了, 并打算使用pnpm. 只需通过 npm: 安装 pnpm 即可npm install -g pnpm。每当你想安装某些东西时，请使用它而不是 npm：pnpm i foo。 您还可以在pnpm GitHub 存储库或pnpm.js.org阅读更多信息。您可以在 Twitter 上关注pnpm on Twitter或在pnpm Gitter 聊天室寻求帮助。 5. Nodejs 系列文章最新更新以及更多Nodejs相关文章请访问 鹏叔的技术博客 - Nodejs 6. 参考文章Why should we use pnpm?","link":"/nodejs/why_pnpm.html"},{"title":"唤醒心中猛兽","text":"为什么停下?what’s stopping you?是什么在阻碍你?Are you too tired?是太累了吗?Didn’t get enough sleep?睡眠不足?Don’t have enough energy?精力不济?Don’t have enough time?时间不够?Is that what’s stopping you right now?是这些东西阻碍你吗?Don’t have enough money?还是因为缺钱?Is that the thing?是这样吗?Or is the thing that’s stopping you还是说真正阻碍你的you?是你自己? 别找借口Excuses sound best to the person who’s making them up借口对编造它的人来说总是完美的Stop feeling sorry for yourself不要再可怜自己Get off the pity party别再自怨自艾telling everybody you’re sad别再诉苦and sob stories, trying to get people别再用委屈和眼泪to show up your pity parties and your pity parades博取同情和怜悯 奋进if you ever see me in a rolls royce如果你看到我坐在劳斯莱斯里or a 6 or 7 star hotel进出六七星级酒店里living my life to the fullest过着舒适的生活don’t get jealous of me.不要嫉妒我because I worked my ass off to get it.因为这些都是我全力以赴拼命换来的Nobody handed me anything没有人施舍我wake your ass up.醒醒吧Awaken the beast inside唤醒你内心沉睡的猛兽It’s game on.比赛开始了It’s go season赛季已经开始it’s time for you to take advantage of the access是时候主动出击.and the resource that you have抓住一切机会in your country and your community.调用一切资源you got a problem with your life?你觉得生活不公平吗?You got a problem with your environment?对自己的境遇感到不满吗?Do something about it.行动起来if you want it你渴望什么go get it.就放手一搏Recognize你要明白The execuses are not valid.借口毫无意义They’re conjured up它们都是虚幻的They’re fabricated是编造的they’re lies是谎言And how do you stop the lies?怎样战胜谎言? 打破谎言, 战胜接口You stop the lies with the truth.用真相击败他们.the truth is you have time.真相是你有时间you have the skill你有技能you have the knowledge and the support and the willpower and the disipline to get it done.你有达成目标的知识, 支持, 信念, 自律.the fruit of everything good in life生命中所有美好的东西begins with a challenge.都是以挑战开始.Everything is uphill that’s worthwhile.所有奋斗都是值得的And it’s not going to come to you.成功不会自己找上门.and it’s not going to fall in your lap.不会从天而降and it’s not going to be something that, oh my gosh但也不是难于登天it just was so simple道理很简单it’s always going to be difficult.不劳而获if you want it, you gotta go get it.渴望,那就全力以赴This is your chance.这是你的机会This is your shot这是你的舞台This is your moment.这是你的时刻This is your time.这是你的时代This is your place这是你的地盘This is your opportunity.这是你的机遇 付诸行动, 马上This is my time.就是此时This is my moment.就是此刻Tomorrow, tomorrow, tomorrow说什么明天, 后天, 大后天ain’t no such thing as tomorrow压根不存在明天这种东西we only got today我们只有今天It’s your dream这是你的梦想if you’re going to have it如果你想实现get your butt up and make it happen马上付诸行动if you’re going to have it如果你想拥有rise and grind就自强不息you still got work to do你还要练习stay on that basketball court留在篮球场上stay on that football field留在橄榄球场上it’s grind season homie.坚持磨练吧, 哥们 注释pity party - 应该为失意, 没人理解, 可怜的意思.ass - 屁股;sob - 啜泣, 呜咽;beast - 野兽, 兽性conjure - 念咒文召唤, 变戏法, 想象; 变戏法, 施魔法;uphill - a. 上坡的, 向上的grind - n. 磨, 碾, 苦差, 摩擦声, 用功的学生 nvt. 磨擦, 磨碎, 磨光, 折磨, 压榨 nvi. 磨, 磨碎, 苦干","link":"/others/wake_your_ass_up.html"},{"title":"值得观看的电影","text":"值得观看的电影《白日梦想家》《辩护人》《勇敢的心》《阿甘正传》 导演: 罗伯特.泽米吉斯 主演: 汤姆.汉克斯/罗宾.怀特/加里*西尼斯/买凯尔泰.威廉逊 豆瓣: 9.5 《–》 导演: 杨德昌 主演: 吴念真/李凯莉/金艳玲/张洋洋 豆瓣: 9.1 《教父》《千与千寻》《美丽人生》《海上钢琴师》《傲慢与偏见》《天堂电影院》《灿烂人生》《幸福来敲门》《楚门的世界》《西西里的美丽传说》《燃情岁月》《闻香识女人》《辛德勒的名单》《心灵捕手》《盗梦空间》《第七封印》《E.T》《指环王》《角斗士》《卡特教练》《放牛班的春天》参考文档人生中必看的50部电影 人生必看的十部经典电影 有什么好看的电影，最值得看的电影，十大经典电影","link":"/others/worth_watching_movies.html"},{"title":"客户满意度模型 - 卡诺模型","text":"1. 什么是卡诺模型Kano模型是由Noriaki Kano在 20 世纪 80 年代开发的产品开发和客户满意度理论，它将客户偏好分为五类。 2. 类别这些类别已被翻译成英文，使用不同的名称（delighters/exciters、satisfiers、dissatisfiers 等），但均出自 Kano 撰写的原始文章。 2.1. 必须的品质简单地说，这些是客户期望的、理所当然的要求。如果做得好，顾客只是中立，但如果做得不好，顾客会非常不满意。卡诺最初将这些称为“必须的”，因为它们是必须包含的要求，也是进入市场的门槛。 示例：在酒店中，提供干净的房间是基本必需品。在呼叫中心，问候客户是基本的必需品。 2.2. 一维品质这些属性在满足时会导致满足，在不满足时会导致不满意。这些是口头上的属性，也是公司竞争的属性。举个例子，在牛奶包装上，据说同等价格下多加百分之十的牛奶就会让顾客满意，但如果只加百分之六，顾客就会感到被误导，从而产生不满。 示例：在呼叫中心解决客户问题所花费的时间。酒店的等候服务。 2.3. 有吸引力的品质这些属性在完全实现时会带来满足感，但在未实现时不会引起不满。这些是通常不期望的属性，例如，牛奶包装上的温度计显示牛奶的温度。由于这些类型的质量属性出乎意料地令顾客满意，因此它们通常是不言而喻的。示例：在呼叫中心，向客户提供特别优惠和补偿或主动升级并立即解决问题是一项有吸引力的功能。在酒店里，提供免费食物是一个吸引人的特点。 2.4. 冷漠的品质这些属性指的是既不好也不坏的方面，它们不会导致客户满意或客户不满意。例如，牛奶盒上蜡涂层的厚度。这可能是纸盒设计和制造的关键，但消费者甚至没有意识到其中的区别。识别产品中的这些属性以抑制它们并从而降低生产成本是很有趣的。示例：在呼叫中心，高度礼貌的讲话和非常迅速的响应可能不一定能让客户满意，也可能不会得到他们的赞赏。这同样适用于酒店。 2.5. 逆向品质这些属性指的是导致不满意的高度成就以及并非所有客户都是一样的这一事实。例如，有些顾客喜欢高科技产品，而另一些顾客则喜欢产品的基本型，如果产品有太多附加功能就会不满意。[1]示例：在呼叫中心，与客户交谈时使用大量行话、使用过多的寒暄或使用过多的脚本可能会让他们感到反感。在酒店中，制作精美的设施照片，设定很高的期望，但在访问时却不满意，可能会让顾客不满意。 3. 必须达到的品质Kano模型中评估的要点之一是阈值属性。这些基本上是产品必须具备的功能才能满足客户的需求。如果忽略这个属性，那么该产品就是不完整的。如果一个新产品没有经过门槛方面的审查，就可能无法进入市场。这是卡诺模型的第一个也是最重要的特征。 该产品是为某种类型的消费群制造的，因此这必须是产品创新的关键部分。阈值属性是产品的简单组件。然而，如果无法获得，该产品很快就会因不满意而退出市场。该属性要么存在，要么不存在。阈值属性的一个示例是汽车的方向盘。如果汽车不能操纵，那它就不好了。 阈值属性通常被视为进入价格。许多产品都有被忽视的门槛属性。由于产品的这个组成部分是必要的指南，因此许多消费者不会判断特定功能的先进程度。因此，很多时候公司会希望改善其他属性，因为消费者对门槛部分的变化保持中立。 4. 一维品质绩效属性被定义为与工作绩效相关的技能、知识、能力或行为特征。绩效属性是公司实现其业务愿望所依据的指标。他们有明确的目的。公司优先考虑其投资、决策和努力，并使用绩效属性解释其策略。这些策略有时可以通过公司的口号来识别。例如雷克萨斯的口号是“追求完美”（品质）和沃尔玛；“始终低价。”（成本）。在零售业，重点通常是确保以最佳成本提供产品。 性能属性是指越多越好，更好的性能属性将提高客户满意度。相反，较弱的性能属性会降低客户满意度。当客户讨论他们的需求时，这些需求将落入性能属性类别。然后，这些属性将形成针对正在评估的产品概念的加权需求。客户愿意为产品支付的价格与性能属性密切相关。因此，性能属性越高，客户就越愿意为产品支付费用。 性能属性通常还需要针对成本进行权衡分析。随着客户开始认为属性越来越重要，公司必须问自己：“他们愿意为该属性支付多少额外费用？” 并且“该属性的产品价格上涨是否会阻止客户购买它？” 优先级矩阵可用于确定哪些属性可以提供最大的客户满意度回报。 5. 有吸引力的品质Kano模型不仅具有性能属性，还包含“兴奋”属性。令人兴奋的属性在很大程度上是客户无法预见的，但可能会产生最大的满足感。拥有兴奋属性只会对你有帮助，但在某些情况下不包含它们也没关系。兴奋属性背后的美妙之处在于激发潜在消费者的想象力，这些属性用于帮助客户发现他们以前从未想过的需求。卡诺模型背后的关键是工程师发现这种“未知的需求”并启发消费者，从而产生“敬畏效应”。产品中同时具有令人兴奋的属性可以提供相对于竞争对手的显着竞争优势。在多样化的产品类别中，兴奋属性充当令人惊叹的因素，并引发客户心中的冲动需求。客户对这些令人惊奇的新想法思考得越多，他们就越想要它。在卡诺模型引入的所有属性中，兴奋属性是最强大的，并且有可能带来最高的毛利率。毫无疑问，创新是向客户提供这些属性的催化剂；你需要能够区分今天什么是令人兴奋的，因为明天它就会成为一个众所周知的功能，而后天它就会被全世界使用。 6. 属性在模型上的位置可能变化随着客户期望随着竞争产品的性能水平而变化，属性可以从令人愉悦的需求转变为性能需求，然后再转变为基本需求。 例如，2009年，手机充电可持续12小时。随着每一代新手机电池续航时间的提高，12 小时电池续航时间的属性已经从令人愉悦的属性转变为低于基本需求的属性。 7. 经验测量卡诺提出了一种标准化问卷，以隐式方式衡量参与者的意见。因此，参与者需要针对每个产品功能回答两个问题，其中一个是“功能性”（以积极方式表述），一个是“功能失调”（以消极方式表述）。 示例 我喜欢 我期待它 我是中立的 我可以忍受 我不喜欢它 功能性 如果该产品具有……，您会有什么感觉？ 如果有更多……，你会有什么感觉？ 功能失调 如果产品没有……，您会有什么感觉？ 如果……少一点，你会有什么感觉？ 评价 根据一名参与者对功能性问题和功能性问题的回答的组合，人们可以推断出特征类别。 功能性 功能失调 类别 我期待它 + 我不喜欢它 → 必须是 我喜欢 + 我不喜欢它 → 一维 我喜欢 + 我是中立的 → 吸引人的 我是中立的 + 我是中立的 → 冷漠 我不喜欢它 + 我期待它 → 撤销 不合逻辑的答案（例如，对于功能性和功功能失调都“我喜欢它”）通常会被忽略或放入特殊类别“有问题”。人们提出了多种跨多个参与者聚合类别的方法，其中最常见的是“离散分析”和“连续分析”，还有“满意度系数”。 8. 工具卡诺模型的数据通常是通过标准化调查问卷收集的。调查问卷可以是纸质的、通过访谈收集的或通过在线调查进行的。对于后者，可以使用通用的在线调查软件，同时也有专门针对卡诺模型及其分析的专用在线工具。 9. 用途质量功能部署(QFD) 在构建综合 QFD矩阵时利用了卡诺模型。[26]在 QFD 矩阵中混合 Kano 类型可能会导致客户对产品特性的权重发生扭曲。例如，在最初的质量屋中混合必须的产品特性（例如成本、可靠性、工艺、安全性和产品中使用的技术）通常会导致完全填充具有高相关值的行和列。其他使用附加矩阵的综合 QFD 技术可用于避免此类问题。卡诺的模型提供了对客户偏好动态的洞察，以了解这些方法动态。 卡诺模型提供了对客户认为重要的产品属性的一些见解。该工具的目的是通过更好地发展团队理解来支持产品规范和讨论。卡诺的模型侧重于差异化产品功能，而不是最初关注客户需求。卡诺还提出了一种将消费者对调查问卷的反应映射到他的模型上的方法。 10. 参考文档Kano model","link":"/product/Kano_model.html"},{"title":"百度统计的使用","text":"1. 前言百度统计是全球领先的中文网站流量分析平台，帮助企业收集网站访问数据，提供流量趋势、来源分析、转化跟踪、页面热力图、访问流等多种统计分析服务，同时与百度搜索、百度推广、云服务无缝结合，为网站的精细化运营决策提供数据支持，进而有效提高企业的投资回报率。 2. 如何注册百度统计账号?1, 点击进入百度统计的官网，https://tongji.baidu.com 2, 注册一个账号，如果有百度的账号可以直接登陆 首先点击登录, 在登录页下方, 有一个注册链接, 点击注册链接可以导航到注册页面. 在此可以注册两种类型的百度账号, 可以任选一种进行注册, 注册方式类似. 一种为百度营销账号, 一种为百度账号. 以下以百度账号为例, 导航到注册页面后, 输入用户名, 手机号, 密码, 短信验证码, 勾选百度用户协议, 隐私协议等, 然后点击注册. 3, 注册完成后即可凭用户名, 密码登录百度统计. 3. 如何给网站安装百度统计代码?新增网站: 登录百度统计后, 导航到【使用设置】–&gt; 【用户设置】–&gt;【网站列表】–&gt;【自有网站】–&gt;【新增网站】, 来到新增网站后, 输入网址域名, 网站首页, 选择行业, 点击确定. 获取代码: 在网站列表页, 对应的网站右侧有获取代码按钮, 点击进入获取代码页面, 对应的百度统计代码将会显示出来. 点击复制代码按钮, 复制统计代码. 12345678910&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?token_xxxxxx&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 安装统计代码: 将统计代码拷贝到自己网站的首页. 或者按照获取代码页的详细指引进行操作. 验证: 一旦网页被访问即可在百度统计实时访客页面, 看到统计数据. 4. 排除规则设置百度统计不会自动排除你自己的浏览，这样会使你的统计“受污染”，你需要自己把你的IP排除在外。 在“使用设置”界面左侧选择“规则设置”然后再选择“排除规则设置”，这里会直接提示当前登录的IP，你直接复制就行。有时候这个 IP 并不是你在浏览自己界面时的 IP，这时候你得在第一次记录到你的浏览时找到记录的 IP 粘贴在这里（在“报告”界面中的“实时访客”可以找到你实际使用的IP。或者使用IP地址查询工具查询自己的IP. 5. 声明本文为团队创造, 由philoenglish.com团队撰写, 更多关于产品设计的文章请参考鹏叔的技术博客 - 产品营销, 获取最新版本请访问鹏叔的技术博客 6. 参考文档如何给网站安装百度统计代码 网站分析平台：是选择百度统计，还是 Google Analytics 呢？","link":"/product/baidu_analytics.html"},{"title":"买家决策过程详解","text":"1. 前言作为消费者行为的一部分，购买决策过程是消费者在购买商品或服务之前、期间和之后对市场交易进行的决策过程。它可以被视为存在多种替代方案的情况下成本效益分析的一种特殊形式。 常见的例子包括购物和决定吃什么。决策是一种心理建构。这意味着，虽然决策无法“看到”，但我们可以从可观察的行为推断已经做出了决策。因此，我们得出结论，发生了心理“决策”事件。这是一种将承诺归于行动的结构。也就是说，根据可观察到的行动，我们假设人们已经做出了实施该行动的承诺。 诺贝尔奖获得者赫伯特·A·西蒙 (Herbert A. Simon)认为经济决策是理性的徒劳尝试。西蒙声称（1947 年和 1957 年），如果要进行完整的分析，做出决定将非常复杂。西蒙还写道，人的信息处理能力是有限的。经济行为者完全理性的假设是不现实的。消费者受到情感和非理性考虑的影响，使得理性的尝试只能部分成功。他呼吁用适合认知受限主体的理性概念来取代经济人的完美理性假设。即使买方的决策过程是高度理性的，所需的产品信息和/或知识通常在质量或范围上受到很大限制，潜在替代品的可用性也是如此。认知努力和决策时间等因素也发挥了作用。 2. 买家决策过程买家决策过程的各个阶段由约翰·杜威 (John Dewey) 于 1910 年首次提出。后来的研究在杜威的最初发现的基础上进行了扩展。恩格尔、布莱克威尔和科拉特(1968)。 在伦敦伯灵顿拱廊购物的消费者会参与各种娱乐性和功能性的购买活动 - 从橱窗购物到将购买的商品运回家 问题/需求识别 - 识别问题或需求是什么，并确定所需的产品或产品类型。页面文本。 信息搜索——消费者研究能够满足既定需求的产品。 替代品评估 - 消费者评估搜索到的替代品。一般来说，信息搜索会显示多种产品，供消费者评估和了解哪种产品合适。 购买决策 - 在消费者评估了所有选项并打算购买任何产品后，现在可能只有两件事可能会改变消费者购买该产品的决定，即其他同行的决定消费者对产品的看法以及任何不可预见的情况。例如，在这种情况下，不可预见的情况可能是导致不购买产品的经济损失。 购买后行为——购买后，消费者可能会体验到购买后的不和谐感觉，认为购买另一种产品会更好。解决购买后的失调问题可以传播产品的好口碑，并增加频繁回购的机会。 这五个阶段是评估客户购买决策过程的框架。虽然许多消费者以固定的线性顺序经历这些阶段，但在整个购买决策过程中可能会出现一些阶段，例如评估替代方案。每个阶段投入的时间和精力取决于许多因素，包括感知风险和消费者的动机。在冲动购买的情况下，例如购买巧克力棒作为个人款待，消费者可能会花费最少的时间进行信息搜索和评估，并直接进行实际购买。 3. 问题/需求识别问题/需求识别是购买决策的第一步。如果不了解客户的需求，他们就不会被吸引去购买产品。这种需求可以由内部刺激（例如饥饿、口渴）或外部刺激（例如广告）触发。马斯洛认为，需求是按层次结构排列的。根据马斯洛层次理论，一个人只有满足了某一阶段的需求，才能进入下一阶段。问题一定是可用的产品或服务。这就是问题或需求如何被认识到的。 4. 资料搜寻信息搜索阶段是客户在认识到问题或需求后可能采取的下一步，以找出他们认为最好的解决方案。这是买方在搜索内部和外部业务环境以识别和观察与焦点购买决策相关的信息源方面所做的努力。过去四十年来，信息领域取得了长足的进步，使得信息发现变得更加容易和快捷。消费者可以依靠印刷、视觉和/或语音媒体来获取信息。 5. 可选方案的评估在此阶段，消费者根据不同的产品属性来评估不同的产品/品牌，以及这些产品/品牌是否能够提供客户所寻求的利益。这个阶段很大程度上受到一个人的态度的影响，因为“态度使一个人处于一种心态：喜欢或不喜欢一个物体，接近或远离它”。影响评估过程的另一个因素是参与 程度。例如，如果客户参与度高，那么他/她会评估多个品牌；如果较低，则仅评估一个品牌。 客户参与 高的 中等的 低的 特征 高的 中等的 低的 审查的品牌数量 许多 一些 很少 考虑的卖家数量 许多 一些 很少 评估的产品属性数量 许多 缓和 一 使用的外部信息源数量 许多 很少 没有任何 搜索所花费的时间 大量 小的 最小 6. 购买决定这是第四阶段，即进行购买。根据 Kotler、Keller、Koshy 和 Jha（2009）的说法，最终的购买决定可能会受到两个因素的干扰：其他客户的负面反馈以及遵守或接受反馈的动机水平。例如，经过上述三个阶段后，客户选择购买尼康D80 单反相机。然而，由于他的好朋友（也是一名摄影师）给了他负面反馈，他必然会改变他的偏好。其次，决策可能会因突然失业或零售店关门等意外情况而受到干扰。 7. 购买后行为这些阶段对于留住客户非常重要。客户将产品与他们的体验相匹配，以确定他们对产品是否满意。这会影响未来从同一家公司进行类似采购的决策过程，主要是在信息搜索阶段和替代方案评估阶段。如果建立了品牌忠诚度，那么客户通常会快速跟踪或完全跳过其他阶段的信息搜索和评估。 无论是满意还是不满意，客户都会传播对产品的好或坏的意见。在这个阶段，企业会尝试进行有利的售后沟通，以鼓励顾客购买。 此外，认知失调（营销术语中的消费者混淆）在这个阶段也很常见；顾客在购买后常常会经历心理紧张或焦虑的感受。问题包括：“我做出了正确的决定吗？”、“这是一个好的选择吗？”等等。 8. 购买者决策模型分析消费者购买决策的方法通常有以下三种： 经济模型——主要是定量的，并且基于理性和近乎完美的知识的假设。消费者被视为最大化其效用。参见消费者理论。在某些情况下也可以使用博弈论。 心理模型- 心理和认知过程，例如动机和需求识别。它们是定性的而不是定量的，并且建立在文化影响和家庭影响等社会学因素的基础上。 消费者行为模型 - 营销人员使用的实用模型。它们通常融合了经济模型和心理模型。 在对买方决策过程文献的早期研究中，Frank Nicosia（Nicosia，F. 1966；第 9-21 页）确定了三种类型的买方决策模型。它们是单变量模型（他称之为“简单方案”），其中在刺激-反应类型的关系中只允许一个行为决定因素；多变量模型（他称之为“简化形式方案”），其中假设有许多自变量来确定购买者的行为；最后是“方程组”模型（他称之为“结构方案”或“过程方案”。）其中众多函数关系（单变量或多变量）在复杂的方程组中相互作用。他的结论是，只有第三种类型的模型能够表达买方决策过程的复杂性。在第七章中，尼科西亚构建了一个涉及五个模块的综合模型。编码模块包括“品牌属性”、“环境因素”、“消费者属性”、“组织属性”和“消息属性”等决定因素。系统中的其他模块包括消费者解码、搜索和评估、决策和消费。 一些神经营销学研究论文探讨了如何根据前额叶皮层脑电图 (EEG) 不对称性所指示的动机来预测品牌和价格变化时的购买决策。在受试者内部设计中，参与者对 14 种不同的杂货产品（七种自有品牌和七种国家品牌产品）进行了购买决策试验，这些产品的价格在记录他们的脑电图活动时有所上升和下降。结果表明，在决策期间，相对较大的左额叶激活（即较高的接近动机）预示着肯定的购买决定。与自有品牌产品相比，当产品价格低于正常价格时（即，隐含参考价格）与高于正常价格时的比较。对产品的更高的感知需求和更高的感知产品质量与更大的相对左额叶激活相关。 对于任何高参与度的产品类别，决策时间通常很长，买家通常会非常谨慎地评估可用信息。他们还利用主动的信息搜索过程。与此类决定相关的风险非常高。 9. 神经科学神经科学是买家决策研究中的有用工具和理论发展和测试的来源。神经成像设备用于神经营销学来调查消费者行为。 10. 后记本文为翻译文章, 由philoenglish.com团队翻译, 原文请参考Buyer decision process, 更多关于产品设计的文章请参考鹏叔的技术博客 - 产品 11. 参考文章Buyer decision process","link":"/product/buyer_decision_process.html"},{"title":"什么是客户满意度？","text":"1. 前言客户满意度（通常缩写为CSAT ）是营销中经常使用的术语。它衡量公司提供的产品和服务如何满足或超越客户期望。客户满意度被定义为“报告的对公司产品或服务（评级）的体验超过指定满意度目标的客户数量或客户总数的百分比”。客户发挥着重要作用，对于保持产品或服务的相关性至关重要；因此，确保客户满意度并建立客户忠诚度符合企业的最佳利益。 营销责任标准委员会 (MASB)认可营销指标中出现的定义、目的和衡量标准，作为其正在进行的营销项目通用语言的一部分。在一项针对近 200 名高级营销经理的调查中，71% 的受访者表示，他们发现客户满意度指标对于管理和监控其业务非常有用。客户满意度被视为企业内的关键绩效指标，并且通常是平衡计分卡的一部分。在企业争夺客户的竞争市场中，客户满意度被视为主要的差异化因素，并日益成为业务战略的重要组成部分。 2. 目的客户满意度提供了消费者购买意愿和忠诚度的前提指标。作者还写道，“客户满意度数据是最常收集的市场认知指标之一。它们的主要用途有两个：” “在组织内部，这些数据的收集、分析和传播传达了一个信息，即照顾客户并确保他们对公司的商品和服务有积极的体验的重要性。”“虽然销售额或市场份额可以表明一家公司当前的业绩如何，但满意度可能是衡量该公司的客户未来进一步购买的可能性的最佳指标。许多研究都集中在客户满意度与客户满意之间的关系上。”研究表明，在极端情况下，满意度的影响最为强烈。”按照五分制，“满意度为‘5’的个人可能会成为回头客，甚至可能为公司宣传。与满意度相关的第二个重要指标是推荐意愿。该指标是定义为“表示会向朋友推荐某个品牌的受访客户的百分比。”之前一项关于客户满意度的研究表明，当客户对某种产品感到满意时，他或她可能会将其推荐给朋友、亲戚这可能是一个强大的营销优势。根据 Faris 等人的说法，“相比之下，满意度为‘1’的个人不太可能回归。更远，推荐意愿是与客户满意度相关的一个关键指标。” 3. 理论基础在研究文献中，从不同的角度研究了客户满意度的前因。这些观点从心理角度延伸到物理角度，也从规范角度延伸。然而，在许多文献中，研究都集中在两个基本概念上：(a) 购买或使用产品之前的期望；(b) 客户使用该产品后对该产品性能的看法。 客户对产品的期望取决于客户对产品性能的看法。消费者在对产品的预期性能形成意见时被认为有各种“类型”的期望。Miller (1977) 描述了四种类型的期望：理想的、期望的、最低可容忍的和失望的。Day（1977）强调了不同类型的期望，包括关于成本、产品的性质、收益和社会价值的期望。 人们认为顾客根据一组有限的规范和属性来判断产品。Olshavsky 和 ​​Miller (1972) 以及 Olson 和 Dover (1976) 设计了他们的研究来操纵实际的产品性能，他们的目的是找出期望如何影响感知的性能评级。这些研究展开了关于解释期望与感知绩效之间差异的讨论。” 在一些研究中，学者们已经能够确定客户满意度具有强烈的情感成分，即情感成分。还有一些研究表明，客户满意度的认知和情感成分随着时间的推移相互影响，从而决定总体满意度。 特别是对于随着时间的推移而消耗的耐用品，从动态角度看待客户满意度是有价值的。从动态的角度来看，随着客户重复使用产品或与服务交互，客户满意度会随着时间的推移而变化。每次互动所体验到的满意度（交易满意度）可以影响整体的累积满意度。学者们表明，不仅是总体客户满意度，而且客户忠诚度也会随着时间的推移而变化。 4. 否定模型“否定模型基于客户的期望和他们的感知性能评级的比较。具体来说，当产品的性能符合预期时，个人的期望得到确认。当产品的性能比预期差时，个人的期望得到了否定的确认。当产品的表现超出预期时，确认就是积极的（Churchill &amp; Suprenant 1982）。有四种结构来描述传统的否定范式，即期望、性能、否定和满意度。“满意度被认为是购买和使用的结果，是购买者将预期回报和购买成本与预期后果进行比较而产生的。在操作中，满意度在某种程度上类似于态度，因为它可以被评估为对产品某些功能的满意度总和。” “在文献中，满意度的认知和情感模型也被开发出来并被认为是替代方案（Pfaff，1977）。Churchill和Suprenant于1982年评估了文献中的各种研究，并形成了下图所示的否定过程的概述：” 5. 建设组织需要保留现有客户，同时瞄准非客户。衡量客户满意度可以表明组织在向市场提供产品和/或服务方面的成功程度。 “客户满意度是在个人层面上衡量的，但几乎总是在总体水平上得到体现。它是可以而且经常是从不同的维度来衡量的。例如，酒店可能会要求客户对其前台的体验进行评分前台和登记入住服务、房间、房间内的设施、餐厅等等。此外，从整体意义上来说，酒店可能会询问“对您的住宿”的整体满意度。” 随着对消费体验的研究不断增长，有证据表明，消费者购买商品和服务是为了两种利益的结合：享乐性和功利性。享乐效益与产品的感官和体验属性相关。产品的实用性利益与产品更具工具性和功能性的属性相关（Batra 和 Athola 1990）。 客户满意度是一个模糊而抽象的概念，满意度状态的实际表现因人而异，因产品/服务而异。满意度状态取决于许多心理和身体变量，这些变量与满意度行为（例如退货率和推荐率）相关。满意度水平还可以根据客户可能拥有的其他选择以及客户可以将组织的产品进行比较的其他产品而变化。 Parasuraman、Zeithaml 和 Berry (Leonard L) 在 1985 年至 1988 年间所做的工作，通过利用客户对绩效的期望与他们对绩效的感知体验之间的差距，为衡量客户对服务的满意度提供了基础。这为测量者提供了客观且定量的满意度“差距”。Cronin 和 Taylor 的工作提出了“确认/否定”理论，将 Parasuraman、Zeithaml 和 Berry 所描述的“差距”作为两种不同的衡量标准（绩效的感知和期望）结合到根据期望的单一绩效衡量标准中。 客户满意度的常用衡量标准包括使用李克特量表进行的调查。要求客户根据他们对被衡量组织绩效的看法和期望来评估每项陈述。 良好的质量测量需要具有高满意度负载、良好的可靠性和低误差方差。在比较常用满意度测量的实证研究中，发现两种多项目语义差异量表在享乐和功利服务消费环境中表现最佳。Wirtz &amp; Lee (2003) 的一项研究，发现六项 7 点语义微分量表（例如，Oliver 和 Swan 1983）是一个包含 6 项 7 点的双极量表，在享乐型服务和功利性服务中始终表现最佳。在这两项研究中，它的满意度最高，项目可靠性最高，并且误差方差最低。在这项研究中，六个项目询问了受访者对他们最近使用ATM服务和冰淇淋餐厅的体验的评价，以及这六个项目中的七个点：“让我高兴”、“让我不高兴” 、“满意到厌恶” 、“非常满意到非常不满意”、“为我做得很好“对我来说工作做得很差”，“明智的选择到糟糕的选择”和“高兴到不满意”。语义差异（4 个项目）量表（例如，Eroglu 和 Machleit 1990）是一个包含 4 个项目的 7 点双极量表，是表现第二好的测量方法，在两种情况下再次保持一致。 在这项研究中，受访者被要求评估他们对这两种产品的体验，按照以下四个项目中的七点进行评价：“满意到不满意”、“有利到不利”、“愉快到不愉快””和“我非常喜欢它，我根本不喜欢它”。第三个最佳量表是单项百分比测量，即单项 7 点双极量表（例如，Westbrook 1980）。再次，受访者被要求评估他们在 ATM 服务和冰淇淋餐厅的体验，分为“高兴到糟糕”的七个等级。 最后，所有测量都捕获了满意度的情感和认知方面，与其量表锚无关。情感测量捕捉消费者对产品的态度（喜欢/不喜欢），这可以由任何产品信息或体验产生。另一方面，认知元素被定义为对产品性能与预期相比（或超出或低于预期）、有用（或无用）、适合情况（或不适合）的评估或结论，超出了情况要求（或没有超出）。 单项四点HappyOrNot客户满意度反馈终端最近的研究表明，在大多数商业应用中，例如进行客户调查的公司，单项总体满意度量表的表现与多项目量表一样好。特别是在研究人员需要从大量客户收集数据的大规模研究中，单项量表可能是首选，因为它可以减少总调查误差。最近，通过重新采访一家公司的相同客户，我们发现了一个有趣的发现，即只有 50% 的受访者在重新采访时给出了相同的满意度评级，即使在两次调查之间客户和公司之间没有发生过服务接触。 该研究发现客户满意度反应存在“均值回归”效应，即在第一次调查中给出过低分数的受访者群体在第二次调查中回归到平均水平，而给出过高分数的受访者群体则倾向于回归平均水平。下降至第二次调查的总体平均水平。 6. 方法论美国顾客满意度指数（ACSI）是衡量顾客满意度的科学标准。学术研究表明，全国 ACSI 分数是国内生产总值(GDP) 增长的有力预测指标，也是个人消费支出(PCE) 增长的有力预测指标。在微观经济层面，学术研究表明，ACSI数据与企业的财务绩效相关，包括投资回报率（ROI）、销售额、企业长期价值（托宾q）、现金流、现金流波动性等 、人力资本绩效、投资组合回报、债务融资、风险和消费者支出。增加 ACSI 分数已被证明可以预测忠诚度、口碑推荐和购买行为。ACSI 每年衡量 43 个行业和 10 个经济部门的 200 多家公司的客户满意度。除了季度报告外，ACSI 方法还可应用于私营企业和政府机构，以提高忠诚度和购买意向。 卡诺模型是由卡诺纪明教授在 20 世纪 80 年代开发的产品开发和客户满意度理论，它将客户偏好分为五类：有吸引力、一维、必须、冷漠、反向。卡诺模型提供了对客户认为重要的产品属性的一些见解。 SERVQUAL或RATER 是一个服务质量框架，已纳入客户满意度调查（例如修订后的挪威客户满意度晴雨表），以表明客户期望与体验之间的差距。 JD Power and Associates提供了另一种衡量客户满意度的方法，以其顶盒方法和汽车行业排名而闻名。JD Power and Associates 的营销研究主要包括消费者调查，并以其产品奖项的价值而闻名。 其他研究和咨询公司也有客户满意度解决方案。其中包括科尔尼公司的客户满意度审核流程，该流程包含卓越阶段框架，有助于根据八个关键确定的维度来定义公司的状态。 净推荐值(NPS) 也用于衡量客户满意度。该分数从 0 到 10 分，衡量客户向他人推荐公司的意愿。尽管从科学角度来看存在许多批评，但 NPS 在实践中得到了广泛的应用。它的流行和广泛使用归因于它的简单性和公开可用的方法。 对于客户群较小的B2B客户满意度调查来说，调查的高响应率是可取的。美国客户满意度指数（2012）发现纸质调查的回复率约为 10%，电子调查（网络、wap 和电子邮件）的回复率平均在 5% 至 15% 之间 -这只能提供客户意见的草稿民意调查。 欧盟成员国正在使用许多衡量电子政务服务影响和满意度的方法， eGovMoNet项目试图对这些方法进行比较和协调。 这些客户满意度方法尚未由营销责任标准委员会 (MASB)根据MMAP（营销指标审核协议）进行独立审核。 有许多提高客户满意度的运营策略，但在最基本的层面上，您需要了解客户的期望。 最近，人们越来越有兴趣使用大数据和机器学习方法（以行为和人口特征作为预测因子）来预测客户满意度，以采取有针对性的预防措施，以避免客户流失、投诉和不满。 7. 流行率2008年的一项调查发现，只有3.5%的中国消费者对网上购物体验感到满意。亚利桑那州立大学2020 年的一项调查发现，美国的客户满意度正在恶化。大约三分之二的调查参与者表示，他们对自己作为消费者的经历感到“愤怒”。自 20 世纪 70 年代以来，消费者满意度连续数十年下降。大多数受访者认为企业没有充分解决他们的客户服务投诉。2022 年的一份报告发现，自COVID-19 大流行开始以来的两年内，美国的消费者体验大幅下降。2022 年，由于人员短缺和与新冠疫情相关的供应危机，英国的客户服务投诉创下历史新高。","link":"/product/customer_satisfaction.html"},{"title":"帮助系统设计2","text":"1. 网站帮助中心的作用 通过向客户表明您了解他们所面临的问题以及如何提供帮助来建立信任； 通过回答常见问题来改善客户服务，增强专业的品牌形象； 通过减少重复发送给支持人员的电话和电子邮件，节省时间和金钱； 增强您在搜索引擎中的知名度（包含更多关键词的帮助中心页面更易被搜索引擎喜欢）； 通过轻松找到他们要寻找的内容而不是搜索站点来改善用户体验。将答案直接链接到博客文章或内容页面可以使访问者更轻松地获取其他信息； 2. 网站帮助中心制作时关键事项2.1. 清楚对象是谁(know who)首先弄清楚自己的用户是谁，是写好网站帮助中心文档的第一步。针对不同的群体要有不同的写作侧重点。如果是给技术看，那么要重点说清楚各个操作以及相关逻辑；如果是给非技术人员看的，一定要尽量『看图说话』，联系他们能够理解的概念来跨越不同职业的鸿沟。 2.2. 结构清晰帮助系统的结构需要清晰, 以便用户快速定位到帮助内容, 使得本来就很迷惑的用户, 不至于受到二次伤害. 2.3. 文字简洁明了, 图文结合帮助系统语言要简洁明了, 站在用户的角度思考, 内容兼顾大多数用户的理解能力. 避免使用生硬的术语, 避免使用缩略语描述问题与解决办法.采用图文相结合的办法描述帮助内容. 如有必要采用视频教学方式指导客户解决问题. 2.4. 展示重要问题帮助系统不仅要结构清晰, 还需要给用户提供问题快捷入口. 使用二八原则, 将用户经常咨询的在制作帮助中心时需要事先收集用户真正关心的问题，可以做个问卷调查将平时客服收到较多的问题写下来，提炼出该问题模块的一些重要流程以及主要操作。然后在此基础上，想着怎样以最少的文字进行最全面的讲解。 2.5. 帮助内容及访问频率适度帮助系统内容不是越多越好, 帮助内容多, 而且频繁背访问, 从侧面反映了系统设计中存在着潜在的交互缺陷. 应该进一步分析原因. 当帮助系统访问频次增长曲线不收敛时, 需要立即分析其原因, 并加以改善. 最终要达到, 常见问题越来越不常见, 问题列表越来短. 2.6. 统一的用户体验尼尔森的交互原则中，有一条就是“一致性原则”。这对帮助文档也适用。由于一般会是不同的产品负责不同的模块，所以如果不在一开始的时候统一用户体验，这会导致最后呈现出来的效果很容易五花八门乱七八糟。帮助文档最好是使用统一的模板，体验都更好一些。 3. 如何制作帮助文档3.1. 编辑文档内容首先记录用户最关注的事情。以用户角度使用产品或服务，并写下其中的每个部分。编辑一份最完整的使用纪要。通过自己遍历整个过程并回答您认为用户会遇到的问题或疑虑，从而了解用户的痛点。不仅可以帮助客户了解企业网站的产品或服务的运作方式，还能发现使用的缺陷。 3.2. 结构化帮助中心记录的内容帮助中心是一个大型的文档，只有将文档中的内容结构化时（将相同类型的文章放到同一栏目中）才能方便用户的查阅。 3.3. 简洁清晰的展示界面网站帮助中心在展示上应该保持简洁清晰的展示风格，这样能使用户更直观的查阅帮助内容，发挥帮助中心的作用。 3.4. 便于检索的帮助中心所有的在线帮助中心或知识库，您都会注意到相同的内容：页面顶部附近拥有醒目的搜索框。搜索框能帮助用户在更短的时间内找到关心的问题，提升帮助中心的问题响应效率。 3.5. 不断优化帮助内容即使您编写了出色的文档，也始终有改进的余地。我们需要不断的听从客户的建议，发现他们在使用过程中出现的新问题，并在帮助中心出解决这些问题，为用户提供最全最新的帮助文档。这需要我们确保帮助文档系统可便于更改易于操作等属性。 4. 说明本文由philoenglish.com团队撰写, 更多关于产品设计的文章请参考鹏叔的技术博客 - 产品营销 5. 参考文档网站帮助中心怎么写","link":"/product/help_system_design2.html"},{"title":"帮助系统案例与赏析","text":"1. 前言网站设计师应将每一位访问我们网站的用户视为潜在的新用户，为他们提供足够的指导和指南，以完成他们的任务并熟悉网站。几乎所有类型的网站都必须帮助用户，但方式不同。网站的类型将决定您应该提供的帮助系统的类型。此外，帮助系统的有效性直接关系到网站设计的质量。一个设计不好的帮助系统——无论其内容多么好——都会带来劣质的用户体验。在本文中，我们将通过示例研究设计有效帮助页面的一些方法，这些方法可能会启发您的工作。 2. 什么是帮助系统我们在网站设计中看到许多术语和类型的帮助系统：“Help”、“Support”、“FAQ”、“Docs”、“Knowledge Base”等。所有这些网页都旨在为用户提供帮助。 帮助系统是一个当用户有疑问或寻求帮助的时候能够方便访问的位置,例如，当他们开始使用网站时，以及当他们可以从有用信息中受益时。它们是至关重要的，因为它们是网站访问者在决定放弃并搜索另一个满足他们要求的网站之前最不希望看到的地方之一。因此，帮助系统对于留住网站访问者至关重要。 虽然帮助系统很重要，而且往往是不可或缺的，但许多网站设计忽略了它们的有用性和重要性。原因通常是网站所有者对帮助内容的需求或将其整合到网站内容中的益处缺乏认识。例如，在网上商店的情况下，您可以将购买说明放在主页或用户可以轻松找到的地方，而不是创建单独的帮助部分。这也将增加可查找性. 3. 帮助系统案例为了帮助后面的讨论，让我们来看几个帮助系统的示例。正如你在下面看到的，Marie Catrib’s网站将其联系信息和营业时间放在主页的页脚。这巧妙地将有时完全独立的页面的内容嵌入页脚中。此信息可被视为网站帮助系统的一部分。FAQ（常见问题）是回答许多用户反复询问或思考的问题的地方。换句话说，它可能是顶级类别中的一个大型站点帮助或支持系统的子集。 在大多数情况下，“帮助”是帮助系统的更好名称。“支持”通常用于提供某种技术服务的商业网站。有些部分被命名为“帮助/支持中心”。下面，您可以看到Josh Lockhart’s website的网站使用“帮助”链接作为其帮助页面的入口点。 帮助页面进一步细分为“如何安装”、“如何购买”、“常见问题解答”等部分。 下面是帮助系统的另一个示例。鉴于其内容（包括各种类别），“帮助中心”是谷歌网站帮助系统的正确名称。因为他们有很多产品，所以他们的系统非常全面，必须组织得很好，才能有效和可用。 California Courts有一个合适的帮助中心，有明确的分类。图标用于促进帮助系统不同部分的视觉认知。 Survey Monkey的帮助中心也有有精心设计的分类。 Ten Little Monkeys在页脚的“帮助和信息”标题下列出了一些帮助页面。 BrightKite和Ten Little Monkeys一样，使用页脚上的“帮助”标题，然后列出一些有用的帮助页面，这些页面是他们帮助系统的一部分。 作为一个反例，Fine Point只将他们的联系信息放在其帮助中心，这是一个错误命名和设计不完整的帮助系统的教训。作为一个很好的惯例，“联系”或“联系我们”应该是这个网页的最好的标题而不是帮助中心。 4. 帮助页面的功能所有帮助页面，无论其各自的特性如何，都有一些共同的特性。 页面必须清晰且具有说明性。 应该对每个主题有一个简短、描述性的解释，以便快速阅读。来帮助页面的用户通常已经感到困惑，因此他们不倾向于阅读长文本块。 遵循良好的扫描辅助工具（如加粗关键字）可以提高可读性。 在下面的示例中，您可以看到，Maverick Label加粗了文本的重要部分，从而帮助用户。 尽管设计简单，但System 7 today上的链接仍能很好地突出重要主题。 除了这些特性之外，还有一些其他特性值得考虑。让我们回顾一下。 4.1. 无障碍任何页面最重要的一个方面是无障碍，但对于帮助页面来说更为重要。帮助页面应简单且快速访问。在页眉和页脚中链接到它们，特别是在长页面和主页上。用户不必深入挖掘隐藏很深的页面。经验应该是直截了当的。例如，Traffik将清晰的链接放在普通背景上，以提高可读性。 ProWorkflow将其支持页面的直接链接放置在其主导航栏中。 Invoice Machine遵循我们在上面看到的模式, 在其主导航上显示了帮助标签,和描述性文本。 Constant Contact为其资源使用适当的措辞（“Learning Center”），并在视觉上与其他链接区分开来。 AAFP的面包屑导航显示了通往帮助中心的超长路径。由于隐藏得太深，帮助部分可能不会被用户的注意注意到。 从主页上找到谷歌的帮助中心相当困难。事实上，谷歌搜索速度更快。 4.2. 良好的分类为了防止混淆，包含大量内容的帮助系统应按主题仔细组织。要使帮助系统有效，您必须在信息体系结构上花费时间。有少量的主要类别，每个类别都可以有子类别。有不同的分类方法，但一般来说，将更重要的主题和常见问题放在结构的更高位置。此外，考虑使用图标来增加类别的视觉提示，并为页面添加生命。在下面的例子中，苹果的帮助中心非常出色，就像它的产品一样！这些主题分类良好，涵盖了用户可能需要帮助的所有领域。 ProWorkflow将其帮助内容组织为多个类别，每个类别包含子类别。 Campaign Monitor使用图标支持其分类，将所有内容放在正确的位置。 为了防止杂乱无章，谷歌将不太重要的项目放在另一个页面上，可以通过链接访问。 Hostway是另一个带有图标但有自己风格的分类示例。 HWG的FAQ页面分类非常简单，没有任何多余的内容。 Apache Ant的帮助系统是另一个纯HTML页面。这很简单，但能完成任务。 4.3. 搜索功能对于广泛的帮助系统，能够搜索可能非常有用。搜索结果应该一眼就能显示有关主题的所有信息。但要真正有用，它应该只显示帮助部分的页面，而不是网站的其他部分，这样所显示的结果就不会让人感到不知所措或困惑。谷歌的帮助中心有一个部分特定的搜索，适当地标记为“搜索帮助”，以表明您只搜索帮助中心。 Storenvy的搜索功能定位良好，标记良好（即“搜索支持”）。 TiVo还显示了良好的定位，并为搜索框创建了独特的空间。还为search框添加了颜色进行美化。 ProWorkflow尽管分类良好，但缺少搜索，这可能会导致使用不方便。 4.4. 链接到其他资源有时，用户会被导航到错误的地方，或者找不到他们想要的东西。通过相关超链接为他们提供其他有用的选项，如其他帮助主题、论坛等。ThinkGeek列出了用户可能想去的几乎所有其他地方，他们把它们放在正确的位置，并有一个好的标题。 Notable链接到最新论坛帖子链接，这是引入新资源和提高可发现性的好主意。 像ThinkGeek一样，雅虎将链接组织在信息标题下，这很有帮助。 4.5. 联系信息将联系人信息放在正确的位置是帮助用户的另一种方式。当用户找不到他们要找的东西时，他们会问，所以你应该可以通过某种方式访问：电话、电子邮件、在线聊天等。虽然联系信息通常出现在主页上，当然也出现在联系页面上，但如果用户找不出他们要找什么，将其放在帮助页面上是一个好主意。 Crazy Egg的联系信息呈现得很好，位置也很好。 iPersonalAssistant提供简单的联系信息，没有任何不必要的修饰。像Crazy Egg一样，它也欢迎电子邮件。 TiVo提供实时聊天，这是网站的一个非常宝贵的功能。 ThinkGeek提供全面的联系信息。并且其定位良好。 help.com邀请用户提交一张帮助单，这很方便，但可能不如实时聊天。当然，这两种方法都需要足够的人手来满足需求。 4.6. 获得用户反馈为了改进帮助材料，评估其效率和衡量用户满意度，反馈非常重要。这个过程不应该很耗时，否则用户不会参与；星级或数字评级比表格更有效。微软的一项非常简单的调查询问帮助资源是否有用。 help.com要求用户写下他们的建议、投诉和其他反馈。虽然反馈可能更详细，但分析它是一项令人厌烦的工作。考虑到参与所需的时间，用户可能会拒绝。 雅虎复杂的形式对用户来说似乎过于累赘。 NASA的宇宙调查！显示平均评级和评级数量是明智的。他们甚至提供帮助（见问号）。 4.7. 整合我们已经回顾了帮助页面的一些基本元素。许多帮助页面都没有这些功能，而一些帮助页面同时显示这些功能。几乎完美的帮助部分很少见，而那些部分往往属于网络上最成功的公司。 Campaign Monitor展示了完美帮助部分的所有特征。 与其他功能一样，网络巨头雅虎在这方面也有非常好的帮助功能。 5. 相关阅读 20 Websites to Help You Master User Interface Design How Cognitive Biases Shape User Experience Making User Interface Elements Difficult to Use By Intent 三十个优秀帮助系统供参考 Slack：Slack的帮助中心组织良好，易于导航。它包括一个搜索栏，一个目录和一个热门文章列表。 Asana：Asana的帮助中心也组织良好，包括一个搜索栏，一个目录和一个热门文章列表。它还包括一个常见问题解答部分。 Trello：Trello的帮助中心简单易用。它包括一个搜索栏和一个热门文章列表。 GitHub：GitHub的文档非常全面，组织良好。它包括一个搜索栏，一个目录和一个热门文章列表。 Shopify：Shopify的帮助中心组织良好，包括一个搜索栏，一个目录和一个热门文章列表。它还包括一个常见问题解答部分。 Zendesk：Zendesk的帮助中心设计精美，易于导航。它包括一个搜索栏，一个目录和一个热门文章列表。 Atlassian：Atlassian的帮助中心组织良好，包括一个搜索栏，一个目录和一个热门文章列表。它还包括一个常见问题解答部分。 Salesforce：Salesforce的帮助中心设计精美，易于导航。它包括一个搜索栏，一个目录和一个热门文章列表。 Zoom：Zoom的帮助中心简单易用。它包括一个搜索栏和一个热门文章列表。 Microsoft：Microsoft的帮助中心非常全面，组织良好。它包括一个搜索栏，一个目录和一个热门文章列表。 Google Workspace: Google Workspace的帮助中心组织有序，包括搜索栏、目录和热门文章列表。 Dropbox: Dropbox的帮助中心简单易用，包括搜索栏和热门文章列表。 Atlassian Community: Atlassian Community是一个用户可以在其中提问和回答有关Atlassian产品的论坛。它包括搜索栏和热门主题列表。 Slack Community: Slack Community是一个用户可以在其中提问和回答有关Slack的论坛。它包括搜索栏和热门主题列表。 Microsoft Tech Community: Microsoft Tech Community是一个用户可以在其中提问和回答有关Microsoft产品的论坛。它包括搜索栏和热门主题列表。 Asana Community: Asana Community是一个用户可以在其中提问和回答有关Asana的论坛。它包括搜索栏和热门主题列表。 GitHub Community: GitHub Community是一个用户可以在其中提问和回答有关GitHub的论坛。它包括搜索栏和热门主题列表。 Shopify Community: Shopify Community是一个用户可以在其中提问和回答有关Shopify的论坛。它包括搜索栏和热门主题列表。 Zoom Community: Zoom Community是一个用户可以在其中提问和回答有关Zoom的论坛。它包括搜索栏和热门主题列表。 Salesforce Trailblazer Community: Salesforce Trailblazer Community是一个用户可以在其中提问和回答有关Salesforce的论坛。它包括搜索栏和热门主题列表。 Google Cloud Community: Google Cloud Community是一个用户可以在其中提问和回答有关Google Cloud的论坛。它包括搜索栏和热门主题列表。 Microsoft Q&amp;A: Microsoft Q&amp;A是一个用户可以在其中提问和回答有关Microsoft产品的论坛。它包括搜索栏和热门主题列表。 Atlassian Marketplace: Atlassian Marketplace是Atlassian产品的应用和插件目录。它包括搜索栏和热门类别列表。 Slack App Directory: Slack App Directory是Slack的应用和集成目录。它包括搜索栏和热门类别列表。 GitHub Marketplace: GitHub Marketplace是GitHub的应用和集成目录。它包括搜索栏和热门类别列表。 Shopify App Store: Shopify App Store是Shopify的应用和插件目录。它包括搜索栏和热门类别列表。 Google Workspace Marketplace: Google Workspace Marketplace是Google Workspace的应用和插件目录。它包括搜索栏和热门类别列表。 Microsoft AppSource: Microsoft AppSource是Microsoft产品的应用和插件目录。它包括搜索栏和热门类别列表。 Zoom App Marketplace: Zoom App Marketplace是Zoom的应用和集成目录。它包括搜索栏和热门类别列表。 Salesforce AppExchange: Salesforce AppExchange是Salesforce的应用和插件目录。它包括搜索栏和热门类别列表。 6. 总结本指南介绍了一些设计有效帮助页面的基本技巧和最佳实践。我希望你能够遵守适用于你的规则，不要为绕过其他规则而付出太大的代价。所以，开始尝试，同时记住基本知识。本文原文发布在鹏叔的技术博客 - 帮助系统案例与赏析 7. 参考文档Effective Website Help Systems: Tips and Examples","link":"/product/help_system_design.html"},{"title":"如何设计一款App","text":"1. 译者序这是一篇很好的关于从零开始创建App的建议的文章, 作者的结构和思路非常清晰, 一个很好的关于创建App的结构性的建议文章. 所以我们将其翻译成中文, 期望读者能进一步以此为蓝本将创建App的想法,思路,建议丰富起来. 同时这也是我们后续编写关于创建app建议文章的蓝本. 译者：philoenglish.com 团队 2. 前言你知道吗，在美国，普通人花大约5个小时粘在智能设备上？无论是发信息、发布照片还是玩游戏，我们生活的当前数字时代都有人不断使用应用程序。随着巨大的流行，随之而来的是巨大的竞争，虽然竞争是一件好事（它让我们保持警觉，让一切变得更好），但进入一个应用程序生长在树上的世界可能是一项令人生畏但又有回报的冒险。 如果你决定开发一款应用程序，那么想出一些能让你在竞争中脱颖而出的东西对你的成功是不可或缺的，这可能是脱颖而出和简单编造数字之间的区别。让人这是一个了不起的应用程序设计. 漂亮的界面、惊人的简单性和轻松的导航是出色应用程序中最突出的 3 个特征。你希望人们向他们的朋友介绍你的应用，了解它的用途，轻松浏览它，并确保他们不断返回使用它。 但是，如何创建出色的应用程序设计呢？ 我们的应用设计终极指南将为您提供帮助，我们将引导您完成如何设计必胜的应用的过程. 3. 准备开始3.1. 设置应用的目标在正式开始创造App之前, 在草稿纸上写下自己的想法,是一个很好的开始.试着想想你为什么要设计一个应用程序，以及你打算完成什么。戴上你的思维帽，记下以下问题的答案： 您的应用程序的基本目标是什么？ 你到底想让它做什么？ 你将如何让你的应用程序吸引用户？ 你打算做什么？ 你想用你的应用程序帮助人们解决什么问题？ 为什么人们会想使用你的应用程序而不是你的竞争对手？ 它是如何与众不同的？ 不仅仅是应用程序设计，目标设定很重要，这也是人生的一课！为你的应用程序设定明确的目标并将其写下来，将为你在整个过程中提供参考。如果你忘记了其中一个问题的答案，把它们记下来将是一个很好的参考. 3.2. 制定计划接下来还不是动手实战的时候, 我们还需要使用笔和纸写下我们的计划.在第一步中考虑问题的答案。现在获取这些信息并勾勒出项目范围的大纲。在此阶段，您可以更深入地研究您的应用程序将如何赚钱（广告、应用内购买等），您需要应用程序做什么，并勾勒出您将把想法带到哪里的路径，以及如何让它们在应用程序中发挥作用。将此阶段视为绘制应用程序的可见路线图，其功能是什么，适用于谁，以及有关如何实现它的迷你分步指南。 3.3. 确定市场定位和研究竞争对手现在可以放下笔，转向万维网研究竞争对手和确立市场定位了。 研究是应用程序设计过程中不可或缺的一步。了解你的应用程序的市场定位，了解你面临的挑战是很重要的。应用程序世界是一个极其多样化和竞争激烈的领域，所以你一定要确保你有独一无二的想法。 不要因为有很多类似的应用程序与你而吓倒。那并不意味着你的应用程序不会胜过所有应用程序。研究你的竞争对手会向你展示他们的应用程序中缺少什么，并让你更好地了解如何融入自己的应用程序。试着关注评论，用户目前对已经存在的应用程序喜欢什么？他们不喜欢什么？你如何解决这个问题？在这一步中，你还可以回顾你的计划和笔记，修改你的笔记，并进一步了解如何改进计划。 4. 设计App4.1. 创建线框图线框图是应用程序视觉架构草图.它将使得你的目标进一步地可视化, 并为应用程序的外观和功能创建一个基本的“蓝图”。你可以先在纸上做这件事，但一些线框图工具会让事情变得更容易，尤其是当你的线框变得越来越复杂和详细时。你想怎么实现目标? 制作线框图是一个很好的理清思路的机会。在此阶段,你还不需要做出任何具体的设计方案选型。这一步只是是关于理清应用程序的工作流程和整体结构。前面的步骤有助于让你了解我们希望应用程序做什么。线框图是一个更详细、更具体说明了应用程序应该如何工作，以及需要哪些页面和功能。有很多易用的线框工具，你可以用来创建线框。看看哪一个最适合你，然后开始让应用程序设计得栩栩如生。以下是一些可以使用的线框工具： Axure Pidoco iPlotz 一旦布置好线框，你就会对需要的页面以及应用程序的工作方式有一个很好的概述。 要测试线框是否是可靠得，可以使用Invision之类的工具创建一个点击模型。这将使您能够点击您设计得屏幕，并帮助您测试您设置的导航是否合理。向你的同事和朋友展示你的线框，并收集他们对你的应用程序的结构和导航的反馈。看看你的测试人员是否觉得很直观，以及所有的屏幕和元素是否对他们有意义。如果你在导航中发现任何问题，或者想重新排列屏幕和布局，你可以简单地调整线框并再次测试。不断地优化它，直到你对你的线框感到满意为止。 4.2. 开始设计应用现在是时候考虑一下应用程序的实际设计，并创建好看、逼真的模型了。这是一个非常重要的步骤，因为这将给你的用户留下永久的印象，所以在应用程序设计时不要匆忙或吝啬。一个美观、专业、美观的设计可以让你的应用程序获得巨大成功。你应该使用什么颜色、字体和设计元素是一个重大决定，所以我们将在下面的设计技巧部分详细讨论这一点。在决定如何设计你的应用程序时，你有几个不同的选择。你可能会考虑自己设计应用程序，但除非你是一名平面设计师，否则我们不建议你这样做。最好依靠专业人士来确保你会取得好成绩。 4.2.1. 一些设计方案实现选项4.2.1.1. 直接与设计师合作如果你已经对你的应用程序应该是什么样子有成熟得想法，并且你知道自己想要什么和需要什么，那么最简单的方法就是与设计师一一合作。你可以雇佣当地的自由职业者，或者如果你与设计师没有任何联系，也可以在网上查看不同的设计师作品集。结合自己的想法，看看设计师以前的作品，在技巧和风格上找到完美的匹配。 4.2.1.2. 举办应用程序设计竞赛如果你不确定你想要的应用程序外观，并且正在寻找建议，一个很好的选择是举办应用程序设计竞赛。你写一篇简介，来自世界各地的设计师阅读它，并将他们对你的应用程序的想法发送给你。你可以给出反馈来完善设计，并最终选择你最喜欢的作为获胜者。 4.2.1.3. 使用应用程序生成器另一种设计方法是使用应用程序生成器。与网络建设者非常相似，与聘请一名全职设计师相比，应用程序建设者可以让你节省一点钱，但你需要更多的动手能力，你能做什么也会受到限制。请记住，如果你想要复杂的设计并有特定的需求，使用生成器可能是不够的。 4.2.1.4. 设计外包可以考虑聘请一家机构从头开始构建你的应用程序，包括设计。如果您的项目非常复杂，并且需要在不同领域拥有大量专业知识，那么这是一个不错的选择。努力接触他们中的一些人，获得报价和想法，看看他们是否适合你想要做的事情。这无疑是你最昂贵的选择，但如果你想以特定的方式完成任务，并有资源实现这一目标，这是一个非常不错的选择。 无论你选择哪一个选项，一定要给出反馈，并关注设计是否真的适合你的应用，从一开始就传达风格和外观。不要忽视你一开始设定的目标，并反思最终通过设计向用户表达了你的想法. 4.2.2. 一些设计注意事项在设计应用程序时，以下是一些需要记住的关键提示： 4.2.2.1. 使其易于导航一个令人惊叹的应用程序离不开简单的导航，所以在设计时要考虑到这一点，以确保为用户提供无缝和愉快的体验。确保导航抽屉或导航栏对用户清晰可见。如果用户不知道如何导航你的应用程序，他们将无法导航，所以请保持可见，以确保他们知道该去哪里。记住要坚持用户熟悉的布局，这样他们就能直观地知道如何在你的应用程序中导航。另一个重要提示：让它对手指友好。如果按钮和链接太小，人们无法用手指点击，他们将很难在你的应用程序中导航。 4.2.3. 简洁设计尽量减少减少界面元素使得界面拥有比较现代的外观，并充分利用空白。这让您的用户能够专注于最重要的事情。同样，使用熟悉的符号和短语可以帮助保持简单易用。简洁设计意味着设计的目的是让用户体验尽可能愉快和简单。一次在屏幕上显示的信息太多或者太多操作，你的用户很可能会不知所措，从而放弃应用程序。 4.2.3.1. 精心挑选颜色和字体色彩心理学对用户有着巨大的影响，所以不要低估它们的影响。同样，你的字体选择也会影响你的应用程序的外观。一定要考虑这些设计元素所传达的隐藏含义，并仔细挑选。要记住：你不想为了保持一致和专业的外观而混合太多不同的颜色和字体。如果你有特定颜色和字体的品牌指南，一定要在应用程序设计中坚持这些指南，这样你的应用程序就会成为你品牌的无缝延伸。 4.2.3.2. 考虑视觉层次和权重视觉权重是指不同屏幕元素与其他元素相比的大小和影响。使用视觉权重来确保设计中最重要的方面脱颖而出。清晰的视觉层次结构将帮助用户确定方向，因此请确保为页面和子页面以及标题和子标题建立的层次结构始终一致。 4.2.3.3. 保持一致以下是颜色、字体和所有其他设计元素的问题：只有你始终如一，它们才能有效并留下积极的品牌效应。这适用于其他图形、导航和您的内容。你的应用程序应该具有视觉一致性（设计元素，如颜色、按钮和标签）、功能一致性（你的应用在所有元素中的功能都应该相似）和外部一致性（任何其他渠道，如网站、姐妹应用程序，看起来都应该与你的新应用程序相似）。在整个应用程序中保持一致会让你看起来很专业，你会更好地让你的用户与你的应用程序和你的品牌建立关系。 4.3. 收集有关设计的反馈现在你有了完美的模型，是时候拜访你的朋友、家人，甚至反对者（如果你有），测试你的应用程序的设计了。一个渲染后的可点击模型会让这变得很容易，并会让你的测试人员真正感受到应用程序的样子。需要注意的是，这还不是一个已竣工的应用程序，稍后还会有更多的测试。这本质上是对布局、导航、外观和感觉的测试，而功能将在稍后提供。你有越多的人来体验你的应用程序设计，你就会得到更多的反馈，从而更好地了解哪些效果良好，哪些需要改进。在这里，建设性的批评将是你需要拥抱的，所以不要害怕用你的模型去更深入地挖掘用户反馈，并确切地了解他们的想法。这里组件是否太拥挤了？不够吸引注意？记下测试人员可能提出的任何意见。如果你有一个渲染后的可点击模型，可以从模型为基础获得更多用户关于应用用户体验方面的观点和建议.一旦你得到了你需要的所有反馈，并很好地了解了什么对你有效，什么需要改进，你就可以回去要求你的设计师做出必要的调整。 5. 开发您的应用现在是时候把你的设计交给你的开发人员或开发团队了。他们会对你的应用程序的功能部分进行编码，并确保它真正做到了它应该做的事情。他们很可能会与你和你的设计师来回调整设计，使一切顺利进行，并找出他们在开发过程中遇到的任何问题。瞧，你现在有了一个功能强大的应用程序！回顾一下你的应用程序在一切开始时所决定的目标。你是否解决了一个常见的问题，通过有趣的创作给人们带来了乐趣，或者在某种程度上简化了人们的生活？很有可能你已经做到了，而且你已经用你出色的设计做到了。 6. 测试和发布6.1. 使用早期用户测试应用现在我们有一个功能齐全的应用程序要进行测试，所以在准备发布之前，您需要确保它确实按照我们的想法在工作。在这一点上，应用程序的各个方面都需要正常运行，并具有视觉吸引力。还记得早些时候帮助你测试UI模型的那批用户吗？再给那些家伙打个电话。让他们成为你的重点关照用户，让他们完全自由地使用你的应用程序。在最终发布之前，试着获得所有你能得到的最终反馈, 并接受最严苛的建设性意见。并与设计师和开发人员合作，对即将发布的的产品进行最终调整。 6.2. 启动测试版Beta版意味着推出应用程序的测试版，并向早期采用者提供小规模的应用程序。通过这种方式，您可以查看应用程序在实时环境中的运行情况，并检查用户对它的响应。让你的用户知道你会感激他们的反馈，并根据你看到的和收到的评论来调整。一旦你得到了所需的反馈，并清楚地分析了你的应用程序在实时环境中的外观和功能，”胜利曙光”即将出现了, 你就可以向世界展示你的杰作了。 6.3. 启动您的应用安卓系统在你启动应用程序之前不需要审查。这意味着你只需将你的应用文件上传到Google Play商店（就像你的测试版一样），人们就可以立即开始下载你的应用。IOS稍有不同，他们会在你的应用程序上线之前对其进行审查。不过，别担心，如果你遵循了我们的终极指南，并正确地完成了每件事，那么你应该不会有问题获得批准。既然你的应用程序已经向大众开放了，不要止步于此。定期改进和更新您的应用程序，为您的用户提供最佳体验。也不要低估下一步营销的重要性。有效地营销您的应用程序将有助于将您的应用软件发布到用户的手机上。要了解如何营销新的移动应用程序的一些直观想法，请查看这篇文章。 6.3.1. 你准备好席卷应用世界了吗？应用程序是当今商业世界的一个重要方面，现在你已经准备好创建和设计一个真正能引起轰动的应用程序了吗?应用程序的设计过程可能看起来很复杂，但如果你遵循本指南并将其分解为可管理的小步骤，它会变得容易得多。那么，你还在等什么？戴上你的设计帽子，让你的应用程序创意成为现实。 声明本文为翻译文章, 由philoenglish.com团队翻译, 原文请参考How to design an app: the ultimate guide, 更多关于产品设计的文章请参考鹏叔的技术博客 - 产品 7. 参考文档How to design an app: the ultimate guide","link":"/product/how_to_build_an_app.html"},{"title":"如何设计 landing page?","text":"如何取得「高转换率( Conversion Rate ) 」一直是销售团队最大的课题！而 Landing Page 的操作就是其中一项有效解决行销难题的秘方！ 什么是 Landing Page？Landing Page 中文称「一页式网站」、「一页式销售网站」或「登入页面」。以追求转化为目标，规划浅显易懂、专讲重点的一个页面，让造访者跟随内容铺陈而逐渐产生「心动」的感觉，最后决定付诸行动前往更进一步的交流，最后成为实质客户！ Landing Pages 的运作方式Landing Page 一页式网站被广泛的应用在各种渠道，如：电商、Facebook、Email、PPC、Ad 等平台，目的在让目标客群能在最短时间透过该页面决定采取下一个动作(报名、预约、填写表单、下单购买、订阅) ，转化成为潜在客户( Lead ) 。 因此你可以将 Landing Page 视为一个强大的转化工具，它的价值在将陌生访客转换成「消费者」。你可以将 Landing Page 想像成一个大漏斗，它汇集了来自四面八方不同渠道涌入的流量( Traffic ) ，并通过漏斗操作( Landing Page 的内容铺成) 后，创造新的消费者！ “单一目标” 是 Landing page 的重点特色。单一目标是指在访客浏览过网页后，我们期待他们能完成最重要的一件事，譬如：预约课程、下单购买、注册会员。因此尽量避免放入太多其他目标的连结、按钮、避免浏览者的目光被其他元素吸引而分心。 以卖”线上”课程为例: 会做：从介绍师资、课程特色、网友评价、当下折扣到最后 CTA「 报名线上课程」。 不做：「 报名线上课程」同时还有「 报名实体课程」、「 其他课程介绍」。 Landing Page 的目标在于获得「高转换率」，网路化的时代，消费者越来越能接受网路购物，但不减对产品认识的渴望与市场对产品的评价。因此用一个页面清楚让消费者能轻松掌握所有的资讯，并且能轻松获得解决痛点的方法，便是 Landing Page 的重点任务！ Landing Page 和 Website 不同之处简单回想一下，记忆中的网页有分首、产品介绍、客户案例等多种分页。众多资讯依据网站架构安排在不同分页中等着让浏览者慢慢探索。而 Landing Page 则是独立出来将你想主打的产品、目的，单独做成一个页面来操作，具备浓缩精华讯息与逐步引导浏览者行为的方式呈现! Landing Page 重点在「 驱动转换」，网页( Website ) 重点在「 让人探索」。 虽然 Landing Page 少了提供 “其他分页” 让人看到其他相关内容的机会，但这种规划却成功解决人类「 选择障碍」与「 分心」的变数。访客能更专注在吸收连贯性的内容，这反而增加了达到网页目标的「 成功率」。 专注，才有可能发展，专注，才有可能创造独特价值。 —— 马云 Landing Page 必备五大元素由于一页式网页的重点明确，所具备的元素也相对单纯。抛开内容布局各行业有你自己的 Know How 外，以 Landing Page 的必备元素于下列出。 行动呼吁设计( CTA : call-to-action ) 表单( Form ) 影片( Video ) 图片( Image ) 吸引人的标题( Compelling Headline ) 行动呼吁设计( CTA : call-to-action )行动呼吁设计( CTA ) 是页面里一个大而明显的「 按钮设计」。他的目的是让浏览者经过内文引导后，能明确知道自己该做的下一个动作是什么，此按钮按( CTA ) 的点击状况，就是这一个 Landing Page 页面的 KPI。 以 Neflix 为例，大而显眼的红色按钮「 开始使用」即为网页的 CTA，在你输入完 Email 后按下该按钮，页面会接着引领你完后续设定，即便你没有完成设定流程， Neflix 也已经成功取得对订阅他们产品有兴趣的 Email 名单。 CTA 除了颜色巧思外，呼吁文字搭配内文做出创意发想，让人更有点击欲望。 表单( Form )Landing Page 的目标是「 转化」，除了呼吁受众点击按钮前往下一步骤之外，收集客户资讯的表单也是很常见的应用方法。 运用表单收集必要的客户资讯。如下图范例， On Demand 这个 Landing Page 的目标是收集客户 Email 获得产品的优惠券，一页式的设计用一个大大的键号指引读者的目光方向，接着使用 Yes / No 单选以及下拉式选单选择想要获得折扣的产品，整个流程客户仅需要手动输入 Email 这个资讯，对填答人来说是非常方便的流程，而 On Demand 光是这个动作就可以收集到 浏览页面人数与 App 使用比率 市场产品销售偏好 潜在客户名单 当然我们看到下方还有大数字 1 - 2 - 3 表示后续还有更多的客户资讯等着收集，因为当下看到的画面简单，题目也容易选择，因此客户愿意填答状况也会更好，即便没有走完全部流程，企业也已经收集到最优先的客户信息。 表单设计着重在使用者体验的优化，降低消费者跳出率( Bounce Rate )。 优质表单设计原则 仅收集必要信息 表单制作时先思考，在这个 Landing Page 的目的推动下，这个问题是不是必须要问到的，像是: 国家、电话、地址、参加的该场活动名称。现代的表单设计工具，要获得客户资料不一定完全需要客户主动填写，透过表单工具结合 CRM 工具其实有很多资讯可以透过先前的规划，就将客户的资讯自动带入表单中，客户不必亲手填写，减少客户的麻烦等同提高表单的提交率。 多元填答型态的辅助 单选题、多选题、下拉式选择、开放式问答、行事历选日期等，多型态的答题方式，可以帮助填答人在回答问题时，更方便，更省时。花点巧思换位思考，今天这份表单如何设计会让你自己回答得更轻松自在。 着墨你的 CTA 用词 相较起「 马上购买」、「 注册」、「 加入购物车」等仿佛你要付出什么东西的词组，使用「 开始我的课程」、「 免费取得」、「 参加 The 5-Day SMART 挑战」、 「 开始规划我的财务」比较正向积极、获得价值等类型的词组更能让人想要点击。 影片( Video )影片的好处就是激化浏览者的视觉感官，吸住他们的眼球！比起黑白枯燥乏味的文字，动态的影片更能将产品「 些微的差异」展现出来、更能引导目光看到你想要说的产品亮点。不同的影片渠道有不同的影片长度、广告长度限制，依据产业也会有不同的受众习性，你需要透过数据分析，找出如何在有限时间内最精准描绘产品特色。 好的影片让无聊严肃的产业”活起来”、让原本充满娱乐性的产业更具魅力！好比会计、法律业可以用影片呈现专业或平常客户看不到的细节，让消费者在观影的数秒内选择该品牌的服务。 相对的，高张力的娱乐业像是游乐园，便可放置孩童开心使用设施的片段，除了让父母了解设施的安全性外，也更期待出游的到来。 图片( Image )好的图片能帮助造访者按下 CTA 按钮！ 让我们来看看以下这组例子，可以想一想以下两个问题： 有人物和没人物的照片，你会比较倾向喜欢哪张的风格？ 如果网站是家具业，你又会做出不一样的选择吗？ 以照片来说，有了人物则多了人性的温暖，甚至有各式的情绪在里头发生。因此，有人物的照片其实相对有趣，但里头所发射出来的情感，在不同人身上的作用也很不一样。要特别注意目标群众是谁而做出相对应的选择！ 此外，业态的不同也影响照片的选择。单纯的家具照片或许就适合家具业。毕竟当我们（或多半是设计师）在设计一个空间时，需要完整的单品的形貌供消费者仔细品选。 然而照片里若有「人物」的存在，则影响了对物件的观察。 那「人物配家具」的照片适合放在什么生态的产业呢？或许你会观察到保险业、金融业等，很常以「家」的概念出发。所以，图片是很有个性的，而不同的个性则传递不同的态度和讯息！ 吸引人的标题( Compelling Headline )标题的重点就是你必须「快、很、准」的切中消费者要害！好的标题要能让人产生好奇心、愉悦感或是得到问题的解方！ 下图分别是两种型态的例子： 吸引人的说法: 以「开始设计你的餐厅 Design Your Dining Room 」来吸引消费者目光。相较于「马上购买」这种陈腔滥调，是否让你更有动力浏览网页呢？ 产品名称法: 如果产品名足够响亮，请把整页留给你的产品！别忘了可以加句小副标，更推动浏览者顺着目标往前滑进！ 参考文章：网路文案操作必学的撰写技巧 Landing Page 的优势提升转换率( Conversion Rate )一页式销售页无疑替目标消费者规划了一条明确的路径，并且一路上插好指标。这么一来，潜在消费者在内容的明示与暗示下，很容易就会跟着「规划好的节奏」买单。 延伸阅读: 转换率(Conversion Rate) 是什么？如何提升转化率？定义、公式、优化方法。看完你就变高手！ 一个概念一个目标( One Topic One Goal )一页式网页( Landing Page ) 与传统网页( Website ) 的区隔在于产品方向明确，甚至主推单一产品。这样一来，Landing Page 的页面规划对于浏览者来说讯息的接收清晰简单。 在资讯量爆炸的时代，相信你也对琳琅满目的商品感到一阵恐惧。有报告指出，多项陈列的商品是有害于心理的健康！所以，你一次只说一件事情！ 好管理( Easy To Manage)如同前所述，网页的单纯化让后台方便管理。而当我们只聚焦在某一产品时，其所相关的行销分析可以做得更精细！当档期活动要开始时这个网页才开始运作，活动结束这个页面就结束，一页式网站单独应用作为广告投放的主要媒介，行销人能方便精准的分析页面成效。 快速开发( Fast Release )因为目标明确，再加上必备的 CTA 、图片、影片或表单后，等于完成百分之八十。剩下的就是如何巧妙编排其中的内容！许多工具可以透过 Drag &amp; Drop 拖拉的方式，让行销人可以独立快速完成 Landing Page 的制作, Landing page 在收集客户资讯的同时，也在 CRM 中同步追踪，后续再搭配再行销策略( Re - target ) ，销售就无往不利。 制作 Landing Page现在免费的资源很多，都有套版的方式让你轻松做成一个 Landing page，譬如：Hubspot、wix、wordpress 等。 以上都是多功能整合式的平台，除了协助”前端”的建构，例如网页、Landing Page 页面套版设计，也提供后端资料库的数据分析。 套版网站的优点在于，有多个模组让你选择，一旦选好之后便将所需的资料放入网页，再依自己的需求稍微调整即可，一样打造出美丽又专业的 Landing Page！ 也可以到 envato elements, 上去寻找灵感. 参考文档Landing Page 是什麼？網頁高轉化率技巧分享 !","link":"/product/landing_page_design.html"},{"title":"应用推广的十个观点(译文)","text":"1. 译者序这是一篇非常好的推广移动应用的想法或者说是策略, 翻译过来分享给大家. 或许有些观点已经很显而易见, 那么就权当是一个总结. 后续会基于此文章陆续更新关于应用推广方面的想法和观点. 译者：philoenglish.com团队; 更多资讯可访问philoenglish.com 2. 前言移动应用市场已经成为我们生活的重要组成部分，现在许多主要业务背后的驱动力来自移动应用技术。面对竞争的海洋，你必须找到创造性的移动应用推广方式，让你的应用脱颖而出。当然，你可能没有一个无限量的银行账户可以使用。对于年轻的初创公司来说，要想在应用领域领先于成熟的公司是一项挑战。但是，你仍然可以通过新的移动应用程序取得成功。 3. 开始手机应用推广3.1. 写出清晰而富有创意的描述许多消费者首先会看到你的应用程序的标题和描述。让它朗朗上口，内容丰富。你能向潜在用户发送的描述你的应用程序的最清晰的信息是什么？看看这些头部App的例子。它们是准确的，并包含强调应用程序能够提供高质量服务的关键词。 Uber：“使用优步应用程序在几分钟内获得可靠的乘车服务，无需预订或排队等候” Yelp：“无论你是在寻找刚开业的披萨店还是附近的咖啡店，Yelp都是你当地的指南，可以帮助你找到吃饭、购物、喝酒、放松和玩耍的完美地方。” Instagram：“Instagram是一种捕捉和分享世界瞬间的简单方式。关注你的朋友和家人，看看他们在做什么，并发现来自世界各地的用户，分享你喜欢的东西” DoorDash：“从附近优选的餐厅送货上门” 无论你想用描述你的标题和描述，可以参考这些成功的应用程序。确保你清楚地展示了你的应用程序的目标，并与你的目标受众保持相关性。 3.2. 启动Beta测试版我们都喜欢在买衣服之前先试穿一下，对吧？创建测试版可以让你的追随者在你的新应用程序完全可用之前对其进行试用。在你发布之前，让你的Instagram和Facebook页面吸引你想要的受众，这样你的测试版就适合合适的人。Beta版允许实际用户使用您的应用程序，这将大大增加您的曝光率。谷歌此前发布了Chrome浏览器的测试版，让他们了解对其更新的普遍看法，并为他们提供了宝贵的反馈。创建您自己的测试版将允许您做同样的事情。 3.3. 接受评测人们一直在寻找新的想法和技巧。在流行的博客或应用程序评论网站上获取您的应用程序，如148app和AppAdvice。在这些网站上使用你的应用程序将增加你的曝光率，并为你提供宝贵的反馈，让你知道人们喜欢（或不喜欢）你的应用。别忘了：很多人都愿意通过评论来回应你的应用。 3.4. 参加应用程序赛事有些组织会奖励应用程序的独创性、功能性和设计。做一些研究，你就可以申请参加适合你的应用程序的比赛。史蒂维奖(The Stevie Awards)或韦伯奖(The Webby Awards)就是几个很好的例子。相信我们：如果你的应用程序背后有一连串的奖项，它会引起更多的关注！许多手机应用程序都因获得此类奖项而迅速发展起来。Dashlane是一款相对较新的应用程序，最近获得了韦伯奖“最佳服务和实用程序应用程序”。2017年获得韦伯奖提名的应用程序包括Airbnb、Spotify、HBO Now和Pokemon Go。如果你有一个很棒的想法，请输入并查看有多少其他人也认为它很棒！ 3.5. 创造赠品机会谁不喜欢免费的东西呢？人们喜欢赠品，喜欢为自己喜欢的东西加分。积分制是一种很好的移动应用推广方法，因为你的应用在不断增长的过程中会产生并保持兴趣。以Expedia为例。他们根据客户的购买情况为他们提供积分，然后可以用于未来的购买。这是让你的消费者保持消费的好方法！其他很棒的在线网站，如Rafflacopter、Gleam和Promossimple，为您的追随者提供了轻松的赠品机会。智能创建的赠品将为您的用户提供巨大的激励，激发他们的兴趣，并让他们不断回来获取更多。 3.6. 关注你的统计数据这一点似乎很明显，但是我们很容易忽略有关应用程序的某些统计数据。应用被下载了多少次，而又拥有多少活跃用户？你的应用程序最受欢迎的功能是什么？这些问题有助于你了解你在哪里取得了成功，以及还有什么需要改进。AppAnnie和Adjust等程序允许您跟踪特定的统计数据，如哪些广告将用户带到了你的应用程序，或者哪些用户花费最多以及为什么。跟踪这些统计数据可能是平庸和成功的分水岭。 3.7. 成为领英达人领英可能是年轻企业可用的最好的社交工具，它是发布新内容的好平台。许多顶级公司定期分享有趣的内容，并创造机会与志同道合的企业和追随者进行讨论。出色的移动应用推广始于与您所在领域相关的积极讨论。在有趣的故事和功能上留下评论和标签，在相关的时候分享你自己的内容。但要足智多谋，记住不要用应用程序的营销淹没服务。 3.8. 创建应用名片你可能已经注意到咖啡店和酒吧里的小名片上有“本周之歌”或“本月下载”。这些都是应用程序名片，是你向大众展示新应用程序的好方法。与当地企业协商，这样你就可以把你的应用名片留在他们的机构里。这种简单的移动应用程序推广使您能够很容易地接触到更广泛的受众。您还可以包括在特定机构领取的卡的免费试用或奖金。在过去的几年里，星巴克与苹果合作，在他们的咖啡店提供免费下载的应用卡。谁不喜欢早上喝一杯咖啡？把你的卡带到当地的企业，看着下载量增加。 3.9. 成为社交媒体达人不要低估社交媒体的力量！以下是一些非常棒的方法，你可以使用社交媒体来超越竞争对手： 脸书和Instagram广告：那些经常出现在我们脸书和脸书订阅源上的广告？这些都是故意放置的广告活动。当人们沉迷于社交媒体时，你可以用这些来吸引他们的眼球。 脸书直播：脸书最新、最吸引人的功能之一即将上线。与你的追随者一起生活会让你与他们在一起，并亲自回答他们的任何问题。 Pinterest：分享有趣的内容，确保内容上包含了你的logo, 关键词和图像。 活跃在社交媒体上的公司就像人群中的人，声音洪亮！遵循以上步骤将帮助您在参与度较低的竞争对手中脱颖而出。 3.10. 认真对待差评这可以说是推广移动应用程序的最重要提示，也是最简单的提示之一。许多企业未能对负面批评做出适当回应。我们中没有人喜欢收到关于自己或业务的负面评论，但同情并与批评者联系会让你更好地理解自己的错误。我们已经提到了诸如148Apps和AppAdvice之类的评测服务。关注你不太满意的评论，并尝试对每一条批评做出回应，以确保怀疑者相信你会纠正任何问题。你将创造一种优雅的体验，并与用户建立更牢固的关系，同时始终为你提供如何做得更好的指导。 4. 稍微与众不同你无法从拥挤的移动应用程序世界中消除竞争，但将自己与竞争区分开来可以迎来成功。记住，客户就是一切。通过以上技巧吸引大批追随者将是您新手机应用程序发展的关键。充满激情，富有创造力，开始你的旅程，开始推广世界上有史以来最棒的新移动应用程序吧! 5. 参考文档Mobile app promotion: 10 ingeniously creative ideas","link":"/product/mobile_app_promotion.html"},{"title":"在身份验证鉴权与业务分离的系统中, 如何实现根据用户属性查询业务信息?","text":"在身份验证与业务逻辑分离的系统中，如果需求要求根据用户的属性，例如名称、用户组、年龄、角色等非唯一标识符进行业务信息查询，常见的解决方案是将这些属性信息与唯一标识符（如 user_id）进行关联，通过索引或联合查询来实现。以下是几种具体实现方案： 1. 用户属性信息的集中存储和索引用户属性存储： 将用户的名称、用户组、年龄、角色等属性信息存储在身份管理系统或专门的用户信息数据库中。 该数据库可以与身份验证服务（如 OAuth、SSO 等）协同工作，提供用户属性的查询接口。 基于属性的查询方式： 在收到查询请求时，业务系统首先查询用户信息数据库，通过指定的查询条件（如名称、用户组、年龄或角色）获取相应的 user_id。然后，业务系统使用 user_id 在业务数据库中查询与该用户关联的业务数据。 实现方式： 为用户属性（如名称、用户组、角色等）建立索引，以便快速查找满足条件的用户。例如： 12SELECT user_id FROM users WHERE name = 'John Doe' AND group = 'Admin' AND age &gt; 30; 查询得到的 user_id 可以用于进一步关联业务数据，如订单、账户信息等。 2. 基于检索服务的实现（如 Elasticsearch）用户属性索引： 对用户信息数据库使用分布式搜索引擎（如 Elasticsearch、Solr 等），对用户的各类属性进行全文索引。这使得系统能够支持复杂查询，如按用户名称、用户组、年龄或角色等多个字段进行条件组合检索。 查询流程： 系统接收到用户的查询条件时，首先通过 Elasticsearch 对用户的属性进行检索，返回符合条件的用户集合（通常是 user_id 列表）。然后根据这些 user_id 在业务系统中查询对应的业务数据。 优势： 支持复杂查询，且搜索性能高效。可以实现例如模糊搜索、范围查询（如年龄在 20-30 之间）、多字段组合查询等。 3. 属性与业务数据联合查询联合查询模式： 如果系统不想通过多个步骤查询，也可以考虑在业务数据库中存储部分用户属性，如名称、用户组或角色，直接与业务数据建立关联。 在业务数据库中为这些属性建立索引，这样可以直接通过这些属性在业务数据库中进行联合查询。例如： 12345SELECT *FROM orders oJOIN users u ON o.user_id = u.user_idWHERE u.name = 'John Doe' AND u.group = 'Admin' AND u.age &gt; 30; 这种模式减少了查询用户数据库的步骤，但需要确保用户属性在业务数据库中及时同步更新。 4. 使用 GraphQL 等 API 网关技术动态查询： 使用 GraphQL 等查询语言，前端可以通过一个 API 端点发起针对用户属性的查询。GraphQL 能够灵活地组合查询条件，并通过身份验证服务返回符合条件的用户及其关联数据。 在这种架构下，GraphQL 可以整合不同数据源，前端可以动态构建查询条件，无需分别调用不同的接口。 5. 基于用户组和角色的访问控制（RBAC/ABAC）基于角色的访问控制： 系统可以实现基于角色的访问控制（RBAC），通过角色信息来过滤和查询业务数据。 业务数据和角色之间的关系可以在业务数据库中建立。 例如，用户的角色和用户组可以映射到特定的业务数据范围，系统根据角色查询与之相关的业务信息。 基于属性的访问控制（ABAC）： 在 ABAC 中，可以根据用户的属性（如年龄、组别等）动态决定其访问权限。在业务查询时，系统会根据用户属性来筛选其可以访问的数据。 例如： 用户组为”管理员”的用户可以访问所有订单； 年龄大于 18 岁的用户可以访问特定的内容或数据集。 缓存和分布式查询缓存查询结果： 对于频繁查询的用户属性，可以将用户与其业务数据的关联结果缓存到高速缓存（如 Redis、Memcached 等）中。这使得查询用户属性后可以快速获取相关业务数据，而无需每次都查询数据库。 分布式查询： 在微服务架构下，可以通过分布式查询系统（如 Apache Kafka、Apache Druid 等），让不同微服务处理不同部分的数据查询，最后将结果合并。例如，用户信息服务负责根据用户属性返回用户 ID，业务服务负责查询用户 ID 对应的业务数据。 扩展查询接口（API 层实现）在 API 层上扩展查询接口，使得客户端可以通过名称、用户组、年龄、角色等非唯一标识符发起查询请求。API 层负责将这些查询条件映射为后台数据库的查询操作。例如： 123456{ &quot;name&quot;: &quot;John Doe&quot;, &quot;group&quot;: &quot;Admin&quot;, &quot;age&quot;: { &quot;gt&quot;: 30 }, &quot;role&quot;: &quot;Manager&quot;} API 接收到请求后，会查询用户服务，获得符合条件的用户 ID，然后再去业务服务查询业务信息。 6. 总结根据用户的名称、用户组、年龄、角色等属性查询业务信息的实现方式，核心在于如何高效地将这些属性与用户的唯一标识符（如 user_id）进行关联，并通过 user_id 进行后续的业务数据查询。通过索引、联合查询、缓存和分布式系统等方式，可以满足复杂查询的需求，并确保系统在大规模用户数据下仍然高效运行。","link":"/product/query_on_auth_and_business_decoupled_systems.html"},{"title":"如何在Ubuntu 22.04上安装Sentry","text":"Sentry 是一个免费和开源的错误跟踪平台，可以实时监控和修复崩溃。它使软件开发人员能够看到重要的东西，更快地解决问题，并不断了解他们的应用程序。这个平台提供了对生产部署的实时洞察力，并提供了重现和修复崩溃的信息。Sentry 支持所有主要的语言和框架，并与你喜欢的应用程序和服务集成。 1. 前提条件 一台运行 Ubuntu 22.04 的服务器。 一个有效的域名被指向你的服务器 IP。 在你的服务器上配置了一个根密码。 2. 硬件配置要求安装 self-hosted sentry 需要的硬件配置取决于您的应用程序的大小和复杂性。以下是一些一般建议： CPU： 至少 2 核。如果您的应用程序非常复杂，则需要更多核。内存： 至少 4GB。如果您的应用程序生成大量日志，则需要更多内存。存储： 至少 20GB。如果您的应用程序生成大量日志，则需要更多存储空间。网络： 至少 100Mbps。如果您的应用程序生成大量日志，则需要更高的网络带宽。 以下是一些具体的配置建议： 对于小型应用程序（&lt;100 个用户）， 您可以使用以下配置： CPU：2 核 内存：4GB 存储：20GB 网络：100Mbps 对于中型应用程序（100-1,000 个用户）， 您可以使用以下配置： CPU：4 核 内存：8GB 存储：60GB 网络：500Mbps 对于大型应用程序（&gt;1,000 个用户）， 您可以使用以下配置： CPU：8 核 内存：16GB 存储：120GB 网络：1Gbps 可以根据需要调整这些建议。例如，如果希望 sentry 能够处理更高的并发连接，则需要更多的 CPU 和内存。如果希望 sentry 能够存储更长时间的日志，则需要更多的存储空间。 您可以使用 Sentry 提供的 性能指南 来帮助您确定适合您应用程序的硬件配置。 3. 环境本教程实验环境 Ubuntu 22.04.1Docker 24.0.5Docker-Compose 2.22.0Sentry 23.11.0 3.1. 安装所需的依赖项在开始之前，建议将你的软件包更新到最新版本。你可以用以下命令来更新它们： 配置国内的镜像源, 并更新. 123sudo apt update -y# apt upgrade会更新内核, 请谨慎使用#sudo apt upgrade -y 如果您以前安装过 containerd 或 runc，请卸载它们以避免与 Docker Engine 捆绑的版本发生冲突。 运行以下命令卸载所有冲突的程序包： 123for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done 一旦你的系统被更新，用下面的命令安装所有需要的软件包： 1sudo apt-get install curl git build-essential apt-transport-https ca-certificates software-properties-common gnupg -y 3.2. 安装 Docker 和 Docker Compose默认情况下，最新版本的 Docker 和 Docker Compose 包在 Ubuntu 22.04 的默认软件库中是不可用的。所以你需要在 APT 中添加 Docker 官方仓库。 首先，用以下命令下载并添加 Docker GPG 密钥: 123456sudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg 接下来，用下面的命令添加 Docker 存储库: 123456echo \\ &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 一旦版本库被添加，用以下命令更新版本库缓存。 1sudo apt-get update -y 接下来，用下面的命令安装 Docker 和 Docker Compose。 12345678# 安装最新版本sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 或者, 像这样安装指定版本# List the available versions:apt-cache madison docker-ce | awk '{ print $3 }'VERSION_STRING=5:24.0.0-1~ubuntu.22.04~jammysudo apt-get install docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io docker-buildx-plugin docker-compose-plugin 配置镜像加速 1234567sudo echo -e \\&quot;{ \\n&quot; \\&quot; \\&quot;registry-mirrors\\&quot;: [\\&quot;https://&lt;你的ID&gt;.mirror.aliyuncs.com\\&quot;], \\n&quot; \\&quot; \\&quot;live-restore\\&quot;: true,\\n&quot; \\&quot; \\&quot;debug\\&quot;: true\\n&quot; \\&quot;}&quot; | sudo tee /etc/docker/daemon.json &gt; /dev/null 安装 docker-compose 12345sudo curl -L https://github.com/docker/compose/releases/download/v2.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/bin/docker-compose# 授予docker-compose可执行权限sudo chmod +x /usr/bin/docker-compose 如果下载速度太慢, 可以通过一台可以快速访问 github 的电脑手动下载 docker-compose, 然后上传至服务器. 查看 docker 和 docker-compose 版本信息 1234$ docker -vDocker version 24.0.7, build afdd53b 123$ docker-compose -vDocker Compose version v2.22.0 查看镜像配置是否成功 1sudo docker info 如果镜像仓库显示有如下内容，则配置成功。 1234Registry Mirrors: https://your_id.mirror.aliyuncs.com/ #如果这里显示这里刚才的配置的地址,则配置成功Live Restore Enabled: false 安装好这两个软件包后，用以下命令启动 Docker 服务并使其在系统重启时启动： 12sudo systemctl start dockersudo systemctl enable docker 现在你可以用下面的命令来验证 Docker 的状态： 1sudo systemctl status docker 你应该得到以下输出： 12345678910111213141516171819202122? docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2023-01-10 04:37:27 UTC; 5s agoTriggeredBy: ? docker.socket Docs: https://docs.docker.com Main PID: 45847 (dockerd) Tasks: 8 Memory: 29.1M CPU: 220ms CGroup: /system.slice/docker.service ??45847 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockJan 10 04:37:26 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:26.903435377Z&quot; level=info msg=&quot;scheme \\&quot;unix\\&quot; not registered, fallback to defau&gt;Jan 10 04:37:26 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:26.903453803Z&quot; level=info msg=&quot;ccResolverWrapper: sending update to cc: {[{unix:&gt;Jan 10 04:37:26 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:26.903464761Z&quot; level=info msg=&quot;ClientConn switching balancer to \\&quot;pick_first\\&quot;&quot; &gt;Jan 10 04:37:26 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:26.916581613Z&quot; level=info msg=&quot;Loading containers: start.&quot;Jan 10 04:37:26 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:26.997807510Z&quot; level=info msg=&quot;Default bridge (docker0) is assigned with an IP a&gt;Jan 10 04:37:27 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:27.060381720Z&quot; level=info msg=&quot;Loading containers: done.&quot;Jan 10 04:37:27 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:27.074467014Z&quot; level=info msg=&quot;Docker daemon&quot; commit=20.10.12-0ubuntu4 graphdriv&gt;Jan 10 04:37:27 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:27.074649813Z&quot; level=info msg=&quot;Daemon has completed initialization&quot;Jan 10 04:37:27 vultr systemd[1]: Started Docker Application Container Engine.Jan 10 04:37:27 vultr dockerd[45847]: time=&quot;2023-01-10T04:37:27.092699576Z&quot; level=info msg=&quot;API listen on /run/docker.sock&quot; 3.3. 安装 Sentry首先，使用以下命令从 Git 仓库下载最新版本的 Sentry： 1git clone https://github.com/getsentry/self-hosted.git 下载完成后，将目录改为下载的目录，并运行 Sentry 安装脚本，开始安装。 vi ~/self-hosted/.env 将 event 保留时间修改成 90 天, 默认是 30 天 12COMPOSE_PROJECT_NAME=sentry-self-hostedSENTRY_EVENT_RETENTION_DAYS=30 123456789101112cd self-hosted# 切换到release版本git checkout 23.10.1# 安装sentry# 这里为了避免中间弹出prompt提示创建超级用户,# 使用skip-user-creation选项跳过了了超级用户创建# 后续会有单独的步骤创建超级用户sudo ./install.sh --no-report-self-hosted-issues --skip-user-creation# 创建超级用户# 将email替换成你的管理员email, password做相应替换docker-compose --ansi never run --rm web createuser --force-update --superuser --email user@example.com --password secret 自托管监控 当运行./install.sh 时，您可以选择加入或退出 sentry 官方的监控。此监控用于开发和调试目的，以便我们能够掌握您面临的问题，从而使我们能够提供更加无缝的安装过程。 请注意，从 22.11.0 版本开始，选择是否发送错误将成为强制要求。 在安装过程中，你会被要求创建一个管理员账户，如下图所示： 123456789101112131415161718192021222324252627Here's the info we may collect: - OS username - IP address - install log - runtime errors - performance dataThirty (30) day retention. No marketing. Privacy policy at sentry.io/privacy.Would you like to create a user account now? [Y/n]: yEmail: Email: your_email@xxx.comPassword:Repeat for confirmation:Added to organization: sentryUser created: your_email@xxx.comCreating missing DSNsCorrecting Group.num_comments counter-----------------------------------------------------------------You're all done! Run the following command to get Sentry running: docker-compose up -d----------------------------------------------------------------- 接下来，使用以下命令验证所有下载的镜像。 1docker images 你应该看到以下输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243REPOSITORY TAG IMAGE ID CREATED SIZEvroom-cleanup-self-hosted-local latest ea9a97a173e4 8 hours ago 119MBsymbolicator-cleanup-self-hosted-local latest ddf3f91711b9 8 hours ago 139MBsentry-cleanup-self-hosted-local latest 3f649c2adb51 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; e6275ee189a4 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; ffb03d72b02c 8 hours ago 1.04GBsentry-self-hosted-local latest 7e021f899f9d 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 7e93f5ff254c 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; cfb9b6b7e493 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; b25501401a89 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 83f5784ea774 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; a25a2fe8d5dd 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 247203428a29 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; b317e37159df 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; acb9c8ac94a4 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 8798646a9a6e 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; eeb84b793191 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 33786daa04f9 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; e9207519f5ea 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 5a6bc83fb1d5 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 284a0389a802 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 01822573c6da 8 hours ago 1.04GB&lt;none&gt; &lt;none&gt; 863ad8d9962c 8 hours ago 1.04GBsentry-self-hosted-jq-local latest 802ce2121fdc 9 hours ago 76.8MBgetsentry/sentry nightly fab0bb9cf072 17 hours ago 1.04GBgetsentry/relay nightly da690b7dffe9 2 days ago 277MBgetsentry/snuba nightly 58aa2f0ddbd0 2 days ago 1.08GBgetsentry/vroom nightly 4248c1746c67 2 days ago 118MBdebian bookworm-slim 8edcf5b83723 11 days ago 74.8MBgetsentry/symbolicator nightly 29b78918bd5a 2 weeks ago 137MBnginx 1.25.2-alpine 661daf9bcac8 3 weeks ago 42.6MBgetsentry/sentry-cli latest 329fdf92d508 2 months ago 27.3MBbusybox latest a416a98b71e2 3 months ago 4.26MBghcr.io/maxmind/geoipupdate v6.0.0 3fdbd1ffd226 4 months ago 15.5MBredis 6.2.13-alpine 529fcf955ad4 4 months ago 28MBmemcached 1.6.21-alpine 2db2248e0a53 4 months ago 10.3MBpostgres 14.5 cefd1c9e490c 12 months ago 376MBtianon/exim4 latest a56a3348ddb1 21 months ago 158MBclickhouse-self-hosted-local latest 79441da6ab2b 22 months ago 706MBconfluentinc/cp-kafka 5.5.7 b362671f2bc0 22 months ago 737MBconfluentinc/cp-zookeeper 5.5.7 22b646e1afd0 22 months ago 737MBcurlimages/curl 7.77.0 e062233fb4a9 2 years ago 8.26MB 3.4. 启动 Sentry 容器在这一点上，Sentry 已经安装完毕。现在你可以使用以下命令启动 Sentry 容器： 1234# 启动服务sudo docker-compose up -d# 如果需要停止服务, 使用如下命令sudo docker-compose down 这将启动 Sentry 的所有容器，如下所示： 1234567891011121314151617181920212223Starting sentry_onpremise_memcached_1 ... doneStarting sentry_onpremise_redis_1 ... doneStarting sentry_onpremise_symbolicator_1 ... doneCreating sentry_onpremise_symbolicator-cleanup_1 ... doneStarting sentry_onpremise_zookeeper_1 ... doneStarting sentry_onpremise_clickhouse_1 ... doneStarting sentry_onpremise_smtp_1 ... doneStarting sentry_onpremise_postgres_1 ... doneStarting sentry_onpremise_kafka_1 ... doneStarting sentry_onpremise_snuba-consumer_1 ... doneStarting sentry_onpremise_snuba-outcomes-consumer_1 ... doneStarting sentry_onpremise_snuba-api_1 ... doneStarting sentry_onpremise_snuba-sessions-consumer_1 ... doneStarting sentry_onpremise_snuba-replacer_1 ... doneCreating sentry_onpremise_snuba-cleanup_1 ... doneCreating sentry_onpremise_relay_1 ... doneCreating sentry_onpremise_web_1 ... doneCreating sentry_onpremise_post-process-forwarder_1 ... doneCreating sentry_onpremise_cron_1 ... doneCreating sentry_onpremise_sentry-cleanup_1 ... doneCreating sentry_onpremise_worker_1 ... doneCreating sentry_onpremise_ingest-consumer_1 ... doneCreating sentry_onpremise_nginx_1 ... done 你可以使用下面的命令验证所有容器的状态。 1sudo docker-compose ps 访问 Sentry Web UI 此时，Sentry 已经启动，并在 9000 端口上监听。现在，打开你的网页浏览器，输入网址http://your-server-ip:9000，访问 Sentry 仪表板。你将会被转到 Sentry 的登录页面. 4. 准备一个 nginx，并配置 https，将其转发到 sentry 主机的 9000 端口即可安装 nginx 可以参考我的文章nginx 安装教程 5. 配置 DNS添加一条新的 DNS A 记录例如 sentry_host.your_domain.com 指向公网 ip 6. 配置 nginx修改 123456789101112131415161718192021222324server { listen 80; server_name sentry_host.your_domain.com; rewrite ^(.*)$ https://$host$1 permanent;}server { listen 443; server_name sentry_host.your_domain.com; ssl on; ssl_certificate /etc/nginx/ssl/sentry_host.your_domain.com.pem; ssl_certificate_key /etc/nginx/ssl/sentry_host.your_domain.com.key; location /admin { return 404; } location / { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://sentry_host_ip:9000/; }} 7. 如何打扫数据vi ~/self-hosted/docker-compose.yml 1234567891011environment: PYTHONUSERBASE: &quot;/data/custom-packages&quot; SENTRY_CONF: &quot;/etc/sentry&quot; ..... SENTRY_EVENT_RETENTION_DAYS: 7 SENTRY_MAIL_HOST: SENTRY_MAX_EXTERNAL_SOURCEMAP_SIZE: # Set this value if you plan on using the Suggested Fix Feature OPENAI_API_KEY: 重启Sentry 1sudo docker-compose down &amp; sudo docker-compose up -d 参考: How Sentry is cleaned up correctly 8. troubleshooting1234RUN echo 'deb http://mirrors.aliyun.com/debian-archive/debian stretch main contrib non-free\\n\\deb http://mirrors.aliyun.com/debian-archive/debian stretch-proposed-updates main contrib non-free\\n\\deb http://mirrors.aliyun.com/debian-archive/debian-security/ stretch/updates main contrib non-free\\n'\\&gt; /etc/apt/sources.list","link":"/product/sentry_install.html"},{"title":"在各种操作系统上安装和配置Rust","text":"1. 安装 rust Rust 官网: https://www.rust-lang.org 2. 在 Linux or macOS 上安装 Rust 在 Linux or Mac 上安装 Rust: 1curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf| sh 3. 在 Windows 上安装 Rust windows: 按官网安装指引操作 下载安装程序，下载 RUSTUP-INIT.exe 32 位安装程序 或 下载 RUSTUP-INIT.exe 64 位安装程序 然后运行程序并按照屏幕上的说明进行操作。 当提示您安装Visual Studio C++ build tools时，您可能需要安装这些工具。 完成安装后需要将 &lt;home_dir&gt;/.cargo/bin/ 添加到 Path 环境变量, 这样在任何位置都可以执行 rustc, cargo 和 rustup 命令了 windows subsystem for Linux(WSL): 1curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 4. 配置 Rust4.1. 配置PATh在Rust开发环境中，所有工具都安装到~/.cargo/bin目录中，在这里您可以找到Rust工具链，包括rustc、cargo和rustup。 为了在任何目录下都能使用这些工具，需要将~/.cargo/bin添加到环境变量PATH中。 4.2. 替换镜像(linux, Windows, macOS 通用)安装完成后需要将 crates.io 替换成国内镜像. https://crates.io 的访问非常缓慢，github 的仓库也经常不能访问，建议大家切换到国内镜像站。镜像站实时缓存，托管在码云的 gitee 仓库每隔 30 分钟与 github 同步。 配置方式 在 &lt;home_dir&gt;/.cargo 目录新建文件 config 注意：新安装的机器没有这个文件，需要新建，并且该文件没有后缀名 编辑文件内容： 123456789101112131415161718192021222324252627282930[source.crates-io]registry=&quot;https://github.com/rust-lang/crates.io-index&quot; # 这行可以不要,只是说明原始地址# 替换成你偏好的镜像源replace-with = 'tuna'#replace-with = 'ustc'[source.crates-cn]registry=&quot;https://gitee.com/crates/crates.io-index.git&quot;# 清华大学[source.tuna]registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;# 中国科学技术大学[source.ustc]registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 上海交通大学[source.sjtu]registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;# rustcc社区[source.rustcc]registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;[net]git-fetch-with-cli =true 修改完保存后即可编译 Rust 项目 1cargo build 5. 更新 Rust1rustup update 6. 卸载 Rust1rustup self uninstall 7. 安装指定版本的Rust（例如 1.56）1rustup install 1.56 8. 验证安装是否成功1rustc --version 结果格式: rustc x.y. z (abcabcabc yyyy-mm-dd) 会显示最新稳定版的: 版本号, commit hash, commit 日期 当前我安装的版本为 rustc 1.56.1 (59eed8a2a 2021-11-01) 9. 延申阅读Rust 编程语言入门教程 10. 参考文章Notes about Rust installation","link":"/rust/install_rust_on_windows.html"},{"title":"在VSCode配置Rust环境","text":"1. 安装Rust安装Rust可以参考Windows上安装Rust 2. 安装VSCode和扩展安装VSCode可参考vscode基本配置指南 2.1. 安装Rust analyzer安装此插件需要安装vscode 1.67及以上版本的vscode. 在VSCode的扩展，搜索 Rust 。找到Rust analyzer点击install。 2.2. 通过VSCode Debug项目安装CodeLLDB插件","link":"/rust/vscode_rust_ide.html"},{"title":"Angular整合strapi CMS","text":"1. 前言对于我们这些开发人员来说，启动一个新的web项目可能是一项乏味的工作。一些普通的增删改查都要自己亲自动手去写，那效率着实是大打折扣的。 一些技术选型工作要一次一次地被重复考虑. 前端应该使用什么技术？ 我应该在后端使用什么技术？ 什么数据库是最好的？ 因为现在所有的Javascript技术，如React、Angular和Vue，在构建Web应用程序时都非常流行，所以我们可以很快得到第一个问题的答案。但是后端呢？我应该使用NodeJS还是.NET Core？使用关系数据库还是非关系数据库更好？后端解决方案Strapi已经找到了所有这些问题的答案。 在本文中，我们将使用Strapi和Angular构建一个简单的web应用程序。 2. 什么是Strapi?Strapi是一个开源的headless接口优先（API-first）的内容管理系统，让开发人员可以自由选择他们喜欢的工具和前端框架。凭借丰富的插件和built-in功能，Strapi为开发人员提供了自定义和可扩展性的能力。Strapi还提供了一个API，可以通过REST或GraphQL轻松访问，这对开发人员非常友好。 3. 安装Strapi请参考我的博客文章安装strapi和使用 安装完strapi后需要创建一些Content-type用于测试 4. 创建Angular应用关于如何创建Angular应用的详细解释可以参考我的博客创建Angular项目. 这里只列出简单步骤: 使用以下命令安装 Angular CLI： 123npm install -g @angular/cli 创建并运行新的 Angular 应用程序： 12345ng new blog-web cd blog-web ng serve 如果您导航到http://localhost:4200/您将能够看到新的应用程序。 5. 创建用于访问strapi数据的服务现在，我们可以开始设计应用程序并从API访问数据。首先，我们将创建服务和API调用以从 Strapi 获取数据。进入src文件夹并运行以下命令： 12345mkdir servicescd servicesng g s post Angular CLI 将创建post服务，以便我们准备好编码。environment.ts我们将在其中输入我们的 API URL。 1234567export const environment = { production: false, apiUrl: &quot;http://localhost:1337&quot;}; 导航到post服务并插入以下代码： post.service.ts 12345678910111213141516171819202122import { HttpClient } from '@angular/common/http';import { Injectable } from '@angular/core';import { environment } from 'src/environments/environment';import { map } from 'rxjs/operators';@Injectable({ providedIn: 'root'})export class PostService { constructor(private http: HttpClient) { } getAllPosts() { return this.http.get(`${environment.strapiUrl}/posts`).pipe(map(res =&gt; res)); } getPost(postId: any) { return this.http.get(`${environment.strapiUrl}/posts/${postId}`).pipe(map(res =&gt; res)); }} 我们创建了两种方法：一种用于获取所有页面，一种用于通过 id 获取页面。 注意：使用前HttpClient我们需要注册app-module.ts 转到 app-module.ts导入HttpClientModule自@angular/common/http, 123import { HttpClientModule } from '@angular/common/http'; 将其添加到@NgModule.imports数组中： 1imports:[HttpClientModule, ...] 接下来，我们将创建post-component包含帖子样式和功能的内容 1ng g c post 将以下代码插入到 post 组件中： 1234567891011121314&lt;div *ngIf=&quot;posts&quot; class=&quot;row&quot;&gt; &lt;div *ngFor=&quot;let post of posts&quot; class=&quot;col-lg-4 col-md-4 col-sm-6&quot;&gt; &lt;div class=&quot;post-item&quot;&gt; &lt;a class=&quot;post-link&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;http://localhost:1337{{post.content.CoverImage[0].url}}&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;div class=&quot;post-caption&quot;&gt; &lt;div class=&quot;post-caption-heading&quot;&gt;{{post.content.Title}}&lt;/div&gt; &lt;div class=&quot;post-caption-subheading text-muted&quot;&gt;{{post.content.Value}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; post.component.css 1234567891011121314151617181920212223#post .post-item { max-width: 25rem;}#post .post-item .post-caption { padding: 1.5rem; text-align: center; background-color: #f6f6f6;}#post .post-item .post-caption .post-caption-heading { font-size: 1.5rem; font-family: &quot;Montserrat&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-weight: 700; margin-bottom: 0;}#post .post-item .post-caption .post-caption-subheading { font-style: italic; font-family: &quot;Droid Serif&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;;} post.component.ts 123456789101112131415161718192021import { Component, OnInit } from '@angular/core';import { PostService } from 'services/post.service';@Component({ selector: 'app-post', templateUrl: './post.component.html', styleUrls: ['./post.component.scss']})export class PostComponent implements OnInit { posts: any = []; constructor(private postSvc: PostService) { } ngOnInit() { this.postSvc.getAllPosts().subscribe(res =&gt; { console.log(&quot;posts&quot;, res); this.posts = res; }); }} 因为我们正在使用引导程序类，所以我们也需要将引导程序包含到我们的项目中。我们可以通过添加以下内容来做到这一点index.html： 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootswatch/4.3.1/cosmo/bootstrap.min.css&quot;&gt; 现在, 我们成功构建了一个简单的博客应用程序以Strapi为内容管理系统, 动态的显示博客了。 6. 参考文档How to fast build Web Application with Strapi + Angular","link":"/strapi/angular_strapi_app.html"},{"title":"Rust 编程语言入门教程","text":"1. 第一章: Rust 简介1.1. 为什么要用 RustRust 是一种令人兴奋的新编程语言, 它可以让每一个人编写可靠且高效的软件.它可以用来替换 C/C++, Rust 和他们具有同样的性能, 但是很多常见的 bug 在编译时就可以被消灭.Rust 是一种通用的编程语言, 但是它更善于以下场景:需要运行时的速度需要内存安全更好的利用多处理器 1.2. 与其他语言比较C/C++ 性能非常好, 但类型系统和内存都不太安全.JAVA/C#, 拥有 GC, 能保证内存安全, 也有很多优秀特性, 但是性能不行RUST:安全无需 GC易于维护, 调试, 代码安全高效 1.3. Rust 特别擅长的领域高性能 webservicewebassembly命令行工具网络编程嵌入式设备系统编程 1.4. Rust 与 Firefox Rust 最初是 Mozilla 公司的一个研究性项目, firefox 是 Rust 产品应用的一个重要例子.Mozilla 一直以来都在用 rust 创建一个名为 servo 的实验性浏览器引擎, 其中的所有内容都是并行执行的.目前 servo 的部分功能已经被集成到 firefox 里面了firefox 原来的量子版就包含了 servo 的 css 渲染引擎 rust 使得 firefox 在这方便得到了巨大的性能改进 1.5. Rust 的用户和案例 google: 新操作系统 Fuschia, 其中 Rust 代码量大约 30% Amazon: 基于 Linux 开发的直接可以在裸机, 虚拟机上运行容器的操作系统. System76: 纯 Rust 开发了下一代安全操作系统 Redox 蚂蚁金服: 库操作系统 Occlum 斯坦福和密歇根大学: 嵌入式实时操作系统, 应用于 google 的加密产品. 微软: 正在使用 Rust 重写 windows 系统中的一些低级组件. 微软: winRT/Rust 项目 Dropbox, yelp, Coursera, LINE, Cloudflare, Atlassian, npm, Ceph, 百度, 华为, Sentry, Deno 1.6. Rust 的优点 性能 安全性 无所畏惧的并发 1.7. Rust 的缺点 难学 1.8. 注意Rust 有很多独有的概念, 它们和现在大多主流语言都不同. 所以学习 Rust 必须从基础概念一步一步学, 否则会懵. 1.9. 参考教材The Rust programming languageRust 权威指南 2. 安装 Rust2.1. 安装 rust Rust 官网: https://www.rust-lang.org Linux or Mac: 1curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf| sh windows: 按官网安装指引操作 下载安装程序，下载 RUSTUP-INIT.exe 32 位安装程序 或 下载 RUSTUP-INIT.exe 64 位安装程序 然后运行程序并按照屏幕上的说明进行操作。 当提示您安装Visual Studio C++ build tools时，您可能需要安装这些工具。 完成安装后需要将 &lt;home_dir&gt;/bin/.cargo 添加到 Path 环境变量, 这样在任何位置都可以执行 rustc, cargo 和 rustup 命令了 windows subsystem for Linux: 搭建 WSL 可参考我的博客Windows 下搭建 WSL Linux 开发环境 安装 rust 可使用如下命令命令 1curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 2.2. 配置 Rust2.2.1. 替换镜像安装完成后需要将 crates.io 替换成国内镜像. 访问https://crates.io非常缓慢，github 的仓库也经常不能访问，建议大家切换到国内镜像站。镜像站实时缓存，托管在码云的 gitee 仓库每隔 30 分钟与 github 同步。 配置方式 在 .cargo 目录新建文件 config 注意：新安装的电脑中没有这个文件，需要手动创建 config 文件，并且该文件没有后缀名 编辑文件内容： 123456[source.crates-io]registry=&quot;https://github.com/rust-lang/crates.io-index&quot; #这行可以不要,只是说明原始地址replace-with='crates-cn'[source.crates-cn]registry=&quot;https://gitee.com/crates/crates.io-index.git&quot; 如果使用中科大 USTC 的镜像 1234567[source.crates-io]replace-with='ustc'[source.ustc]registry=&quot;https://mirrors.ustc.edu.cn/crates.io-index&quot; 修改完保存后执行 build 即可 1cargo build 2.3. 更新 Rust1rustup update 2.4. 卸载 Rust1rustup self uninstall 2.5. 验证安装是否成功1rustc --version 结果格式: rustc x.y. z (abcabcabc yyyy-mm-dd) 会显示最新稳定版的: 版本号, commit hash, commit 日期 当前我安装的版本为 rustc 1.56.1 (59eed8a2a 2021-11-01) 3. 第二章：第一个 rust 程序3.1. hello worldmain.rs 123fn main() { println!(&quot;hello world&quot;);} 编译: 1rustc main.rs 编译完成后将会输出可执行文件 main,运行程序使用命令 1./main 3.2. Rust 程序解析 定义函数 fn main() {}没有参数, 没有返回值 main 函数很特别 : 他是每一个 Rust 可执行程序 最先运行的代码 打印文本: println!(“hello, world!”) rust 的缩进是 4 个空格而不是 tab println! 是一个 Rust macro(宏), 如果是函数的话就没有感叹号(!) “hello world” 是字符串, 它是 println!的参数 这行代码以;结尾 3.3. 编译和运行是单独的两步 运行 rust 程序之前需要先编译, 命令为: rustc 源文件名 1234# 编译程序rustc main.rs# 运行程序./main 编译成功后, 会生成一个二进制文件例如 main 在 window 上还会生成一个.pdb 文件, 里面包含调试信息 Rust 是 ahead-of-time(AOT)预编译的语言 可以先编译程序, 然后把可执行文件交给别人运行(无需安装 Rust) rustc 只适合简单的 Rust 程序, 当文件比较多, 项目管理还是需要使用 Cargo 3.4. hello cargo3.4.1. cargo 介绍 Cargo 是 Rust 的构建系统和包管理工具 构建代码, 下载依赖的库, 构建这些库 安装 Rust 的同时会自动安装 Cargo, 所以这里不需要额外的步骤去安装 Cargo 12$cargo --versioncargo 1.56.0 (4ed5d137b 2021-10-04) 3.4.2. 使用 Cargo 创建项目 创建项目: 1cargo new hello_cargo 创建完成后项目的目录结构 123456789101112$tree -a .hello_cargo├── Cargo.toml├── .git│ ├── config│ ├── description│ ├── HEAD...................├── .gitignore└── src └── main.rs 目录结构说明：Cargo.toml: TOML(Tom’s obvious, Minimal Language)格式，是 Cargo 的配置格式 12345678[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2018&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] [package], 是一个项目信息区域，表示下方内容是用来配置包（package）的． name: 项目名 version: 项目版本 authors: 项目作者 edition: The Rust edition 更多参数说明请参考The Manifest Format [dependencies], 另一个区域的开始，它会列出项目的依赖项． 在 Rust 里面，代码的包称作crate(板条箱,装货箱;如果cargo是装货物的集装箱,Crate 板条箱就是装载整批货物的小箱子) src/main.rs cargo 生成的 main.rs 在 src 目录下 而 Cargo.toml 在项目顶层下 源代码都应该在 src 目录下 顶层目录可以放置：README, 许可信息, 配置文件和其它与程序源代码无关的文件 如果创建项目时没有使用 cargo, 也可以把项目转化为使用 cargo: 把源代码文件移动到 src 下 创建 Cargo.toml 并填写相应的配置 3.4.3. 构建 Cargo 项目 cargo build创建可执行文件：target/debug/hello_cargo (linux/macos)或者 target\\debug\\hello_cargo.exe (windows) 第一次运行 cargo build 会在顶层目录生成 cargo.lock 文件 该文件负责追踪项目依赖的精确版本 不需要手动修改该文件 构建和运行 cargo 项目 cargo run cargo run, 编译代码+执行结果 如果之前编译成功过，并且源代码没有改变，那么就会直接运行二进制文件 cargo check cargo check, 检查代码，确保能通过编译，但是不产生任何可执行文件 cargo buid -release 编译时会进行优化 代码会运行的更快, 但是编译时间更长 会在 target/release 而不是 target/debug 生成可执行文件 两种配置，一种是开发用的，一种是发布用的 3.5. 猜数字游戏3.5.1. 声明变量main.rs 12345678910111213141516171819202122232425262728println!(&quot;猜数！&quot;);println!(&quot;猜测一个数！&quot;);/*** let声明一个变量* mut 声明变量为可变变量,* 默认情况下变量是不可变的, 除非显示使用mut指明变量为可变变量* = 赋值操作* 注意申明时没有指定变量类型, 变量类型是根据赋初始值时进行推导的* String是由rust 的标准库所提供的类型，内部是使用utf-8编码* :: 符号表明new是String类型的关联函数，关联函数相当与其他语言中的静态方法**/let mut guess = String::new();/*** io是rust标准库中的一个包名* stdin()方法会返回一个Ｓtdin对象, 标准输入对象* read_line 是标准输入对象的一个方法，调用该方法时，需要提供一个可变字符串变量，用于接收用户输入* &amp; 取地址符号，表示传递引用, 表示这个参数是一个引用reference，通过引用我们就可以在不同地方，访问程序的统一块内存区域* &amp;mut表示这个引用是可变的, 如果不加mut, 表明这个引用也是不可变的* read_line函数返回的是一个i0:Result&lt;usize&gt;对象，expect是result对象的一个方法* result是一个枚举类型, 其有两种类型的返回结果, 一种是err, 一种ok* 如果返回的result为err, 该expect就会将错误信息输出到终端* 如果返回结果是ok类型, expect就会提取出result中附加的值并将这个值作为结果返回给用户* 如果不调用expect方法, 编译时将会收到rusult未被使用的警告**/io::stdin().read_line(&amp;mut guess).expect(&quot;无法读取行&quot;);//{} 是一个占位符，输出时将会替换成相对应的变量的值println!(&quot;你猜测的数时｛｝&quot;, guess); 3.5.2. 引入依赖包 rust 中的依赖包被称为 cratecrate 分为两种, 一种是二进制格式的可执行文件; 一种是源文件,也被称为 library crate rust 的 crate 仓库为 crates.io, 可以访问该网站获得相应的 crate cargo 引入依赖的方式 在 dependencies 区域添加依赖的 crate 名称和版本如下所示. 12345678#Cargo.toml[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2018&quot;[dependencies]rand = &quot;^0.7.0&quot; 示例代码 12345678910111213141516171819202122232425262728293031323334use std::io;use rand::Rng; //traituse std::cmp::Ordering;fn main() { println!(&quot;猜数！&quot;); let secret_num = rand::thread_rng().gen_range(1, 101); //rust循环 loop { println!(&quot;猜测一个数！&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess).expect(&quot;无法读取行&quot;); println!(&quot;你猜测的数是: {}&quot;, guess); //shadow let guess:u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(ex) =&gt; { //rust异常处理 println!(&quot;解析错误 {} {}&quot;, guess, ex); continue; } }; // rust条件运算 match guess.cmp(&amp;secret_num) { Ordering::Less =&gt; println!(&quot;Too small!&quot;), //arm Ordering::Greater =&gt; println!(&quot;Too big!&quot;), Ordering::Equal =&gt; { println!(&quot;You win!&quot;); break; } } }} 4. 第三章 通用的编程概念4.1. 变量和可变性 声明变量使用 let 关键字 默认情况下，变量是不可变的(immutable)例如: 12345let x =5; // x 为不可变变量println!(&quot;the value of x is {}&quot;, x);x = 6; // 注意: 这里会有编译错误println!(&quot;the value of x is {}&quot;, x); 声明变量时, 在变量前面加上 mut, 就可以使变量可变． 1234let mut x =5;println!(&quot;the value of x is {}&quot;, x);x = 6;println!(&quot;the value of x is {}&quot;, x); 4.2. 变量和常量 常量(constant), 常量在绑定值以后也是不可变的, 但是它与不可变的变量有很多区别： 不可以使用 mut, 常量永远都是不可变的 声明常量使用 const 关键字, 它的类型必须被标注 常量可以在任何作用域内进行声明, 包括全局作用域 常量只可以绑定到常量表达式, 无法绑定到函数的调用结果或只能在运行时才能计算出的值 在程序运行期间, 常量在其声明的作用域内一直有效 命名规范: Rust 里常量使用全大写字母, 每个单词之间用下划线分开, 例如： 1const MAX_POINTS: u32 = 100_000; 4.3. shadowing (隐藏) 可以使用相同的名字声明新的变量, 新的变量就会 shadow（隐藏）之前声明的同名变量 在后续代码中这个变量名代表的就是新的变量 shadow 和把变量标记为 mut 是不一样的例如: 1234567891011121314151617fn main() { //定义不可变变量x let x = 5; println!(&quot;the value of x is {}&quot;, x); // x = 6 // 如果这里给x赋值会报错 // 但是如果我们声明一个同名的新的变量，就可以编译通过 // 我们甚至可以改变x的数据类型, 甚至可以定义新的同名但是不同的可变性的变量 //新的同名变量 let x = 6; println!(&quot;the value of x is {}&quot;, x); //不同可变性的同名变量 let mut x = &quot;my love&quot;; println!(&quot;the value of x is {}&quot;, x); x = &quot;hello kitty&quot;; println!(&quot;the value of x is {}&quot;, x);} 4.4. Rust 数据类型 Rust 是静态编译语言, 在编译时必须知道变量的类型 基于使用的值, 编译器通常能够推断出它的具体类型 但如果可能的类型比较多(例如把 String 转为整数的 parse 方法)，就必须添加类型的标注，否则编会报错．例如: 12let guess: u32 = &quot;42&quot;.parse().expect(&quot;not a number&quot;) println!(&quot;{}&quot;, guess) 4.4.1. 标量类型 一个标量类型代表一个单个的值 Rust 有四个主要的标量类型： 整数类型 浮点类型 布尔类型 字符类型 4.4.1.1. 整数类型 整数类型分为无符合整数类型, 无符号整数类型以ｕ开头 有符号整数类型以 i 开头 Rust 的整数类型列表如图： 每种长度都有对应的有符号型和无符号型． 有符号范围 (负的 2 的 n-1 次方-1) 到(2 的 n-1 次方-1) 无符号范围 0 到 2 的 n 次方 -1 isize 和 usize 类型 isize 和 usize 类型的位数由程序运行的计算机的架构所决定 如果是 64 位的计算机，那就是 64 位的 如果是 32 位的计算机，那就是 32 位的 使用 isize 或者 usize 的场景是对某种集合进行索引操作 length signed unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 i64 128-bit i128 u128 arch isize usize 整数的字面值 除了 byte 类型外, 所有的数值字面值都允许使用类型后缀例如： 57u8: 值为 57 类型为 u8 整数的默认类型就是 i32: 总体来说速度很快, 即使在 64 位系统中 NumberLiteral Example Decimal Oxff Hex Oo77 Binary Ob1111_0000 Byte (u8 only) b’A’ 整数溢出例如：u8 的范围是 0-255, 如果你把一个 u8 变量的值设为 256, 那么： 调试模式下编译：rust 会检查整数溢出, 如果发生溢出, 程序编译时就会 panic 在发布模式下(–release)编译：rust 不会检查可能导致 panic 的整数溢出 在这种模式下如果发生溢出：rust 会执行环绕操作256 变成 0, 257 变成 1…. 但是不会导致 panic 4.5. 浮点类型 rust 有两种基础的浮点类型，也就是含有小数部分的类型 f32, 32 位, 单精度 f64, 64 位，双精度 rust 的浮点类型使用了 IEEE-754 标准来表述 f64 是默认类型，因为在现代 cpu 上 f64 和 32 的运算速度差不多，而且精度更高例子: 12let x = 2.0 //默认为f64let y: f32 = 3.0; //f32 4.6. 数值操作12345let sum = 5+10; //i32let difference = 95.5-4.3; //f64let product = 4*30;let quotient = 56.7/32.2 //f64let reminder = 54%5 4.7. 布尔类型 Rust 的布尔类型有两个值: true 和 false 占用一个字节(Byte)的大小 符号是 bool 例子 1234567fn main() { //编译器推断类型 let t = true; //显示指定类型 let s: bool = false;} 4.8. 字符类型rust 语言中 char 类型被用来描述语言中最基础的单个字符．字符类型的字面值使用单引号占用４字节大小是 Unicode 标量值, 可以表示比 ASCII 多得多的字符内容：拼音, 中日文, 零长度空白字符，emoji 表情等． 其范围为 U+0000 到 U+D7FF U+E000 到 U+10FFFF 但是 unicode 中并没有字符的概念, 所以直觉上认为的字符也许与 Rust 中的概念并不相符 4.9. 复合类型 复合类型可以将多个值放在一个类型里 Rust 提供了两种基础的复合类型: 元组(Tuple), 数组 4.9.1. Tuple Tuple 可以将多个类型的多个值放在一个类型里 Tuple 的长度是固定的: 一旦声明就无法改变 4.9.1.1. 创建 tuple 在小括号里, 将值用逗号分开 Tuple 中的每个位置都对应一个类型，tuple 中各元素的类型不必相同 实例 12let tup: (i32, f64, u8) = (500, 6.4, 1)println!(&quot;{},{},{}&quot;, tup.0, tup.1, tup.2) 4.9.1.2. 获取 tuple 的元素值 可以使用模式匹配来解构(destructure)一个 Tuple 来获取元素的值 例子 123let tup: (i32, f64, u8) = (500, 6.4, 1);let (x, y, z) = tup; //这里使用模式匹配解构tup的值println!(&quot;{},{},{}&quot;, x, y, z) 4.9.2. 访问 tuple 的元素 在 tuple 变量使用点标记法，后接元素的索引号 实例 12let tup: (i32, f64, u8) = (500, 6.4, 1)println!(&quot;{},{},{}&quot;, tup.0, tup.1, tup.2) 4.10. 数组 数组也可以将多个值放在一个类型里 数组中每个元素的类型必须相同 数组的长度也是固定的 4.10.1. 声明一个数组 在中括号里, 各值用逗号分开 例子 123fn main() { let a = [1, 2, 3, 4, 5]} 4.10.2. 数组的用处 如果想让你的数据存放在栈(stack)上, 而不是堆(heap)上，或者想保证有固定数量的元素, 这时使用数组更有好处． 数组没有 Vector 灵活(以后再讲) Vector 和数组类似，它是由标准库提供的 Vector 的长度是可以改变的 如果你不确定应该使用数组还是 vector, 那么估计你应该用 vector. 例子 1234567fn main() { let months = [&quot;January&quot;, &quot;Fabruary&quot;, ...... &quot;December&quot; ]} 4.10.3. 数组的类型 数组的类型以这种形式来表示: [类型; 长度] 例如: let a: [i32; 5] = [1, 2, 3, 4, 5]; 另外一种声明数组的方法如果数组的没一个元素值都相同, 那么可以在:在中括号里指定初始值然后是一个;最后是数组的长度例如： let a = [3; 5]; 它相当于：let a = [3, 3, 3, 3, 3] 4.10.4. 访问数组的元素 数组是 stack 上分配的单个块的内存 可以使用索引来访问数组的元素 例子 12let first = months[0];let second = months[1]; 如果访问的索引超出了数组的范围, 那么 编译会通过 运行会报错(runtime 时会 panic) Rust 不会允许其继续访问相应地址的内存说明：在简单的情况下，编译会报错，但是在复杂情况下，编译不会报错例如 12let index = 15;let month = months[index]; //此时编译会报错 12let index = [15, 1, 2 , 3];let month = months[index[0]]; //此时编译不会报错, 运行时会发生panic 4.11. 3.4 函数 声明函数使用 fn 关键字 依照惯例，针对函数和变量名，rust 使用 snake case 命名规范: 所有的字母都是小写的, 单词之间使用下划线分开 例子 12345678fn main() { println!(&quot;hello world&quot;); another_function();}fn another_function() { println!(&quot;another function&quot;)} 4.11.1. 函数的参数 parameters, arguments 例子 12345678fn main() { println!(&quot;hello world&quot;); another_function(5);}fn another_function(x: i32) { println!(&quot;the value of x is {}&quot;, x)} 4.11.2. 函数中的语句(statement)和表达式(expression) 函数体由一系列语句组成, 可选的由一个表达式结束 Rust 是一个基于表达式的语言 语句是执行一些动作的指令 表达式会计算产生一个值 函数的定义也是语句 语句不返回值，所以不可以使用 let 将一个语句－赋给一个变量 例子 12345678fn main() { let x = 5; let y = { let x = 1; //x+3; //注意这里有个分号，它是语句而不是表达式, 但是这个语句有些特殊, 它的值等于一个空的tuple 即（） x+3 //这里没有分号, 它是一个表达式, 表达式的值为5 它是整个block的返回值, 该值将会被赋给变量y }} 4.11.3. 函数的返回值 在-&gt;符号后边声明函数返回值的类型, 但是不可以为返回值命名 在 Rust 里面, 返回值就是函数体里面最后一个表达式的值 若想提前返回, 需使用 return 关键字, 并指定一个值 大多数函数都是默认使用最后一个表达式为返回值例子: 1234567fn five() -&gt; i32 { 5}fn main() { let x = five(); println(&quot;the value of x is: {}&quot;, x);} 4.12. 注释单行注释多行注释文档注释 4.13. 控制流4.13.1. ｉ f 表达式 if 表达式允许你根据条件来执行不同的代码分支 这个条件必须是 bool 类型 if 表达式中, 与条件相关联的代码块就叫做分支(arm) 可选的, 在后面可以加上一个 else 表达式 但是如果使用了多余一个 else if, 那么最好使用 match 来重构代码 例子 12345678fn main() { let number = 3; if number &lt; 5 { println!(&quot;condition was false&quot;); } else { println!(&quot;condition was false&quot;); }} 例子：else if 12345678910fn main() { let number = 3; if number % 4 == 0 { println!(&quot;number is divisaible by 4&quot;); } else if number % 3 == 0 { println!(&quot;number is divisaible by 3&quot;); } else { println!(&quot;number is not divisaible by 3 or 4&quot;); }} 4.13.2. 在 let 语句中使用 if 因为 if 是一个表达式, 所以可以将它放在 let 语句中等号的右边(例子) 12345fn main() { let condition = ture; let muber = if condition {5} else {6}; //相对于其它语言中的三元表达式 println!(&quot;The value of number is {}&quot;, number);} 4.14. Rust 的循环 Rust 提供了３中循环：loop, while 和 for. 4.14.1. loop 循环loop 关键字告诉 Rust 反复地执行一块代码，直到你喊停为止可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环例子 1234567891011fn main() {let mut counter = 0; let resut = loop { counter += 1; if counter == 10 { break counter * 2; } } println!(&quot;The result is: {}&quot;, result);} 4.14.2. while 条件循环 另外一种常见的循环模式是每次执行循环体之前都判断一次条件． while 条件循环就是为这种模式而生的 例子 123456789fn main() { let mut number = 3; while number != 0 { println!(&quot;{}!&quot;, number); number = number -1; } println!(&quot;LIFTOFF!!!&quot;);} 4.15. for 循环遍历集合 可以使用 while 或 loop 来遍历数组, 但是易出错且低效． 使用 for 循环更简洁紧凑, 它可以针对集合中的每一个元素来执行一些代码 例子 123456fn main() { let a = [10, 20, 30, 40, 50] for element in a.iter() { println!(&quot;the value is: {}&quot;, element); }} 由于 for 循环的安全，简洁性，所以它在 Rust 里用的最多 4.16. Range 标准库提供 指定一个开始数字和一个结束数字，Range 可以生成它们之间的数字(不包含介绍) rev 方法可以反转 range 例子 123456fn main() { for number in (1..4).rev() { println!(&quot;{}!&quot;, number); } println!(&quot;LIFTOFF!&quot;);} 5. 第四章： 所有权5.1. 4.1 什么是所有权 Rust 的核心特性就是所有权 所有程序在运行时都必须管理它们使用计算机内存的方式 有些语言有垃圾收集机制，在程序运行时, 它们不断地寻找不再使用的内存 在其他语言中，程序员必须显示地分配和释放内存 Rust 采用了第三种方式 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则． 当程序运行时，所有权特性不会减慢程序运行速度 5.2. Stack vs Heap Stack 按值的接收顺序来存储，按相反的顺序将它们移除(后进先出, LIFO) 添加数据叫做压入栈 移除数据叫做弹出栈 所有存储在 stack 上的数据必须拥有已知的固定的大小 编译时大小未知的数据或运行时大小可能变化的数据必须存放在 heap 上 Heap 内存组织性差一些 当你把数据放入 heap 时, 你会请求一定数量的空间 操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址 这个过程叫做在 heap 上进行分配, 有时仅仅称为分配 把值压到 stack 上不叫分配 因为指针是已知固定大小的, 可以把指针存放在 stack 上．但如果想要实际数据，你必须使用指针来定位 把数据压倒 stack 上要比在 heap 上分配快得多： 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在 stack 的顶端 在 heap 上分配空间需要做更多的工作： 操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配 访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据 对于现代的处理器来说, 由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快． 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些(stack 上) 如果数据之间的距离比较远，那么处理速度就会慢一些(heap 上) 在 heap 上分配大量的空间也是需要时间的 当你的代码调用函数时，值被传入到函数(也包括指向 heap 的指针)．函数本地的变量被压到 stack 上，当函数结束后，这些值会从 stack 上弹出． 5.3. 所有权存在的原因 所有权解决的问题 跟踪代码的哪些部分正在使用 heap 的哪些数据 最小化 heap 上的重复数据量 清理 heap 上未使用的数据以避免空间不足 一旦你懂得了所有权，那么就不需要经常去想 stack 或 heap 了 但是知道管理 heap 数据是所有权存在的原因，这有助于解释它为什么会这样工作． 5.4. 所有权，内存与分配5.4.1. 所有权规则 每个值都有一个变量，这个变量是该值的所有者 每个值同时只能有一个所有者 当所有者超出作用域的时候，该值将被删除 5.5. 变量作用域 scope 就是程序中一个项目的有效范围 例子 12345fn main() { //s 不可以 let s = &quot;hello&quot;; // s可用 //可以对s进行相关操作} //s 作用域到此结束，s不再可用 5.5.1. string 类型 String 比那些基础标量数据类型更复杂 字符串字面值: 程序里手写的那些字符串值．它们是不可变的 Rust 还有第二种字符串类型: String 在 heap 上分配，能够存储在编译时未知数量的文本 5.5.1.1. 创建 String 类型的值 可以使用 from 函数从字符串字面值创建出 String 类型 1let s = String::from(&quot;hello&quot;);// :: 表示from是String类型下的函数 这类字符串是可以被修改的 123456fn main() { let mut s = String::from(&quot;Hello&quot;); s.push_str(&quot;, world&quot;); pringln!(s);} 字符串字面值，在编译时就知道它的内容, 其文本内容直接被编码到最终的可执行文件里 速度快，高效，得益于其不可变性 String 类型，为了支持可变性, 需要在 heap 上分配内存来保存编译时未知的文本内容： 操作系统必须在运行时来请求内存 这步通过调用 String::from 来实现 当用完 String 之后，需要使用某种方式将内存返回给操作系统 这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存 没有 GC 的语言中，就需要我们去识别内存何时不再使用，并调用代码将它释放 如果忘了，那就浪费内存． 如果提前做了，变量就会非法 如果做了两次，也是 bug. 必须一次分配对应一次释放 rust 采用了不同的方式: 对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的归还给操作系统． drop 函数 5.5.2. 变量和数据交互的方式: 移动 move 多个变量可以与同一个数据使用一种独特的方式来交互 12let x = 5;let y = x; 整数是已知且固定大小的简单的值, 这两个５被压到了 stack 中 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; 一个 String 由３部分组成： 一个指向存放字符串内容的内存的指针 一个长度 一个容量 上面这些东西被放在 stack 上. 存放字符串内容的部分在 heap 上 长度 len, 就是存放字符串内容所需的字节数 当把 s1 赋值给 S2, String 的数据被复制了一份 在 stack 上复制了一份指针, 长度, 容量 并没有复制指针所指向的 heap 上的数据 当变量离开作用域时，Rust 会自动调用 Drop 函数，并将变量使用的 heap 内存释放．当 S1, S2 离开作用域时, 它们都会尝试释放相同的内存 二次释放(double free) bug为了保证内存安全： Rust 没有尝试复制被分配的内存 Rust 让 s1 失效 当 s1 离开作用域的时候, rust 不需要释放任何东西 试试看当 s2 创建后，再使用 s1 是什么效果 12345fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = s1; println!(&quot;{}&quot;, s1); //这里会有编译错误，这里s1已经失效了} 浅拷贝(shallow copy) 深拷贝(deep copy) 你也许会将复制, 指针, 长度, 容量视为浅拷贝, 但是由于 Rust 让 s1 失效了, 所以我们用一个新的术语：移动 move 隐藏了一个设计原则，Rust 不会自动创建数据的深拷贝 就运行时性能而言, 任何自动赋值的操作都是廉价的 5.5.3. 变量和数据交互的方式: 克隆(Clone) 如果真想对 heap 上面的 String 数据进行深拷贝, 而不仅仅是 stack 上的数据，可以使用 clone 方法 12345fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); println!(&quot;{}&quot;, s1);} 5.5.4. Stack 上的数据： 复制 Copy trait, 可以容易想到整数这样完全放在 stack 上面的类型如果一个类型实现了 Copy 这个 trait,那么旧的变量在赋值后仍然可用 如果一个类型或者该类型的一部分实现了 Drop trait,那么 Rust 不允许让它再去实现 Copy trait 了 5.5.5. 一些拥有 copy trait 的类型 任何简单标量的组合类型都可以是 copy 的 任何需要分配内存或某种资源的都不是 copy 的 一些拥有 Copy trait 的类型 所有的整数类型, 例如 u32 bool char 所有的浮点类型, 例如 f64 tuple 元组, 如果其所有的字段都是 Copy 的(i32, i32) 是(i32, String) 不是 5.5.6. 所有权与函数 在语义上, 将值传递给函数和把值赋给变量是类似的： 将值传递给函数将发生移动或复制 5.5.7. 返回值与作用域 函数在返回值的过程中同样也会发生所有权的转移 12345678910111213fn main() { let s1 = gives_ownership(); let s2 = String::from(&quot;hello&quot;); let s3 = take_and_gives_back(s2);}fn gives_ownership() -&gt; String { let some_string = String::from(&quot;hello&quot;); some_string}fn takes_and_gives_back(a_string: String) -&gt; String { a_string} 一个变量的所有权总是遵循同样的模式： 把一个值赋给其它变量时就会发生移动 当一个包含 heap 数据的变量离开作用域时，它的值就会被 Drop 函数清理，除非数据的所有权移动到另一个变量上了 5.5.8. 如何让函数使用某个值，但是不获得其所有权？12345678910fn main() { let s1 = String::from(&quot;hello&quot;); let（s2, len）= calculate_length(s1); println!(&quot;the length of '{}' is {}&quot;, s2, len);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); (s，length)} 5.6. 引用和借用 以下例子中参数的类型是&amp;String 而不是 String &amp;符号就表示引用：允许你引用某些值而不取得所有权 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let（s2, len）= calculate_length(s1); println!(&quot;the length of '{}' is {}&quot;, s2, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()} 我们把引用作为函数参数这个行为叫做借用是否可以修改借用的东西？不行和变量一样，引用默认也是不可变的 12345678910fn main() { let s1 = String::from(&quot;hello&quot;); let（s2, len）= calculate_length(s1); println!(&quot;the length of '{}' is {}&quot;, s2, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.push_str(&quot;, world!&quot;) //编译期就会报错, can't borrow *s as mutable, as it's behind a '&amp;' reference s.len()} 5.6.1. 可变引用可变引用有一个重要的限制： 在特定作用域内，对某一块数据, 只能有一个可变引用 1234567fn main() { let mut s = String::from(&quot;hello&quot;); let s1 = &amp;mut s; let s2 = &amp;mut s; // 这里会报编译错误 can't borrow s as mutable more than once at a time} 这样做的好处是可在编译时防止数据竞争 以下三种行为下会发生数据竞争： 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有使用任何机制来同步对数据的访问 可以通过创建新的作用域, 来允许非同时的创建多个可变引用(例子) 不可以同时拥有一个可变引用和一个不变的引用 1234567891011fn main() { let mut s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;mut s1); println!(&quot;Then length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;mut String) -&gt; usize { s.push_str(&quot;, world&quot;) s.len()} 5.6.2. 悬空引用 Dangling References 悬空指针(Dangling Pointer): 一个指针引用了内存中的某个地址, 而这块内存可能已经释放并分配给其它人使用了． 在 Rust 里, 编译器可保证引用永远都不是悬空引用： 如果你引用了某些数据, 编译器将保证在引用离开作用域之前数据不会离开作用域 12345678fn main() { let r = dangle();}fn dangle() -&gt; &amp;String { // 这里编译器会报错，因为s出了此作用域将会被释放，而返回值是一个指向已经被释放区域的指针，这会导致问题，而rust在编译期就杜绝了这种错误． let s = String::from(&quot;hello&quot;); &amp;s} 5.6.3. 引用的规则 在任何给定的时刻, 只能满足下列条件之一: 一个可变的引用 任何数量不可变的引用 5.7. 切片Rust 的另一种不持有所有权的数据类型: 切片(slice) 一道题, 编写一个函数 它接收字符串作为参数 返回它在这个字符串里找到的第一个单词 如果函数没有找到任何空格, 那么整个字符串就被返回 1234567891011121314151617181920fn main() { println!(&quot;Hello, world!&quot;) let mut s = String::from(&quot;Hello world&quot;); let wordIndex = first_word(&amp;s); println!(&quot;{}&quot;, wordIndex);}fn first_word(s: &amp;string) -&gt; usize { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return i; } } s.len()} 字符串切片 字符串切片是指向字符串中一部分内容的引用 例子 形式：[开始索引..结束索引] 开始索引就是切片起始位置的索引值 结束索引是终止位置的下一个索引值 1234567891011fn main() { let s = String::from(&quot;Hello world&quot;) let hello= &amp;s[0..5] // 或者&amp;s[..5] let world= &amp;s[6..11] // 或者&amp;s[6..] println!(&quot;{}, {}&quot;, hello, world)} 注意： 字符串切片的范围索引必须发生在有效的 UTF-8 字符边界内。 如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出 1234567891011121314151617181920fn main() { println!(&quot;Hello, world!&quot;) let mut s = String::from(&quot;Hello world&quot;); let wordIndex = first_word(&amp;s); println!(&quot;{}&quot;, wordIndex);}fn first_word(s: &amp;string) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[..i]; } } s} 将字符串切片作为参数传达 fn first_word(s: &amp;String) -&gt; &amp;str { 有经验的 Rust 开发者会采用&amp;str 作为参数类型，因为这样就可以同时接收字符串和&amp;str 类型的参数了 fn first_word(s: &amp;str) -&gt; &amp;str { 使用字符串切片，直接调用该函数 使用 String, 可以创建一个完整的 String 切片来调用该函数 定义函数时使用字符串切片来代替字符串引用会使得我们的 API 更加通用，且不丧失任何功能。 1234567891011121314151617181920fn main() { println!(&quot;Hello, world!&quot;) let mut s = String::from(&quot;Hello world&quot;); let wordIndex = first_word(&amp;s); println!(&quot;{}&quot;, wordIndex);}fn first_word(s: &amp;str) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[..i]; } } s} 其他类型的切片 例子 123456fn main() { let a = [1,2,3,4,5] let slice = &amp;a[1..3] //&amp;[i32]} 5. Struct定义并实例化 struct什么是 struct struct 结构体 自定义的数据类型 为相关联的值命名， 打包=&gt;有意义的组合 定义 struct 使用 struct 关键字， 并为整个 struct 命名 在花括号内， 为所有字段(Field)定义名称和类型 例如： struct User {username: String,email: String,sign_in_count: u64,active: bool,} 实例化 struct 想要使用 struct, 需要创建 struct 的实例： 为每个字段指定具体值 无需按声明的顺序进行指定 例子： 1234567891011fn main() { println!(&quot;Hello, world!&quot;); let user1 = User { email: String::from(&quot;acb@126.com&quot;), username: String::from(&quot;Nikky&quot;), active: true, sign_in_count: 556, }} 获取 struct 里面的某个值 使用点标记法： 12345678910let mut user1 = User { email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;Nikky&quot;), active: true, sign_in_count: 556,}user1.email = String::from(&quot;anotheremail@example.com&quot;), 注意： 一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的。rust 不允许我们声明 struct 中一部分字段可变，而另一部分字段不可变。 struct 作为函数的返回值12345678910fn build_user(email: String, username: String) -&gt; User { User { email: email, username: username, active: true, sign_in_count: 1, }} 字段初始化简写 当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式： 12345678910fn build_user(email: String, username: String) -&gt; User { User{ email, username, active: true, sign_in_count: 1, }} struct 更新语法 当你想基于某个 struct 实例来创建一个新实例的时候，可以使用 struct 的更新语法 不使用更新语法的例子： 12345678let user2 = User { email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;Nikky&quot;), active: user1.active, sign_in_count: user1.sign_in_count,} 使用更新语法的例子： 1234567let user2 = User { email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;Nikky&quot;), ..user1} Rust基础部分未完待续 6. Rust web 框架2022 年可选择的三个 Rust Web 框架：actix-web、warp 和 axum。 actix-web：4.0.0-rc.35,134,720Actix Web 是一个功能强大、实用且速度极快的 Rust Web 框架 Warp: 0.3.24,114,095 以翘曲的速度服务于网络 axum: 专注于人体工程学和模块化的 Web 框架（由 tokio 团队提供） 比较： axum 有最干净的 API，它建立在 hyper 之上，它（当然）是 Rust 中经过测试最可靠的 HTTP 堆栈，并且因为它是由 tokio 团队开发的。但它的年轻可能会让一些人感到不舒服。 对于较大的项目，我认为这 actix-web 是无可争议的赢家。这就是为什么它是我选择 Bloom 的原因。 对于较小的项目（最多 50 条路由）warp，尽管它有原始的 API，但它非常好，因为它也是建立在其之上的 hyper，因此受益于它的可靠性和性能。 详细比较： JSON 反序列化：所有框架都使用泛型来提供简单的 JSON 反序列化。话虽如此，我发现两者都 axum 可以 actix-web 更直接地与他们的助手一起使用来自动提取类型化的正文有效负载。 路由：axum 是明显的赢家，紧随其后的是 actix-web，然后是 warp 有利于组合的功能性 API，这与我们通常对 Web 框架的期望相去甚远。 中间件：warp， 毫无疑问… 状态：在构建 Web 服务时，您需要共享一些变量，例如数据库连接池或一些用于外部服务的客户端。所有框架的人机工程学都非常相似。 Which web framework do you use in Rust? axum was voted mostly 7. 后记本文原文位于鹏叔的技术博客 - Rust 编程语言入门教程, 若需要获取最近更新, 请访问原文. 7.1. web 框架选择参考文档两张图展示当前 Rust Web 生态2022 年选择哪个 Rust Web 框架","link":"/rust/rust_study.html"},{"title":"strapi的安装和使用","text":"strapi一款基于Node.js开发的headless, 接口优先（API-first）的内容管理系统. Strapi 应用程序可以本地安装在计算机上，也可以安装在远程服务器上。以下安装指南提供了有关如何在本地计算机上安装和创建新Strapi项目的分步说明。 Strapi CLI（命令行界面）安装脚本是让 Strapi 在本地运行的最快方法, 也是官方推荐的安装方式。 1. 安装前准备工作在安装 Strapi 之前，您的计算机上必须安装以下软件： Node.js：仅支持维护版本和 LTS 版本（v16、v18和v20）。 建议安装 Strapiv4.3.9及以上版本使用 Node v18.x 建议安装 Strapi v4.0.x 到 v4.3.8 版本使用 Node v16.x 。 安装Node.js可以参考我之前的博客 Windows上安装nvm和nodejs MacOS上安装nvm Nodejs升级以及快速版本切换 Node.js 包管理器 npm（v6及以上） yarn Python（如果使用 SQLite 数据库） 任何 Strapi 项目支持的数据库： 数据库 最低限度 推荐版本 MySQL 5.7.8 8.0 MariaDB 10.3 10.6 PostgreSQL 11.0 14.0 SQLite 3 3 注意: Strapi v3 支持 MongoDB, 但是Strapi v4不支持MongoDB。后续版本可能仍然会支持MangoDB, 详情请参考这篇文章MongoDB support in Strapi: Past, Present and FuturePostgreSQL安装可以参考Centos7上安装PostgreSQL 14 | 鹏叔的技术博客MariaDB安装可以参考Centos7上安装MariaDB | 鹏叔的技术博客 里面涉及到的版本有些旧了, 要安装新版本的MariaDB可能需要替换Yum源.如果使用MySQL, MariaDB, PostgreSQL应该提前将数据库创建好, 再创建Strapi项目, 以PostgreSQL, 数据库的表结构会在项目首次运行时导入. 2. 创建Strapi项目按照以下步骤创建一个新的Strapi项目，确保使用适合您已安装的包管理器的命令： 2.1. 在终端中，运行以下命令使用npm创建Strapi项目 1234567npx create-strapi-app@latest my-project# 'npx' runs a command from an npm package# 'create-strapi-app' is the Strapi package# '@latest' indicates that the latest version of Strapi is used# 'my-project' is the name of your Strapi project 或者使用yarn创建Strapi项目 123456yarn create strapi-app my-project# 'yarn create' creates a new project# 'strapi-app' is the Strapi package# 'my-project' is the name of your Strapi project 2.2. 选择安装类型- Quickstart (推荐)，它使用默认数据库（SQLite） - Custom (手动配置)，它允许选择您首选的数据库 2.3. (仅限自定义安装类型）在数据库列表中，为您的 Strapi 项目选择一个数据库2.4. （仅限自定义安装类型）为项目的数据库命名2.5. CLI 一些安装选项说明上述安装指南仅涵盖使用 CLI 的基本安装选项。创建新的 Strapi 项目时还可以使用其他选项，例如： 1234--quickstart：以快速开始方式直接创建工程。--template：使用Strapi配置模板创建项目（请参阅[模板](https://docs.strapi.io/dev-docs/templates)）。--typescript/--ts：使用TypeScript创建项目。--no-run：仅创建不自动启动Strapi服务（与--quickstart结合使用）。 3. 启动Strapi应用程序要启动 Strapi 应用程序，请在项目文件夹中运行以下命令： 12345 npm run develop# 或者yarn develop 一旦应用启动后, 我们可以通过以下链接导航到我们的管理面板：http://localhost:1337/admin. 当您浏览时您将能够看到注册页面。 4. 一些有用的Strapi命令12345678910111213npm run developStart Strapi in watch mode. (Changes in Strapi project files will trigger a server restart)npm run startStart Strapi without watch mode.npm run buildBuild Strapi admin panel.npm run strapiDisplay all available commands. 5. 使用strapi5.1. 注册管理员账号管理面板打开之后，系统会提示我们创建一个超级管理员的身份，输入自己的账号和密码，目前界面显示的是英文，稍后我们进行配置接口让其显示中文界面。 注册输入一个账号、邮箱、密码，点击 Let’s start，进入到即可进入到 CMS 系统当中。 5.2. 修改 strapi 管理界面为中文接下来我们进行项目代码的配置，将界面设置为中文，使用自己熟悉的开发工具打开工程，这里我使用 VSCode，项目的结构如下图所示 这里我使用了文件折叠的插件，才让下面那些配置文件显示成层级结构的，不用管，将 src/admin/app.example.tsx 修改为 src/admin/app.tsx，并将代码修改成如下： 123456789101112export default {config: { locales: [ 'zh-Hans', 'zh', ],},bootstrap(app) { console.log(app);},}; 保存代码，项目会自动重启，打开管理系统，找到 Settings -&gt; internationalization -&gt; Add new locale ，添加一个中文的语言设置. 点击 save 保存语言配置项，然后重启一下项目，再次登录到管理系统当中。点击左下角的头像，选择 Profile，跳转到个人信息设置页面，可以看到有设置中文的选项了，我们选中中文（简体），然后点击 save，即可看到界面切换到中文。 5.3. 如何创建博文 首先在左侧导航栏中选择 Content-Type builder, 在中间的导航栏选择Collection Type 选项下选择create new Collection Type 在Create a collection type对话框输入Content-Type的名称, 在Advanced setting中确保Draft&amp;publish勾选上, 这一项在编辑博客文章时先保存为草稿, 等编辑完成后手动点击publish. 点击Continue按钮进入字段设置对话框. 创建字段如下标题: 字段名title, 类型Text, 在Advanced setting中勾选’Required field’, ‘Unique field’ 等选项, 保存.内容: 字段名content, 类型Rich text, 在Advanced setting中勾选’Required field’作者: 字段名author, 类型Relation, 在Advanced setting中勾选’Required field’标签: 字段名Tags, 类型Relation, 在Advanced setting中勾选’Required field’ 因为我们的博客文章包括多个字段, 例如标题, 正文, 标签, 作者等字段, 所以我们需要选择Collection Type而不是Single type.可以将Content-type理解为数据库的table, 创建Content-Type相当于动态建立数据库表结构标签字段为Relation, 需要新建Tag Content-Type, 然后将字段与Tag Content-Type关联, Author字段同理. 6. 问题排查1. 运行项目`npm run develop`时报错 123456789101112131415 Building your admin UI with development configuration...Admin UI built successfullyerror: ���ݿ� &quot;xxx-project&quot; ������ at Parser.parseErrorMessage (D:\\dev\\proj\\xxx-project\\node_modules\\pg-protocol\\dist\\parser.js:287:98) at Parser.handlePacket (D:\\dev\\proj\\xxx-project\\node_modules\\pg-protocol\\dist\\parser.js:126:29) at Parser.parse (D:\\dev\\proj\\xxx-project\\node_modules\\pg-protocol\\dist\\parser.js:39:38) at Socket.&lt;anonymous&gt; (D:\\dev\\proj\\xxx-project\\node_modules\\pg-protocol\\dist\\index.js:11:42) at Socket.emit (node:events:513:28) at Socket.emit (node:domain:489:12) at addChunk (node:internal/streams/readable:324:12) at readableAddChunk (node:internal/streams/readable:297:9) at Readable.push (node:internal/streams/readable:234:10) at TCP.onStreamRead (node:internal/stream_base_commons:190:23) 原因数据库未创建, 数据库配置解析失败. 2. 忘记管理员密码，如何重置。 在登陆界面点击忘记密码连接，跳转到重置密码界面。注册时的邮箱地址，会收到一封重置密码的邮件，点击邮件中的链接，跳转到重置密码界面，重置密码即可。 7. 参考文档Installing from CLI","link":"/strapi/install_strapi.html"},{"title":"strapi 项目结构介绍","text":"1. 项目结构如果 Strapi 项目是使用starter CLI创建的，则其结构包括frontend和backend文件夹，其中backend文件夹具有默认结构。 123456my-project├─── frontend # 前端代码文件夹├─── backend # 后端端代码文件夹, 拥有nodejs后端应用默认的目录结构└─── node_modules # 依赖包 不使用CLI自定义创建的 Strapi 项目的默认结构取决于该项目是使用普通 JavaScript 还是使用TypeScript创建的，使用TypeScript创建的项目如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970. # 应用的根目录├──── .cache # 用于构建管理面板的文件├──── .tmp├──── config # API 配置文件│ ├ api.ts│ ├ admin.ts│ ├ cron-tasks.ts│ ├ database.ts│ ├ middlewares.ts│ ├ plugins.ts│ └ server.ts├──── database│ └──── migrations├──── dist # 后端的构建│ └──── build # 管理面板的构建├──── node_modules # 项目用到的npm包├──── public # 外部可访问的文件│ └──── uploads├──── src│ ├──── admin # 管理员自定义文件│ │ ├──── extensions # 扩展管理面板的文件│ │ ├ app.example.tsx│ │ ├ webpack.config.ts| | └ tsconfig.json│ ├──── api # 按API划分为子文件夹的项目的业务逻辑│ │ └──── (api-name)│ │ content-types│ │ │ └──── (content-type-name)│ │ │ └ lifecycles.ts│ │ │ └ schema.json│ │ ├──── controllers│ │ ├──── middlewares│ │ ├──── policies│ │ ├──── routes│ │ ├──── services│ │ └ index.ts│ │ │ ├──── components│ │ └──── (category-name)│ │ ├ (componentA).json│ │ └ (componentB).json│ ├──── extensions # 扩展已安装插件的文件│ │ └──── (plugin-to-be-extended)│ │ ├──── content-types│ │ │ └──── (content-type-name)│ │ │ └ schema.json│ │ └ strapi-server.js│ ├──── middlewares│ │ └──── (middleware-name)│ │ ├ defaults.json│ │ └ index.ts│ ├──── plugins # 本地插件文件│ │ └──── (plugin-name)│ │ ├──── admin│ │ │ └──── src│ │ │ └ index.tsx│ │ │ └ pluginId.ts│ │ ├──── server│ │ │ ├──── content-types│ │ │ ├──── controllers│ │ │ └──── policies│ │ ├ package.json│ │ ├ strapi-admin.js│ │ └ strapi-server.js│ ├─── policies│ └ index.ts # 包括 register(), bootstrap() and destroy() functions├ .env├ tsconfig.json└ package.json 2. 参考文档Strapi Project structure","link":"/strapi/strapi_project_structure.html"},{"title":"使用rpm部署Strapi","text":"strapi 是目前我最喜欢的 CMS 系统之一, 因为它可以嵌入到各种前端框架, 并于各种前端技术浑然天成, 这是我喜欢它的原因. 这里大胆预测一些, 它大概会成为下一代 CMS 系统的引领者. 虽然它还很年轻, 但是已经出现王者气象. 正如很多年轻技术一样, 它还有很多不够完善的地方, 今天就它对于 self-hosted 部署方式的不足之处, 我们另辟蹊径介绍一种我正在实践的自动部署方式. 那就是使用 rpm 包进行部署. Strapi 的大部分功能还是很优秀的, 只是在部署, 尤其是部署到 self-hosted 环境中时显得特别麻烦, 主要是官方文档没有讲这一块, 官方文档花费打理的篇幅在讲如何部署到 strapi cloud, 以及如何部署到一些公有云平台. 在 self-hosted 部署方面官方文档写得也是晦涩难懂. 主要篇幅都在讲数据库如何安装, 云服务器如何创建, 而在打包帮忙讲得特别肤浅. 或许 self-hosted 不是他们推荐的方式, 而 Strapi 着力推广的也是 strapi cloud 部署, 而使用 strapi cloud 部署就特别方便, 一键部署, 这就是比较鸡贼的地方. 本文作为 Strapi 部署文档的补充, 讲介绍一种新的部署或更新 Strapi 的方式, 即使用 rpm 包部署 strapi. 这样做获得的好处, 在目标服务器, 一键安装 strapi 项目, 自动更新启动脚本, 自动讲 strapi 项目设置为自启动. 1. 手动部署手动部署前, 需要先编译项目 123npm run build 另外需要手动创建 server.js 文件, 内容如下: 123const strapi = require(&quot;@strapi/strapi&quot;);const app = strapi({ distDir: &quot;./dist&quot; });app.start(); 另外还要手动创建一个 tsconfig.json 文件, 内容与系统默认的 tsconfig.json 稍有不同. 如果不包含 tsconfig.json 文件在数据 import, export 的时候将会遇到一些问题 1234567891011121314&quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;dist&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;allowJs&quot;: true //enables the build without .ts files }, &quot;include&quot;: [ &quot;./&quot;, //&quot;./**/*.ts&quot;, //将这两行注释掉 //&quot;./**/*.js&quot;, &quot;src/**/*.json&quot; ], 然后将必要的文件拷贝到需要部署的服务器 这里假设我们要部署的组件目录为 strapi-cms, 将生成的整个 dist 目录拷贝到 123456789101112strapi-cms├── dist├── node_modules├── package.json├── public| └── uploads├── .env├── favicon.png├── tsconfig.json└── server.js 启动应用程序 启动应用程序使用如下命令 123node server.js 2. 首先我们需要制作 rpm 安装包首先强调一点, 制作 rpm 包不是部署 strapi 必须的步骤, 这里只是为了将部署过程自动化. 当然也可以将 strapi 制作成其他任何形式的安装包, 例如 debian 包或 packman 安装包, 以及一些通用的安装包. 总之都是基于手动部署步骤, 并将手动安装过程自动化, 便于将 strapi 纳入 devops 流水线管理. 最终的效果就是开发和测试阶段完成后交付制品即为 rpm 安装包, 在 staging 环境以及生产环境, 我们不必去安装开发依赖包, 只需要安装 nodejs 运行时环境即可. 编译和制作必要文件的过程与手动部署相同, 这里不再赘述. 2.1. 准备 spec 文件如何制作 rpm 包可以参考如何制作 RPM 安装包 | 鹏叔的技术博客 一旦了解了 RPM 安装包, 剩下的就是编写 spec 文件了 完整的 rpm 包 spec 文件内容粘贴如下, 仅供参考. 这里假定安装包名为 strapi_cms vim strapi_cms.spec 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#This is a RPM spec file for strapi_cms%define _topdir %{getenv:HOME}/rpmbuild%define name strapi_cms%define release %{_build_number}%{?dist}%define version 1.0.0%define buildroot %{_topdir}/%{name}-%{version}-rootBuildRoot: %{buildroot}Summary: your rpm summaryLicense: commercialName: %{name}Version: %{version}Release: %{release}.%{_env_name}Source: %{name}%{version}.tar.gzPrefix: /usrVendor: your domain name or other vendor inforGroup: Applications/Internet# requires部分不是必须的, 根据项目实际情况添加Requires(pre): /usr/sbin/useradd, /usr/bin/getentRequires(postun): /usr/sbin/userdel%descriptionSome description goes here to depict your project.%prep%buildcd ${WORKSPACE}/strapi_cms/npm install --legacy-peer-depsnpm run build%install[ &quot;${RPM_BUILD_ROOT}&quot; != &quot;/&quot; ] &amp;&amp; [ -d &quot;${RPM_BUILD_ROOT}&quot; ] &amp;&amp; \\ rm -rf &quot;${RPM_BUILD_ROOT}&quot;mkdir -p ${RPM_BUILD_ROOT}/var/strapi/cms/public/uploadscp -r ${WORKSPACE}/strapi_cms/dist ${RPM_BUILD_ROOT}/var/strapi/cms/distcp -r ${WORKSPACE}/strapi_cms/node_modules ${RPM_BUILD_ROOT}/var/strapi/cms/node_modulescp ${WORKSPACE}/strapi_cms/package.json ${RPM_BUILD_ROOT}/var/strapi/cms/package.jsoncp ${WORKSPACE}/strapi_cms/server.js ${RPM_BUILD_ROOT}/var/strapi/cms/server.jscp ${WORKSPACE}/strapi_cms/favicon.png ${RPM_BUILD_ROOT}/var/strapi/cms/favicon.pngcp ${WORKSPACE}/strapi_cms/tsconfig.json ${RPM_BUILD_ROOT}/var/strapi/cms/tsconfig.json%if &quot;%{?_env_name}&quot; == &quot;prod&quot;cp ${WORKSPACE}/strapi_cms/.env_prod ${RPM_BUILD_ROOT}/var/strapi/cms/.env%elsecp ${WORKSPACE}/strapi_cms/.env_dev ${RPM_BUILD_ROOT}/var/strapi/cms/.env%endifmkdir -p ${RPM_BUILD_ROOT}/var/log/strapi/cms%clean[ &quot;${RPM_BUILD_ROOT}&quot; != &quot;/&quot; ] &amp;&amp; [ -d &quot;${RPM_BUILD_ROOT}&quot; ] &amp;&amp; \\ rm -rf &quot;${RPM_BUILD_ROOT}&quot;cd ${WORKSPACE}/strapi_cms/rm -rf dist/%pre/usr/bin/getent group strapi || /usr/sbin/groupadd -r strapi/usr/bin/getent passwd strapi || /usr/sbin/useradd -r -s /sbin/nologin strapi -g strapi%files%defattr(-,strapi,strapi)/var/log/strapi//var/strapi/cms/ 2.2. 制作 rpm 安装文件将以上 rpm spec 文件保存为 strapi_cms.spec, 放置与项目根目录, 然后运行以下命令开始制作 rpm 安装文件. 1234# 手动运行rpmbuild还需要设置一下WORKSPACE环境变量, 让系统知道项目位置export WORKSPACE=/home/gitlab-runner/builds/pyswkhQm/0/root/your_project_parent_folderrpmbuild --define '_env_name dev' --define &quot;_build_number `date '+%y%m%d%H%M'`&quot; -bb strapi_cms.spec 2.3. gitlab pipeline job为了让整个打包过程自动化, 我定义了一个 gitlab pipeline job, 内容如下 12345678910111213141516strapi_cms_dev_releaseBuild: stage: releaseBuild when: manual script: - echo &quot;Creating dev release build for strapi_cms&quot; - source /etc/profile - mkdir -pv ~/rpmbuild/{SOURCES,SPEC,RPMS,BUILD,SRPMS,BUILDROOT} - mkdir -pv /rpm/centos/7/os/ - cd strapi_cms - rpmbuild --define '_env_name dev' --define &quot;_build_number `date '+%y%m%d%H%M'`&quot; -bb strapi_cms.spec - # copy rpm package to rpm repository - rsync -zvr ~/rpmbuild/RPMS/ /rpm/centos/7/os/ environment: name: staging variables: WORKSPACE: ${CI_PROJECT_DIR} 2.4. 安装 strapi_cms将 strapi_cms rpm 包拷贝到部署机, 进行安装. 123rpm -i strapi_cms-1.0.0-2310091804.el7.dev.x86_64.rpm 由于 strapi 依赖 vips 程序, 大多数 linux 发行版默认都没有安装 vips, 所以在安装 strapi_cms 需要手动安装 vips具体步骤可以参考https://tufora.com/tutorials/linux/general/install-vips-vips-tools-and-vips-devel-libvips-on-centos-7 安装好 strapi_cms 以后, 进入/var/strapi/cms, 启动 strapi_cms 123node server.js 启动之前需要确保相应的数据库已经创建, 本文中使用的是 postgresql, 可以使用如下命令创建数据库 123createdb -h localhost -p 5432 -U postgres cms_db 确保.env 文件中的连接信息与 postgresql 数据库一致如果允许外部网络可以访问 strapi cms 需要放开 1337 端口 12sudo firewall-cmd --add-port=1337/tcp --permanentsudo firewall-cmd --reload 3. 数据更新如果数据结构或数据发生改变, 需要手动导入数据. 先导出数据 1234# 首先进入工作目录，在本例中为/var/strapi/cms/cd /var/strapi/cms/npm run strapi export -- --file my-strapi-export 运行 export 命令时会问是否要输入加密的 key, 可以输入一个简单的加密 key, 例如 123, 然后记住它，在导入数据时需要使用 将数据上传至服务器 然后导入到新创建的数据库中 1npm run strapi import -- --file my-strapi-export 4. 设置开机启动设置为开机自启, 需要借助 PM2 启动 12345export NODE_ENV=productionpm2 start --name strapi_cms /var/strapi/cms/server.js 设置开机自启动 123456789101112131415161718# 设置环境变量vi /etc/profile.d/strapi.sh# 添加export NODE_ENV=production# 保存要在机器重新启动时重新生成的列表pm2 save# 生成开机自启动服务pm2 startup# enable pm2开机自启systemctl enable pm2-root# 查看process 详情pm2 show process_name 另外一些有用的 pm2 命令 123456# 查看进程pm2 list# 关闭prcesspm2 stop process_name# 删除进程pm2 delete process_name 至此 PM2 配置完成, ssr 默认会监听在 4000 端口, 可以通过如下命令查找端口号 1grep &quot;process.env\\[\\&quot;PORT\\&quot;\\]&quot; /var/your_app/webapp/server/main.js 其他一些有用的 pm2 命令 查看日志某个任务的日志 123pm2 log the_process_name 4.1. 配置 Nginx 反向代理修改/etc/nginx/conf.d/defaut.conf 将之前的配置由如下 1234567location / { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:1337/; } 5. 问题排查5.1. issue 1当安装程序时, 遇到如下错误 123456 rpm -i application-1.0.0-2310091804.el7.dev.x86_64.rpmerror: Failed dependencies: libvips-cpp.so.42()(64bit) is needed by application-1.0.0-2310091804.el7.dev.x86_64-bash-4.2$ rpm -i application-1.0.0-2310092051.el7.dev.x86_64.rpm 需要安装 vips, centos7 上可以参考https://tufora.com/tutorials/linux/general/install-vips-vips-tools-and-vips-devel-libvips-on-centos-7 almalinux 8 上安装 libvips: 首先安装 epel yum 源：参考https://blog.csdn.net/u011458874/article/details/119679216 或者https://www.jianshu.com/p/8f35adeeef58 5.2. issue 212345678910111213141516$npm run strapi export -- --file my-strapi-export&gt; strapi-cms@0.1.0 strapi&gt; strapi export --file my-strapi-export? Please enter an encryption key [hidden]Error: Unknown dialect undefined at getDialectName (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\database\\lib\\dialects\\index.js:36:13) at getDialect (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\database\\lib\\dialects\\index.js:42:23) at new Database (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\database\\lib\\index.js:31:20) at Database.init (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\database\\lib\\index.js:121:14) at Strapi.bootstrap (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\strapi\\lib\\Strapi.js:433:30) at Strapi.load (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\strapi\\lib\\Strapi.js:504:16) at async createStrapiInstance (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\strapi\\lib\\commands\\utils\\data-transfer.js:133:12) at async module.exports (&lt;strapi-cms-project-root&gt;\\node_modules\\@strapi\\strapi\\lib\\commands\\actions\\export\\action.js:59:18) 原因: 参考https://github.com/strapi/strapi/issues/13237 This is because the @strapi/typescript-utils/lib/utils/is-using-typescript uses the tsconfig.json file to determine whether you are starting a Typescript project or a Javascript project 解决办法, 在部署时需要包含 tsconfig.json 文件 但是对原有 tsconfig.json 做一些修改 1234567891011121314&quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;dist&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;allowJs&quot;: true //enables the build without .ts files }, &quot;include&quot;: [ &quot;./&quot;, //&quot;./**/*.ts&quot;, //将这两行注释掉 //&quot;./**/*.js&quot;, &quot;src/**/*.json&quot; ], 6. 参考文档Next.js+Strapi+Ubuntu 从 0 到 1 搭建 CMS 内容管理系统（含域名及证书申请教程） Install vips, vips-tools and vips-devel (libvips) on CentOS 7 如何从开发环境将 Strapi 项目构建到生产环境","link":"/strapi/strapi_deployment.html"},{"title":"如何在Strapi v4中创建Slug系统","text":"在为客户或您自己构建网站时，您通常希望通过 URL 中的人类可读的 slug 来访问您的公共内容。这将有助于搜索引擎优化 (SEO)，并且更容易让用户理解。值得庆幸的是，借助Strapi，您可以轻松地以这种方式访问​​您的内容。 1. 什么是 URL Slug？slug是一个报纸术语，slug是一个种短标签，只包含字母，数字，下划线或连字符。通常用于url中，在 seo 中，slug叫做url固定链接，是 URL 中最后一个反斜杠之后的部分。例如，您现在正在阅读的文章的 URL 如下所示： https://hrefgo.com/blog/technical-seo/what-is-a-url-slug 此URL 的 slug 是“/what-is-a-url-slug”。 2. 为什么 Slug 对 SEO 很重要？slug 对于关键字 SEO 来说非常强大。如果用户要在 Google 上搜索“什么是 slug”，您内容的 URL 结构中的关键字有助于向 Google 表明您的内容应该包含在 SERP 中。如果一个好的 slug 可以清楚地说明网页的内容，它可以改善用户的体验， 还可以帮助 Google 抓取机器人了解如何访问您的页面并确认页面上的内容。 3. Web Slug 对搜索引擎排名很重要吗？简短的回答是肯定的。在 URL 中使用 SEO 关键字可以帮助您对目标关键字进行排名。Google 使用 URL 作为对您的页面进行排名的一个因素，因此如果 URL slug 包含您的关键字，那么 Google 将更有可能对其进行排名。 4. Strapi中的slug在 Strapi版本3中，要为您的 Strapi 内容构建 slug 系统，您需要使用代码手动执行几个步骤，以便为您的 Strapi 应用程序自动生成 slug。您还可以在 Strapi v3 文档中查看构建 slug 系统的快速概述。现在，在 Strapi v4 中，为网站内容生成 slugs 变得更加容易。 4.1. Strapi v4 使生成 Slug 变得容易在 Strapi 版本 4 中，Strapi 附带了新的字段类型UID。这是为了生成在前端使用的唯一标识符。 此功能的强大之处在于，您可以使用内容类型中的另一个字段来为您生成唯一标识符。例如，如果您撰写标题为“Create a slug system in Strapi v4”的博客，系统将为您生成一个 slug，例如“create-a-slug-system-in-strapi-v4”。现在，您无需搞乱代码即可构建开箱即用的 slug 系统！ 4.2. 在strapi中自动生成slug的步骤下面我将概述为 Strapi v4 中的内容生成 slugs 的几个步骤。 转到内容类型生成器。 在开发模式下，转到 Strapi 管理面板中的内容类型构建器。 创建新的内容类型。 选择创建新集合类型的选项。 为集合类型命名 添加具有文本字段类型的标题字段。 添加 slug 字段。选择UID类型, attached field选择例如title 保存您的内容类型 为您的新内容类型添加新条目。 添加标题，然后查看生成的 slug！ 4.3. 在前端使用Slug您可能想要生成和使用 slugs 的主要原因是出于 SEO 目的。搜索引擎可以使用包含标题关键字的 slugs 更好地理解内容并对其进行排名。为了利用并通过 slug 获取内容，您只需按 slug 过滤内容即可。 下面是对上面 /blogs 端点的 REST API 请求示例： 1GET /api/blogs?filters[Slug][$eq]=create-a-slug-system-with-strapi-v4 GraphQL 查询示例： 123456789101112query { blogs(filters: { Slug: { eq: &quot;create-a-slug-system-with-strapi-v4&quot; } }) { data { id attributes{ Title Slug publishedAt } } }} 5. strapi 系列文章最新更新以及更多strapi相关文章请访问 鹏叔的技术博客 - strapi 6. 参考文档什么是固定链接地址(slug)及其对SEO的重要性 How to Create a Slug System in Strapi v4","link":"/strapi/strapi_slug_system.html"},{"title":"sass学习笔记","text":"1. sass 安装1cnpm install -g sass 检查是否安装成功 12$ sass --version1.42.1 compiled with dart2js 2.14.2 2. 把 sass 编译成 css进入 sass 项目所在目录项目结构 12345C:sass_study├─css│└─scss style.scss 编译 sass 1sass scss/style.scss:css/style.css 说明: 冒号左边为要编译的文件, 冒号右边为编译后的输出文件. 3. 自动编译 sass可以使用–watch 选项监视一个目录, 当目录中的文件发生变化以后, 自动将变化的文件编译后保存到 css 目录 12$ sass --watch scss:cssSass is watching for changes. Press Ctrl-C to stop. 4. 修改编译输出的 css 格式sass 输出有四种格式:nested 嵌套compact 紧凑expanded 扩展compressed 压缩 例如使用扩展, 这种样式常常用在开发模式下 1sass --watch scss:css --style expanded 5. .sass 和 .scss 的区别从 sass3.0 以后 sass 的语法发生了较大的变化,新的样式被称为 sassy css, 区别主要在以下方面. 首先这两种文件的扩展名不一样两种文件的注释方式不一样scss 语法比较接近 css, sass 是缩进式语法scss import 是需要在文件名上添加引号, sass 不需要scss mixin 需要使用@, sass mixin 需要使用前面需要=号其他见下图 6. 变量 variables声明变量以$开头, 冒号为赋值符号 1$primary-color: #123456; 使用变量 123div.box { backgound-color: $primary-color;} 12345678910111213h1.pageheader { border: 1px solid $primary-color;}``变量的值可以是数字, 字符串, 颜色值, 如果是字符串的话需要使用引号引起了例如```scss$primary-color: #123456;$primary-border: 1px solid $primary-color;h1.pageheader { border: $primary-border;} 变量名字中可以包含中划线(-), 也可以使用下划线(_), 最好是根据团队的编程规范进行统一命名规范. 7. 嵌套 Nesting1234567891011.nav { height: 100px; ul { margin: 0; li { float: left; list-style: none; padding: 5px; } }} 以上嵌套写法对应的 css 输出样式如下 1234567891011.nav { height: 100px;}.nav ul { margin: 0;}.nav ul li { float: left; list-style: none; padding: 5px;} 伪类选择嵌套写法 123456789a { display: block; color: #820; padding: 5px; &amp;:hover { background-color: #082f7e; color: #fff; }} 输出样式 123456789a { display: block; color: #820; padding: 5px;}a:hover { background-color: #082f7e; color: #fff;} 引用父选择器的例子 123456.nav { height: 100px; &amp; &amp;-text { font-size: 15px; }} css 输出 123456.nav { height: 100px;}.nav .nav-text { font-size: 15px;} 8. 嵌套属性示例 1: 1234567body { font: { family: Arial; size: 15px; weight: normal; }} 输出的 css 12345body { font-family: Arial; font-size: 15px; font-weight: normal;} 示例 2: 123456.nav { border: 1px solide #020 { left: 0; right: 0; }} 输出的 css 12345.nav { border: 1px solide #020; border-left: 0; border-right: 0;} 9. 混合 mixin可以把它想象成一块有名字的定义好的样式, 有点像 js 中的函数定义 mixin 的语法 123@mixin 名字(参数1, 参数2 ...) { ...} 调用 mixin 的语法@include 名字(参数 1, 参数 2 …)说明如果 mixin 不带参数, 则调用方式如下@include 名字 10. 继承/扩展 inheritance关键字@extend 示例 123456789101112.alert { padding: 15px;}.alert a { font-weight: bold;}.alert-info { @extend .alert; background-color: #d9df7;} 输出 12345678910111213.alert,.alert-info { padding: 15px;}.alert a,.alert-info a { font-weight: bold;}.alert-info { background-color: #d9df74;} 11. Partials 与 @importpartial 文件需要以下划线(_)开头 示例:文件结构├─css│└─scssstyle.scss_base.scss _base.scss 内容 1234body { padding: 0; margin: 0;} style.scss 内容注意: import 时不需要输入文件名前面的下划线, 也不需要输入文件的扩展名 1234567891011121314@import &quot;base&quot;;.alert { padding: 15px;}.alert a { font-weight: bold;}.alert-info { @extend .alert; background-color: #d9df74;} 输出 css 如下: 1234567891011121314@import &quot;base&quot;;.alert { padding: 15px;}.alert a { font-weight: bold;}.alert-info { @extend .alert; background-color: #d9df74;} 12. scss 中的注释scss 中有三种注释:单行注释, 多行注释, 和强制注释他们之间的差别为:单行注释不会被编译到输出文件中,多行注释一般情况下会输出到编译后的输出文件, 但是在压缩输出时会被去除掉, 强制注释会输出到编译后的 css 文件,在任何输出样式中都不会被清除. 单行注释示例: 12345678910111213141516171819202122// 这是一块单行注释background-color: yellow;``多行注释```scss/* 这是一块多行行注释* 这是多行注释的第二行* 我会出现在一般输出样式中* 我不会出现在压缩(compressed)样式中*/background-color: yellow;``强制注释```scss/*!* 我是一行强制注释* 我与多行注释的差别是我多了一个感叹号* 我会在任何输出样式中出现*/background-color: yellow; 13. 数据类型 data typesass -i 使用交互式模式 scss 属于类型有:数值型: number字符串: string列表: list颜色: color 1234567891011121314151617$ sass -i&gt;&gt; type-of(5)&gt;&gt; number&gt;&gt; type-of(5px)&gt;&gt; number&gt;&gt; type-of(hello)&gt;&gt; string&gt;&gt; type-of(1px solid red)&gt;&gt; list&gt;&gt; type-of(10px 5px)&gt;&gt; list&gt;&gt; type-of(#123456)&gt;&gt; color&gt;&gt; type-of(&quot;hello&quot;)&gt;&gt; string&gt;&gt; type-of($colors)&gt;&gt; map 14. 数值运算14.1. 加法运算2+8 结果 105px + 5px 结果 10px 14.2. 减法8-2 结果 65px -2 结构 3px 14.3. 乘法28 结果 165px2 结果 10px5px*2px 结果 10px*px注意: 虽然有结果, 但是 px*px 不是 css 能识别的单位 14.4. 除法(8/2) 结果 4(10px/2) 结果 5px 注意: 除法需要加括号, 因为/已经是 css 值得关键字 例如 font: 16px/1.8 serif 混合运算 2+3*5px 结果 17px 15. sass 函数123456789101112131415$ sass -i&gt;&gt; abs(10)&gt;&gt; 10&gt;&gt; abs(10px)&gt;&gt; 10px&gt;&gt; abs(10ox)&gt;&gt; 10ox&gt;&gt; type-of(10ox)&gt;&gt; numberround(10.5)&gt;&gt; 11cell(10.3)&gt;&gt; cell(10.3)min(1,2,4,3)&gt;&gt; 1 16. 字符串字符串连接 12345678910111213141516171819202122$ sass -i&gt;&gt; hello + &quot; world!&quot;&gt;&gt; hello world!&gt;&gt; &quot;hello&quot; + world!&gt;&gt; ^Error: Expected &quot;important&quot;.&gt;&gt; &quot;hello&quot; + world&gt;&gt; &quot;helloworld&quot;&gt;&gt; &quot;hello&quot; world&gt;&gt; &quot;hello&quot; world&gt;&gt; &quot;hello&quot; / world&gt;&gt; &quot;hello&quot;/world&gt;&gt; hello* world ^^^^^^^^^^^^Error: Undefined operation &quot;hello * world&quot;.&gt;&gt; hello + world&gt;&gt; helloworld&gt;&gt; hello *2 ^^^^^^^^Error: Undefined operation &quot;hello * 2&quot;.&gt;&gt; hello - world&gt;&gt; hello-world 17. 字符串变量123456789$ sass -i&gt;&gt; $greeting: &quot;hello world&quot;&gt;&gt; &quot;hello world&quot;&gt;&gt; $greeting&gt;&gt; &quot;hello world&quot;&gt;&gt; to_upper-case($greeting)&gt;&gt; &quot;HELLO WORLD&quot;&gt;&gt; str-length($greeting)&gt;&gt; 11 18. 颜色123456789/*16进制表示*/#123456/*RGB颜色*/RGB(255, 0, 0)RGBA(255, 0, 0, 0.5)red/*HSL颜色*/hsl(0, 100%, 50%)hsla(0, 100%, 50%, 0.2) 可以使用操作符处理颜色值, 也可以使用函数操作颜色 颜色操作函数:lighten, darken: 增减颜色的亮度 1234567$base-color: hsl(222, 100%, 50%)$light-color: lighten($base-color, 30%)$dark-color: darken($base-color, 20%);.alert { color: $dark-color;} 19. 列表列表和列表函数appendlengthindexjoin 20. map 类型的数据12345678910111213141516171819$ sass -i&gt;&gt; $colors: (light:#123456)&gt;&gt; (light: #123456)&gt;&gt; $colors: (light:#123456, dark:#000000)&gt;&gt; (light: #123456, dark: #000000)$colors&gt;&gt; (light: #123456, dark: #000000)&gt;&gt; length($colors)&gt;&gt; 2&gt;&gt; map-get($colors, light)&gt;&gt; #123456&gt;&gt; map-keys($colors)&gt;&gt; light, dark&gt;&gt; map-values($colors)&gt;&gt; #123456, #000000map-has-key($colors, light)&gt;&gt; truemap-merge($colors, (light-gray: #e5e5e5))&gt;&gt; (light: #123456, dark: #000000, light-gray: #e5e5e5) 21. boolean 值12345678910111213141516171819202122$ sass -i&gt;&gt; 5px &gt; 3px&gt;&gt; true&gt;&gt; 5px &lt; 3px&gt;&gt; false&gt;&gt; (5px &gt; 3px) and (4px &lt; 3px)&gt;&gt; false&gt;&gt; (5px &gt; 3px) and (4px &gt; 3px)&gt;&gt; true&gt;&gt; (5px &gt; 3px) or (4px &lt; 3px)&gt;&gt; true&gt;&gt; (5px &gt; 3px) or (4px &gt; 3px)&gt;&gt; true&gt;&gt; (5px &lt; 3px) or (4px &lt; 3px)&gt;&gt; falsenot(5px&gt; 3)&gt;&gt; false&gt;&gt; not(5px&gt; 3px)&gt;&gt; false&gt;&gt; not(5px &lt; 3px)&gt;&gt; true 22. 函数插值法(Interpolation)把变量放到属性名称上面 123456789$version: &quot;0.0.1&quot;/*项目当前版本是: #{$version} */$name: &quot;info&quot;;$attr: &quot;border&quot;.alert-#($name) { #($attr)-color: #ccc} css 输出: 12345@charset &quot;UTF-8&quot;;/*项目当前版本是: 0.0.1 */.alert-info { border-color: #ccc;} 23. 控制指令@if@for@each 24. if 指令123456789101112131415$use-prefixes: true;body { padding: 0;}.rounded { @if $use-prefixes { -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; } border-radius: 5px;} css 输出 1234567891011body { padding: 0;}.rounded { -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;} 25. for 循环1234567$columns: 12;@for $i from 1 through $columns { .col-#{$i} { width: 100% / $columns * $i; }} 26. each 循环123456$icons: success error warning;@each $icon in $icons { .icon-#{$icon} { }} 27. while 循环28. 用户自定义函数123语法 @function 名称 (参数1, 参数2) { @return;}","link":"/sass/sass_notes.html"},{"title":"使用Tailwind CSS必须知道的29个组件库","text":"Tailwind 是一个实用程序优先的 CSS 框架，提供了一整套预先设计的样式和组件，使您可以轻松创建令人惊叹的 UI，而无需自定义 CSS。 然而，即使拥有 Tailwind 大量的预先设计的样式，从头开始构建网站或应用程序仍然是一项艰巨的任务。这就是 Tailwind 组件库派上用场的地方。在本文中，我们将探索 2023 年 28 个最佳免费 Tailwind CSS 组件库，每个库都提供一组独特的组件，帮助您更快、更高效地构建下一个项目。无论您是经验丰富的 Web 开发人员还是刚刚入门，这些组件库都将使您的工作流程更加顺畅和愉快。 该列表还在不断丰富种， 最新更新将发布在29 个最佳 Tailwind CSS 组件库， 另外我们希望得到您的反馈， 以便我们给各组件库一个公道的评价。 推荐指数从一星到五星， 你会给您接触过的组件库几颗星并给出您的看法， 欢迎到原文下方留言。 1. Tailwind css 组件库列表 Tailwind UI Tailwind Elements Tailwind Components Tailwind Components是一个提供基于 Tailwind CSS 的 UI 组件和模板的在线平台。Tailwind Components 则进一步扩展了 Tailwind CSS 的应用范围，提供了大量现成的 UI 组件，让开发者可以更加高效地进行前端开发。这些组件包括但不限于下拉菜单、表单控件、导航栏、卡片布局、模态框等，都是基于 Tailwind CSS 的样式和理念设计的。在 Tailwind Components 的平台上，开发者可以浏览各种组件的示例和代码，并根据自己的需求进行选择和修改。这些组件的代码都是开源的，可以方便地集成到现有的项目中。同时，Tailwind Components 也支持开发者上传和分享自己的组件，形成了一个开放、共享的社区。 Tailwind Toolbox Flowbite UI Kit Saas Blocks shadcn/ui Tailwind UI Kit Meraki UI Daisy UI Float UI Components Material Tailwind WindUI Tailblocks Tailwind Starter Kit Windframe Blocks Tailkit Tailgrids Component library Mamba UI Mamba UI 是今年上榜的多个基于 Tailwind 的工具中的第一个。这是一个包含 150 多个组件和模板的 UI 库，基于流行的实用程序优先 CSS 框架。该库包含 40 多个类别的预样式组件，您可以快速获取 HTML、Vue 或 JSX 格式的任何组件的代码。 Flowrift UI Blocks Preline UI Components Hyper UI Tocinocode UI Components Headless UI Sailboat UI Sailboat UI 是一个基于 Tailwind 的 UI 组件库，包含 150 多个开源组件。这些组件非常类似于 Bootstrap，您可以在文档中搜索并查看组件的实时预览。 Tailwind Stamps shuffle vercel 2. Tailwind css 模板库列表 Tailwind Awesome Tailwind UI 模板库 模板类型包括：spotlight, salient, Protocal, Commit(changelog), Primer, Studio, Pocket, Transmit, Syntax, Keynote Float UI 模板库 模板类型包括：Mailgo, IO Academy, Starboard, Split, Blinder more template Tailwind Toolbox 模板库 模板类型包括：Admin, Landing page, Blog, store, Support, Portfolio, Navigation, Login, Starter Meraki ui 模板库 模板类型包括：Dashboard, Hero Header, Blog, Showcase, landing page, Tailgrids ui 模板库 模板类型包括：Dashboard, Agency, Business, Saas, Startup, Ecommerce, multipage, Landing page tailwind kit 模板库 模板类型包括：Landing page, Dashboard, Error Page Mamba ui 模板库 模板类型包括：Business, Portfolio vercel 模板库 模板类型包括：AI, Starter, Ecommerce, Blog, Edge functions, Edge middleware, Edge config, Portfolio, Saas, CMS, Cron, multi tenant apps, realtime-apps, documentation, virtual event, monorepos, Web3 3. tailwind 博客列表 tailwindcomponents discover tailwindcomponents blog material-tailwind blog windframe blog tailkit blog tailgrids blog Hyperui blog tocinocode blog 4. 组件分类4.1. 用户交互类组件4.1.1. number input组件库： flowbite number input tailwindcomponents number input counter tailwindcomponents number input preline number input tailwindtoolbox number input counter 4.1.2. input field组件库： flowbite input field 4.1.3. file input组件库： flowbite file input 4.1.4. search input组件库： flowbite search input 4.1.5. phone input组件库： flowbite phone input 4.1.6. select组件库： flowbite select 4.1.7. textarea组件库： flowbite textarea 4.1.8. timepicker组件库： flowbite timepicker datepicker组件库： preline datepicker 4.1.9. checkbox组件库： flowbite checkbox tailwindcomponents checkbox 4.1.10. radio组件库： flowbite radio floatui radio group 4.1.11. radio组件库： flowbite radio 4.1.12. toggle组件库： flowbite toggle 4.1.13. range组件库： flowbite range 4.1.14. floating label组件库： flowbite floating label 4.1.15. buttons组件库： flowbite buttons tailwindcomponents buttons preline buttons tw-elements buttons 4.1.16. button group组件库： flowbite button group tailwindcomponents button group preline button group tw-elements button group 4.1.17. modal组件库： flowbite modal tailwindtoolbox modal 4.1.18. popover组件库： flowbite popover 4.1.19. skeleton组件库： flowbite skeleton preline skeleton tailwindtoolbox skeleton 4.2. 排版（Typography）4.2.1. headings组件库： flowbite headings 4.2.2. paragraphs组件库： flowbite paragraphs 4.2.3. images组件库： flowbite images preline images 4.2.4. blockquote组件库： flowbite blockquote tailwindcomponents blockquote preline blockquote 4.2.5. lists组件库： flowbite lists preline lists list group组件库： preline list group 4.2.6. links组件库： flowbite links preline links 4.2.7. text组件库： flowbite text 4.2.8. Horizontal Line组件库： flowbite Horizontal Line preline Horizontal Line 4.3. 导航类组件4.3.1. bottom navigation组件库： flowbite bottom navigation tailwindcomponents bottom navigation 4.3.2. breadcrumb组件库： flowbite breadcrumb tailwindcomponents breadcrumb preline breadcrumb 4.3.3. mega menu组件库： flowbite mega menu preline mega menu tailwindtoolbox mega menu 4.3.4. navbar组件库： flowbite navbar preline navbar preline navs floatui navs 4.3.5. speed-dial组件库： flowbite speed dial 4.3.6. stepper组件库： flowbite stepper preline stepper 4.3.7. toast组件库： flowbite toast preline toast 4.3.8. tooltips组件库： flowbite tooltips 4.4. 布局类组件4.4.1. drawer组件库： flowbite drawer 4.4.2. footer组件库： flowbite footer 4.4.3. sidebar组件库： flowbite sidebar preline sidebar floatui sidebar 4.4.4. tabs组件库： flowbite tabs preline tabs floatui tabs 4.4.5. scrollbar组件库： preline custom scrollbar preline scrollspy 4.4.6. collapse组件库： preline collapse chip组件库： david-ui chip 4.5. 信息展示类4.5.1. accordion组件库： flowbite accordion tailwindcomponents accordion preline accordion tw-elements accordion tailwindtoolbox accordion 4.5.2. alerts组件库： flowbite alerts tailwindcomponents alerts preline alerts tw-elements alerts floatui alerts 4.5.3. avatar组件库： flowbite avatar tailwindcomponents avatar preline avatar preline avatar group tw-elements avatar floatui avatar tailwindtoolbox circular avatar 4.5.4. badge组件库： flowbite badge tailwindcomponents badges preline badge tw-elements badge tailwindtoolbox badge 4.5.5. banner组件库： flowbite banner tailwindcomponents banner 4.5.6. cards组件库： flowbite card tailwindcomponents cards preline cards floatui cards 4.5.7. gallery组件库： flowbite gallery 4.5.8. indicators组件库： flowbite indicators preline legend indicator 4.5.9. Jumbotron组件库： flowbite Jumbotron 4.5.10. list group组件库： flowbite list group 4.5.11. pagination组件库： flowbite pagination preline pagination floatui pagination 4.5.12. progress组件库： flowbite progress preline progress preline file upload progress tailwindtoolbox progress bar 4.5.13. spinner组件库： flowbite spinner preline spinner 4.5.14. ratings组件库： flowbite rating preline ratings 4.5.15. tables组件库： flowbite tables tailwindtoolbox tables 4.5.16. timeline组件库： flowbite timeline preline timeline 4.5.17. calendar组件库： tailwindcomponents calendar 4.5.18. carousel组件库： tailwindcomponents carousel preline carousel tailwindtoolbox carousel 4.5.19. charts组件库： tailwindcomponents charts 4.6. 其他4.6.1. chat bubble组件库： flowbite chat bubble preline chat bubble 4.6.2. clipboard组件库： flowbite clipboard 4.6.3. device mockups组件库： flowbite device mockups preline device mockups 4.6.4. Keyboard组件库： flowbite Keyboard preline Keyboard 5. 推荐Landing page templates: Play - Free Tailwind CSS SaaS Template Blog templates: SaaS blocks Blog Auth templates: SaaS blocks Auth Settings templates: SaaS blocks Settings 6. 关联阅读tailwindcss 教程 从@Angular/Flex-Layout 迁移到 Tailwindcss 7. 参考文档11 Best Tailwind CSS Component Libraries in 2023 Top 5 Tailwind Component Libraries Top 12 Tailwind CSS UI Kits and Components","link":"/sass/tailwind_best_component_libs.html"},{"title":"从@Angular&#x2F;Flex-Layout迁移到Tailwindcss","text":"1. 前言根据flex-layout官方宣告, @angular/flex-layout当前(2023-06-25)处于deprecated状态. 替代方案为Tailwind或者Angular CDK. 具体原因参考官方的anoucement - Medium post和github上的讨论 建议新项目使用其他css library, 旧项目考虑移植到其他css library. 以下是我从flex-layout的一些实践. 2. 引入tailwind3. css class对照表 Angular Flex-Layout directives Tailwind Equivalent CSS classes fxLayout=”&lt;direction&gt; &lt;wrap&gt;” Use flex-&lt;direction&gt; flex-&lt;wrap&gt; classes fxLayoutAlign=”&lt;main-axis&gt; &lt;cross-axis&gt;” Use justify-&lt;main-axis&gt; items-&lt;cross-axis&gt; content-&lt;cross-axis&gt; classes fxLayoutGap=”% | px | vw | vh” Use gap on flex items fxFlex=”” | px | % | vw | vh | &lt;grow&gt; | &lt;shrink&gt; &lt;basis&gt; Use flex, grow, and shrink classes along with customflex-basis classes overriding tailwind config fxFlexOrder=”int” Use Order classes along with custom classesoverriding tailwind config fxFlexOffset=”% | px | vw | vh” Use Margin classes fxFlexAlign=”start | baseline | center | end” Use Align Self classes fxFlexFill and fxFill Use w-full and h-full classes fxShow and fxHide Use block and hidden classes Responsive API Override Tailwind’s default breakpoints to match with Angular Flex-Layout. For example,theme: {extend: {screens: {‘sm’: { ‘min’: ‘600px’, ‘max’: ‘959px’ },‘lt-sm’: { ‘max’: ‘599px’ }….},}} personally I didn’t need to do this. [ngClass.xs]=”{‘first’:false, ‘third’:true}” Use aforementioned responsive API class=”gt-xs:first xs:third” [ngStyle.sm]=”{‘font-size’: ’16px’}” Use custom CSS classes as mentioned above. &lt;img src=”a.ico” src.xs=”b.ico”/&gt; Use custom CSS classes as mentioned above. gdAreas.xs=”header header | sidebar content” Tailwind does not have a support forgrid-template-areas so we have to use grid columnsand then apply Grid Row Start/End or Grid Column Start/End classes on grid items.For example, xs:grid-cols-2 xs:grid-rows-2 gdAlignColumns=”&lt;main-axis&gt; &lt;cross-axis&gt;” Use Align Items and Align Content classes gdAlignRows=”&lt;main-axis&gt; &lt;cross-axis&gt;” Use Place Content and Place Items and Place Items classes gdAuto Use Grid Auto Flow classes gdColumns Use Grid Template Columns classes along with customclasses overriding tailwind config gdRows Use Grid Template Rows classes along with customclasses overriding tailwind config gdGap Use Gap classes along with custom classesoverriding tailwind config 4. 引入Tailwind依赖包通过npm安装tailwindcss，然后运行init命令生成tailwind.config.js文件。 1234npm install -D tailwindcss postcss autoprefixernpx tailwindcss init 5. 自动转换工具这里有套自动转换工具https://github.com/NIPE-Solutions/flex-layout-migrator 使用方法: 安装工具 1npm install -g @ng-flex/layout-migrator 批量转换文件 1fxMigrate ./path/to/your/input/folder --output ./path/to/your/output/folder 单个文件转换 1fxMigrate ./path/to/your/input/file.html --output ./path/to/your/output/file.html 6. 罗列出系统中使用的所有flex-layout特性如果需要手动迁移可以参考以下实际案例 Angular Flex-Layout tailwind equivalent comments fxLayout=”column” class=”flex flex-col” fxLayout=”column” fxLayoutAlign=”start center” class=”flex flex-col justify-start items-center” fxLayout=”row” class=”flex flex-row” fxFlex=”100” class=”w-full” or class=”h-full” it’s w-full or h-full depends on the container is flex-col or flex-row fxLayoutGap=”8px” class=”gap-2” fxLayout=”row wrap” fxLayoutAlign=”start center” class=”flex flex-wrap justify-start items-center” fxFlex.xs=”100” fxFlex.sm=”50” fxFlex.md=”33.3” fxFlex.lg=”25” fxFlex.gt-lg=”20” class=”w-full sm:w-1/2 md:w-1/3 xl:w-1/5” fxFlexFill class=”w-full” or class=”h-full” fxFlex=”1 1 100%” class=”w-full” or class=”h-full” fxLayout.gt-sm=”row wrap” class=”flex flex-row md:flex-wrap” fxLayout=”column” fxLayoutAlign=”center center” class=”flex flex-col justify-center items-center” [fxShow]=”settings.displaySearchBar” [fxShow.xs]=”false” class=”hidden” [ngClass]=”settings.displaySearchBar?’flex’:’hidden’” fxLayoutAlign.xs=”start center” class=”justify-start items-center sm:justify-start sm:items-stretch” fxFlex=”80” fxFlex.gt-sm=”30” fxFlex.sm=”60” class=”w-4/5 md:w-[30%] sm:w-[60%]” [fxLayout]=”(menuParentId == 0) ? ‘row’ : ‘column’” [ngClass]=”(menuParentId == 0) ? ‘flex flex-row’ : ‘flex flex-col’” [fxLayoutAlign]=”(settings.menuType==’default’) ? ‘start center’ : ‘center center’” [ngClass]=”(settings.menuType==’default’) ? ‘justify-start items-center’ : ‘justify-center items-center’” 7. 设置默认的字体排版1npm install @tailwindcss/typography@latest --save-dev 修改tailwind.config.js 12345678910111213// tailwind.config.js module.exports = { theme: { ... }, variants: {}, plugins: [ require('@tailwindcss/typography'), ] } 通过require这个插件，我们收到了一个新的特殊实用程序类，名为prose。这个强大的类为任何普通HTML提供了排版样式。要使用这种功能，您所要做的就是将prose类添加到元素中。 123456789&lt;article class=&quot;prose&quot;&gt; &lt;h2&gt;This is a h2 heading, and will be styled by the prose class&lt;/h2&gt; &lt;p&gt;This paragraph tag is also styled by the prose class&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Even this list item&lt;/li&gt; &lt;li&gt;Cool he?&lt;/li&gt; &lt;/ul&gt;&lt;/article&gt; 现在，文章标记中的所有内容都应用了很好的样式设计。 8. 关联阅读tailwindcss教程 20 个最佳 Tailwind CSS 组件库 9. 参考文档Angular Layout Migration Guides You might not need Angular Flex-Layout The best way to set typographic defaults in Tailwind CSS","link":"/sass/tailwind_migration.html"},{"title":"tailwindcss教程","text":"1. 前言Tailwind 是一个基于 Atomic/Utility-First 规范 CSS 框架，提供了基础的工具类 utility classes（如：内边距 padding、字体 text 和 font、动画 transition 等预设类），能直接在脚本标记语言中组合起来，构建出您想要的设计。 Tailwind CSS 优点 可定制化程度极高 减少为 class 取名字的苦恼。 响应式设计Tailwind CSS 遵循移动优先的设计模式，断点系统很灵活。比如实现一个媒体查询，要求根据不同的屏幕宽度实现不同的图片宽度。传统写法如下 CSS 体积大幅降低 2. 安装tailwindcss针对不同的试用方式, 不同的web框架有不同的安装方式, 详情请参考官方的安装指南TailwindCSS installation,简言之, tailwindcss具有非常良好的整合性, 和大多数流行的web框架都能良好的协作. 无论我们使用哪种安装方式, 我们都需要生成tailwindcss配置文件. 这一点非常重要, 因为tailwindcss不像其它css框架, tailwindcss非常灵活, 非常容易定制. 3. 核心概念3.1. 工具类优先基本原理3.2. 响应式设计(Responsive design)使用响应式变量工具类构建自适应用户界面。 Tailwind 中的每个断点工具类都可以根据不同的屏幕宽度应用不同的样式，这使得构建复杂的响应式接口变得轻而易举。 默认情况根据常见设备分辨率分为五个断点： Breakpoint prefix Minimum width CSS 适应屏幕 sm 640px @media (min-width: 640px) { … } 手机竖屏 md 768px @media (min-width: 768px) { … } 手机横屏, 平板竖屏 lg 1024px @media (min-width: 1024px) { … } 平板横屏, 笔记本电脑屏幕 xl 1280px @media (min-width: 1280px) { … } 台式电脑屏幕 2xl 1536px @media (min-width: 1536px) { … } 巨屏 屏幕尺寸/分辨率/PPI大全 要添加工具类仅使其在某种屏幕尺寸生效，您所需要做的就是在工具类前面添加断点名称，如下: 12&lt;!-- Width of 16 by default, 32 on medium screens, and 48 on large screens --&gt;&lt;img class=&quot;w-16 md:w-32 lg:w-48&quot; src=&quot;...&quot;&gt; 这适用于框架中的每个工具类，这意味着您可以为给定屏幕尺寸更改任何内容 - 甚至是字母间距或光标样式之类的内容。 3.3. 深色模式(Dark mode)使用 Tailwind CSS 为您的网站设计深色模式。 基本用法现在，深色模式是许多操作系统的头等功能，设计网站的深色版本以配合系统默认设计变得越来越普遍。 为了使这一过程尽可能简单，Tailwind 提供了一个深色变体，可让您在启用深色模式时以不同的方式展现网站内容： 12345678910111213&lt;div class=&quot;bg-white dark:bg-slate-800 rounded-lg px-6 py-8 ring-1 ring-slate-900/5 shadow-xl&quot;&gt; &lt;div&gt; &lt;span class=&quot;inline-flex items-center justify-center p-2 bg-indigo-500 rounded-md shadow-lg&quot;&gt; &lt;svg class=&quot;h-6 w-6 text-white&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;!-- ... --&gt;&lt;/svg&gt; &lt;/span&gt; &lt;/div&gt; &lt;h3 class=&quot;text-slate-900 dark:text-white mt-5 text-base font-medium tracking-tight&quot;&gt;Writes Upside-Down&lt;/h3&gt; &lt;p class=&quot;text-slate-500 dark:text-slate-400 mt-2 text-sm&quot;&gt; The Zero Gravity Pen can be used to write in any orientation, including upside-down. It even works in outer space. &lt;/p&gt;&lt;/div&gt; 默认情况下，这使用prefers-color-scheme CSS 媒体功能，但您也可以使用“class”策略构建支持手动切换成深色模式的网站。 上例中, 当用户切换到深色模式, 最外层的div将应用背景颜色dark:bg-slate-800, 最内侧的文字颜色也会发生改变dark:text-white dark:text-slate-400 3.3.1. 手动切换深色模式如果您想支持手动切换深色模式而不是依赖操作系统偏好选项，请使用class策略而不是media策略： tailwind.config.js 123456module.exports = { darkMode: 'class', // ...} 现在，不再是基于操作系统偏好选项应用 dark:{class} 类，而是只要 HTML 树中出现深色类，就会应用深色模式。 12345678910111213141516171819&lt;!-- Dark mode not enabled --&gt;&lt;html&gt;&lt;body&gt; &lt;!-- Will be white --&gt; &lt;div class=&quot;bg-white dark:bg-black&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- Dark mode enabled --&gt;&lt;html class=&quot;dark&quot;&gt;&lt;body&gt; &lt;!-- Will be black --&gt; &lt;div class=&quot;bg-white dark:bg-black&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果您在 Tailwind 配置中设置了前缀，请务必将其添加到 dark 类中。 例如，如果您有 tw- 前缀，则需要使用 tw-dark 类来启用深色模式。如何将 dark 类添加到 html 元素取决于您，但常见的方法是使用一些 JS 从某处（例如 localStorage）读取首选项并相应地更新 DOM。 某些框架（如 NativeScript）有自己的方法来启用深色模式，并在深色模式处于活动状态时添加不同的类名。 您可以通过将 darkMode 设置为数组并将自定义选择器作为第二项来自定义深色模式选择器名称： tailwind.config.js 1234module.exports = { darkMode: ['class', '[data-mode=&quot;dark&quot;]'], // ...} 3.4. 添加自定义样式将您自己的自定义样式添加到 Tailwind 的最佳实践。 通常，使用框架时最大的挑战是弄清楚当框架无法为您处理您需要的某些内容时您应该做什么。 Tailwind 从一开始就被设计为可扩展和可定制的，因此无论您正在构建什么，您都不会觉得自己在与框架作斗争。 本指南涵盖的主题包括自定义设计令牌、如何在必要时突破这些限制、添加您自己的自定义 CSS 以及使用插件扩展框架等。 3.4.1. 定制您的主题如果您想更改调色板、间距比例、排版比例或断点等内容，请将自定义添加到 tailwind.config.js 文件的主题部分： tailwind.config.js 12345678910111213141516171819202122232425262728293031323334module.exports = { theme: { screens: { sm: '480px', md: '768px', lg: '976px', xl: '1440px', }, colors: { 'blue': '#1fb6ff', 'pink': '#ff49db', 'orange': '#ff7849', 'green': '#13ce66', 'gray-dark': '#273444', 'gray': '#8492a6', 'gray-light': '#d3dce6', }, fontFamily: { sans: ['Graphik', 'sans-serif'], serif: ['Merriweather', 'serif'], }, extend: { spacing: { '128': '32rem', '144': '36rem', }, borderRadius: { '4xl': '2rem', } } }} 在主题配置文档中了解有关自定义主题的更多信息。 3.4.2. 使用任意值虽然您通常可以使用一组受约束的design tokens来构建大部分精心制作的设计，但有时您需要突破这些约束以获得像素完美的东西。 当您发现自己确实需要像 top: 117px 这样的东西来在正确的位置获取背景图像时，请使用 Tailwind 的方括号表示法动态生成具有任意值的类： 12345&lt;div class=&quot;top-[117px]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 这基本上类似于内联样式，主要好处是您可以将其与交互式修饰符（如悬停）和响应式修饰符（如 lg）结合使用： 123&lt;div class=&quot;top-[117px] lg:top-[344px]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 这适用于框架中的所有内容，包括背景颜色、字体大小、伪元素内容等： 123&lt;div class=&quot;bg-[#bada55] text-[22px] before:content-['Festivus']&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 甚至可以使用 theme 函数来引用 tailwind.config.js 文件中的定义的值： 123&lt;div class=&quot;grid grid-cols-[fit-content(theme(spacing.32))]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 当使用 CSS 变量作为任意值时，不需要将变量包装在 var(…) 中 - 只需提供实际的变量名称就足够了： 123&lt;div class=&quot;bg-[--my-color]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 3.4.3. 任意属性如果您需要使用 不包含在Tailwind 范围内的的 CSS 属性，您还可以使用方括号表示法来编写完全任意的 CSS： 12345&lt;div class=&quot;[mask-type:luminance]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 这确实很像内联样式，但同样具有可以使用修饰符的好处： 123&lt;div class=&quot;[mask-type:luminance] hover:[mask-type:alpha]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 这对于 CSS 变量之类的东西也很有用，特别是当它们需要在不同条件下更改变量时： 123&lt;div class=&quot;[--scroll-offset:56px] lg:[--scroll-offset:44px]&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 4. Colors5. Customization6. Typography7. Spaces &amp; Sizes8. Flex9. Grids10. Layouts11. Borders12. Effects &amp; filters13. Animations14. Core Concepts15. Design System16. Dark mode17. 关联阅读从@Angular/Flex-Layout 迁移到 Tailwindcss 20 个最佳 Tailwind CSS 组件库 18. 参考文档TailwindCSS 快速入门教程 tailwind-elements","link":"/sass/tailwindcss_tutorial.html"},{"title":"快速的将web应用转化为桌面应用","text":"1. 前言本文讲述如何将Web应用转化为桌面应用。 2. 安装 TAURI CLI123npm install --save-dev @tauri-apps/cli 3. 配置npm run命令添加tauri脚本, 在package.json中添加一个tauri脚本用于调用tauri cli 123&quot;scripts&quot;: { &quot;tauri&quot;: &quot;tauri&quot;} 搭建一个使用 Tauri 的简单 Rust 项目 1npm run tauri init 运行您的应用程序 1npm run tauri dev 4. 参考文档Tauri集成已有项目 【05】Tauri 入门篇 - 跨平台编译","link":"/tauri/convert_web-app_into_desktop.html"},{"title":"在Linux上配置Tauri环境","text":"1. 前言本文讲述如何在linux操作系统中配置Tauri编译, 打包环境. 2. 安装依赖工具和开发包您将需要安装几个系统依赖项，例如C编译器和webkit2gtk。以下是一些流行发行版的命令： debian 系列Linux发行版, 123456789101112131415sudo apt updatesudo apt install libwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ file \\ libssl-dev \\ libgtk-3-dev \\ libayatana-appindicator3-dev \\ librsvg2-dev## for Ubuntu 22.04+sudo apt install libfuse2 Fedora/RHEL系列 123456789101112131415161718192021222324# for Fedora 36+ sudo dnf check-updatesudo dnf install webkit2gtk4.0-devel \\ openssl-devel \\ curl \\ wget \\ file \\ libappindicator-gtk3-devel \\ librsvg2-develsudo dnf group install &quot;C Development Tools and Libraries&quot;# for Fedora 36 and belowsudo dnf check-updatesudo dnf install webkit2gtk3-devel \\ openssl-devel \\ curl \\ wget \\ file \\ libappindicator-gtk3-devel \\ librsvg2-develsudo dnf group install &quot;Development Tools&quot; Arch系列 12345678910111213sudo pacman -Syusudo pacman -S --needed \\ webkit2gtk \\ base-devel \\ curl \\ wget \\ file \\ openssl \\ appmenu-gtk-module \\ gtk3 \\ libappindicator-gtk3 \\ librsvg \\ libvips 3. 安装RustRust环境如果已经安装过, 可以忽略此步骤. 如果未安装或者需要升级, 请参考的博客鹏叔的技术博客 - 在各种操作系统上安装和配置Rust 4. 关联阅读创建gitlab pipeline打包Tauri跨平台应用程序 Tauri cli详解 在Linux上配置Tauri环境 使用Tauri和Angular创建桌面应用程序 Tauri开发环境配置 Tauri Mobile-使用JavaScript和Rust开发移动应用程序 5. 参考文档Setting Up Linux Can’t Run AppImage on Ubuntu 22.04? Here’s How to Fix it","link":"/tauri/setup_tauri_for_linux.html"},{"title":"使用Tauri和Angular创建桌面应用程序","text":"1. 前言Tauri 是一个应用程序构建工具包，可让您使用 Web 技术为所有主要桌面操作系统构建软件。核心库是用 Rust 编写的，用户界面几乎可以使用任何前端框架编写。它包括一个可选的、tree-shakeable JavaScript API用于舒适地访问底层操作系统、一个具有签名和验证的桌面二进制捆绑器、一个让您的用户保持最新版本的安全更新程序、一个可扩展的插件系统以及支持与操作系统整合，例如通知和应用程序托盘。 Tauri 使用简单且易于扩展。对于 Rust 编程语言的新手，Tauri 提供了一个舒适的学习环境，将与您一起成长。安装 Rust 后，创建您的第一个应用程序只需运行create-tauri-app. 但如果您希望保持 100% Rust 的安全性和舒适性，那么您根本不必使用 Node.js。 我们为注重安全、尊重隐私和具有环保意识的软件工程社区构建 Tauri Tauri的设计哲学: 我们为注重安全、尊重隐私和具有环保意识的软件工程社区构建Tauri. 2. 预先准备首先您需要安装 Rust 及其他系统依赖。安装Rust环境可以参考鹏叔的技术博客 - Windows上安装Rust 3. 创建一个tauri功能123npm create tauri-app 这里的npm create实际是npm init的别名, tauri-app是一个initializer 对应的npm包为create-tauri-app, 关于npm create的详细讲解请参考鹏叔的技术博客 - npm create命令详解 12345C:\\code&gt;npm create tauri-app✔ Project name · your_project_name✔ Choose which language to use for your frontend · TypeScript / JavaScript - (pnpm, yarn, npm)✔ Choose your package manager · npm✔ Choose your UI template · Angular - (https://angular.io/) 输入应用名称选择前端语言选择包管理工具选择UI template, 正如标题所说, 本文主要讲述使用Tauri和Angular创建桌面应用程序, 所以这里我选择Angular 初始化完成后, 项目的目录结构如下: 1234567891011121314151617181920212223$tree -I &quot;node_modules&quot; -L 2your_project_name # 项目名称├── node_modules # 前端依赖├── README.md # 项目介绍文件├── angular.json # Angular工程配置文件├── package-lock.json # 前端依赖的精确描述信息├── package.json # 前端项目清单├── src # 前端程序源│ ├── app # Angular 类, 模板, 样式, 组件等│ ├── assets # 图片等静态资源│ ├── index.html # 项目主界面│ ├── main.ts # Angular应用入口文件│ └── styles.scss # css样式文件├── src-tauri│ ├── Cargo.lock # 包含了依赖的精确描述信息，类似于 yarn.lock 或 package-lock.json│ ├── Cargo.toml # Tauri (Rust) 项目清单│ ├── build.rs # Tauri 构建应用│ ├── icons # 应用程序图标│ ├── src # Tauri App 程序源，例如系统菜单，托盘，插件配置等│ ├── target # 构建的产物会被放入此文件夹中，target 目录的结构取决于是否使用 --target 标志为特定的平台构建│ └── tauri.conf.json # 自定义 Tauri 应用程序的配置文件，例如应用程序窗口尺寸，应用名称，权限等├── tsconfig.app.json # Angular要用到的typescript 配置文件└── tsconfig.json # typescript 配置文件 4. 编译运行项目创建成功后, 进入项目根目录, 安装依赖. 123npm install 启动程序 123npm run tauri dev 执行以上命令, 如果没有严重错误, 一个桌面应用程序将会自动打开. 第一次运行此命令时，Rust包管理器需要几分钟的时间来下载和构建所有必需的包。由于它们是缓存的，所以后续的构建要快得多，因为只有您的代码需要重新构建。Rust构建完成后，会打webview显示您的应用程序。你可以对你的应用程序进行更改，如果应用程序已经打开，webview应该像浏览器一样自动更新。当你对Rust文件进行更改时，它们会自动重建，你的应用程序也会自动重新启动。 5. 构建应用Tauri Bundler 是一个 Rust 工具，用于编译二进制文件、打包资产并准备最终捆绑包。 它会检测你当前的操作系统并相应地构建一个包。目前支持： Windows: .msi macOS: .app, .dmg Linux: .deb, .appimage 123npm run tauri build 如果未修改 src-tauri/tauri.conf.json 中的 identifier 直接 build 会报以下错误。想要正确构建，只需修改为自己特有的标识符即可，如 com.myapp.dev。构建完成后，在 src-tauri/target/release/bundle/{platform}/{app} 下就可以找到应用程序安装包。参考问题排查问题4 了解更多不同平台打包注意事项：Tauri Building 6. 如何debug tauri前端程序在开发阶段，可以使用如下命令，编译并允许Tauri应用，应用会自动打开， 右键菜单会出现inspect选项，点击inspect就能调出devtools程序。 123npm run tauri dev 或者，打包时加上debug选项如下： 123npm run tauri buid -- --debug 使用如上命令打包的安装包是带有debug功能的， 安装软件后打开应用， 右键菜单会出现inspect选项，点击inspect就能调出devtools程序。 7. 问题排查问题1: 在执行npm run tauri dev 时, 超时 123√ Compiled successfully.; class=Os (2)ous network error (2 tries remaining): failed to send request: 操作超时; class=Os (2)ous network error (1 tries remaining): failed to send request: 操作超时 原因是: cargo需要远程下载以下crate超时, 需正确配置cargo使用国内镜像, 超时原因你懂的. 关注我的博客首页可以获得解决办法. 问题2: 在执行npm run tauri build, nsis-3.zip下载不了 解决办法: 手动下载nsis-3.zip, 将加压后的文件夹nsis-3.08文件夹重命名为NSIS, 放到C:\\Users&lt;UserName&gt;\\AppData\\Local\\tauri目录下. 问题3: 在执行npm run tauri build, 无法下载NSIS-ApplicationID.zip 12Error failed to bundle project: `https://github.com/tauri-apps/binary-releases/releases/download/nsis-plugins-v0/NSIS-ApplicationID.zip: Connection Failed: Connect error: 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。 (os error 10060)` 解决办法: 手动下载 NSIS-ApplicationID.zip, 将解压后的文件放到NSIS\\Plugins并将NSIS\\Plugins\\ReleaseUnicode\\ApplicationID.dll复制到NSIS\\Plugins\\x86-unicode\\ApplicationID.dll 将nsis_tauri_utils.dll 复制到NSIS\\Plugins\\x86-unicode\\nsis_tauri_utils.dll 问题4: 当执行npm run tauri build报如下错误 1Error You must change the bundle identifier in `tauri.conf.json &gt; tauri &gt; bundle &gt; identifier`. The default value `com.tauri.dev` is not allowed as it must be unique across applications. 原因: 默认生成的bundle identifier不是唯一的很容易跟其它应用冲突 问题5: 使用_setup.exe二进制安装包安装的应用程序报错: “由于找不到WebView2Loader.dll, 重新安装此程序可能会解决问题.” 问题分析: 同一个打包过程, 打出的msi安装包没有此问题, 但是在_setup.exe中该文件缺失. 将WebView2Loader.dll手动拷贝到应用程序同级的目录下, 在执行应用程序, 错误消失. 查看了官方文档, nsis配置文件是可以定制的, 需要添加与打包msi格式相同的一段代码, 拷贝.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\webview2-com-sys-0.19.0\\x64\\WebView2Loader.dlldll文件到 可能的解决办法可以是自定义nsis 另外还有一种办法是将WebView2Loader.dll作为额外的资源文件添加到安装包中, 参考Embedding Additional Files. 8. 关联阅读创建gitlab pipeline打包Tauri跨平台应用程序 Tauri cli详解 在Linux上配置Tauri环境 使用Tauri和Angular创建桌面应用程序 Tauri开发环境配置 Tauri Mobile-使用JavaScript和Rust开发移动应用程序 9. 相关文章本文原文位于使用Tauri和Angular创建桌面应用程序, 欢迎访问原文以获得最近更新.更多Angular相关文章请访问Angular合集 | 鹏叔的技术博客 10. 参考文档Tauri开发指南 - 预先准备 nsis 下载超时 Tauri 入门篇 - 创建项目","link":"/tauri/tauri_angular_desktop.html"},{"title":"Tauri cli详解","text":"1. 前言这是一份Tauri cli中文版详细说明文档, 由philoenglish.com团队翻译.原文位于鹏叔的技术博客 - Tauri cli详解, 要获得最近更新及反馈问题请访问原文! 2. infoinfor命令用于显示有关Tauri依赖项和项目配置的信息 用法: cargo-tauri info [OPTIONS] 12345678910# for npmnpm run tauri info# for yarnyarn tauri info# for pnpmpnpm tauri info# for Cargocargo tauri info 选项: 1234 --interactive 交互模式用于自动修复-v, --verbose... 开启详细日志-h, --help 打印帮助信息-V, --version 查询版本号 它可以用来显示了开发环境、Rust、Node.js 及其版本以及一些相关配置的简明信息列表。 当您需要快速概览应用程序时，此命令非常有用。当您请求帮助时，与我们分享此报告可能会很有用。 示例1: 查看项目配置信息 12345678910111213141516171819202122232425262728293031323334$ npm run tauri info&gt; xxx-web@1.0.0 tauri&gt; tauri info[✔] Environment - OS: Windows 10.0.22000 X64 ✔ WebView2: 114.0.1823.51 ✔ MSVC: Visual Studio Build Tools 2017 ✔ rustc: 1.68.0 (2c8cc3432 2023-03-06) ✔ Cargo: 1.68.0 (115f34552 2023-02-26) ✔ rustup: 1.25.2 (17db695f1 2023-02-01) ✔ Rust toolchain: stable-x86_64-pc-windows-msvc (default) - node: 18.16.1 - npm: 9.5.1[-] Packages - tauri [RUST]: 1.4.1 - tauri-build [RUST]: 1.4.0 - wry [RUST]: 0.24.3 - tao [RUST]: 0.16.2 - @tauri-apps/api [NPM]: not installed! - @tauri-apps/cli [NPM]: 1.4.0[-] App - build-type: bundle - CSP: unset - distDir: ../dist/ - devPath: http://localhost:4200/ - framework: Angular - bundler: Webpack 示例2: 查看版本 123456$ npm run tauri info -- --version&gt; xxxx-web@1.0.0 tauri&gt; tauri info --versiontauri-cli-info 1.4.0 3. init初始化Tauri项目 用法: cargo-tauri init [OPTIONS] 12345678910# for npmnpm run tauri init# for yarnyarn tauri init# for pnpmpnpm tauri init# for Cargocargo tauri init 选项: 1234567891011121314151617181920212223242526272829Options: --ci 跳过输入提示 -v, --verbose... 开启详细日志 -f, --force 强制覆盖src-tauri文件夹 -l, --log 开启日志记录 -d, --directory &lt;DIRECTORY&gt; 设置init的目标目录 [默认值: /home/runner/work/tauri-docs/tauri-docs] -t, --tauri-path &lt;TAURI_PATH&gt; Tauri项目的保存路径（相对于当前工作目录） -A, --app-name &lt;APP_NAME&gt; Tauri应用程序的名称 -W, --window-title &lt;WINDOW_TITLE&gt; Tauri应用程序的窗口标题 -D, --dist-dir &lt;DIST_DIR&gt; Web资源文件的位置，相对于&lt;project-dir&gt;/src-tauri -P, --dev-path &lt;DEV_PATH&gt; 开发服务器的Url --before-dev-command &lt;BEFORE_DEV_COMMAND&gt; 在“tauri dev”启动之前运行的shell命令 --before-build-command &lt;BEFORE_BUILD_COMMAND&gt; 在“tauri build”开始之前运行shell命令 -h, --help 在控制台打印帮助信息 -V, --version 在控制台打印版本信息 示例: 打印版本信息 12345678$npm run tauri init -- -V&gt; demo-web@1.0.0 tauri&gt; tauri init -Vtauri-cli-init 1.4.0 4. plugin init初始化Tauri插件项目 用法: cargo-tauri plugin init [OPTIONS] --name &lt;PLUGIN_NAME&gt; 12345678910# for npmnpm run tauri plugin init# for yarnyarn tauri plugin init# for pnpmpnpm tauri plugin init# for cargocargo tauri plugin init 选项: 1234567891011Options: -n, --name &lt;PLUGIN_NAME&gt; Tauri插件的名称 -v, --verbose... 开启详细日志 --api 使用TypeScript API初始化Tauri插件 -d, --directory &lt;DIRECTORY&gt; 设置init的目标目录 [默认: /home/runner/work/tauri-docs/tauri-docs] -t, --tauri-path &lt;TAURI_PATH&gt; Tauri项目的路径 (相对于当前工作目录) -a, --author &lt;AUTHOR&gt; 作者名称 -h, --help 打印帮助信息 -V, --version 打印版本信息 示例: 打印版本信息 123456$npm run tauri plugin init -- -V&gt; demo-web@1.0.0 tauri&gt; tauri plugin init -Vtauri-cli-plugin-init 1.4.0 5. devtauri dev 命令用于在开发模式下启动 Tauri 应用程序。在开发模式下，Tauri 应用程序会将前端和后端代码捆绑在一起，并将其加载到一个 Web 浏览器中。这使得开发人员可以轻松地调试应用程序，并查看应用程序在不同平台上的运行情况。 用法: cargo-tauri dev [OPTIONS] [ARGS]... 12345678# for npmnpm run tauri dev# for yarnyarn tauri dev# for pnpmpnpm tauri dev# for cargocargo tauri dev 参数和选项: 123456789101112131415161718参数: [ARGS]... 传递给运行程序的命令行参数。将“--”之后的参数传递给应用程序Options: -r, --runner &lt;RUNNER&gt; 用于运行应用程序的二进制文件 -v, --verbose... 开启详细日志 -t, --target &lt;TARGET&gt; 针对triple目标进行构建 -f, --features [&lt;FEATURES&gt;...] 要激活的Cargo功能列表 -e, --exit-on-panic panic时退出 -c, --config &lt;CONFIG&gt; 要与tauri.conf.JSON合并的JSON字符串或JSON文件路径 --release 在release模式下运行代码 --no-watch 禁用文件监视程序 --no-dev-server 禁用静态文件的dev server --port &lt;PORT&gt; 为静态文件指定开发服务器的端口。默认值为1430也可以使用`TAURI_DEV_SERVER_PORT`环境变量 -h, --help 打印帮助信息 -V, --version 打印版本信息 此命令将在开发模式下打开WebView。它利用了src-tauri/tauri.conf.json文件中的build.devPath属性。如果您在build.beforeDev Command属性中输入了一个命令，那么这个命令将在dev命令之前执行。 TROUBLESHOOTING:如果您没有使用build.beforeDev Command，请确保您的build.devPath是正确的，如果使用的是开发服务器，请确保它在使用此命令之前已启动。 6. buildTauri build 用法: cargo-tauri build [OPTIONS] [ARGS]... 12345678910# for npmnpm run tauri build# for yarnyarn tauri build# for pnpmpnpm tauri build# for cargocargo tauri build 参数和选项: 123456789101112131415161718192021222324252627282930313233343536373839404142参数: [ARGS]... 传递给Runner的命令行参数Options: -r, --runner &lt;RUNNER&gt; 用于构建应用程序的二进制文件，默认为`cargo` -v, --verbose... 开启详细日志 -d, --debug 调试标志 -t, --target &lt;TARGET&gt; 构建triple目标。 对于通用macOS应用程序，它必须是“$rustc--print target list”或“universal apple darwin”输出的值之一。 请注意，编译通用macOS应用程序需要同时安装“aarch64-apple-darwin”和“x86_64-apple-darwin”目标。 -f, --features [&lt;FEATURES&gt;...] 空格或逗号分隔的要激活的功能列表 -b, --bundles [&lt;BUNDLES&gt;...] 空格或逗号分隔的要打包的bundle列表。 每个bundle必须是MacOS上的“deb”、“appimage”、“msi”、“app”或“dmg”中的一个，以及所有平台上的“updater”。如果指定了“none”，则将跳过绑定程序。 请注意，“updater”bundle不是自动添加的，因此如果启用了updater，则必须指定它。 -c, --config &lt;CONFIG&gt; 要与tauri.conf.JSON合并的JSON字符串或JSON文件路径 --ci 跳过输入提示 -h, --help 打印帮助信息 -V, --version 打印版本信息 如果您使用–debug标志，此命令将打包您的应用程序，无论是在生产模式还是调试模式。它利用了src-tauri/tauri.conf.json文件中的build.distDir属性。如果您在build.beforBuildCommand属性中设置了一个命令，则此命令将在build命令之前执行。 7. icon为所有主要平台生成各种图标. Tauri附带了一个基于其标志的默认图标集。当您分发应用程序时，这不是您想要的。为了纠正这种常见的情况，Tauri提供了图标命令，该命令将获取一个输入文件（默认为“./app-icon.png”），并创建各种平台所需的所有图标。 源图像文件要求: png图片 源图像必须为方形, 即长宽比一定要是1:1, 例如都是图片分辨率592*592 用法: cargo-tauri icon [OPTIONS] [INPUT] 12345678910# 通过npm调用npm run tauri icon# 通过yarn调用yarn tauri icon# 通过pnpm调用pnpm tauri icon# 通过cargo调用cargo tauri icon 参数和选项: 1234567891011Arguments: [INPUT] 源图标的路径（png，带透明度的1240x1240px）[默认值：./app icon.png]Options: -o, --output &lt;OUTPUT&gt; 输出目录。默认值：tauri.conf.json文件同级的“icons”目录 -v, --verbose... 开启详细日志 -p, --png &lt;PNG&gt; 要生成的自定义PNG图标大小。设置后，不会生成默认图标 -h, --help 打印帮助信息 -V, --version 打印版本信息 有关更多信息，请查看完整的Tauri图标指南。 8. completions命令补全 用法: cargo-tauri completions [OPTIONS] --shell \\&lt;SHELL&gt; 12345678910# 通过npm调用npm run tauri completions# 通过yarn调用yarn tauri completions# 通过pnpm调用pnpm tauri completions# 通过cargo调用cargo tauri completions 选项: 12345678Options: -s, --shell &lt;SHELL&gt; 要为其生成命令补全脚本的Shell类型。[可能的值：bash、elvish、fish、powershell、zsh] -v, --verbose... 开启详细日志 -o, --output &lt;OUTPUT&gt; shell命令补全的输出文件。默认情况下，完成打印到控制台. -h, --help 打印帮助信息 -V, --version 打印版本信息 Tauri CLI可以为Bash、Zsh、PowerShell和Fish生成shell补全。以下是一些配置Bash、Zsh和PowerShell的说明。如果您遇到问题，请按照shell的说明进行操作。请注意，出于安全原因，建议在执行生成的完成脚本之前先进行检查。 8.1. Bash生成Bash补全并移动到已知文件夹： 用法: 123456789101112131415161718# 通过npm生成npm run tauri completions -- --shell bash &gt; tauri.shmv tauri.sh /usr/local/etc/bash_completion.d/tauri.bash# 通过yarn生成yarn tauri completions --shell bash &gt; tauri.shmv tauri.sh /usr/local/etc/bash_completion.d/tauri.bash# 通过pnpm生成pnpm tauri completions --shell bash &gt; tauri.shmv tauri.sh /usr/local/etc/bash_completion.d/tauri.bash# 通过cargo生成cargo tauri completions --shell bash &gt; tauri.shmv tauri.sh /usr/local/etc/bash_completion.d/tauri.bash 通过在.bashrc中添加以下内容来加载completions脚本： 123source /usr/local/etc/bash_completion.d/tauri.bash 8.2. Zsh生成Zsh补全并移动到已知文件夹： 用法: 123456789101112131415161718192021# 通过npm生成npm run tauri completions -- --shell zsh &gt; completions.zshmv completions.zsh $HOME/.completions/_tauri# 通过yarn生成yarn tauri completions --shell zsh &gt; completions.zshmv completions.zsh $HOME/.completions/_tauri# 通过pnpm生成pnpm tauri completions --shell zsh &gt; completions.zshmv completions.zsh $HOME/.completions/_tauri# 通过cargo生成cargo tauri completions --shell zsh &gt; completions.zshmv completions.zsh $HOME/.completions/_tauri 使用fpath加载completions文件夹，并将以下内容添加到.zshrc： 12fpath=(~/.completions $fpath)autoload -U compinit 8.3. PowerShell生成PowerShell补全并将其添加到$profile文件中，以便在所有会话上执行它： 123456789101112131415161718# 通过npm生成npm run tauri completions -- --shell powershell &gt; ((Split-Path -Path $profile)+&quot;\\_tauri.ps1&quot;)Add-Content -Path $profile -Value '&amp; &quot;$PSScriptRoot\\_tauri.ps1&quot;'# 通过yarn生成yarn tauri completions --shell powershell &gt; ((Split-Path -Path $profile)+&quot;\\_tauri.ps1&quot;)Add-Content -Path $profile -Value '&amp; &quot;$PSScriptRoot\\_tauri.ps1&quot;'# 通过pnpm生成pnpm tauri completions --shell powershell &gt; ((Split-Path -Path $profile)+&quot;\\_tauri.ps1&quot;)Add-Content -Path $profile -Value '&amp; &quot;$PSScriptRoot\\_tauri.ps1&quot;'# 通过cargo生成cargo tauri completions --shell powershell &gt; ((Split-Path -Path $profile)+&quot;\\_tauri.ps1&quot;)Add-Content -Path $profile -Value '&amp; &quot;$PSScriptRoot\\_tauri.ps1&quot;' 9. version描述:获取tauri版本信息 用法: 12345678910# 通过npm获取版本信息npm run tauri -- --version# 通过yarn获取版本信息yarn tauri -- --version# 通过pnpm获取版本信息pnpm tauri -- --version# 通过cargo获取版本信息cargo tauri -- --version 10. 关联阅读创建gitlab pipeline打包Tauri跨平台应用程序 Tauri cli详解 在Linux上配置Tauri环境 使用Tauri和Angular创建桌面应用程序 Tauri开发环境配置 Tauri Mobile-使用JavaScript和Rust开发移动应用程序 11. 参考文档Tauri Cli 使用Tauri自带命令生成各平台图标方法，超级简单，只需要一张png图片","link":"/tauri/tauri_cli.html"},{"title":"Tauri Debug","text":"在本文中我们将详细讲解在各平台如何debug tauri项目。 Tauri 程序是使用 Tauri 工具包构建的桌面应用程序。Tauri 是一个开源的应用构建工具包，可用将使用 Web 技术（HTML、CSS 和 JavaScript）构建程序包装成桌面应用程序。 1. 了解Tauri项目结构在进行Tauri Debug之前， 我需要了解一个Tauri项目的典型结构。 在我的博客使用Tauri和Angular创建桌面应用程序中详细解剖了一个典型的应用程序结构如下： 1234567891011121314151617181920212223your_project_name # 项目名称├── node_modules # 前端依赖├── README.md # 项目介绍文件├── angular.json # Angular工程配置文件├── package-lock.json # 前端依赖的精确描述信息├── package.json # 前端项目清单├── src # 前端程序源│ ├── app # Angular 类, 模板, 样式, 组件等│ ├── assets # 图片等静态资源│ ├── index.html # 项目主界面│ ├── main.ts # Angular应用入口文件│ └── styles.scss # css样式文件├── src-tauri│ ├── Cargo.lock # 包含了依赖的精确描述信息，类似于 yarn.lock 或 package-lock.json│ ├── Cargo.toml # Tauri (Rust) 项目清单│ ├── build.rs # Tauri 构建应用│ ├── icons # 应用程序图标│ ├── src # Tauri App 程序源，例如系统菜单，托盘，插件配置等│ ├── target # 构建的产物会被放入此文件夹中，target 目录的结构取决于是否使用 --target 标志为特定的平台构建│ └── tauri.conf.json # 自定义 Tauri 应用程序的配置文件，例如应用程序窗口尺寸，应用名称，权限等├── tsconfig.app.json # Angular要用到的typescript 配置文件└── tsconfig.json # typescript 配置文件 从以上结构我们可以看出，一个典型Tauri项目一般分为两部分： src 第一部分是位于src下的前端代码，包括HTML，样式文件和js或ts脚本，其允许在webview中，其作用是用来展现应用视图，以及与用户进行交互； src-tauri 第二部分是位于src-tauri部分， 这部分代码主要是使用Rust编写，最终也运行在终端上，如桌面端和移动端。 其有多种作用，首先其相当前端应用的壳，将前端程序包装成特定平台的应用程序，并负责与前端平台例如（Windows, Linux, Macos, Android, iOS)进行交互。 其二， 它也可用与前端应用程序进行交互，以增强前端应用程序的功能。由于前端应用只允许运行在webview上，其功能受到很大限制， 而src-tauri编译出来的应用程序运行在操作系统上和native应用具有相同的权限，具有更强的与系统交互的能力。 其三， src-tauri部分也可以直接与后端程序进行交互。 而debug这两部分代码的方式是不同的。多数情况下我们debug前端程序我们需要借助devtool工具；而debug src-tauri我们需要借助Rust相关debug工具。 2. 前端debug2.1. 开发阶段debug在开发过程中，我们可以使用debug选项启动项目。关于tauri命令详解， 可以参考我的文档Tauri cli详解 123npm run tauri dev 系统将会打开应用程序，在应用程序界面右键菜单，选择检查（inspect）打开Devtools进行debug, 后续操作跟浏览器上debug几乎一样，这里就不详细展开来讲了。 2.2. 测试环境debug有时我们的应用发布到测试环境例如QA环境，或者UAT环境后依然会出错，此时如何进行debug呢？ 如果在打包时带上debug选项，生成的应用程序是支持debug的。 123npm run tauri build -- --debug 将应用在测试环境安装并打开， 在右键菜单中会存在检查（inspect）， 点击检查菜单即可打开Devtools程序进行debug。 3. src-tauri debug创建一个.vscode/launch.json文件，并将以下json内容粘贴到其中： 12345678910111213141516171819202122232425262728293031323334{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Tauri Development Debug&quot;, &quot;cargo&quot;: { &quot;args&quot;: [ &quot;build&quot;, &quot;--manifest-path=./src-tauri/Cargo.toml&quot;, &quot;--no-default-features&quot; ] }, // task for the `beforeDevCommand` if used, must be configured in `.vscode/tasks.json` &quot;preLaunchTask&quot;: &quot;ui:dev&quot; }, { &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Tauri Production Debug&quot;, &quot;cargo&quot;: { &quot;args&quot;: [&quot;build&quot;, &quot;--release&quot;, &quot;--manifest-path=./src-tauri/Cargo.toml&quot;] }, // task for the `beforeBuildCommand` if used, must be configured in `.vscode/tasks.json` &quot;preLaunchTask&quot;: &quot;ui:build&quot; } ]} 这启动脚本直接使用cargo来构建Rust应用程序，并在开发和生产模式中加载它。请注意，它不使用Tauri CLI，因此不执行独占CLI功能。beforeDevCommand和beforeBuildCommand脚本必须事先执行，或者在preLaunchTask字段中配置为任务。下面是一个示例.vscode/tasks.json文件，它有两个任务，一个用于生成开发服务器的beforeDevCommand，另一个用于beforeBuildCommand： .vscode/tasks.json 123456789101112131415161718192021222324252627{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;ui:dev&quot;, &quot;type&quot;: &quot;shell&quot;, // `dev` keeps running in the background // ideally you should also configure a `problemMatcher` // see https://code.visualstudio.com/docs/editor/tasks#_can-a-background-task-be-used-as-a-prelaunchtask-in-launchjson &quot;isBackground&quot;: true, // change this to your `beforeDevCommand`: &quot;command&quot;: &quot;yarn&quot;, &quot;args&quot;: [&quot;dev&quot;] }, { &quot;label&quot;: &quot;ui:build&quot;, &quot;type&quot;: &quot;shell&quot;, // change this to your `beforeBuildCommand`: &quot;command&quot;: &quot;yarn&quot;, &quot;args&quot;: [&quot;build&quot;] } ]} 现在，您可以在src-tauri/src/main.rs或任何其他Rust文件中设置断点，并按F5键开始调试 4. 参考文档Application Debugging","link":"/tauri/tauri_debug.html"},{"title":"Tauri开发环境配置","text":"1. 前言本文要介绍的Tauri，一个多语言工具链，可使用小型和快速的二进制文件构建安全的原生应用。官网地址：https://tauri.app/. 2. 开发环境说明操作系统: windows 11 家庭版 3. 安装 Build Tools for Visual Studio 20223.1. 下载 Microsoft C++ 生成工具下载地址位于visual-cpp-build-tools 进入下载页面后点击”下载工具生成”进行下载. 下载完vs_BuildTools后, 双击打开. 首先选择Desktop development with C++, 在右侧侧边栏选择需要安装的组件, 确保至少Windows 10 SDK (10.0.19041.0)和MSVC v143 - VS 2022 C++ x64/x86 被包括在内. 版本一定要对上. 然后按指引安装即可. 4. 关联阅读创建gitlab pipeline打包Tauri跨平台应用程序 Tauri cli详解 在Linux上配置Tauri环境 使用Tauri和Angular创建桌面应用程序 Tauri开发环境配置 Tauri Mobile-使用JavaScript和Rust开发移动应用程序","link":"/tauri/tauri_env_setup.html"},{"title":"创建gitlab pipeline打包Tauri跨平台应用程序","text":"1. 前言关于如何对 Tauri 项目进行打包和发布, 在 Tauri 的官方网站实际上只做了基本的介绍. 而且由于 Tauri 或者说是 Rust 对跨平台编译以及打包支持得不是很好. 所以到底如何在 Github.com 以外得平台进行编译打包, 讲得不够详细. 本人希望搜索到能对这方面有所补充的博客文章, 但是也没有找到. 包括一些英文方面的资料以及视频教程都不理想。 网上关于 Tauri 的 devops 自动化编译打包部署方面都是照本宣科, 按照官方的介绍使用 github action 进行配置. 而这些内容对于企业开发或者非开源项目来说帮助非常有限. 于是我静下心来, 花费了一些时间, 将这 Tauri devops 部分内容以中文的形式整理出来, 以供对后来者有所帮助. 一来是出于对开源运动的支持, 二来我是非常喜欢 Tauri, 经过测试, 我发现这就是我心中一直在找的一种跨平台解决方案, 有一种众里寻他千百度, 蓦然回首, 那人却在灯火阑珊处的感觉, 所以我很愿意将我在 Tauri 上的研究分享出来, 以帮助到更多的同道中人. 考虑到将所有内容都放在一篇文章中内容可能有些杂乱, 冗长. 于是我将内容打撒成一些小的文章, 然后将其整合到这篇文章, 中间也重用了一些之前的写的文章. 当然也是将单一职责原则应用的日常的写作中来, 也即每篇文章讲一个非常小的主题。学以致用嘛。 特别说明，虽然本文是以 gitlab pipeline 为例, 但是对其它各种自动化平台创建 devops pipeline 也会有参考价值. 另外本文对于非 Tauri 项目创建 gitlab pipeline 也要实际操作层面的价值. 本文原文发布在我的博客网站快速的将 web 应用转化为桌面应用 | 鹏叔的技术博客, 要获取最新更新, 请访问原文. 更多 Tauri 相关话题, 请访问鹏叔的技术博客 - Tauri 专题, 后续文章将持续更新到该专题中. 2. macOS 开发环境配置2.1. 安装 macOS 虚拟机当然如果有钱又任性, 完全可以忽略这一步, 直接买几台不同版本的 Macbook 用于打包和测试工作, 完全可以跳过这一步. 但是如果您有降本增效考量, 采购流程又很漫长且复杂, 可以考虑安装 Macos 虚拟机来达到同样的目的. 安装 macOS 虚拟机, 可以参考我的博客鹏叔的博客空间 - 如何安装一台 MacOS 虚拟机 2.2. macOS 上配置 rust安装和配置 Rust 可以参考我的博客鹏叔的技术博客 - 在各种操作系统上安装和配置 Rust 2.3. macOS 上配置 nodejs安装和配置 nodejs 可以参考我的博客鹏叔的技术博客 - MacOS 上安装 nvm 3. Ubuntu 环境配置3.1. 安装 Ubuntu 虚拟机安装 Ubuntu 虚拟机参考鹏叔的技术博客 - 安装 Ubuntu 虚拟机 3.2. Ubuntu 上配置 rust安装和配置 Rust 可以参考我的博客鹏叔的技术博客 - 在各种操作系统上安装和配置 Rust 3.3. Ubuntu 上配置 nodejs安装和配置 nodejs 可以参考我的博客鹏叔的技术博客 - 安装并配置 nodejs 以及一篇关于升级 nodejs 的文章, 里面有关于安装 typescript, angular cli 的部分. 4. Windows 开发环境配置4.1. 安装 Windows 虚拟机可以在 VMWare 或 VMware ESXi 上安装 windows 虚拟机来用以编译,测试 和打包. 但是由于安装包都很大, license 的问题等等种种原因. 这里我使用的是手头上一台开发机器替代的, 后续将会补充安装 Windows 虚拟机的部分, 并在此更新. 4.2. Windows 上配置 rustWindows 上安装和配置 Rust 可以参考我的博客鹏叔的技术博客 - 在各种操作系统上安装和配置 Rust 4.3. Windows 上配置 nodejsWindows 上安装和配置 nodejs 可以参考我的博客鹏叔的技术博客 - 安装并配置 nodejs 以及升级 nodejs 的文章, 里面有关于安装 typescript, angular cli 的部分. 5. 配置 tauri gitlab pipeline以上所有的步骤都是为我们创建 tauri gitlab pipeline 创建基础设施, 基础设施搭建完成后, 我们就可以创建 gitlab pipeline. 在 gitlab pipeline 中我要做三件事: 一, 创建 windows 安装程序; 二, 而创建 debian/ubuntu 安装程序; 三, 创建 macos 安装程序. 5.1. windows gitlab pipeline job如果您没有安装 gitlab 并打算安装, 可以参考鹏叔的技术博客 - gitlab 安装升级及迁移 以及鹏叔的技术博客 - gitlab CICD 基础 修改项目的配置文件.gitlab-ci.yml, 添加一个新的 job 用于编译 windows desktop application. 12345678910demo_desktop_windows_build: stage: releaseBuild when: manual timeout: 3h tags: [windows-runner] script: - echo &quot;description - job to build demo-desktop Windows tuari app&quot; - ./scripts/demo_desktop_windows_build.ps1 在 Job 定义脚本中定义tags:[windows-runner] 使其与 windows gitlab-runner 是的标签对应, 这样这个 job 就会被运行在 windows 环境上 gitlab-runner 所执行. 最终打出的包即为 msi. ./scripts/demo_desktop_windows_build.ps1 的内容如下 1234567echo &quot;building windows desktop application&quot;echo &quot;install npm packages&quot;cd ../demonpm installnpm run tauri build 5.2. ubuntu/debian gitlab pipeline job修改项目的配置文件.gitlab-ci.yml, 添加一个新的 job 用于编译 ubuntu/debian desktop application. 12345678910demo_desktop_ubuntu_build: stage: releaseBuild when: manual timeout: 3h tags: [ubuntu-runner] script: - echo &quot;description - job to build demo-desktop ubuntu/deb tuari app&quot; - ./scripts/demo_desktop_ubuntu_build.sh 指定tags: [ubuntu-runner], 这样 job 就会在拥有 ubuntu 标签的 gitlab-runner 上运行. scripts/demo_desktop_ubuntu_build.sh 的内容如下, 与 windows 的脚本没有太大差别, 但是 build 出来的安装文件格式会不一样. 123456789101112#!/bin/bashecho &quot;building ubuntu desktop application&quot;echo &quot;install npm packages&quot;cd ../demonpm installnpm run tauri build 5.3. macOS gitlab pipeline job修改项目的配置文件.gitlab-ci.yml, 添加一个新的 job 用于编译打包 macos desktop application. 12345678910demo_desktop_macos_build: stage: releaseBuild when: manual timeout: 3h tags: [macos-runner] script: - echo &quot;description - job to build demo-desktop macOS tuari app&quot; - ./scripts/demo_desktop_macos_build.sh 指定tags: [macos-runner], 这样 job 就会在拥有 macos 标签的 gitlab-runner 上运行. scripts/demo_desktop_macos_build.sh 的内容如下, 与以上两个的脚本没有太大差别, 但是 build 出来的会是 pkg 和 dmg 两种安装包格式. 123456789101112#!/bin/bashecho &quot;building macOS desktop application&quot;echo &quot;install npm packages&quot;cd ../demonpm installnpm run tauri build 6. 升级 App 到 Tauri 2.0 并配置 Tauri Mobile升级 App 到 Tauri 2.0 并配置 Tauri Mobile 7. 关联阅读创建 gitlab pipeline 打包 Tauri 跨平台应用程序 Tauri cli 详解 在 Linux 上配置 Tauri 环境 使用 Tauri 和 Angular 创建桌面应用程序 Tauri 开发环境配置 Tauri Mobile-使用 JavaScript 和 Rust 开发移动应用程序 8. TroubleShouting问题一: 在 ubuntu 上执行npm run tauri build时, 报如下错误 123Error failed to bundle project: error running appimage.sh 问题排查: 登录到 ubuntu 进入, 进入 project 目录, 执行命令并开启详细日志. 123npm run tauri build -- --verbose 参数说明:verbose 的字面意思是详述的意思, 在此是输出详细日志. 发现 appimage.sh 脚本试图从 githubusercontent 下载另外一个脚本 wget -q -4 -N https://raw.githubusercontent.com/tauri-apps/linuxdeploy-plugin-gtk/master/linuxdeploy-plugin-gtk.sh 最后的解决办法是将 appImage 格式从 target 中去除了. 修改 tauri.conf.json, 将 targets 修改如下. 注意: 这种办法只是暂时解决了打包脚本失败的问题, 并没有实质解决制作 appImage 格式安装包的问题.关注我的博客原文, 后续我抽出时间会实质性的解决该问题. 1&quot;targets&quot;: [&quot;deb&quot;, &quot;nsis&quot;, &quot;msi&quot;, &quot;app&quot;, &quot;dmg&quot;, &quot;updater&quot;], 问题二: windows 应用程序安装后, 启动时报错”WebView2Loader.dll was not found” 原因是没有正确的安装 tauri 依赖的环境. 详细原因请参考这个 issue 解决办法: 重新安装相关依赖 1234choco install visualstudio2019buildtoolschoco install visualstudio2019-workload-vctools 9. 参考文档Set up macOS runners Tauri 开发一： Tauri 开发工具介绍","link":"/tauri/tauri_gitlab_pipeline.html"},{"title":"Tauri Mobile-使用JavaScript和Rust开发移动应用程序","text":"1. 前言Tauri 定位为一个为所有主要桌面平台构建微小、速度极快的二进制文件的框架。开发人员可以集成任何可编译为 HTML、JS 和 CSS 的前端框架来构建用户界面。应用程序的后端是一个 Rust 二进制文件，具有前端可以与之交互的 API。 因此，Tauri 是一个框架，允许您使用您已经熟悉的技术构建跨平台应用程序。现在它还支持移动应用程序。听起来很棒，不是吗? 2. 为什么使用 Tauri现在，为什么要使用像 Tauri 这样的东西而不是 KotlinAndroid 应用程序和 SwiftiOS 应用程序呢？首先也是最重要的是，它允许您使用您已经熟悉的技术。不必被迫学习全新的编程语言，更不用说该语言所需的整个工具链，这会安全得多。它还可以轻松地将您当前的 Web 应用程序扩展到移动应用程序领域，而无需雇用专门的工程师。 除了这些原因之外，其他需要考虑的因素还有： 安全是否开源免费(FLOSS)Bundle 尺寸性能插件体系自我更新器 3. 最小的 Tauri 移动应用程序该应用是基于 2.0 Alpha 版本和 2.0 版本的早期文档。该实用程序的更新版本 create-tauri-app 正在开发中，以使以下许多步骤变得更加容易。话虽这么说，了解基础知识总是有帮助的！ 3.1. 开发环境首先，确保您已安装移动应用程序开发所需的所有先决条件。我正在 Mac 上工作并构建 iOS 应用程序，因此我按照此处的说明进行操作。如果您使用不同的操作系统或想要以 Android 为目标，则可以从这里开始。 现在我们已经准备好了开发环境，让我们开始安装 Tauri create-tauri-appRust 实用程序。这将使我们能够轻松初始化一个新的 Tauri 项目。我将要创建一个 Vue 项目并使用 TypeScript 开发。 12345cargo install create-tauri-appcargo create-tauri-app 现在 cd 进入新创建的文件夹，并确保我们使用的是最新版本。首先，运行以下命令. 1npm install @tauri-apps/cli@next @tauri-apps/api@next 这就是 Node 部分需要做的事情.现在 cd 进入该 src-tauri 文件夹并运行以下命令来更新 Rust 部分： 12345cargo add tauri@2.0.0-alpha.0cargo add tauri-build@2.0.0-alpha.0 --buildcargo install tauri-cli --version &quot;^2.0.0-alpha&quot; 我们已经准备好开发我们的移动应用程序了！要开发移动 Tauri 应用程序，前端必须在您的公共网络地址监听并提供服务。可以使用 internal-ip npm 包找到网络地址。您可以使用以下命令安装它： 1npm install --save-dev internal-ip 4. 修改配置文件接下来，我们需要更新该 vite.config.ts 文件。我正在使用 Vue，所以我的看起来像这样： 123456789101112131415161718192021222324252627282930313233343536373839import { defineConfig } from &quot;vite&quot;;import { internalIpV4 } from &quot;internal-ip&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;export default defineConfig(async () =&gt; { const host = await internalIpV4(); /** @type {import('vite').UserConfig} */ const config = { plugins: [vue()], // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build` // prevent vite from obscuring rust errors clearScreen: false, server: { host: &quot;0.0.0.0&quot;, // listen on all addresses port: 5173, strictPort: true, hmr: { protocol: &quot;ws&quot;, host, port: 5183, }, }, // to make use of `TAURI_DEBUG` and other env variables // https://tauri.studio/v1/api/config#buildconfig.beforedevcommand envPrefix: [&quot;VITE_&quot;, &quot;TAURI_&quot;], build: { // Tauri supports es2021 target: process.env.TAURI_PLATFORM == &quot;windows&quot; ? &quot;chrome105&quot; : &quot;safari13&quot;, // don't minify for debug builds minify: !process.env.TAURI_DEBUG ? &quot;esbuild&quot; : false, // produce sourcemaps for debug builds sourcemap: !!process.env.TAURI_DEBUG, }, }; return config;}); 如果您使用不同的框架，请确保保留此文件中特定于框架的插件。 更新 tauri.conf.json, 这很重要！： 这里有两件事我们需要改变。第一，在 bundle 对象中添加以下对象，如下所示： 123456789101112&quot;bundle&quot;: { &quot;active&quot;: true, &quot;category&quot;: &quot;DeveloperTool&quot;, &quot;copyright&quot;: &quot;&quot;, &quot;deb&quot;: { &quot;depends&quot;: [] }, &quot;externalBin&quot;: [], &quot;iOS&quot;: { &quot;developmentTeam&quot;: &quot;demo&quot; }, &quot;icon&quot;: [ 还要更改 Tauri 正在侦听的端口，使其与您的 JS 框架将运行的端口相匹配。就我而言，它是 5173. 像这样： 1234567&quot;build&quot;: { &quot;beforeDevCommand&quot;: &quot;npm run dev&quot;, &quot;beforeBuildCommand&quot;: &quot;npm run build&quot;, &quot;devPath&quot;: &quot;http://localhost:5173&quot;, &lt;- Here &quot;distDir&quot;: &quot;../dist&quot;, &quot;withGlobalTauri&quot;: false }, 5. 修改 Rust 代码现在配置文件已准备就绪，让我们对 Rust 文件进行一些更改。 src-tauri/Cargo.toml 更新如下： 12[lib]crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;, &quot;rlib&quot;] 创建一个新 src-tauri/src/lib.rs 文件并添加以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465use tauri::App;#[cfg(mobile)]mod mobile;#[cfg(mobile)]pub use mobile::*;pub type SetupHook = Box&lt;dyn FnOnce(&amp;mut App) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; + Send&gt;;#[tauri::command]fn greet(name: &amp;str) -&gt; String { format!(&quot;Hello, {}!&quot;, name)}#[derive(Default)]pub struct AppBuilder { setup: Option&lt;SetupHook&gt;,}impl AppBuilder { pub fn new() -&gt; Self { Self::default() } #[must_use] pub fn setup&lt;F&gt;(mut self, setup: F) -&gt; Self where F: FnOnce(&amp;mut App) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; + Send + 'static, { self.setup.replace(Box::new(setup)); self } pub fn run(self) { let setup = self.setup; tauri::Builder::default() .setup(move |app| { if let Some(setup) = setup { (setup)(app)?; } Ok(()) }) .invoke_handler(tauri::generate_handler![greet]) .run(tauri::generate_context!()) .expect(&quot;error while running tauri application&quot;); }}#[cfg(mobile)]fn do_something() { println!(&quot;Hello from Mobile!&quot;);}#[cfg(desktop)]fn do_something() { println!(&quot;Hello from Desktop!&quot;);}fn run() { if cfg!(mobile) { println!(&quot;Hello from Mobile!&quot;); } else { println!(&quot;Hello from Desktop!&quot;); }} 创建一个新 src-tauri/src/mobile.rs 文件并添加以下内容： 1234#[tauri::mobile_entry_point]fn main() {super::AppBuilder::new().run();} 这是重要的一步 将内容更新 src-tauri/src/main.rs 为： 123456789#![cfg_attr(all(not(debug_assertions), target_os = &quot;windows&quot;),windows_subsystem = &quot;windows&quot;)]pub fn main() {// Change demo_mobile_app to the name of your app!demo_mobile_app::AppBuilder::new().run();} 现在这已经解决了，请完成以下步骤： cargo tauri ios init 在主文件夹中运行。 如果您收到有关 cocoapods 的错误，请运行：brew install cocoapods 然后重试 运行 cargo tauri ios dev 以启动服务器 6. 结果恭喜！现在应该询问您希望应用程序在哪个模拟器中运行. 7. 关联阅读升级App到Tauri 2.0并配置Tauri Mobile 创建 gitlab pipeline 打包 Tauri 跨平台应用程序 Tauri cli 详解 在 Linux 上配置 Tauri 环境 使用 Tauri 和 Angular 创建桌面应用程序 Tauri 开发环境配置 Tauri Mobile-使用 JavaScript 和 Rust 开发移动应用程序 8. 结论在这篇博文中，我们设置了一个最小的 Tauri 应用程序，它允许我们使用 JS、Vue（在我们的例子中）和 Rust 构建可安装的 iOS 应用程序！从这里开始，您应该拥有坚实的基础来构建自己的想法并启动您一直想要构建的令人惊叹的应用程序！您可以在这里找到本文的代码：GitHub","link":"/tauri/tauri_mobile.html"},{"title":"升级App到Tauri 2.0并配置Tauri Mobile","text":"Tauri 2.0的新alpha.4 版本已经发布。此版本包括即将发布的Tauri 1.3版本的所有更改，此版本包含了对HTTP客户端的一些breaking change和TauriNative mobile插件的功能一些更改。 以下是从Tauri 1.3或1.4升级到Tauri 2.0.0-alpha.4的一些指引。 升级前环境说明： OS：windows 11NPM: 8.5.0rust: rustc 1.68.0cargo: 1.68.0Angular CLI: 16.2.10Node: 16.14.2 1. 升级rustc由于Tauri 2.0.0-alpha.4需要rustc至少是1.70.0版本，而我当前的rustc仅为1.68.0版本, 所以需要首先升级rustc, 否则在后续升级tauri-cli时会报错。 1rustup update 升级以后的rust版本为1.74.0 2. 安装Android SDKTauri2.0依赖的Android SDK的版本是Android 12（API级别 31）。这意味着 Tauri2.0应用程序只能在运行Android 12或更高版本的设备上运行。 安装Android SDK可以参考我的文章Android SDK安装与配置 | 鹏叔的技术博客 以下是Tauri2.0依赖的Android SDK的具体版本号： Android SDK Platform-Tools：31.0.5Android SDK Build-Tools：31.0.5Android SDK Tools：31.0.5Android SDK Documentation：31.0.5如果您使用的是旧版本的Android SDK，则可能会遇到错误或不兼容性。 3. 安装NDKNDK 是 Native Development Kit 的缩写，它是一个开发原生 Android 应用程序的工具包。Tauri 会依赖 NDK 的原因有两个： Tauri 是一个跨平台框架，它可以运行在 Windows、macOS、Linux、Android 和 iOS 等平台上。为了访问原生平台的功能，为了在这些平台上提供一致的体验，Tauri 需要访问原生平台的功能，例如图形、音频、文件系统等。NDK 提供了访问这些功能的接口。 为了提高性能。Tauri 使用 WebAssembly 作为其运行时。WebAssembly 是一种高性能的二进制格式，可以编译成机器码。然而，WebAssembly 仍然比原生代码的性能要低一些。为了提高性能，Tauri 可以使用 NDK 来编译原生代码，然后将其嵌入到 WebAssembly 模块中。 4. 更新 NPM 依赖包12345npm install -D @tauri-apps/cli@next npm install --save @tauri-apps/api@nextnpm install --save @tauri-apps/plugin-shell@next 5. 更新 Cargo 依赖包进入src-tauri目录，更新Cargo 依赖包。 12345cargo add tauri@2.0.0-alpha.20cargo add tauri-build@2.0.0-alpha.13 --buildcargo install tauri-cli --version &quot;^2.0.0-alpha.20&quot; 6. 更新配置文件升级到Tauri 2.0后有些配置不再兼容，需要修改。 编辑src-tauri/tauri.conf.json 将不符合配置规范的部分移除 12345678&quot;allowlist&quot;: { &quot;all&quot;: false }, &quot;updater&quot;: { &quot;active&quot;: false }, 修改src-tauri/Cargo.toml 12345678910111213141516// 添加lib配置[lib]name = &quot;demo_lib&quot;crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;, &quot;rlib&quot;][build-dependencies]tauri-build = { version = &quot;2.0.0-alpha&quot;, features = [] }[dependencies]serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }tauri = { version = &quot;2.0.0-alpha&quot;, features = [] }tauri-plugin-shell = &quot;2.0.0-alpha&quot;serde_json = &quot;1.0&quot; 7. 重新创建移动项目以使用新功能首先，确保安装所需的rust android目标 1rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android 123456# 如果src-tauri/gen有内容，将其清除在重新生成#rm -r src-tauri/gennpm run tauri android initnpm run tauri ios init 12345678910111213141516171819$npm run tauri android init&gt; demo-web@1.0.0 tauri&gt; tauri &quot;android&quot; &quot;init&quot; Info &quot;path-to-demo-project\\\\node_modules\\\\.bin\\\\\\\\..\\\\@tauri-apps\\\\cli\\\\tauri.js&quot; relative to &quot;path-to-demo-project\\\\src-tauri&quot; is &quot;..\\\\node_modules\\\\.bin\\\\\\\\..\\\\@tauri-apps\\\\cli\\\\tauri.js&quot;Installing Android Rust toolchains...info: downloading component 'rust-std' for 'aarch64-linux-android'info: installing component 'rust-std' for 'aarch64-linux-android'info: downloading component 'rust-std' for 'armv7-linux-androideabi'info: installing component 'rust-std' for 'armv7-linux-androideabi'info: downloading component 'rust-std' for 'i686-linux-android'info: installing component 'rust-std' for 'i686-linux-android'info: downloading component 'rust-std' for 'x86_64-linux-android'info: installing component 'rust-std' for 'x86_64-linux-android'Generating Android Studio project... Info &quot;path-to-demo-project\\\\src-tauri&quot; relative to &quot;path-to-demo-project\\\\src-tauri\\\\gen/android\\\\app&quot; is &quot;..\\\\..\\\\..\\\\&quot;victory: Project generated successfully! Make cool apps! 🌻 🐕 🎉 初始化Android项目后，由于网络原因，使用默认配置会遇到网络延迟或阻塞的情况，所以需要将一些默认配置替换掉。 gradle镜像仓库 修改配置demo-project/src-tauri/gen/android/build.gradle.kts， 添加阿里云仓库 123456789101112131415161718192021222324252627 buildscript { repositories { maven(url = &quot;https://maven.aliyun.com/repository/central&quot;) maven(url = &quot;https://maven.aliyun.com/repository/public&quot;) maven(url = &quot;https://maven.aliyun.com/repository/jcenter&quot;) maven(url = &quot;https://maven.aliyun.com/repository/google&quot;) maven(url = &quot;https://maven.aliyun.com/repository/releases&quot;) maven(url = &quot;https://maven.aliyun.com/repository/snapshots&quot;) maven(url = &quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) google() mavenCentral() } }allprojects { repositories { maven(url = &quot;https://maven.aliyun.com/repository/central&quot;) maven(url = &quot;https://maven.aliyun.com/repository/public&quot;) maven(url = &quot;https://maven.aliyun.com/repository/jcenter&quot;) maven(url = &quot;https://maven.aliyun.com/repository/google&quot;) maven(url = &quot;https://maven.aliyun.com/repository/releases&quot;) maven(url = &quot;https://maven.aliyun.com/repository/snapshots&quot;) maven(url = &quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) google() mavenCentral() }} gradle wrapper配置 手动获取gradle-8.0-bin.zip，并放在本地某个目录下， 例如~/.gradle/wrapper/gradle-8.0-bin.zip, 修改配置如下 webapp3/src-tauri/gen/android/gradle/wrapper/gradle-wrapper.properties 12345678910111213141516 distributionBase=GRADLE_USER_HOME # distributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-bin.zip distributionUrl=file:///~/.gradle/wrapper/gradle-8.0-bin.zip distributionPath=wrapper/dists zipStorePath=wrapper/dists zipStoreBase=GRADLE_USER_HOME ````## 8. 启动Android应用```bashnpm run tauri android dev 如果Android SDK配置没有问题，并且项目能顺利通过。该命令会自动打开Android 模拟器，并将Android运行在模拟器中。 9. 编译apk和aab安装包123npm run tauri android build 10. 生成签名生成签名。参考链接：https://next--tauri.netlify.app/next/guides/distribution/sign-android/ 根据这个链接，我们需要先生成一个签名。对于windows，使用下面这个命令来生成(注意keystore里面的用户名改成你的，最好是全英语）。 对于windows，使用下面这个命令来生成(注意keystore里面的用户名改成你的，最好是全英语）。 123keytool -genkey -v -keystore %userprofile%\\upload-keystore.jks -storetype JKS -keyalg RSA -keysize 2048 -validity 10000 -alias upload 对于Mac/Linux 使用下面这个命令来生成 123keytool -genkey -v -keystore ~/upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload 修改 [project]/src-tauri/gen/android/app/build.gradle.kts file. 添加两个imports 12import java.util.Propertiesimport java.io.FileInputStream 加载keyProperties 1234567val keyPropertiesFile = rootProject.file(&quot;key.properties&quot;)val keyProperties = Properties()keyProperties.load(FileInputStream(keyPropertiesFile))android { ...} 配置signingConfigs 12345678910111213signingConfigs { create(&quot;release&quot;) { keyAlias = keyProperties[&quot;keyAlias&quot;] as String keyPassword = keyProperties[&quot;keyPassword&quot;] as String storeFile = file(keyProperties[&quot;storeFile&quot;] as String) storePassword = keyProperties[&quot;storePassword&quot;] as String }}buildTypes { ...} 打包时使用签名信息 1234567buildTypes { ... getByName(&quot;release&quot;) { ... signingConfig = signingConfigs.getByName(&quot;release&quot;) }} 这样创建release build时会自动带上签名信息 11. troubleshooting11.1. issue 1: 在做Android开发时经常出现android adb devices offline重启adb服务 1234adb kill-serveradb start-server 12. 参考文档Tauri 2.0.0-alpha.4 Released Windows 11环境下使用Tauri2.0编译安卓apk","link":"/tauri/upgrade_to_tauri_2.0.html"},{"title":"Typescript教程","text":"1. TS简介1.1. typescript是什么?以javascript为基础构建的语言可以在任何支持javascript的平台中执行一个javascript的超集typescript扩展了javascript，并添加了类型TS不能被JS解析器直接执行，需要经过编译成javascript后被JS解析器执行。 1.2. Typescript增加了什么？ 类型 保证原有类型的基础上增加了一些新类型 支持ES的新特性 添加ES不具备的新特性 丰富的配置选项 强大的开发工具 2. TS开发环境搭建 typescript开发环境搭建 下载Node.js 64位 https://npmmirror.com/mirrors/node/v14.15.1-x64.msi 32位 https://npmmirror.com/mirrors/node/v14.15.1-x86.msi 安装Node.js 使用npm全局安装typescript 进入命令行 输入：npm i -g typescript 创建一个ts文件 使用tsc对ts文件进行编译 进入命令行 进入ts文件所在目录 执行命令: tsc xxx.ts 3. TS的类型声明 类型声明 类型声明是TS非常重要的一个特点 通过类型声明可以指定TS中变量（参数, 形参）的类型 指定类型后, 当为变量赋值时, TS编译器会自动检查值是否符合类型声明, 符合则赋值, 否则报错。 简而言之, 类型声明给变量设置了类型, 使得变量存储某种类型的值。 语法 123456let 变量：类型;let 变量：类型 = 值;function fn(参数：类型, 参数：类型) ：类型 {} 自动类型判断 TS拥有自动类型判断机制 当对变量的声明和赋值是同时进行的, TS编译器会自动判断变量的类型 所以如果你的变量的声明和赋值是同时进行的，可以省略掉类型声明 4. TS中的类型 TS基本类型 类型 例子 描述 number 1, -33, 2.5 任意数字 string 任意字符串 boolean true, false 布尔值true或false 字面量 其本身 限制变量的值就是该字面量的值 any * 任意类型 unknown * 类型安全的any void 空值（undefined） 没有值（或者undefined） never 没有值 不能是任何值 object {name: ‘孙悟空’} 任意JS对象 tuple [4,5] 元素，TS新增类型，固定长度数组 enum enum{A, B} 枚举，TS新增类型 number 12345let decimal： number = 6;let hex: number = 0xf00d;let binary: number = 0b1010let octal: number = 0o744let big: bigint = 100n; 字面量 1234567891011121314//这种不常用let a: 10;a = 10;a = 11; // 编译报错, 因为a声明时已经指定为字面量10//常用let b: &quot;male&quot; | &quot;female&quot;b= &quot;male&quot;b= &quot;female&quot;b=&quot;hello&quot; // 编译报错let c: boolean | stringc = true;c = 'true'; any 显式声明变量为any 12345// any 表示的是任意类型, 一个变量设置类型为any后相当于该变量关闭了TS的类型检测let d： anyd = 10;d = 'hello'd = true; 隐式声明变量为any 12345// any 表示的是任意类型, 一个变量设置类型为any后相当于该变量关闭了TS的类型检测let d： anyd = 10;d = 'hello'd = true; unknown unknown表示未知类型的值 any 和 unknown 的差别 12345678let d: anyd = truelet s: strings = d； // 这里不会报错 12345678let d: unknownd = truelet s: strings = d； // 这里会报错 解决办法 123456789101112131415161718let d: unknownd = truelet s: stringd= 'hello';if(typeof e === &quot;string&quot;) { s = d； // 这里不会报错}或者//使用断言s = d as string;或者s = &lt;string&gt;d void never object 123456789101112131415161718192021let a :object;a = {}a = function() {}// {} 用来指定对象中可以包含哪些属性// 语法： {属性名： 属性值}let b: {name: string}b = {name: '孙悟空'}属性上加上?, 表示属性是可选的let b: {name: string, age?: number}b = {name: '孙悟空', age: 18}// 对象里有name属性let c: {name: string, [propName: string]： any} Function 123let d: (a:number, b: number) =&gt; number; Array 123456let e: string[];e = ['a', 'b', 'c']let g: Array&lt;number&gt;g = [1,2,3] tuple 元组 123let h: [string, string]h = ['hi', 'world'] enum 枚举 12345enum Gender { Male, Female} 补充 //&amp; 同时 1let j: {name: string} &amp; {age: number} // 类型的别名 1type myType = 1|2|3|4|5 ; 5. TS编译选项tsconfig.json include 123&quot;include&quot;: { &quot;./src/**/*&quot;} exclude 123&quot;exclude&quot;: { &quot;./src/hello/**&quot;} compilerOptions target 选项 es3 es5 es6 es2015(ES6) es2016 es2017 es2018 es2019 es2020 esnext (ES最新版本) module 指定使用的模块化的解决方案 选项 es6 es2015 es2020 es2020 esnext umd system amd commonjs none lib 1lib: [] outDir outFile allowJs 是否对JS文件进行编译 checkJs 是否检测js代码的语法 removeComments 编译过程中是否删除注释 noEmit 不生成编译后的文件 noEmitOnError 当有错误的时候不生成编译后的文件 语法检测相关选项 alwaysStrict 6. 面向对象简介面向对象是程序中一个非常重要的思想, 因被很多同学理解成一个比较难, 比较深奥的问题, 其实不然, 面向对象很简单, 简而言之就是程序之中所有的操作都需要通过对象来完成。 举例来说： 操作浏览器要使用window对象 操作网页要使用document对象 操作控制台要使用console对象 一切操作都要通过对象, 也就是所谓的面向对象, 那么对象到底是什么呢？ 这就要先说到程序是什么, 计算机程序的本质是对现实事物的抽象, 抽象的反义词是具体, 比如： 照片是对一个具体的人的抽象, 汽车模型是对具体的汽车的抽象等等。 程序也是对事物的抽象。在程序中我们可以表示一个人, 一条狗, 一把枪, 一颗子弹等等所有的事物。 一个事物到了程序中就变成了一个对象。在程序中所有的对象都被分成了两个部分数据和功能, 以人为例, 人的姓名, 性别, 年龄, 身高, 体重等属于数据, 人可以说话, 走路, 吃饭, 睡觉这些属于人的功能。 数据在对象中成为属性, 而功能就被称为方法。 所以简而言之, 在程序中一切皆是对象。 7. 类的简介 类(class) 要想面向对象, 操作对象, 首先要拥有对象, 那么下一个问题就是如何创建对象。 要创建对象, 必须首先定义类, 所谓的类可以理解为对象的模型, 程序中可以根据类创建指定的对象, 举例来说: 可以通过Person类来创建人的对象, 通过Dog类来创建狗的对象,通过Car类来创建汽车的对象, 不同的类可以创建不同的对象。 定义类 123456789101112 class 类名 { 属性： 类型； constructor(参数： 类型) { } 方法名（） { }} 示例： 12345678910111213class Person { name: string; age: number; constructor(name:string, age:number) { this.name = name; this.age = age; } introduce() { console.log(&quot;my name is &quot;+ name + &quot;I am &quot;+age+&quot; old&quot;) }} 使用类 123456 const zhangsan = new Person(&quot;ZhangSan&quot;, 20); const lisi = new Person(&quot;lisi&quot;, 22); zhangsan.introduce();lisi.introduce(); 定义实例属性 12name: string;age: number; 定义实例方法 123sayHello(){ console.log(&quot;hello&quot;)} 定义类属性属性 1static attrName: string; 定义类方法 123static sayHi() { console.log(&quot;Hi&quot;)} 定义只读属性 12readonly name: string; 构造函数 12constructor() { } 8. 构造函数和this9. 继承简介12345class Dog extends Animal {} 9.1. 方法的重写9.2. super关键字10. 抽象类123456789101112131415abstract class Animal { name: string; constructor(name:string){ this.name = name; } sayHello() { console.log(&quot;动物在叫&quot;) }} 抽象方法 1234567891011121314abstract class Animal { name: string; constructor(name:string){ this.name = name; } // 定义一个抽象方法 // 抽象方法使用abstract开头, 没有方法体 // 抽象方法只能定义在抽象类中, 子类需要对方法进行实现 abstract sayHello(): void;} 11. 接口11.1. 定义接口123456789101112/** 接口可以在定义类的时候限制类的结构* 接口中的所有的属性都不能有实际值* 接口只定义对象的结构, 而不考虑实际值* 在接口中所有的方法都是抽象方法*/interface myInterface { name:string; age: number; sayHello(): void;} 11.2. 实现接口12345678910111213141516/** 定义类时, 可以使类去实现一个接口，* 实现接口就是使类满足接口的要求**/class MyClass implements myInterface { name: string; constructor(name:string) { this.name = name; } sayHello() { console.log('hello everyone') }} 12. 属性的封装1234567891011121314151617181920212223class Person { name: string; age: number; constructor(name:string, age: number) { this.name = name; this.age = age; }} const per = new Person('孙悟空', 18)； /* * 现在属性时在对象中设置的, 属性可以任意被修改， * 属性可以任意被修改会导致对象中的数据变得非常不安全 **/ per.name = '猪八戒' per.age = -38 console.log(per); 属性的可见性 public, private, protected 123456789101112131415161718192021222324252627282930313233343536373839404142class Person { /* * public 修饰的属性可以在任意位置访问(修改) 默认值 * private 私有属性, 私有属性只能在类内部进行访问 * - 通过在类中添加方法使得私有属性可以被外部访问 * protected 受保护的属性或方法，只能在子类中访问 **/ private name: string; private age: number; constructor(name:string, age: number) { this.name = name; this.age = age; } // 定义方法, 用来获取name属性 getName() { return this.name; } // 定义方法, 用来设置name属性 // 有了 setName(value: string) { } } const per = new Person('孙悟空', 18)； /* * 现在属性时在对象中设置的, 属性可以任意被修改， * 属性可以任意被修改会导致对象中的数据变得非常不安全 **/ per.name = '猪八戒' per.age = -38 console.log(per); 12.1. ts中实现getter setter的独特方式123456789101112131415161718192021222324252627282930313233343536class Person { private _name: string; private _age: number; constructor(name:string, age: number) { this._name = name; this._age = age; } // 定义方法, 用来获取name属性 get name() { return this._name; } // 定义方法, 用来设置name属性 // 有了 setName(value: string) { } } const per = new Person('孙悟空', 18)； /* * 现在属性时在对象中设置的, 属性可以任意被修改， * 属性可以任意被修改会导致对象中的数据变得非常不安全 **/ per.name = '猪八戒' console.log(per); 12.2. 简化写法13. 泛型123456789101112131415//泛型的定义function fn&lt;T&gt; (a: T): T {}// 泛型的使用:// 可以直接调用具有泛型的函数fn(10) //不指定类型, TS可以自动对类型进行推断//也可以明确指定参数类型fn&lt;string&gt; ('hello') //多泛型的定义 123456789function fn2&lt;T, K&gt; (a: T, b: K): T { console.log(b) return a;}// 限定泛型的类型function fn3&lt;T extends Inter&gt;(a: T): number { return a.length;} 泛型类 1234567891011class MyClass&lt;T&gt; { name: T; constructor(name: T) { this.name = name; }}使用const mc = new MyClass&lt;string&gt;('孙悟空')； 14. 参考尚硅谷typescript教程 TypeScript 语言简介","link":"/typescript/typescript_tutorial.html"},{"title":"esxi6.7升级至esxi7.0","text":"1. 升级前准备1.1. 备份将当前ESXi Server的数据备份至其它ESXi Server 参考升级路径 esxi 升级路径 下载升级包 访问VMWare 7.0下载页面 在Standard 列表中选择 VMware vSphere Hypervisor (ESXi), 点击右侧”go to downloads”进入下载页面. 在下载页面选择合适的版本, 下载offlineBundle, 点击下载. 快捷的下载页面的如下, 例如我选择的是VMware vSphere Hypervisor (ESXi) 7.0b 通过ESXi Web管理界面，将文件VMware-ESXi-7.0b-16324942-depot.zip上传到ESXI存储设备的根目录。 如果没有权限下载, 可以尝试从以下载的用户共享的链接下载, 例如: https://cloud.189.cn/t/73mmqmriE7Fb（访问码：my98） 上传升级包具体操作如下: 找到存储 datastore1 (每台机可能名称不相同) 点击数据存储浏览器 选择一个文件夹 点击上载 等待上载完成 2. 启用Shell如果没有启动ssh登录, 需要启用shell. 导航到主机&gt;操作&gt;服务菜单，启用安全Shell(ssh)。 3. 登录ESXi主机123ssh root@192.168.1.100 输入密码后登录。 4. 检查升级程序与硬件以及驱动的兼容性先找到升级包存储位置并记录下来，存储位置可以ESXi Web管理界面 =&gt; 存储 =&gt; datastore1 (每台机可能名称不相同) 找到. 123/vmfs/volumes/5cb88c50-f1c6a935-c840-406231072a3a 确认升级模块 123456esxcli software sources profile list -d /vmfs/volumes/57d939a9-f9b32497-21b5-f8b156c98780/VMware-ESXi-7.0U3m-21686933-depot.zipName Vendor Acceptance Level Creation Time Modification Time----------------------------- ------------ ---------------- ------------------- -------------------ESXi-7.0U3m-21686933-standard VMware, Inc. PartnerSupported 2023-05-03T00:00:00 2023-05-03T00:00:00ESXi-7.0U3m-21686933-no-tools VMware, Inc. PartnerSupported 2023-05-03T00:00:00 2023-04-28T16:03:19 这里显示有两个个模块，我们要升级的模块为“ESXi-7.0U3m-21686933-standard” 升级第二步，检查是否能正常升级。注意用查到的升级模块替换对应的参数。 123esxcli software profile update -p ESXi-7.0U3m-21686933-standard -d /vmfs/volumes/57d939a9-f9b32497-21b5-f8b156c98780/VMware-ESXi-7.0U3m-21686933-depot.zip --dry-run 如果出现Dependency error, 选用安装官方文档解决兼容性问题. 我比较幸运, 没有遇到兼容性问题. 命令输出内容如下. 123456Update Result Message: Dryrun only, host not changed. The following installers will be applied: [BootBankInstaller, LockerInstaller] Reboot Required: true VIBs Installed: 5. 开始升级123esxcli software profile update -p ESXi-7.0U3m-21686933-standard -d /vmfs/volumes/57d939a9-f9b32497-21b5-f8b156c98780/VMware-ESXi-7.0U3m-21686933-depot.zip --dry-run 等待命令执行完成. 接着手动输入重启命令，升级完成。 123reboot 再次登录到ESXI web管理页面, 可以看到版本已经升级到7.0 update 3版本 6. 参考文档VMware vSphere ESXI 6.7升级7.0 VMware vSphere ESXi 7.0安装配置","link":"/vmware/esxi_upgrade.html"},{"title":"如何制作 macOS Sonoma ISO 文件","text":"因为我的一些编译和测试工作需要在 macOS 上进行， 然而项目预算有限不够支撑去购买一台 macOS，而且测试需要在不同版本的 macOS 上进行。此时在虚拟机上安装 macOS 操作系统成为了一个不错的选择。 此前曾经在 VMWare esxi 上成功安装了一台 macOS High Sierra 10.13.6 虚拟机， 教程可参考如何安装一台 MacOS 虚拟机 | 鹏叔的技术博客 ，由于 VMWare esxi 的版本太低，一直运行的是 6,7 版本的 VMWare esxi，而且由于服务器硬件的原因无法升级到更高级版本，导致不能将 macOS 更高版本。 因此打算在一台较新的个人电脑上安装 VMware player 最新版本(17.5.0), 然后在在其上安装 macOS Sonoma. 安装过程中发现 macOS High Sierra 的 ISO 镜像很难获得，下载速度奇慢，同时也出于安全性考虑（担心 iso 文件被挂码），另外上一篇介绍如何安装 MacOS 虚拟机 的教程也缺少了制作 iso 镜像文件的过程，刚好之前安装的 macOS 虚拟机还能够使用，条件也都具备，于是着手自己制作一个纯净的 ISO 镜像。以下是整个制作的全过程。 1. 一些概念在进入制作过程之前，我们需要了解一些概念，以便于我们清楚地执行 iso 制作过程。 1.1. macOS 安装文件格式在 macOS 中，常见的安装文件格式是pkg。这种格式是 macOS 平台下的一种常见安装包格式，类似于 Windows 平台的安装包程序。pkg 文件是安装包配置文件，是制作安装程序的核心部分。它包含了制作iso安装文件所需要的全部信息，引导用户如何安装软件。 此外，macOS 中还有其他一些常见的运行文件格式，如**.app、.dmg 等。其中，.app 文件是 macOS 中常见的应用程序**文件格式，用户可以直接双击打开应用程序；而.dmg 文件是 macOS 中常见的磁盘映像文件格式，用户可以通过将.dmg 文件挂载到系统中来访问其中的文件和应用程序。 1.2. 什么是 macOS Sonoma ISO 文件?macOS Sonoma ISO 文件 (.iso) 是 macOS Sonoma 的磁盘映像文件，通常用于在 VMware 或 VirtualBox 等虚拟机上安装 macOS Sonoma、创建可启动安装程序，或用于 Apple 通过以下方式提供的标准升级过程之外的其他安装方法： Mac App Store 或软件更新。 如果您有 macOS Sonoma ISO 文件，您可以在 VMware 或 VirtualBox 中创建一个新的虚拟机，将 macOS Sonoma ISO 挂载为虚拟光驱，然后在该虚拟机上安装 macOS Sonoma，从而在虚拟环境中有效运行 macOS Sonoma 计算机，无论您的实际计算机运行的是 Windows、Linux 还是其他操作系统。 2. 如何创建制作 macOS Sonoma ISO？整个制作过程分为一下几个步骤： 第 1 步：下载 macOS Sonoma 完整安装程序 第 2 步：创建一个空的 ISO 磁盘映像 第 3 步：制作 macOS Sonoma 安装程序 第 4 步：卸载 macOS Sonoma 磁盘映像并将其转换为 .iso 格式 3. 下载 macOS Sonoma 完整安装程序创建 macOS Sonoma ISO 文件的第一步是 下载 macOS Sonoma 的完整安装程序。 对于兼容 macOS Sonoma 的 Mac，您可以从 Mac App Store 下载。为此，请打开 App Store，在搜索栏中搜索“macOS Sonoma”，然后按 Enter 键。 当 macOS Sonoma 显示时，单击“查看”&gt;“获取”，然后您将被重定向到“软件更新”页面。当系统询问您是否想要获取 macOS Sonoma 时，请单击“下载”按钮。 对于不兼容 macOS Sonoma 的 Mac，从 appstore 获取的安装程序是不完整的。要想获得完整的安装程序，可以从Apple 服务器下载完整的 installer。下载的是.pkg 格式的安装包。下载完成后，您可以打开 InstallAssistant.pkg 文件并按照屏幕上的说明将其安装一次。安装后，您应该会在“应用程序”文件夹中看到“安装 macOS Sonoma”应用程序。 123wget -O /tmp/InstallAssistant.pkg https://swcdn.apple.com/content/downloads/04/13/052-77516-A_4P7VY083DT/83qy3989rsnylxagdmim3owwjdtc33zfe4/InstallAssistant.pkg 如果需要下载其他版本，可以到这个网址找到相应的连接。更多 Macos 版本信息可以参考macOS 系统各版本发布日期时间及 Mac 系统下载集合 4. 创建一个空的 ISO 磁盘映像下一步是为 macOS Sonoma 安装程序准备一个空磁盘映像，并使用磁盘命令行工具 hdiutil 制作一个空的磁盘镜像。 打开命令行工具, 执行以下命令： 1hdiutil create -o /tmp/Sonoma -size 15979m -volname Sonomaiso -layout SPUD -fs HFS+J -type UDTO -attach 此命令使用 HFS+ 日志文件系统在 /tmp 目录中创建一个卷名为“Sonomaiso”的新的单分区 15979 MB 磁盘映像，名称为“Sonoma”，类型适合创建 CD /DVD ISO。创建磁盘映像后，它会立即挂载到系统中。 以下是该命令的详细说明： hdiutil create： 这将启动新磁盘映像的创建。 -o /tmp/Sonoma： -o 选项指定输出文件的位置和名称。 /tmp/Sonoma 是将创建新磁盘映像的路径。该文件将临时存储在系统的 /tmp 目录中，名称为“Sonoma”。 -size 15979m： 这将磁盘映像的最大大小设置为 15979 兆字节。 -volname Sonomaiso： 这会将卷名称“Sonomaiso”分配给磁盘映像。 -layout SPUD： -layout 选项指定磁盘映像的分区方案。 “SPUD”代表单分区 UDIF（通用磁盘映像格式）。 -fs HFS+J： 这将磁盘映像的文件系统指定为启用日志功能的 HFS+。 HFS+ 是 macOS 常用的文件系统。 -type UDTO： 这将磁盘映像类型指定为 UDTO，它代表通用磁盘映像格式 (UDIF) DVD/CD-R 主盘。此类型通常用于创建可刻录到 CD/DVD 的 ISO 映像。 -attach： 创建磁盘映像后，-attach 选项将新的磁盘映像挂载到文件系统，使其像物理磁盘一样可访问。 5. 制作 macOS Sonoma 安装程序现在，您可以在创建的空磁盘映像上制作可启动的 macOS Sonoma 安装程序。 将以下命令粘贴到终端并按 Enter 键。然后输入您的管理员密码并再次按 Enter。 （请注意，密码不会回显到屏幕上。） 1sudo /Applications/Install\\ macOS\\ Sonoma.app/Contents/Resources/createinstallmedia --volume /Volumes/Sonomaiso --nointeraction 以下是该命令的详细说明： sudo： 通常用于执行管理任务或命令。 /Applications/Install\\ macOS\\ Sonoma.app/Contents/Resources/createinstallmedia： 这是位于 macOS Sonoma 安装程序包内的 createinstallmedia 命令的路径，该安装程序包通常位于 /Applications 目录中。反斜杠 () 是转义字符，用于处理命令行中文件或目录名称中的空格。 –volume /Volumes/Sonomaiso： 这指定卷“Sonomaiso”作为将创建可引导安装程序的位置。 –nointeraction： 此标志运行命令而不需要用户交互，这意味着它不会在执行过程中提示用户进行确认或其他输入。 6. 卸载 macOS Sonoma 磁盘映像并将其转换为 .iso 格式创建 macOS Sonoma 安装介质后，您需要卸载它，将其格式从 Sonoma.cdr 转换为 Sonoma.iso，然后将其移动到桌面。 在终端中，执行以下命令卸载“安装 macOS Sonoma”磁盘映像。 123hdiutil detach -force /Volumes/Install\\ macOS\\ Sonoma 然后运行以下命令将 macOS Sonoma 安装程序移动到桌面并将扩展名从 .cdr 重命名为 .iso： 1mv /tmp/Sonoma.cdr ~/Desktop/Sonoma.iso 现在，您的Mac桌面上已经有了macOS Sonoma ISO文件；您可以使用它在VMware、VirtualBox或其他虚拟机上安装macOS Sonoma。 7. Troubleshootingissue 1: Install macOS Sonoma.app does not appear to be a valid OS installer application 12sudo /Applications/Install\\ macOS\\ Sonoma.app/Contents/Resources/createinstallmedia --volume /Volumes/Sonomaiso/Applications/Install macOS Sonoma.app does not appear to be a valid OS installer application 原因分析： 很多时候，当你还没有升级到新操作系统时，安装程序将是部分安装程序。它不包含创建安装程序所需的组件。 解决办法下载完整的安装程序，并执行一次安装。参考本文“下载”章节。 8. 参考文档How to Download/Create macOS Sonoma ISO for VMware or VirtualBox?","link":"/vmware/how_to_create_macos_Sonoma_ISO.html"},{"title":"linux上安装vmware","text":"本文主要讲述在 Linux 上如何安装 vmare 软件， 文章以 vmware player 为例，当然对 vmware pro 也同样适用。 下载https://www.vmware.com/products/workstation-player/workstation-player-evaluation.html 下载 linux 版本：VMware Workstation Pro 17.5.0 for Linu 安装赋予执行权限： 123chmod +x VMware-Player-Full-17.5.0-22583795.x86_64.bundle 运行 vmware 安装包： 123sudo ./VMware-Player-Full-17.5.0-22583795.x86_64.bundle 进入图形化界面，选择默认选型即可 安装完毕后进入虚拟机，接下来你便可以开始使用 VMware 搭建你的小集群了！","link":"/vmware/linux_install_vmware_player.html"},{"title":"Macos开发环境配置","text":"1. 前言本文讲述如何为Macos配置开发环境. 2. 环境说明Macos版本: High_Sierra_10.13.6 3. 开启共享3.1. 开启vnc打开: 设置 =&gt; 共享 =&gt; 屏幕共享 允许访问 =&gt; 勾选仅这些用户 =&gt; 添加用户 3.2. 开启ssh打开: 设置 =&gt; 共享 =&gt; 远程登录 允许访问 =&gt; 勾选仅这些用户 =&gt; 添加用户 3.3. 安装xcode在安装XCode之前首先确定Macos的确切版本, 然后到release notes上去找能与之兼容的的Xcode版本. 查询Xcode release notes, 发现和macOS 10.13兼容性最好的还是Xcode 9.4.1 打开浏览器, 登录https://developer.apple.com/download/more/ 需要苹果id登录 搜索”Xcode 9.4.1” 下载 将下载的Xcode安装文件上传到Macos虚拟机 123scp Xcode_9.4.1.xip xxx@192.168.1.26:/tmp 安装Xcode, 这个安装包解压后有5.6G, 所以在解压前一定要预留足够的磁盘空间. 123xip --expand /tmp/Xcode_9.4.1.xip 123# 查看解压后文件大小Xcode.app $ du -sh5.6G 将Xcode.app移动到/Applications目录 123mv /tmp/Xcode.app /Applications 再次打开finder, 点击Xcode即可打开Xcode了. 4. 安装brewbrew for macos 10.13.6 123/bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot; 5. 安装nodejs安装和配置nodejs可以参考我的博客鹏叔的技术博客 - MacOS上安装nvm 6. 安装vscodevscode for mac有三个版本, 一个是用于intel芯片组的版本, 一个apple silicon版本的, 还有一个Universal版本. 从vscode下载页面 下载Universal版本, 双击安装即可. 7. 参考文档MacOS 安装Brew 低版本Mac OS安装合适xcode的方法 MacBook 苹果笔记本 下载Xcode历史版本并安装！ How to install Xcode from xip file mac下镜像飞速安装Homebrew教程","link":"/vmware/macos_env_setup.html"},{"title":"vmware ESXi配置","text":"1. 前言这篇文章主要用来收集VMWare ESXi的一些配置步骤. 2. 开启SSH服务默认ssh服务是关闭的, 开启ssh服务过程如下 进入管理=&gt;服务, 找到TSM-SSH服务, 右击该服务会弹出子菜单, 点击启动. 要设为开机启动, 右击服务, 选择策略, 选择随主机启动和停止 3. 时间配置此任务将介绍如何从 VMware Host Client 设置 NTP。 过程 启动 VMware Host Client，然后连接到 ESXi 主机。 单击管理。 在系统下，单击时间和日期，然后单击编辑设置。 选择使用网络时间协议 (启用 NTP 客户端)。 在“NTP 服务器”文本框中，输入要与其同步的一个或多个 NTP 服务器的 IP 地址或完全限定域名。这里我使用的是aliyun的NTP服务器 ntp7.aliyun.com, 更多服务器可以访问国内可靠的NTP服务器 从 NTP 服务启动策略下拉菜单中，选择随主机启动和停止。 单击保存。 此时，主机将与 NTP 服务器同步。 参考文章使 ESXi 时钟与网络时间服务器同步 4. 设置管理界面自动超时时间 选择管理–系统–高级设置–搜索timeout关键字 选择UserVars.HostClientSessionTimeout. 可见默认值为900s 也就是15min 选择编辑按钮，根据具体情况设置你期望的超时时间。如果想永不超时退出，设置为0即可。不过考虑到安全影响，尽量不要设置为0. 当近期任务中显示成功完成时, 表示修改成功. 参考文章esxi web 管理界面自动超时退出解决办法 5. 配置静态ipESXi默认使用DHCP自动获取IP, ip经常会发生变化, 这对于管理ESXi代理一些麻烦. 所以最好设置为固定ip 设置固定ip的方法如下 首先登陆网页控制台，在主界面点击“主机”–&gt;”操作”–&gt;“服务”–&gt;“启用安全shell” 用shell工具连接esxi主机，在命令行输入 就会出现显示器的控制台，由于没有显示器，所以就用这种方式改比较方便，如果有显示器，直接在显示器输出的界面上改就行，我这里由于是命令行，所以是黑白界面，显示器上博认识黄黑界面。 12TERM=xterm dcui 进入dcui界面后, 按f2进入登录界面，输入用户名和密码回车 选择“configure management network” 并按回车键 选择“IPv4 Configuration” 并按回车键 选中”set static IPv4 address and network configuration” 并按空格键 输入值固定ip, 子网掩码, 网关, 按回车键保存修改 一直按Esc键退到System Custumization页面, 选择”Restart Management network”让配置生效 直到使用静态IP可以访问ESXI服务器, 即表示设置成功 参考文档 ESXi6.7修改静态ip地址 6. 安装rsync下载 rsync 在 ESXI 中可以使用 tgz 格式的 rsync。 进入 rsync 官网下载页面，找到适合 ESXI 的 tgz 格式文件，下载到本地。 将文件上传到 ESXI 的某个目录中，比如 /tmp 中。 123scp rsync-3.2.7.tar.gz root@192.168.100.100:/tmp 关联阅读Macos开发环境配置 用Vmware esxi安装一台MacOS虚拟机 如何使用VMware ESXi安装一台Windows虚拟机 安装Ubuntu虚拟机 参考文档What is a VMware VIB?","link":"/vmware/vmware_configuration.html"},{"title":"安装Ubuntu虚拟机","text":"1. 前言安装Ubuntu虚拟机主要是为了打包Tauri桌面应用, 这里使用的虚拟化平台是VMWare ESXi 6.7. 2. 前提条件 需要一个虚拟化系统, 可以是Vmare, ESXI, 也可以是virtualBox, podman. 需要Ubuntu系统的iso文件. 3. 下载安装包Ubuntu安装包可以在各大镜像网站获取, 比如清华镜像站, 中科大镜像站, 阿里镜像站点, 华为镜像站点等. 本次安装我是用的是清华镜像站点, 下载地址Ubuntu desktop 22.4 4. 创建虚拟机创建步骤: 打开虚拟机界面 点击创建虚拟机 创建类型: 选择创建新虚拟机, 下一步 给虚拟机取一个有意义的名字 兼容性选择ESXi 6.7虚拟机 客户机操作系统系列: 选择Linux 客户机操作系统版本: 选择Ubuntu Linux(64位) 存储: 选择合适的存储 指定CPU个数, 内存大小, 硬盘大小, 其它默认即可 点击完成, 一个Ubuntu虚拟机即创建好了 此时的虚拟机仍然是一台裸机, 还没有安装操作系统和软件. 5. 安装操作系统 上传安装程序 将下载的Ubuntu安装文件上传到Vmware ESXi 存储. 打开Vmware ESXi =&gt; 存储 =&gt; datastore1 =&gt; 数据存储浏览器. 创建一个收纳安装文件的文件夹 例如: isos, 将安装文件上传到该目录下. 挂载光驱 编辑虚拟机 =&gt; 虚拟机硬件 =&gt; CD/DVD驱动器 =&gt; 选择数据存储ISO文件 =&gt; 选择上传的安装文件 调整启动顺序 编辑虚拟机 =&gt; 虚拟机选项 =&gt; 引导选项 =&gt; 可以将引导延迟加大比如10秒 或者 勾选强制执行BIOS设置 这样有机会进入BIOS程序, 调整启动盘为光驱 开机安装ubuntu 开机后调整启动盘为光驱 系统将引导至Ubuntu安装界面 当进入安装界面后, 选择”Install Ubuntu” 选择键盘布局 选择Minimal installation 和 download update while installing Ubunt, 点击Continue Install type 选择Erase disk and Install Ubuntu 时区选择ShangHai 输入用户名, 给电脑命名, 设置密码 开始安装, 等等安装完成, 完成后重启 一台Unbuntu虚拟机操作系统就安装完成了, 接下来就是配置虚拟机了. 关联阅读Macos开发环境配置 用Vmware esxi安装一台MacOS虚拟机 如何使用VMware ESXi安装一台Windows虚拟机","link":"/vmware/vmware_install_ubuntu.html"},{"title":"如何使用VMware ESXi安装一台Windows虚拟机","text":"1. 前言最近在开发一个Tauri桌面应用, 由于Tauri应用的跨平台编译特性还不是特别完善, 比如打包Windows桌面应用程序, 需要在Windows上进行. 于是想到了是否能安装一台Windows虚拟机用于打包, 并兼顾Windows上的测试. 于是就有了这篇文章. 本文原文位于鹏叔的博客空间 - 如何安装一台Windows虚拟机, 原文下面有打赏按钮, 原创不易, 希望得到您的支持, 您的支持是持续输出更多好文的动力! 2. 下载Windows安装程序可以到微软官方网站下载. 地址位于windows 11 选择: 下载 Windows 11 磁盘映像 (ISO) 3. 创建虚拟机使用vmware或者vmware ESXi或者 virtual Box创建一个8vCPU, 32G RAM, 300-500G硬盘的Windows 10或者11虚拟机. 显存调整16M, 这样支持更改分辨率. 4. 安装Windows将安装文件挂载到虚拟机的光驱. 按照指引操作即可安装windows操作系统. 安装注意事项: 如果出现”这台电脑无法运行Windows 11”, 需要绕过TPM检查. 在进入安装程序之前, 在选择语言键盘的界面做如下操作. 不要点击“现在安装” 按 Shift+F10 呼出命令提示符输入以下命令添加注册表键值 123REG ADD HKLM\\SYSTEM\\Setup\\LabConfig /v BypassTPMCheck /t REG_DWORD /d 1 5. 安装VMware tools在ESXi上点击 操作=&gt; 客户机操作系统 = &gt; 安装VMware tools ESXi将会把vmware tools安装包自动加载到windows虚拟机的光驱中, 在windows虚拟机会弹出vmware tools安装提示. 按照指引安装即可. 关联阅读Macos开发环境配置 用Vmware esxi安装一台MacOS虚拟机 安装Ubuntu虚拟机 6. 参考文档VMware ESXi 中安装Windows 11报错：这台电脑无法运行Windows 11","link":"/vmware/vmware_install_windows.html"},{"title":"Windows开发环境配置","text":"1. 安装Chocolatey以管理员身份打开powershell.exe,执行以下代码 12Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 2. 安装nodejs首先安装nvm 123choco install nvm 1nvm install 17 ## 安装 Node.js 17.X 版本 安装后，可以验证安装的内容： 1nvm ls 如果您的系统上安装了多个版本，您可以随时将任何版本设置为默认版本。要将节点 18.X 设置为默认版本，只需使用： 123nvm use 17 3. 安装rustRust环境如果已经安装过, 可以忽略此步骤. 如果未安装或者需要升级, 请参考的博客鹏叔的技术博客 - 在各种操作系统上安装和配置Rust","link":"/vmware/windows_env_setup.html"},{"title":"用Vmware安装一台MacOS虚拟机","text":"1. 前言最近在开发一个 Tauri 桌面应用, 由于 Tauri 应用的跨平台编译特性还不是特别完善, 比如打包 macos 桌面应用程序, 需要在 Macos 上进行. 于是想到了是否能安装一台 macos 虚拟机用于打包, 并兼顾 Macos 上的测试. 于是就有了这篇文章. 当然安装 macos 虚拟机的好处远不指这些. 原创不易, 本文原文位于如何安装一台 MacOS 虚拟机 | 鹏叔的技术博客 , 原文下面有打赏按钮, 希望得到您的支持, 您的支持是持续输出更多好文的动力! 2. 了解 macOS 的版本在安装 macOS 之前我们需要了解一下, macOS 都有哪些版本, 以及对虚拟机平台的硬件要求. macOS Sonoma macOS 发布时间 版本 macOS Sonoma 2024 年 03 月 26 日 14.4.1 (23E224) macOS Sonoma 2023 年 10 月 25 日 14.1 (23B74) macOS Sonoma 2023 年 09 月 26 日 14 (23A344) macOS Sonoma 2023 年 08 月 30 日 14.0 Beta 7 (23A5328b) macOS Ventura macOS 发布时间 版本 macOS Ventura 2023 年 09 月 21 日 13.6 (22G120) macOS Ventura 2023 年 09 月 07 日 13.5.2 (22G91) macOS Ventura 2023 年 08 月 17 日 13.5.1 (22G90) macOS Ventura 2023 年 07 月 24 日 13.5(22G74) macOS Ventura 2023 年 06 月 21 日 13.4.1 (22F82) macOS Ventura 2023 年 05 月 18 日 13.4 (22F66) macOS Ventura 2023 年 04 月 07 日 13.3.1(22E261) macOS Ventura 2023 年 03 月 27 日 13.3 (22E252) macOS Ventura 2023 年 02 月 13 日 13.2.1 (22D68) macOS Ventura 2023 年 01 月 23 日 13.2 (22D49) macOS Ventura 2022 年 12 月 13 日 13.1 (22C65) macOS Ventura 2022 年 11 月 10 日 13.0.1 (22A400) macOS Ventura 2022 年 10 月 25 日 13.0 (22A380) macOS Monterey macOS 发布时间 版本 macOS Monterey 2023 年 09 月 21 日 12.7 macOS Monterey 2023 年 07 月 28 日 12.6.8 macOS Monterey 2023 年 06 月 22 日 12.6.7 macOS Monterey 2023 年 05 月 18 日 12.6.6 macOS Monterey 2023 年 04 月 10 日 12.6.5 macOS Monterey 2023 年 03 月 27 日 12.6.4 macOS Monterey 2023 年 01 月 26 日 12.6.3 macOS Monterey 2022 年 12 月 16 日 12.6.2 macOS Monterey 2022 年 10 月 24 日 12.6.1 macOS Monterey 2022 年 09 月 13 日 12.6 macOS Monterey 2022 年 08 月 17 日 12.5.1 macOS Monterey 2022 年 07 月 25 日 12.5 macOS Monterey 2022 年 05 月 18 日 12.4 macOS Monterey 2022 年 03 月 31 日 12.3.1 macOS Monterey 2022 年 03 月 14 日 12.3 macOS Monterey 2022 年 02 月 10 日 12.2.1 macOS Monterey 2022 年 01 月 27 日 12.2 macOS Monterey 2021 年 12 月 14 日 12.1 macOS Monterey 2021 年 10 月 26 日 12.0.1 macOS Big Sur (macOS 11.x) 首次发布时间 2020 年 11 月 12 日 macOS Catalina (macOS 10.15.x) 首次发布时间 2019 年 10 月 7 日 macOS Mojave (macOS 10.14.x) 首次发布时间 2018 年 9 月 24 日 macOS High Sierra (macOS 10.13.x) 首次发布时间 2017 年 10 月 5 日 其他 macOS macOS 发布时间 版本 macOS Sierra 2017 年 7 月 19 日 10.12.6 OS X El Capitan 2016 年 7 月 18 日 10.11.6 OS X Yosemite 2015 年 8 月 13 日 10.10.5 OS X Mavericks 2014 年 9 月 17 日 10.9.5 OS X Mountain Lion 2013 年 9 月 12 日 10.8.5 OS X Lion 2012 年 10 月 4 日 10.7.5 Mac OS X Snow Leopard 2011 年 7 月 25 日 10.6.8 Mac OS X Leopard 2007 年 10.5.8 Mac OS X Tiger 2005 年 10.4.11 Mac OS X Panther 2003 年 10.3.9 Mac OS X Jaguar 2002 年 10.2.8 Mac OS X Puma 2001 年 10.1.5 Mac OS X Cheetah 2001 年 10.0.4 更多 Macos 版本信息可以参考macOS 系统各版本发布日期时间及 Mac 系统下载集合 3. 了解 macos 的安装包格式macos 的安装包有两种格式: PKG 和 DMG. PKG 文件格式通常被苹果公司用于其移动和桌面设备。它受到 macOS 和 iOS 的支持。不过，这并不是苹果设备独有的，因为索尼也使用 PKG 在 PlayStation 设备上安装软件包。 DMG 是磁盘映像文件的缩写。DMG 是 Apple 磁盘映像文件的扩展名。它是一个磁盘映像，可以用于分发软件或其他文件，甚至可以用于存储（如可移动媒体） DMG 又分为两个版本: 一个是基于 Apple Silicon cpu 架构的也就是 ARM 架构的, 一个是 Intel cpu 也就是 x86 和 x64 架构的. 以下是本教程使用的 DMG 版本: macOS High Sierra 10.13.6 (DMG 格式) 下载地址 DMG 格式的安装文件下载后需要转换为 ISO 格式才能在虚拟机上使用, 下面是转换好的格式. macOS High Sierra 10.13.6 (ISO 格式) 下载地址 密码：1t3e 无论选择哪种格式下载过程会很久, 请耐心等待. update on 2024-4-26: 关于如何制作ISO文件，可以参考我近期的博客如何制作 macOS Sonoma ISO 文件 | 鹏叔的技术博客 4. 安装 macos Unlockermacos Unlocker 最新版是一个用于电脑安装 mac 虚拟机的破解工具，用户可以使用此工具来解锁系统权限，让你可以选择 macos 等其他系统的安装。允许您使用 VMware 或 VirtualBox 将 Mac OS X 安装到任何计算机上以创建苹果虚拟机。 针对不同的虚拟平台下载不同的 macos Unlocker. 本教程针对 vmware esxi 6.7 和 vmware player 17.5.0 进行了测试，两者安装 VMware Unlocker 的过程稍有不同，下面分别介绍如何安装 VMware Unlocker. For Vmare esxi针对 Vmare esxi 所以使用的是 VMware Unlocker for esxi. 首先下载VMware Unlocker for esxi 上传至 ESXi 服务器, 解压并执行解锁程序. 1234567891011unzip unlocker302.zip# 执行Unlocker补丁./esxi-install.sh# 安装完成后检测一下, 当输出smcPresent = true表示解锁成功./esxi-smctest.sh For vmware player对于 vmware player， 本文测试使用的版本为 17.5.0 ， 如果不是该版本，需要了解 vmware 与 vmare unlocker 的版本兼容性进行调整。 首先下载Unlocker 4.2.7， 保存到 tmp 目录 1234567## 下载Unlocker，并保存到tmp目录wget -O /tmp/unlocker427.zip https://github.com/DrDonk/unlocker/releases/download/v4.2.7/unlocker427.zip## 或者# 如果操作系统上安装了curl命令, 可以使用curl下载curl --output /tmp/unlocker427.zip https://github.com/DrDonk/unlocker/releases/download/v4.2.7/unlocker427.zip 解压并执行解锁程序. 123456789101112unzip /tmp/unlocker427.zip -d /tmp/unlocker# 执行Unlocker补丁, 执行unlock之前需要确保vmware已经关闭cd /tmp/unlocker/linuxsudo ./unlock# 安装完成后检测一下sudo ./unlock 5. 创建 MacOS 虚拟机如果下载的是 DMG 格式需要使用工具例如 UltraISO 将其转换为 ISO 格式. 这里使用的虚拟化平台是 VMWARE ESXI, 安装步骤也适用于 VMWare 系列产品. 将 ISO 或者 PKG 文件上传至 ESXi 存储盘. 创建 Macos 虚拟机: 在 ESXi web 界面点击”创建/注册虚拟机” 选择”创建类型” =&gt; “创建新虚拟机” 输入虚拟机名称 =&gt; 兼容性选择 “ESXi 6.5 虚拟机” =&gt; 客户操作系统系列 选择”Mac OS” =&gt; 客户机操作系统版本 选择”Apple Mac OS X 10.13(64 位)” 选择存储 自定义设置, 在内存和 CPU 足够的情况下尽量多给一些. 经测试 8vCPU, 32G 内存够用但是依然有点卡顿. CD/DVD 驱动器, 选择 ISO 镜像, 并确保光驱在开机时自动连接. 等待虚拟机创建完成. 6. 安装操作系统虚拟机创建完成后, 点击打开电源. 如果看到白苹果界面, 表示虚拟机创建成功. 接下来的工作即是按照安装指引进行, 这里不做截图. 需要说明的几点: 在跳过语言选择界面后, 需要点击上方工具栏, 磁盘工具, 进行手动的磁盘格式化, 这一步容易被忽略, 导致后续步骤找不到磁盘, 实际原因是漏掉磁盘格式化步骤. 也许苹果是出于对于苹果电脑数据安全性考虑, 没有自动引导至磁盘格式化步骤, 但是对于虚拟机其实这种这种安全考虑不是太重要. 在登录 Apple 账号的时候, 在客户隐私政策和 Game Center 条款和条件界面, 同意按钮始终不能点击. 不要登录苹果 ID 就可以了, 可跳过这一步. 安装完成后, 对系统做一次升级, 将其升级到 10.13.6 参考https://www.maczd.com/post/macos-high-sierra-10-13-6.html 7. 安装 VMWare ToolsVMWare Tools 允许允许在虚拟机管理系统上显示虚拟机的详细信息, 比如 IP 地址, 内存使用情况, CPU 使用情况等. 并允许在虚拟机上执行操作, 例如正常关闭, 重新引导. 这里建议 VMWare Tools 还有一个最主要的原因, 是可以调整 Macos 的分辨率, 默认的分辨率只有一个, 不适合远程连接时全屏显示, 全屏时屏幕不能完全占满, 总是有大片的黑边. 当然 Macos 上也有调整分辨率的软件可以使用, 试过几款都不是很好用. 由于 ESXi 6.7 上没有自带 Macos 的 VMTools, 需要到 vmware 官网去下载. VMware Tools 一直在更新，最新版本为 13.0.2，可以在这个网站上下载. 我选择的是最新的版本 13.0.2, 下载后解压缩, 将 payload\\VMware Fusion.app\\Contents\\Library\\isoimages\\x86_x64\\darwin.iso 上传到 ESXi server 的存储路径. 在虚拟机开启的状态下, 先弹出光驱, 在挂载 darwin.iso 至光驱, 这时候 macos 应该能感知到光驱重新插入, 提示安装 VMware Tools. 然后按照安装指引进行安装, 安装过程中需要注意的地方是, 即将开始安装时, 系统会弹出系统扩展已被阻止, 此时打开系统安全偏好设置, 允许来自开发者”VMWare Inc.”的系统软件. 安装完 VMWare Tools 后关机, 将虚拟机的显存调大到例如 32M, VMware 虚拟机默认的显存太小. 会导致后续设置分辨率时 Requested resolution 和 Effective resolution 分辨率不一致. 然后重启 macos 虚拟机, 设置分辨率. 1234567sudo /Library/Application\\ Support/VMware\\ Tools/vmware-resolutionSet 1920 1080Password:Requested resolution: 1920x1080Effective resolution: 1920x1080 注意: 如果这里 Requested resolution 和 Effective resolution 可能是显存不足, 可以加大显存再试. 关联阅读Macos 开发环境配置 如何使用 VMware ESXi 安装一台 Windows 虚拟机 安装 Ubuntu 虚拟机 8. 参考文档在虚拟机中安装 macOS 系统全套图文教程，附工具与镜像 macOS 虚拟机安装全过程（VMware）（非常详细）从零基础入门到精通，看完这一篇就够了 How To Run Mac OS X In Windows 10 With VMware Unlocker ESXi6.7 上安装 MAC 系统（苹果系统 Installing macOS High Sierra 10.13.5 with VMware Virtualization Software.md Bootable Mac ISO with Linux.md Create a bootable installer for macOS Download/Create macOS Sonoma ISO for VMware or VirtualBox","link":"/vmware/vmware_macos_vm.html"},{"title":"block、inline 和 inline-block三者之间的区别","text":"1. 前言 block 和 inline 这两个概念是简略的说法，完整确切的说应该是 block-level elements (块级元素) 和 inline elements (内联元素)。block 元素通常被现实为独立的一块，会单独换一行；inline 元素则前后不会产生换行，一系列 inline 元素都在一行内显示，直到该行排满。 大体来说 HTML 元素各有其自身的布局级别（block 元素还是 inline 元素）： 常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6, DL, OL, UL 等。 常见的内联元素有 SPAN, A, STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。 block 元素可以包含 block 元素和 inline 元素；但 inline 元素只能包含 inline 元素。要注意的是这个是个大概的说法，每个特定的元素能包含的元素也是特定的，所以具体到个别元素上，这条规律是不适用的。比如 P 元素，只能包含 inline 元素，而不能包含 block 元素。 一般来说，可以通过 display:inline 和 display:block 的设置，改变元素的布局级别。 2. display: block block 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。 block 元素可以设置 width,height 属性。块级元素即使设置了宽度,仍然是独占一行。 block 元素可以设置 margin 和 padding 属性。 3. display:inline inline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline 元素设置 width,height 属性无效。 inline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right 都产生边距效果；但竖直方向的 padding-top, padding-bottom, margin-top, margin-bottom 不会产生边距效果。 例外: input, video 和 img 等元素设置为 inline 元素 width 和 height 是有效的其 margin 和 padding 属性竖直方向也都是有效的 4. display: inline-block简单来说就是将对象呈现为 inline 对象，但是对象的内容作为 block 对象呈现。 与 display: inline 相比，主要区别在于 display: inline-block 允许在元素上设置宽度和高度。 同样，如果设置了 display: inline-block，将保留上下外边距/内边距，而 display: inline 则不会。 与 display: block 相比，主要区别在于 display：inline-block 在元素之后不添加换行符，因此该元素可以位于其他元素旁边。 下例展示 display: inline、display: inline-block 以及 display: block 的不同行为： 注意: IE（低版本 IE）本来是不支持 inline-block 的，所以在 IE 中对内联元素使用 display:inline-block，理论上 IE 是不识别的，但使用 display:inline-block 在 IE 下会触发 layout，从而使内联元素拥有了 display:inline-block 属性的表象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; span.a { display: inline; /* the default for span */ width: 100px; height: 100px; padding: 5px; border: 1px solid blue; background-color: yellow; } span.b { display: inline-block; width: 100px; height: 100px; padding: 5px; border: 1px solid blue; background-color: yellow; } span.c { display: block; width: 100px; height: 100px; padding: 5px; border: 1px solid blue; background-color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;display 属性&lt;/h1&gt; &lt;h2&gt;display: inline&lt;/h2&gt; &lt;div&gt; Shanghai is one of the four direct-administered municipalities of &lt;span class=&quot;a&quot;&gt;the People's Republic of China&lt;/span&gt;. Welcome to &lt;span class=&quot;a&quot;&gt;Shanghai&lt;/span&gt;! &lt;/div&gt; &lt;h2&gt;display: inline-block&lt;/h2&gt; &lt;div&gt; Shanghai is one of the four direct-administered municipalities of &lt;span class=&quot;b&quot;&gt;the People's Republic of China&lt;/span&gt;. Welcome to &lt;span class=&quot;b&quot;&gt;Shanghai&lt;/span&gt;! &lt;/div&gt; &lt;h2&gt;display: block&lt;/h2&gt; &lt;div&gt; Shanghai is one of the four direct-administered municipalities of &lt;span class=&quot;c&quot;&gt;the People's Republic of China&lt;/span&gt;. Welcome to &lt;span class=&quot;c&quot;&gt;Shanghai&lt;/span&gt;! &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5. 补充说明一般我们会用 display:block，display:inline 或者 display:inline-block 来调整元素的布局级别，其实 display 的参数远远不止这三种，仅仅是比较常用而已。 display 所有的参数如下: 1234567891011121314151617181920212223242526272829303132333435/* precomposed values */display: block;display: inline;display: inline-block;display: flex;display: inline-flex;display: grid;display: inline-grid;display: flow-root;/* box generation */display: none;display: contents;/* two-value syntax */display: block flow;display: inline flow;display: inline flow-root;display: block flex;display: inline flex;display: block grid;display: inline grid;display: block flow-root;/* other values */display: table;display: table-row; /* all table elements have an equivalent CSS display value */display: list-item;/* Global values */display: inherit;display: initial;display: revert;display: revert-layer;display: unset; 6. 参考文档block，inline 和 inline-block 概念和区别 CSS 布局 - display: inline-block","link":"/web/block_inline_inline_block.html"},{"title":"Chart.js教程","text":"1. chart.js 介绍Chart.js是一个流行的由社区维护的开源数据可视化框架。它使我们能够生成响应式条形图、饼图、线图、甜甜圈图、散点图等。我们所要做的就是简单地指出你想在页面的什么地方显示图表，你想绘制什么样的图表，然后向 Chart.js 提供数据、标签和其他设置。在这之后，这个库就完成了所有繁重的工作。 1.1. Chart.js 特点 Chart.js 是开源的，由社区共同维护的开源项目。 Chart.js 支持 8 种图表类型，每种方式都具有动态效果并且可定制。 Chart.js 使用 HTML5 Canvas 技术，在所有现代浏览器（IE11+）上都有高效的绘图效率。 Chart.js 是响应式，可以根据窗口尺寸的变化重绘所有图表，展现更加细腻。 1.2. Chart.js 相关资料 Chart.js 官网：https://www.chartjs.org/ Chart.js Github：https://github.com/chartjs/Chart.js Chart.js 文档：https://www.chartjs.org/docs/latest/ Chart.js 实例：https://www.chartjs.org/docs/latest/samples/information.html 2. chart.js 安装我们可以从 npm、GitHub 版本或使用 Chart.js CDN 获取最新版本的 Chart.js。如果使用的是前端框架（例如，React、Angular 或 Vue），可以查看可用的集成 。 NPM 安装： 1234# 安装最新版本npm install chart.js# 安装指定版本npm install chart.js@x.y.z CDN Chart.js CDN 地址，4.0.1 版本： Staticfile（国内）：https://cdn.staticfile.org/Chart.js/4.0.1/chart.js Cdnjs（海外）：https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.0.1/chart.min.js 实例: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Chart.js examples&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/Chart.js/4.0.1/chart.umd.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = (event) =&gt; { const container = document.getElementById('myChart'); const myChart = new Chart(container, {...}); }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;width: 600px; height: 600px&quot;&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;myChart&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 使用 Chart.js放置 canvas 画布前面我们讲解了如何安装 chart.js 或将 chart.js 引入到我们的页面. 引入了 chart.js 后我们就可以开始使用 chart.js 了. 在使用 chart.js 库之前, 我们需要在页面放置一个&lt;canvas&gt;元素, 因为 Chart.js 需要使用 HTML5 画布来绘图。 首先我们需要在页面上引入 canvas 如下. 123&lt;div style=&quot;width:200px; height:400px;&quot; &gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;myChart&quot;&gt;&lt;/canvas&gt;&lt;/div&gt; 从代码我们可以看出图表的大小比例是由 canvas 的宽度和高度来决定的, 而图表的实际宽高由父元素的宽高限定. 创建 Chart 对象接下来我们需要创建 Canvas 对象. 在构造 Canvas 对象前, 我们需要了解它的 API 说明文档以及源代码. 通过查看Chart.js API 的官方文档 和 Chart 类源代码, 我们发现构造 Chart 对象需要传递两个参数. Chart 对象的构造器 12345678910constructor(item, userConfig) { const config = this.config = new Config(userConfig); const initialCanvas = getCanvas(item); const existingChart = getChart(initialCanvas); if (existingChart) { throw new Error( 'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.' ); } ChartItem一个参数是 item 其类型为ChartItem, 它代表我们放置在界面的 Canvas 元素, 一个参数是 userConfig 用于指定图表的类型, 例如是饼图, 还是柱状图还是其它, 以及图形所需的数据, 以及图形的样式等. 通过查看 getCanvas 函数, 我们发现 item 参数可以是一个标识 Canvas 的 id 字符串, 也可以是一个 jquery 数组例如$('#myChart'), 也可以是一个 Canvas 元素例如document.getElementById('myChart') 或者 document.getElementById('myChart').getContext('2d'); 1234567891011121314function getCanvas(item) { if (_isDomSupported() &amp;&amp; typeof item === 'string') { item = document.getElementById(item); } else if (item &amp;&amp; item.length) { // Support for array based queries (such as jQuery) item = item[0]; } if (item &amp;&amp; item.canvas) { // Support for any object associated to a canvas (including a context2d) item = item.canvas; } return item;} userConfig另外一个参数 userConfig, 其类型为ChartConfiguration &lt;TType, TData, TLabel&gt; | ChartConfigurationCustomTypesPerDataset &lt;TType, TData, TLabel&gt;, 由三部分组成: 类型, 数据, 和标签. Chartjs 图表示例以下实例我们创建一个简单的折线图 123456789101112131415161718192021222324252627const canvas = document.getElementById(&quot;myChart&quot;); const saleData = [ {month:&quot;一月份&quot;, quantity: 65}, {month:&quot;二月份&quot;, quantity: 59}, {month:&quot;三月份&quot;, quantity: 80}, {month:&quot;四月份&quot;, quantity: 81}, {month:&quot;五月份&quot;, quantity: 56}, {month:&quot;六月份&quot;, quantity: 55}, {month:&quot;七月份&quot;, quantity: 40}, ]; // 设置 X 轴上对应的标签 const data = { labels: saleData.map(row =&gt; row.month), datasets: [ { label: &quot;我的第一个折线图&quot;, data: saleData.map(row =&gt; row.quantity), fill: false, borderColor: &quot;rgb(75, 192, 192)&quot;, // 设置线的颜色 tension: 0.1, }, ], }; const config = { type: &quot;line&quot;, // 设置图表类型 data: data, }; const myChart = new Chart(canvas, config); 以下实例创建一个柱形图，显示不同颜色的票数。 12345678910111213141516171819202122232425262728293031323334353637const canvas = document.getElementById(&quot;myChart&quot;);const myChart = new Chart(canvas, { type: &quot;bar&quot;, data: { labels: [&quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Purple&quot;, &quot;Orange&quot;], datasets: [ { label: &quot;# 票数&quot;, data: [12, 19, 3, 5, 2, 3], backgroundColor: [ &quot;rgba(255, 99, 132, 0.2)&quot;, &quot;rgba(54, 162, 235, 0.2)&quot;, &quot;rgba(255, 206, 86, 0.2)&quot;, &quot;rgba(75, 192, 192, 0.2)&quot;, &quot;rgba(153, 102, 255, 0.2)&quot;, &quot;rgba(255, 159, 64, 0.2)&quot;, ], borderColor: [ &quot;rgba(255, 99, 132, 1)&quot;, &quot;rgba(54, 162, 235, 1)&quot;, &quot;rgba(255, 206, 86, 1)&quot;, &quot;rgba(75, 192, 192, 1)&quot;, &quot;rgba(153, 102, 255, 1)&quot;, &quot;rgba(255, 159, 64, 1)&quot;, ], borderWidth: 1, }, ], }, options: { scales: { y: { beginAtZero: true, }, }, },}); 接下来我们来看更多类型的 Chart 图表以及在使用这些图表的异同点. Chart.js 柱状图柱状图是一种以长方形的长度为变量的统计图表。 主要用于多个分类间的数据（大小、数值）的对比，可以用来显示一段时间内的数据变化或显示各项之间的比较情况，适用于二维数据集。柱状图的易用性和解释性使其成为最常用的图表之一. 柱形图的 type 属性为 bar ，type 描述了图表类型。 接下来我们创建一个简单的柱形图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const canvas = document.getElementById(&quot;myChart&quot;);const saleData = [ {month:&quot;一月份&quot;, quantity: 65}, {month:&quot;二月份&quot;, quantity: 59}, {month:&quot;三月份&quot;, quantity: 80}, {month:&quot;四月份&quot;, quantity: 81}, {month:&quot;五月份&quot;, quantity: 56}, {month:&quot;六月份&quot;, quantity: 55}, {month:&quot;七月份&quot;, quantity: 40}, ]; const data = { labels: saleData.map(row =&gt; row.month), datasets: [ { label: &quot;我的第一个柱形图&quot;, data: saleData.map(row =&gt; row.quantity), backgroundColor: [ // 设置每个柱形图的背景颜色 &quot;rgba(255, 99, 132, 0.2)&quot;, &quot;rgba(255, 159, 64, 0.2)&quot;, &quot;rgba(255, 205, 86, 0.2)&quot;, &quot;rgba(75, 192, 192, 0.2)&quot;, &quot;rgba(54, 162, 235, 0.2)&quot;, &quot;rgba(153, 102, 255, 0.2)&quot;, &quot;rgba(201, 203, 207, 0.2)&quot;, ], borderColor: [ //设置每个柱形图边框线条颜色 &quot;rgb(255, 99, 132)&quot;, &quot;rgb(255, 159, 64)&quot;, &quot;rgb(255, 205, 86)&quot;, &quot;rgb(75, 192, 192)&quot;, &quot;rgb(54, 162, 235)&quot;, &quot;rgb(153, 102, 255)&quot;, &quot;rgb(201, 203, 207)&quot;, ], borderWidth: 1, // 设置线条宽度 }, ],};const config = { type: &quot;bar&quot;, // 设置图表类型 data: data, // 设置数据集 options: { scales: { y: { beginAtZero: true, // 设置 y 轴从 0 开始 }, }, },};const myChart = new Chart(canvas, config); 以上实例输出结果为： chart.js 还可以制作水平柱状图. 水平柱形图是垂直条形图的变，常用于显示数据趋势，以及并排比较多个数据集。 设置水平柱形图需要将选项对象中的 indexAxis 属性设置为 y，indexAxis 属性的默认值为 x。 12345678const config = { type: &quot;bar&quot;, // 设置图表类型 data: data, // 设置数据集 options: { indexAxis: &quot;y&quot;, },};const myChart = new Chart(canvas, config); Chart.js 气泡图气泡图用于展示三个变量之间的关系。 气泡的位置由前两个变量决定，对应的是 X 轴和 Y 轴，第三个参数为气泡的大小。 泡图的 type 属性为 bubble ，type 描述了图表类型。 1234567891011121314151617181920212223242526272829303132const ctx = document.getElementById(&quot;myChart&quot;);const data = { datasets: [ { label: &quot;气泡图实例&quot;, data: [ { x: 20, // X 轴 y: 30, // Y 轴 r: 15, // 气泡半径 }, { x: 30, y: 20, r: 20, }, { x: 40, y: 10, r: 10, }, ], backgroundColor: &quot;rgb(255, 99, 132)&quot;, }, ],};const config = { type: &quot;bubble&quot;, // 设置图表类型 data: data, // 设置数据集 options: {},};const myChart = new Chart(ctx, config); 以上实例输出结果为： Chart.js 环形图环形图又叫做甜甜圈图，其本质是饼图将中间区域挖空。 环形图是由两个及两个以上大小不一的饼图叠在一起，挖去中间的部分所构成的图形。 饼图是用圆形及圆内扇形的角度来表示数值大小的图形，它主要用于表示一个样本（或总体）中各组成部分的数据占全部数据的比例，对于研究结构性问题十分有用。 环形图与饼图类似，但又有区别。环形图中间有一个”空洞”，每个样本用一个环来表示，样本中的每一部分数据用环中的一段表示。因此环形图可显示多个样本各部分所占的相应比例，从而有利于构成的比较研究。 环形图 type 属性为 doughnut ，type 描述了图表类型。 接下来我们创建一个简单的环形图： 123456789101112131415161718192021222324252627282930313233343536373839const myCanvas = document.getElementById(&quot;myChart&quot;); const data = [ {color: &quot;Red&quot;, count: 300}, {color: &quot;Blue&quot;, count: 50}, {color: &quot;Red&quot;, count: 100} ] const config = { type: &quot;doughnut&quot;, data: { labels: data.map(row =&gt; row.color), datasets: [ { label: &quot;环形图实例&quot;, data: data.map(row =&gt; row.count), backgroundColor: [ &quot;rgb(255, 99, 132)&quot;, &quot;rgb(54, 162, 235)&quot;, &quot;rgb(255, 205, 86)&quot;, ], hoverOffset: 4, }, ], }, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 scales: { yAxes: [ { ticks: { beginAtZero: true, }, }, ], }, }, }; const myChart = new Chart(myCanvas, config); 以上实例输出结果为： Chart.js 饼图饼图，或称饼状图，是一个划分为几个扇形的圆形统计图表，用于描述量、频率或百分比之间的相对关系。在饼图中，每个扇区的弧长（以及圆心角和面积）大小为其所表示的数量的比例。这些扇区合在一起刚好是一个完全的圆形。顾名思义，这些扇区拼成了一个切开的饼形图案。 饼图 type 属性为 pie ，type 描述了图表类型。 接下来我们创建一个简单的饼图： 1234567891011121314151617181920212223242526272829303132333435363738const myCanvas = document.getElementById(&quot;myChart&quot;);const data = [ { color: &quot;Red&quot;, count: 300 }, { color: &quot;Blue&quot;, count: 50 }, { color: &quot;Red&quot;, count: 100 },];const config = { type: &quot;pie&quot;, data: { labels: data.map(row=&gt; row.color), datasets: [ { label: &quot;饼图实例&quot;, data: data.map(row=&gt; row.count), backgroundColor: [ &quot;rgb(255, 99, 132)&quot;, &quot;rgb(54, 162, 235)&quot;, &quot;rgb(255, 205, 86)&quot;, ], hoverOffset: 4, }, ], }, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 scales: { yAxes: [ { ticks: { beginAtZero: true, }, }, ], }, },};const myChart = new Chart(myCanvas, config); 以上实例输出结果为： Chart.js 折线图折线图是排列在工作表的列或行中的数据可以绘制到折线图中。 折线图可以显示随时间（根据常用比例设置）而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。 折线图 type 属性为 line ，type 描述了图表类型。 接下来我们创建一个简单的折线图： 1234567891011121314151617181920212223242526const myCanvas = document.getElementById(&quot;myChart&quot;);const data = [ { month: &quot;一月份&quot;, quantity: 65 }, { month: &quot;二月份&quot;, quantity: 59 }, { month: &quot;三月份&quot;, quantity: 80 }, { month: &quot;四月份&quot;, quantity: 81 }, { month: &quot;五月份&quot;, quantity: 56 }, { month: &quot;六月份&quot;, quantity: 55 }, { month: &quot;七月份&quot;, quantity: 40 },];const config = { type: &quot;line&quot;, // 设置图表类型 data: { labels: data.map(row=&gt;row.month), datasets: [ { label: &quot;我的第一个折线图&quot;, data: data.map(row=&gt;row.quantity), fill: false, borderColor: &quot;rgb(75, 192, 192)&quot;, // 设置线的颜色 tension: 0.1, }, ], },};const myChart = new Chart(myCanvas, config); Chart.js 混合图Chart.js 可以创建由两种或多种不同图表类型组合而成的混合图表，比如条形图与折线图的混合。 创建混合图表时，我们在每个数据集上指定图表类型。 混合图 type 属性为 scatter。 柱形图 type 属性为 bar ，折线图 type 属性为 line ， type 描述了图表类型。 接下来我们创建一个简单的混合图： 12345678910111213141516171819202122232425262728293031323334353637383940const myCanvas = document.getElementById(&quot;myChart&quot;);const saleData = [ { month: &quot;一月份&quot;, quantity: 45, amount: 50.0 }, { month: &quot;二月份&quot;, quantity: 49, amount: 40.0 }, { month: &quot;三月份&quot;, quantity: 52, amount: 45.0 }, { month: &quot;四月份&quot;, quantity: 48, amount: 49.0 },];const data = { labels: saleData.map((row) =&gt; row.month), datasets: [ { type: &quot;bar&quot;, label: &quot;柱形图数据集&quot;, data: saleData.map((row) =&gt; row.quantity), borderColor: &quot;rgb(255, 99, 132)&quot;, backgroundColor: &quot;rgba(255, 99, 132, 0.2)&quot;, }, { type: &quot;line&quot;, label: &quot;折线图数据集&quot;, data: saleData.map((row) =&gt; row.amount), fill: false, borderColor: &quot;rgb(54, 162, 235)&quot;, }, ],};const config = { type: &quot;scatter&quot;, data: data, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 scales: { y: { beginAtZero: true, }, }, },};const myChart = new Chart(myCanvas, config); 以上实例输出结果为： Chart.js 极地图极区图类似于饼图，但每个数据集具有相同的角度，线段的半径根据提供的值有所不同。 混合图 type 属性为 polarArea。 接下来我们创建一个简单的极地图： 1234567891011121314151617181920212223242526const ctx = document.getElementById(&quot;myChart&quot;);const data = { labels: [&quot;Red&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Grey&quot;, &quot;Blue&quot;], datasets: [ { label: &quot;极地图实例&quot;, data: [11, 16, 7, 3, 14], backgroundColor: [ &quot;rgb(255, 99, 132)&quot;, &quot;rgb(75, 192, 192)&quot;, &quot;rgb(255, 205, 86)&quot;, &quot;rgb(201, 203, 207)&quot;, &quot;rgb(54, 162, 235)&quot;, ], }, ],};const config = { type: &quot;polarArea&quot;, data: data, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 },};const myChart = new Chart(ctx, config); 以上实例输出结果为： Chart.js 雷达图雷达图是一种显示多个数据点及其之间变化的方式。 雷达图是以从同一点开始的轴上表示的三个或更多个定量变量的二维图表的形式显示多变量数据的图形方法。 轴的相对位置和角度通常是无信息的。 混合图 type 属性为 radar。 接下来我们创建一个简单的雷达图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const ctx = document.getElementById(&quot;myChart&quot;);const data = { labels: [ &quot;Eating&quot;, &quot;Drinking&quot;, &quot;Sleeping&quot;, &quot;Designing&quot;, &quot;Coding&quot;, &quot;Cycling&quot;, &quot;Running&quot;, ], datasets: [ { label: &quot;第一个数据集&quot;, data: [65, 59, 90, 81, 56, 55, 40], fill: true, backgroundColor: &quot;rgba(255, 99, 132, 0.2)&quot;, borderColor: &quot;rgb(255, 99, 132)&quot;, pointBackgroundColor: &quot;rgb(255, 99, 132)&quot;, pointBorderColor: &quot;#fff&quot;, pointHoverBackgroundColor: &quot;#fff&quot;, pointHoverBorderColor: &quot;rgb(255, 99, 132)&quot;, }, { label: &quot;第二个数据集&quot;, data: [28, 48, 40, 19, 96, 27, 100], fill: true, backgroundColor: &quot;rgba(54, 162, 235, 0.2)&quot;, borderColor: &quot;rgb(54, 162, 235)&quot;, pointBackgroundColor: &quot;rgb(54, 162, 235)&quot;, pointBorderColor: &quot;#fff&quot;, pointHoverBackgroundColor: &quot;#fff&quot;, pointHoverBorderColor: &quot;rgb(54, 162, 235)&quot;, }, ],};const config = { type: &quot;radar&quot;, data: data, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 elements: { line: { borderWidth: 3, // 设置线条宽度 }, }, },};const myChart = new Chart(ctx, config); 以上实例输出结果为： Chart.js 散点图散点图是由两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联或总结坐标点的分布模式。 散点图 type 属性为 scatter。 123456789101112131415161718192021222324252627282930313233343536373839404142const ctx = document.getElementById(&quot;myChart&quot;);const data = { datasets: [ { label: &quot;散点图实例&quot;, data: [ { x: -10, y: 0, }, { x: 0, y: 10, }, { x: 10, y: 5, }, { x: 0.5, y: 5.5, }, ], backgroundColor: &quot;rgb(255, 99, 132)&quot;, }, ],};const config = { type: &quot;scatter&quot;, data: data, options: { responsive: true, // 设置图表为响应式，根据屏幕窗口变化而变化 maintainAspectRatio: false, // 保持图表原有比例 scales: { x: { type: &quot;linear&quot;, position: &quot;bottom&quot;, }, }, },};const myChart = new Chart(ctx, config); 以上实例输出结果为： 3. 参考文档快学网-刘力超–chart.js 图表创建 Chart.js 中文教程 Chart.js 教程","link":"/web/chartjs_tutorial.html"},{"title":"canvas实现文字图片合成一张图片","text":"参考文档angular 11使用canvas实现文字图片合成一张图片 canvas + angular Canvas文本绘制实现自动换行以及调节文字换行间距","link":"/web/draw_pic_in_convas.html"},{"title":"SVG详解","text":"1. 前言SVG 是一种 XML 语言，类似 XHTML，可以用来绘制矢量图形，英文全称是Scalable Vector Graphics 可缩放矢量图, 是W3C的一项建议. 基于像素的图像, 如果被放大会看到明显的失真, 而svg是基于形状描述的, svg图像无论放大多少倍都不会失真. svg标签是SVG图像的容器. 语法格式 1&lt;svg&gt; &lt;/svg&gt; svg有很多属性和子标签. 2. 使用SVG绘制矩形, 圆形, 椭圆形 矩形 rect 圆形 circle 椭圆形 ellipse 线条 line 多条线 polyline 多边形 polygon 路径 path 2.1. 绘制矩形rectrect是rectangle的缩写 语法 1&lt;rect /&gt; 属性: width: 定义矩形的宽度. height: 定义矩形的高度. fill: 定义矩形的填充颜色. stroke-width: 定义了矩形的边框宽度. stroke: 定义矩形边框的颜色. fill-opacity: 定义填充颜色的透明度. stroke-opacity: 定义描边颜色的透明度. x: 横坐标 y: 纵坐标 rx: 定义圆角x轴上的半径(用于绘制圆角矩形) ry: 定义圆角y轴上的半径(用于绘制圆角矩形) 说明: 其中fill, stroke-width, stroke, fill-opacity, stroke-opacity是很多种图形上都有的属性. 示例 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;SVG demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; fill=&quot;blue&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot;&gt; &lt;/rect&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 绘制一个带透明度的矩形 1234567&lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;rect width=&quot;200&quot; height=&quot;200&quot; fill=&quot;blue&quot; x=&quot;50&quot; y=&quot;50&quot; fill-opacity=&quot;0.5&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot;&gt; &lt;/rect&gt;&lt;/svg&gt; 绘制圆角矩形 12345678&lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;rect width=&quot;200&quot; height=&quot;200&quot; rx=&quot;25&quot; ry=&quot;25&quot; fill=&quot;blue&quot; x=&quot;50&quot; y=&quot;50&quot; fill-opacity=&quot;0.5&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot;&gt; &lt;/rect&gt;&lt;/svg&gt; 2.2. 绘制圆形语法 123&lt;circle&gt;&lt;/circle&gt; 属性: cx: 定义圆形中心的x坐标 cy: 定义圆形中心的y坐标 r: 定义圆形的半径 fill: 定义圆形的填充颜色. stroke-width: 定义了圆形的边框宽度. stroke: 定义圆形边框的颜色. fill-opacity: 定义填充颜色的透明度. stroke-opacity: 定义描边颜色的透明度. 示例: 绘制一个圆形 12345678&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;25&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.5&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot;&gt; &lt;/circle&gt;&lt;/svg&gt; 2.3. 绘制椭圆形绘制椭圆形使用ellipse标签 语法: 1&lt;ellipse /&gt; 属性: cx: 定义椭圆形中心的x坐标 cy: 定义椭圆形中心的y坐标 rx: 定义椭圆形的水平半径 ry: 定义椭圆形的垂直半径 fill: 定义椭圆形的填充颜色. stroke-width: 定义了椭圆形的边框宽度. stroke: 定义椭圆形边框的颜色. fill-opacity: 定义填充颜色的透明度. stroke-opacity: 定义描边颜色的透明度. 示例: 绘制一个椭圆形 1234567&lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;100&quot; rx=&quot;80&quot; ry=&quot;50&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.5&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot;&gt; &lt;/ellipse&gt;&lt;/svg&gt; 绘制三个堆叠的椭圆 1234567&lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;80&quot; rx=&quot;80&quot; ry=&quot;20&quot; fill=&quot;blue&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot; /&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;110&quot; rx=&quot;80&quot; ry=&quot;20&quot; fill=&quot;purple&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot; /&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;140&quot; rx=&quot;80&quot; ry=&quot;20&quot; fill=&quot;lime&quot; stroke-width=&quot;3&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0.5&quot; /&gt;&lt;/svg&gt; 2.4. 绘制线条语法: 123&lt;line /&gt; 属性: x1: 定义直线起点的x轴坐标 y1: 定义直线起点的y轴坐标 x2: 定义直线末端的x轴坐标 y2: 定义直线末端的y轴坐标 stroke-width: 定义了直线的宽度. stroke: 定义直线的颜色. stroke-opacity: 定义直线颜色的透明度. 坐标的原点始终在画布的左上角 示例: 绘制一条直线 1234567&lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;line x1=&quot;50&quot; y1=&quot;50&quot; x2=&quot;180&quot; y2=&quot;180&quot; stroke-width=&quot;3&quot; stroke=&quot;blue&quot;&gt; &lt;/line&gt;&lt;/svg&gt; 2.5. 绘制多边形绘制多边形使用polygon标签 语法: 123&lt;polygon /&gt; 它用于创建至少包含三条边的多边形. 属性: points: 定义多边形顶点坐标. 例如: points=”220,20 250,190, 160,210”x坐标与y坐标之间用逗号隔开, 顶点之间用空格隔开. 绘制过程中, 从起点依照顺序连线, 最后回到起点形成的封闭图形即为多边形. 示例: 绘制一个三角形 1234567&lt;svg width=&quot;300&quot; height=&quot;300&quot;&gt; &lt;polygon points=&quot;220,20 250,190, 160,210&quot; stroke-width=&quot;3&quot;&gt; &lt;/polygon&gt;&lt;/svg&gt; 绘制一个四边形 1234567&lt;svg width=&quot;300&quot; height=&quot;300&quot;&gt; &lt;polygon points=&quot;220,20 250,190, 160,210 150,10&quot; stroke-width=&quot;3&quot;&gt; &lt;/polygon&gt;&lt;/svg&gt; 绘制五角星 1234567&lt;svg width=&quot;500&quot; height=&quot;210&quot;&gt; &lt;polygon points=&quot;100,10 40,198, 198,78 10,78 160,198&quot; fill=&quot;lime&quot; stroke-width=&quot;3&quot;&gt; &lt;/polygon&gt;&lt;/svg&gt; 2.6. 绘制折线绘制多线条使用polyline标签 语法: 123&lt;polyline /&gt; 属性: points: 折线端点坐标 示例: 绘制一条折线 123456&lt;svg width=&quot;500&quot; height=&quot;210&quot;&gt; &lt;polyline points=&quot;100,10 120,20, 150,130&quot; stroke-width=&quot;5&quot; stroke=&quot;red&quot; fill=&quot;none&quot;&gt; &lt;/polyline&gt;&lt;/svg&gt; 注意:线条的颜色使用stroke属性定义, 不要有填充即fill=”none”, 否则其绘制出来的图形类似多边形 3. svg绘制文本在svg里面绘制文本使用text标签. 语法: 1&lt;text&gt; content &lt;/text&gt; 属性: x: 定义文本起始未知的x轴坐标 y: 定义文本起始未知的y轴坐标 font-size: 定义文本字体大小 text-archor: 定义文本的对齐方式 (start| middle| end) 示例: 绘制一段文本 1234567&lt;svg width=&quot;500&quot; height=&quot;310&quot;&gt; &lt;text x=&quot;15&quot; y=&quot;15&quot; stroke-width=&quot;1&quot; stroke=&quot;red&quot;&gt;this is the content &lt;/text&gt;&lt;/svg&gt; 旋转文本 1234567&lt;svg width=&quot;500&quot; height=&quot;310&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; stroke-width=&quot;1&quot; stroke=&quot;red&quot; transform=&quot;rotate(30 20,40)&quot;&gt; this is the content &lt;/text&gt;&lt;/svg&gt; 绘制多行文本 123456789&lt;svg width=&quot;500&quot; height=&quot;310&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; stroke-width=&quot;1&quot; stroke=&quot;red&quot;&gt; this is the content &lt;tspan x=&quot;0&quot; y=&quot;40&quot; &gt; first line &lt;/tspan&gt; &lt;tspan x=&quot;0&quot; y=&quot;80&quot; &gt; second line &lt;/tspan&gt; &lt;/text&gt;&lt;/svg&gt; 带超链接的文本 123456789&lt;svg xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;500&quot; height=&quot;310&quot;&gt; &lt;a xlink:href=&quot;https://philoenglish.com&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; stroke-width=&quot;1&quot; stroke=&quot;blue&quot;&gt; this is the content &lt;/text&gt; &lt;/a&gt;&lt;/svg&gt; 4. SVG绘制路径使用path标签来绘制路径. 语法: 123&lt;path /&gt; 属性: d: 绘制路径的命令, 是draw的缩写. M命令: 是move to的缩写, 命令后接起始坐标 例如 M150 0 L命令: 是line to的缩写, 从上一个命令的结束点绘制一条直线到坐标位置 例如l75 100 注意: 命令字母的大小写含义是不同的, 大写字母表示绝对定位, 小写字母表示相对定位, 绝对定位相对于屏幕坐标原点的位置, 相对定位相对于上一个命令结束点的位置. 示例: 使用path画一个三角形 12345&lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;path d=&quot;M150 0 l20 20 l-40 80&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;&gt;&lt;/path&gt; &lt;/svg&gt; 绘制一个复杂的叠加图形 在该示例中我们将绘制一个三角形的示意图, 文字标注顶点. 首先在svg容器中画三个顶点. 123456789&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g fill=&quot;black&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt; &lt;/g&gt;&lt;/svg&gt; 然后给顶点表示文字 12345678910111213&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt;&lt;g fill=&quot;black&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt;&lt;/g&gt;&lt;g fill=&quot;black&quot; font-size=&quot;24&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;350&quot; text-anchor=&quot;end&quot; &gt;A &lt;/text&gt; &lt;text x=&quot;250&quot; y=&quot;50&quot; text-anchor=&quot;middle&quot;&gt;B &lt;/text&gt; &lt;text x=&quot;400&quot; y=&quot;350&quot; text-anchor=&quot;start&quot;&gt;C &lt;/text&gt;&lt;/g&gt;&lt;/svg&gt; 然后使用path划线的方法画出三角形的边 123456789101112131415161718&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g fill=&quot;black&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot;/&gt; &lt;circle cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot;/&gt; &lt;/g&gt; &lt;g fill=&quot;black&quot; font-size=&quot;24&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;350&quot; text-anchor=&quot;end&quot; &gt;A &lt;/text&gt; &lt;text x=&quot;250&quot; y=&quot;50&quot; text-anchor=&quot;middle&quot;&gt;B &lt;/text&gt; &lt;text x=&quot;400&quot; y=&quot;350&quot; text-anchor=&quot;start&quot;&gt;C &lt;/text&gt; &lt;/g&gt; &lt;g stroke=&quot;black&quot; stroke-width=&quot;2&quot;&gt; &lt;path d=&quot;M100 350 L250 50&quot; &gt;&lt;/path&gt; &lt;path d=&quot;M250 50 L400 350&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M400 350 L100 350&quot;&gt;&lt;/path&gt; &lt;/g&gt;&lt;/svg&gt; 说明: 在本来中我们使用g标签(group标签)将画点, 连线, 标记分组到一起, 并使用group标签定义其子元素的公共属性. 5. svg描边属性描边属性 1234&lt;path stroke=&quot;&quot; /&gt; &lt;!-- 笔画属性 --&gt;&lt;path stroke-width=&quot;&quot; /&gt; &lt;!-- 笔画宽度属性 --&gt;&lt;path stroke-linecap=&quot;&quot; /&gt; &lt;!-- 笔画笔帽属性 --&gt;&lt;path stroke-dasharray=&quot;&quot; /&gt; &lt;!-- 虚线笔画属性 --&gt; stroke属性示例, 画三条不同颜色的线: 123456789&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g stroke-width=&quot;2&quot;&gt; &lt;path stroke=&quot;black&quot; d=&quot;M100 50 l200 0&quot; &gt;&lt;/path&gt; &lt;path stroke=&quot;blue&quot; d=&quot;M100 100 l200 0&quot;&gt;&lt;/path&gt; &lt;path stroke=&quot;green&quot; d=&quot;M100 150 l200 0&quot;&gt;&lt;/path&gt; &lt;/g&gt;&lt;/svg&gt; stroke-width示例: 画三条不同粗细的线条. 1234567&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g&gt; &lt;path stroke=&quot;black&quot; stroke-width=&quot;2&quot; d=&quot;M100 50 l200 0&quot; &gt;&lt;/path&gt; &lt;path stroke=&quot;blue&quot; stroke-width=&quot;4&quot; d=&quot;M100 100 l200 0&quot;&gt;&lt;/path&gt; &lt;path stroke=&quot;green&quot; stroke-width=&quot;6&quot; d=&quot;M100 150 l200 0&quot;&gt;&lt;/path&gt; &lt;/g&gt;&lt;/svg&gt; stroke-linecap示例: 画三条不同线帽的线条. 123456789&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g stroke=&quot;black&quot;&gt; &lt;path stroke-width=&quot;6&quot; stroke-linecap=&quot;butt&quot; d=&quot;M100 50 l200 0&quot; &gt;&lt;/path&gt; &lt;path stroke-width=&quot;6&quot; stroke-linecap=&quot;round&quot; d=&quot;M100 100 l200 0&quot;&gt;&lt;/path&gt; &lt;path stroke-width=&quot;6&quot; stroke-linecap=&quot;square&quot; d=&quot;M100 150 l200 0&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;/svg&gt; stroke-dasharray示例: 绘制三条样式不同的虚线 123456789&lt;svg width=&quot;450&quot; height=&quot;400&quot;&gt; &lt;g stroke=&quot;black&quot;&gt; &lt;path stroke-width=&quot;6&quot; stroke-dasharray=&quot;5,5&quot; d=&quot;M100 50 l200 0&quot; &gt;&lt;/path&gt; &lt;path stroke-width=&quot;6&quot; stroke-dasharray=&quot;10,10&quot; d=&quot;M100 100 l200 0&quot;&gt;&lt;/path&gt; &lt;path stroke-width=&quot;6&quot; stroke-dasharray=&quot;20,10,5,5,5,10&quot; d=&quot;M100 150 l200 0&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;/svg&gt; 6. SVG模糊和阴影效果给svg图形添加模糊效果需要使用到filter属性. 语法: 123&lt;defs&gt; &lt;filter id=&quot;xxx&quot;&gt;&lt;/filter&gt;&lt;/defs&gt; filter元素是在defs(definitions的简写形式)中定义的, 需要为filter指定id属性以便调用方使用该filter效果 示例: 高斯滤镜效果 7. svg自适应前面我们讲过SVG是可缩放的矢量图, 如果您动手试验过上面的一些例子, 您会发现以上示例都是不可缩放的. 原因在于我们给SVG定义了固定的高度和宽度, 例如width=&quot;400&quot; height=&quot;400&quot;, 这往往是不适合的. 如果在制造svg时就固定它的尺寸. 在使用时会很不方便, 而且损失了SVG可缩放的优势. 在大多数情况下. SVG的大小在使用时才能确定. 那么我们在制造SVG时怎样给予它高度和宽度呢. 此时我们可以使用百分比定义SVG的尺寸, 例如width=&quot;100%&quot; height=&quot;100%&quot;. 这样定义的SVG就可以通过调整包裹它的容器例如div上尺寸乘以SVG定义的百分比来确定svg最终的尺寸. 示例: 12345678910111213141516171819&lt;div style=&quot;height: 400px; width: 400Px; background-color:red&quot;&gt; &lt;svg width=&quot;100%&quot; height=&quot;auto&quot; viewBox=&quot;0 0 137 137&quot; preserveAspectRatio=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;g fill=&quot;none&quot; fill-rule=&quot;evenodd&quot;&gt; &lt;path d=&quot;M55.56 128.42a3.57 3.57 0 0 1-3.53-4.21c.03-.16 2.81-16.26-1.86-25.98-2.9-6.02-6.09-7.1-11.86-9.07-2.96-1-6.32-2.15-10.16-4.21-6.43-3.46-9.3-9.67-14.62-14.14C6.35 64.78-5.12 58.74 2.7 47.08c3.32-4.95 9.79-7.45 14.39-7.68a15 15 0 0 1 .73-.02c3.46 0 6.3 1.23 8.58 2.21 1.24.54 2.41 1.04 3.3 1.17.26.04.55.06.86.06.75 0 1.58-.1 2.46-.22 1.05-.14 2.22-.29 3.47-.29.88 0 1.7.07 2.5.23 1.25.23 2.54.47 3.65.47.46 0 .85-.04 1.18-.13.71-.17 1.46-.4 2.19-.64 1.35-.42 2.74-.85 4.29-1.12a11.69 11.69 0 0 1 3.67-.04c-3.42-2.46-6.18-5.5-5.1-9.09 1.29-4.32 6.91-4.82 11.04-4.82 2.1 0 4.53.15 7.23.46.52-4.97.67-13.19.67-13.27a3.6 3.6 0 0 1 2.13-3.21c.47-.21 4.91-2.08 13.6-2.08l2 .03c9.94.32 16.55 2.3 17.27 2.52.68.2 7.3 2.18 15.78 7.36 8.52 5.22 11.6 9.78 11.91 10.28.75 1.16.76 2.67.02 3.84-.5.79-4.58 7.32-6.75 11.51a53.62 53.62 0 0 1 8.14 4.94c1.42 1.09 5.74 4.4 4.49 8.61-1.06 3.55-5.04 4.52-8.7 4.76 1.75 4.74 1.65 9.3-.34 13.36l-.28.55c-1.01 2.05-1.12 2.26-.76 3.83.3 1.33.78 2.68 1.28 4.1.54 1.56 1.1 3.16 1.5 4.89l.26.95.02.08c.3 1.06.81 2.85 1.19 4.4.6 2.4 1.2 4.9-.94 6.5-.4.3-10.27 7.5-32.83 10.21-20.61 2.48-38.93 15.8-39.11 15.93-.63.46-1.36.7-2.13.7&quot; fill=&quot;#FFFFFE&quot;/&gt; &lt;path d=&quot;M94.06 39.45c9.6 2.86 18.12 6.08 24.27 9a32.64 32.64 0 0 1 1.86-4.69c2.25-4.54 7.3-12.57 7.3-12.57s-2.72-4.23-10.77-9.16c-8.39-5.12-14.96-6.98-14.96-6.98s-6.51-2.06-16.34-2.37c-9.43-.3-14.03 1.74-14.03 1.74s-.17 9.48-.8 14.52c-.21 1.77-.59 3.42-.98 4.82 6.65.98 15.23 2.93 24.45 5.69&quot; fill=&quot;#322549&quot;/&gt; &lt;path d=&quot;M132.97 57.14c-1.28 4.27-20.38 2.33-42.65-4.33-22.28-6.66-39.3-15.52-38.02-19.8 1.27-4.27 20.37-2.33 42.65 4.33 22.27 6.66 39.3 15.52 38.02 19.8&quot; fill=&quot;#322549&quot;/&gt; &lt;path d=&quot;M121.36 54.91c-.72 2.42-14.43.45-30.6-4.4-16.19-4.83-28.72-10.7-28-13.11.71-2.41 14.42-.45 30.6 4.39s28.72 10.71 28 13.12&quot; fill=&quot;#322549&quot;/&gt; &lt;path d=&quot;M64.58 37.85c-.54.23-1.06.49-1.56.8-2.73 1.72-4.12 4.6-5.8 7.22-2.09-.94-4.01-1.62-6.32-1.22-2.14.37-4.15 1.19-6.2 1.7-2.03.52-4.28.1-6.37-.3-3.2-.6-6.07.7-9.15.25-3.44-.49-7.02-3.57-11.9-3.33-4.15.22-9.23 2.57-11.6 6.1-2.28 3.4-2.18 11.1 2.82 12.21 2.2.5 3.8-.16 5.23 1.92 4.73 6.83 8.68 14.6 16.12 18.6 10.94 5.87 18.27 3.94 23.54 14.88 5.27 10.95 2.17 28.16 2.17 28.16s18.92-13.97 40.81-16.6c21.9-2.64 31.12-9.53 31.12-9.53.47-.35-1.73-7.56-1.88-8.26-.7-3.06-2.08-5.92-2.78-8.99-.7-3.04.02-4.12 1.31-6.76 2.28-4.64 1.09-9.59-1.4-13.89-2.25-3.9-5.7-7.3-9.94-8.94-7.53-2.9-10.14-3.41-10.14-3.41s-1.22-8.75-15.81-10.57c-5.42-.68-10.78-1.8-16.27-1.3-2 .18-4.11.48-6 1.26&quot; fill=&quot;#322549&quot;/&gt; &lt;path d=&quot;M10.3 60.03s1.22 6.5 2.43 6.5c1.22 0 1.9-6.5 1.9-6.5H10.3&quot; fill=&quot;#322549&quot;/&gt; &lt;path d=&quot;M17.03 49.9c-2.1.63-3.98.5-4.22-.3-.24-.8 1.26-1.96 3.35-2.59 2.1-.63 3.98-.5 4.22.3.24.8-1.26 1.96-3.35 2.59zm70.02 45.77c6.56-2.9 13.2-5.78 19.42-9.36 4.75-2.74 10.49-6.25 13.05-11.3 5.3-10.41-6.67-18.76-15.53-20.42-1.5-.28-12.81-1.72-13.23.85.41-2.54 3.22-3.68 4.56-5.64 2.12-3.07-.87-3.64-3.26-4.67-4.12-1.78-8.4-3.1-12.92-3.19-4.66-.08-8.55.45-12.05 3.88-.62.6-1.43 1.5-1.55 2.35-.35 2.51 4.67 3.29 6.1 2.4a28.4 28.4 0 0 1 10.78-3.73c2.48-.31 5.05-.44 7.46.32.65.21 1.35.46 1.91.85.06.04.48.45.52.45h-4.05s-2.43 3.82-8.1 5.44c-5.68 1.63-13.3-1.62-13.3-1.62s-5.56-2.64-10.58-1.99c-5.03.65-6.13 0-6.13 0v2.4s-2.43-1.63-5.27-2.4c-2.84-.77-6.9-2.67-11.96-1.84-5.07.84-6.09.18-10.75-1.84-4.66-2.01-9.68-1.43-12.57 3.68-2.89 5.12.81 8.4.81 8.4l4.22.11c.92-.06 1.84-.11 2.7-.1.29-1.77 1.12-5.6 3.08-6.55 2.56-1.24 1.36 3 1.63 5 .12.9.31 1.79.48 2.5 3.39 1.27 6.67 3.24 11.2 2.57 5.48-.82 11.36-4.61 16.63-1.7l.22.12c.51-1.15 1.76-3.67 3.03-4 1.66-.44.14 2.27-.13 3.7-.12.63-.2 1.26-.25 1.77.56.31 1.12.62 1.68.9.36-1.35 1.03-3.39 2.04-3.88 1.54-.74.57 2.21.59 3.66 0 .53.03 1.06.07 1.51 2.66 1.14 5.28 1.79 7.96 1.36 5.06-.81 5.83-3.02 13.58.14 2.27.92 4.68 2.99 7.05 3.31 1.5.2 5.88-.06 5.73-2.37.07 1.04.85 1.45.28 2.62-.43.9-1.45 1.45-2.35 1.75-2.72.94-4.85-.69-7.31-1.6-2.72-1.02-5.74-2.78-8.67-3.07-3.65-.37-8.52 2.06-13.38 1.25-4.87-.81-8.92-6.7-15.61-5.88-6.7.81-9.13 4.06-15 2.43-.91-.25-1.73-.52-2.49-.8-.05.2-.1.44-.14.72-.2 1.55.72 4.82-1.26 3.86-1.56-.76-2.2-4.6-2.4-6.2-2.23-1.01-4.22-1.83-7-1.83-.44 0-.85.02-1.25.05 1.63 2.74 5.84 9.4 10.89 14.15C32.7 80.27 39 80.46 39 80.46s-2.03-1.62-3.85-3.04c-1.83-1.42-4.46-5.92-4.46-5.92a64 64 0 0 0 10.94 7.34 501.7 501.7 0 0 0 13.59 6.9s-1.02-.2-3.45-.62c-2.43-.4-7.1-2.22-7.1-2.22s6.29 5.47 12.57 9.53c6.29 4.05 17.64 8.3 17.64 8.3s2.38-.74 12.17-5.06z&quot; fill=&quot;#F5EA3C&quot;/&gt; &lt;path d=&quot;M72.96 31.3l-.12.62c6.56 1.51 13.7 3.4 21.13 5.65a324.6 324.6 0 0 1 22.61 7.71l.27-.63c-6.13-2.82-13.79-8.7-22-11.18-7.98-2.4-15.38-1.11-21.9-2.17M75.52 50.67s2.3 1.77 5.24 1.11c2.95-.64 5.25-2.82 5.25-2.82s-1.73-.32-3.92-.17c-.1.37-.21.78-.36 1.12-.35.78-1.2 1.19-1.2 1.19s-.24-.37-.41-1.34a2.78 2.78 0 0 1-.04-.7c-2.56.53-4.56 1.6-4.56 1.6M119.74 81.8s-5.31 4.91-17.9 10.61c-13.44 6.1-27.48 10.92-41.07 16.7l-.79 7.28s10.23-5.9 24.97-9.23c14.74-3.35 24.76-5.37 29.67-6.42a32.9 32.9 0 0 0 8.66-3.22l-3.54-15.72&quot; fill=&quot;#FFFFFE&quot;/&gt;&lt;path d=&quot;M17.03 49.9c-2.1.63-3.98.5-4.22-.3-.24-.8 1.26-1.96 3.35-2.59 2.1-.63 3.98-.5 4.22.3.24.8-1.26 1.96-3.35 2.59zm89.44 36.4c4.75-2.73 10.49-6.24 13.05-11.29 5.3-10.41-6.67-18.76-15.53-20.42-1.5-.28-12.81-1.72-13.23.85.41-2.54 3.22-3.68 4.56-5.64 2.12-3.07-.87-3.64-3.26-4.67-4.12-1.78-8.4-3.1-12.92-3.19-4.66-.08-8.55.45-12.05 3.88-.62.6-1.43 1.5-1.55 2.35-.35 2.51 4.67 3.29 6.1 2.4a28.4 28.4 0 0 1 10.78-3.73c2.48-.31 5.05-.44 7.46.32.65.21 1.35.46 1.91.85.06.04.48.45.52.45h-4.05s-2.43 3.82-8.1 5.44c-5.68 1.63-13.3-1.62-13.3-1.62s-5.56-2.64-10.58-1.99c-5.03.65-6.13 0-6.13 0v2.4s-2.43-1.63-5.27-2.4c-2.84-.77-6.9-2.67-11.96-1.84-5.07.84-6.09.18-10.75-1.84-4.66-2.01-9.68-1.43-12.57 3.68-2.89 5.12.81 8.4.81 8.4l4.22.11c.92-.06 1.84-.11 2.7-.1.29-1.77 1.12-5.6 3.08-6.55 2.56-1.24 1.36 3 1.63 5 .12.9.31 1.79.48 2.5 3.39 1.27 6.67 3.24 11.2 2.57 5.48-.82 11.36-4.61 16.63-1.7l.22.12c.51-1.15 1.76-3.67 3.03-4 1.66-.44.14 2.27-.13 3.7-.12.63-.2 1.26-.25 1.77.56.31 1.12.62 1.68.9.36-1.35 1.03-3.39 2.04-3.88 1.54-.74.57 2.21.59 3.66 0 .53.03 1.06.07 1.51 2.66 1.14 5.28 1.79 7.96 1.36 5.06-.81 5.83-3.02 13.58.14 2.27.92 4.68 2.99 7.05 3.31 1.22.17 2.86.12 4-.4 1.71-.79.68-1.98-.89-1.89a3.02 3.02 0 0 1 2.4-1.4c3.41-.23 4.58 4.4 5.71 6.81 1.7 3.61 1.35 7.59-.5 11.07-5.6 10.49-22.03 17.44-22.03 17.44s2.38-.75 12.17-5.07c6.56-2.9 13.2-5.78 19.42-9.36z&quot; fill=&quot;#409144&quot;/&gt; &lt;path d=&quot;M65.56 65.66c5.06-.81 5.83-3.02 13.58.14 2.27.92 4.68 2.99 7.05 3.31 1.02.14 3.38.06 4.73-.74l.44-.82c-1.63.37-5.75 1.02-7.92-1.01-2.75-2.58-4.64-4.2-11.54-3.26-5.73.8-9.33 1.01-14.3-1.4-.05.33-.08.65-.07.9 0 .54.03 1.07.07 1.52 2.66 1.14 5.28 1.79 7.96 1.36zm-9.92-4.83c-.43-.24-.87-.5-1.33-.8l-.66-.4a6.3 6.3 0 0 0-.18.7c-.12.64-.2 1.27-.25 1.78.56.31 1.12.62 1.68.9.17-.65.42-1.46.74-2.18zm-38.3-2.14c.09-.6.25-1.44.5-2.32-3.7-.64-7.19-.61-9.1-.53.5 1.81 1.67 2.85 1.67 2.85l4.22.11c.92-.06 1.84-.11 2.7-.1zm33.01 1.83l.22.12c.23-.52.62-1.33 1.1-2.09-5.17-2.49-8.23-1.34-12.39.25-4.82 1.86-8.34 2.23-15.58-.8a22 22 0 0 0-1.62-.6c.12.81.29 1.6.45 2.25 3.38 1.27 6.66 3.24 11.2 2.57 5.47-.82 11.35-4.61 16.62-1.7zM104 54.59c-1.25-.23-9.27-1.26-12.18-.13l-.18.07-.73.56a.92.92 0 0 0-.14.35c.01-.1.04-.19.06-.28L87.12 58s17.72-2.29 22.27 8.54c4.56 10.82-7.95 21.33-17.19 26.85 4.85-2.17 9.68-4.43 14.27-7.08 4.75-2.74 10.49-6.25 13.05-11.3 5.3-10.41-6.67-18.76-15.53-20.42zM69.9 50.92l-2.5-.45c.77.3 1.7.45 2.5.45zm.58 5.63c-2.59-1.2-5.03-3.69-6.46-5.33 1.7.52 2.83 1.06 2.83 1.06s7.63 3.24 13.3 1.62a16 16 0 0 0 1.97-.7l.05-.01c.16-.07.31-.13.48-.22l.06-.03c3.86-1.83 5.56-4.48 5.56-4.48h4.04s-1.34 4.69-7.24 7.48c-5.9 2.8-10.54 2.5-14.59.61z&quot; fill=&quot;#317F3F&quot;/&gt; &lt;path d=&quot;M85.43 96.38l.15-.07-.15.07M75 100.7l-.05.01.04-.01M75.14 100.65c-.02 0-.03 0-.04.02l.04-.02M75.36 100.57l-.07.02.07-.02M30 65.52c8.31.75 12.91-1.93 16.1-1.68 3.2.26 3.72 3.2 12.15 4.6 8.44 1.41 11.8-2.17 16.2.13 3.34 1.75 6.7 3.77 10.4 4.72 1.1.28 2.71.5 4.23.35 2-.19 3.86-.99 4.19-3.06.26-1.7-.93-2.5-1.35-3.77.19.89.73 1.63.28 2.55-.43.9-1.45 1.45-2.35 1.75-2.72.94-4.85-.69-7.31-1.6-2.72-1.02-5.74-2.78-8.67-3.07-3.65-.37-8.52 2.06-13.38 1.25-4.87-.81-8.92-6.7-15.61-5.88-6.7.81-9.13 4.06-15 2.43-.91-.25-1.73-.52-2.49-.8a6.51 6.51 0 0 0-.16 1.8c.9.1 1.82.2 2.77.28M23.6 61.82c-2.24-1.01-4.23-1.83-7-1.83-.45 0-.86.02-1.26.05.53.9 1.34 2.2 2.36 3.73 1.53.3 3.77.7 6.47 1.08-.3-1.14-.48-2.31-.57-3.03&quot; fill=&quot;#E8B63D&quot;/&gt; &lt;path d=&quot;M33 75.01c.5 1.28.6 2.5-.79 2.58-2.93.18-14.5-13.82-14.52-13.83a61.82 61.82 0 0 0 8.54 10.43C32.7 80.27 39 80.46 39 80.46s-2.03-1.62-3.85-3.04a13.13 13.13 0 0 1-2.15-2.4M41.63 78.84l1.31.69c-6.04-3.58-11.5-7.41-11.54-7.44a65.6 65.6 0 0 0 10.23 6.75M93.45 88.1a33.72 33.72 0 0 1-11.38 2.54c-9.15.3-20.75-2.87-28.85-5.89l2 .98s-1.02-.2-3.45-.6c-2.43-.4-7.1-2.23-7.1-2.23s6.29 5.47 12.57 9.53c6.29 4.05 17.64 8.3 17.64 8.3s11.54-4.88 18.57-12.64M76.52 100.13l-.15.06.15-.06M81.73 97.98l-.45.2.45-.2M76.05 100.31l-.12.05.11-.05M80.53 98.48l-.36.16.36-.16M84.72 96.7l-.82.35.82-.36M83.11 97.39l-.59.25.59-.25M77.1 99.9l-.18.07.17-.07M78.56 99.31l-.24.1.24-.1M79.49 98.92l-.31.14.3-.14&quot; fill=&quot;#E8B63D&quot;/&gt; &lt;path d=&quot;M66.83 52.6c-.07-2.58 1.23-4.7 2.92-4.76 1.7-.04 3.12 2 3.19 4.58.07 2.58-1.24 4.7-2.92 4.75-1.7.05-3.12-2-3.19-4.58zm17.56 45.22c-5.62-2.47-12.84-7.58-13.06-15.43-.2-6.76.32-19.85.48-23.37 1.88-.93 3.2-3.56 3.11-6.61-.1-3.79-2.31-6.8-4.93-6.72-2.62.07-4.66 3.2-4.55 6.98.1 3.73 2.25 6.7 4.81 6.71-.25 3.67-.84 17.21-.51 23.54.38 7.3 7.66 15.72 18.12 17.27 10.32 1.51 29.54 1.09 29.54 1.09l1.71-1.24S90 100.3 84.4 97.82z&quot; fill=&quot;#322549&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; &lt;/div&gt; 但是使用百分比确定SVG的尺寸相较于固定尺寸会带来另外一个问题, 在使用固定尺寸例如width=&quot;400&quot; height=&quot;400&quot;, 由于它的尺寸是固定的那么它的长宽比也是固定的比如1:1. 使用百分比后在实际绘制出的图形长宽比就变得不固定了, 例如我们给SVG设置尺寸为width=&quot;100%&quot; height=&quot;400%&quot;, 而其实际尺寸还受到包裹它的容器尺寸影响, 假如假如我们将上例中的图形宽度调整到800px现在容器的尺寸是&lt;div style=&quot;height: 400px; width: 800Px; background-color:red&quot;&gt; 那么SVG的实际尺寸就是高:400px宽800px这样它的实际长宽比就变成了’1:2’, 这意味这图形发生了变形, 就像拉面一样被拉长了,可以想象一张瓜子脸被拉宽会变得多难看, 当然您不必发挥想象, 您可以将上例中的宽度调整到800px, 就知道本来一张完美的鳄鱼脸变形后有多难看了. 问题的原因出在SVG的高度和宽度是不确定的, 导致高和宽的比例不确定. 为了解决这个问题, SVG引入了preserveAspectRatio这个属性, 此属性就是让SVG缩放时保持比例, preserveAspectRatio的默认值为&lt;svg viewBox=&quot;0 0 100 100&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; meet- 缩放SVG图形，直到它符合viewPort高度和宽度xMidYMid- 将区域置于区域viewBox的中心viewPort, 当然该属性还有其它值, 例如 meet即是让SVG自适应包裹SVG容器的宽度, 要搞清楚它是如果工作的还需要了解viewPort和viewBox可以详细阅读Understand the SVG Viewbox 高度宽度缩放的比例由viewBox=&quot;0 0 100 100&quot;定义, 如果我们想让SVG按1:1的比例缩放, 就可定义为viewBox=&quot;0 0 100 100&quot;, 如果我们希望按其它比例缩放可以调整viewBox参数. viewBox的是个参数分别为: x - 指定最小 x 坐标y - 指定最小 y 坐标width - 用户坐标/px 单位的宽度height - 用户坐标/px 单位的高度 刚刚我们讲的是按比例缩放, 这在大多数使用场景下都是这样的, preserveAspectRatio的默认值也是按多少场景设置的. 但是按比例缩放还有问题就是, 由于SVG的尺寸和包裹它的容器尺寸不是100%匹配的, 这样在图片周围就会留下空白. 在某些应用场景平铺图像反而更合适, 此时我们可以将preserveAspectRatio设置为none, 即可平铺图片. 更多属性可以参考preserveAspectRatio的官方文档. 8. 参考文档一小时讲完SVG SVG introduction Understanding SVG preserveAspectRatio","link":"/web/svg.html"},{"title":"CodeWhisperer使用详解","text":"1. 说明AWS的CodeWhisperer是Amazon于2021年12月推出的一款代码补全工具, 与GitHub Copilot类似。与Copilot不同的是CodeWhisperer对于个人用户免费, 也是其优势所在. CodeWhisperer是一款基于机器学习的通用代码生成器，由Amazon出品，可以给我们提供代码建议, 可以帮助程序员更快、更安全地编写代码的工具，可以在他们的开发环境中实时提供代码建议和推荐。 Copilot提供的主要功能有： 代码补全 注释补全 函数/方法参数提示 快速文档提示 关于收费标准和套餐最新详情, 请查看Amazon CodeWhisperer 定价 2. 安装与配置以在vscode为例，演示安装过程。 在菜单顶部，单击Marketplace并在搜索栏中键入 “AWS Tookit”。找到一下图标然后点击安装。 安装完成后右侧tab栏会多一个AWS标签, 点击标签会打开AWS试图, 在视图种会列出Explorer, Developer Tools, CodeCatalysy, CDK, CodeWhisper标签. 选择Developer Tools选择Connect to AWS to Get Started.. 屏幕上方会弹出Add a connection to AWS对话框; 选择”Use a personal email to sign up and sign in with AWS Builder ID” 此时会弹出一个对话框, 对话框上有生成的code, 然后登录https://device.sso.us-east-1.amazonaws.com/ 输入刚刚获得的code, 创建AWS builder ID, 创建过程按照指引进行, 这里省略. 直到出现 “AWS Toolkit for VSCode can now access your data.”消息. 然后检测Vscode Tab =&gt; AWS =&gt; Developer Tools 状态为 Connected with AWS Builder ID表示连接成功. 如果总结出现invalid grant, 可以先登录Aws Builder ID, 然后将上述步骤中create code 等部分重复执行一遍. 3. CodeWhisperer的使用开启Auto-suggestions后, 书写代码即有代码提示, 可以通过方向键选择不同的代码预测。不需要复杂的快捷键去检测，即写即预测 可以根据函数名称预测代码。 可以说只要你用 Amazon CodeWhisperer 越多，让他越了解你，那么它的代码提示就会越准确，毕竟他在学习你写代码。 4. 相关阅读 Vultr + Code-server 自建 Cloud IDE vscode 常用快捷键 Fedora linux 上安装 Visual Studio Code 如何升级 vscode 5. 参考文档AWS CodeWhisperer在vscode的应用 个人免费使用的Github Copilot——AWS CodeWhisperer Amazon CodeWhisperer 代码提示","link":"/vscode/CodeWhisperer_vscode.html"},{"title":"基于 Code-server 快速部署自己的云开发环境","text":"1. 前言Web IDE，顾名思义就是云端开发环境，把 IDE 部署在云上。打开浏览器，连上云 IDE，就可以方便敲代码跑程序。想象一下，带上一台 iPad 或者华为、小米平板，配上蓝牙键盘，坐在阴凉下，或者沙滩上，吹着海风，面朝大海敲代码，多么惬意。 其实 Web IDE 很早就有，但那些都只能说是玩具，直到现在才有一些不错的产品推出，比如微软和 Github 的 Visual Studio Codespaces、coding.net 的 Cloud Studio、华为云 CloudIDE 等。不过，这些产品要么还在测试，要么免费用会有限制或者价格不菲，目前还不是非常方便。 如果想要低成本愉快地使用，自己动手搭建是一个不错的方案。对配置要求不高的话，一年几十块一百多块就能买到廉价的 VPS 或者云主机就足够了。 自己DIY 一套Web IDE 比较成熟的方案有两个，code-server 和 Theia。毕竟 code-server 是基于VS code魔改的，与vs code的插件体系兼容性更好。所以更推荐code-server。Theia虽然有自己的插件体系，也宣称兼容vs code的插件，也是一套优秀的WEB IDE解决方案，但是兼容程度谁知道呢？ Code-server是由 Coder 开发的，把 VS Code 搬到了浏览器上。 下面使用三种方式在一台 4 核 8GB 内存 60 GB SSD 的 VPS 上部署 code-server。这台 VPS 一年 24 刀，配置能满足基本的使用。这篇文章很长，但部署过程很简单，如果不想看太多字，可直接拉到最后。 2. 申请云主机到自己的云服务提供商界面创建云主机 2G8U 80GOS: Centos 7.9 3. VPN 连接云服务商网络 frp 内网穿透 | 鹏叔的技术博客 使用 WireGuard 内网穿透 | 鹏叔的技术博客 4. 登录到云主机1ssh -i ~/.ssh/ssh_key root@server_intranet_ip 5. 安装方式一：使用脚本安装 code-server如果使用安装脚本，则可以预览安装过程中即将发生的情况： 如果对脚本安装有任何担心，请参阅Is curl|bash insecure?如果仍然有担心，请参考本文介绍的其他安装方式 1curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run 确定没有问题后，开始正式安装。 123curl -fsSL https://code-server.dev/install.sh | sh 您可以通过添加或修改一个或多个标志来修改安装过程： –dry-run：在不运行命令的情况下回显安装过程的命令。 –method：选择安装方法。 –method=detect：检测包管理器，但回退到–method=standalone。 –method=standalone：在~/.local 中安装一个独立版本的归档文件。 –prefix=/usr/local：在系统范围内安装独立版本的归档文件。 –version=X.X.X:安装 X.X.X 版本，而不是最新版本。 –help：参阅帮助文档。 –edge：安装最新的 edge 版本（即预发行版） 完成后，安装脚本将打印出运行和启动 code-server 的说明。 6. 安装方式二：rpm/deb 包安装方式6.1. 下载安装包1234567# 适用于 x86_64硬件架构 Fedora, CentOS, RHEL, SUSE，Almalinux 等 Redhat 系列的操作系统curl -L --output /tmp/code-server-4.92.2-amd64.rpm https://github.com/coder/code-server/releases/download/v4.92.2/code-server-4.92.2-amd64.rpm# 适用于 x86_64硬件架构 Debian, Ubuntu等Debian系列操作系统curl -L --output /tmp/code-server_4.92.2_amd64.deb https://github.com/coder/code-server/releases/download/v4.92.2/code-server_4.92.2_amd64.deb 其中版本可以替换成自己需要的版本, 版本信息以及 release notes 可以到 code-server 项目的release 页面查询 6.2. 安装软件包1234567# 适用于 x86_64硬件架构 Fedora, CentOS, RHEL, SUSE，Almalinux 等 Redhat 系列的操作系统sudo rpm -i /tmp/code-server-4.92.2-amd64.rpm# 适用于 x86_64硬件架构 Debian, Ubuntu等Debian系列操作系统sudo dpkg -i /tmp/code-server_4.92.2_amd64.deb 6.3. 设置为开机启动1sudo systemctl enable --now code-server@$USER 现在可以访问 http://127.0.0.1:8080.密码保存在 ~/.config/code-server/config.yaml 6.4. 开放端口如果要允许外部电脑访问 code-server，这需要修改 IP 地址绑定并开发相应端口 vi ~/.config/code-server/config.yaml 123bind-addr: 0.0.0.0:8080 开放端口 12345678910# 检查防火墙是否开启sudo firewall-cmd --state# 显示默认区域的所有规则sudo firewall-cmd --list-all# 如果开启, 需放行80端口sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload 7. 安装方式三：Docker 安装方式7.1. 安装 Docker参考博客 安装并配置 docker | 鹏叔的技术博客 12345678910111213141516171819# 添加docker-ce yum源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 把yum包更新到最新sudo yum clean all &amp;&amp; sudo yum update# 安装依赖的的软件包sudo yum install -y device-mapper-persistent-data lvm2 git# 安装docker# 1. 查看可用的docker版本yum list docker-ce --showduplicates | sort -r# 2. 选择一个版本进行安装sudo yum install -y docker-ce-&lt;version no e.g. 20.10.9-3.el7&gt;# 启动Docker，然后加入开机启动sudo systemctl start dockersudo systemctl enable docker# 验证是否安装成功 docker versionsudo docker version 7.2. 设置 docker使用 Docker 镜像加速器 由于网络原因，我们在 pull Image 的时候，从 Docker Hub 上下载会很慢。 123456sudo vi /etc/docker/daemon.json#添加后：{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;live-restore&quot;: true} 重启 docker 服务 1sudo systemctl restart docker 8. Docker 拉取 Code-Server 镜像, 并启动容器拉取镜像: 1docker pull codercom/code-server 启动容器: 123456789101112131415161718mkdir -p ~/.configdocker run -itd --name code-server -p 0.0.0.0:8080:8080 \\ -v &quot;$HOME/.config:/home/coder/.config&quot; \\ -v &quot;$PWD:/home/coder/project&quot; \\ -u &quot;$(id -u):$(id -g)&quot; \\ -e &quot;DOCKER_USER=$USER&quot; \\ codercom/code-server:latest[2022-12-21T07:36:33.289Z] info Wrote default config file to ~/.config/code-server/config.yaml[2022-12-21T07:36:33.553Z] info code-server 4.9.1 f7989a4dfcf21085e52157a01924d79d708bcc05[2022-12-21T07:36:33.554Z] info Using user-data-dir ~/.local/share/code-server[2022-12-21T07:36:33.567Z] info Using config file ~/.config/code-server/config.yaml[2022-12-21T07:36:33.567Z] info HTTP server listening on http://0.0.0.0:8080/[2022-12-21T07:36:33.567Z] info - Authentication is enabled[2022-12-21T07:36:33.567Z] info - Using password from ~/.config/code-server/config.yaml[2022-12-21T07:36:33.568Z] info - Not serving HTTPS 将容器设置为开机启动 1docker update --restart=always code-server 在宿主机上用浏览器打开http://cloud_vm_ip:8080, 即可访问 code-server, 密码可以在容器的~/.config/code-server/config.yaml 中找到. 可以使用如下命令查看密码 123docker exec -it code-server cat ~/.config/code-server/config.yaml 9. 安装插件以及配置 code-server打开访问 code-server, 例如 http://localhost:8080 打开终端，输入以下命令，即可安装插件 例如： 123456789101112code-server --install-extension eamodio.gitlenscode-server --install-extension esbenp.prettier-vscodecode-server --install-extension golang.gocode-server --install-extension k--kato.intellij-idea-keybcode-server --install-extension Mikael.Angular-BeastCodecode-server --install-extension mrmlnc.vscode-lebabcode-server --install-extension oderwat.indent-rainbowcode-server --install-extension stivo.tailwind-foldcode-server --install-extension vscode-icons-team.vscode-icode-server --install-extension wix.vscode-import-costcode-server --install-extension yzhang.markdown-all-in-onecode-server --install-extension zerefdev.todo-highlighter code-server 配置，可参考我的博客 VSCode 基本配置指南 | 鹏叔的技术博客 以及 vscode 常用快捷键 | 鹏叔的技术博客 10. 关联阅读 Vultr + Code-server 自建 Cloud IDE vscode 常用快捷键 Fedora linux 上安装 Visual Studio Code 如何升级 vscode VSCode 基本配置指南 另外，若要获取最近更新， 请访问原文基于 Code-server vscode 的云开发环境 | 鹏叔的技术博客 11. trouble shooting 解决 docker 无法启动，报：start request repeated too quickly for docker.service 错误参考 https://blog.csdn.net/weixin_39246554/article/details/121800320 12. 参考文档code-server github 官网 随时随地敲代码，基于 Theia 快速部署自己的云开发环境 云开发工具 code-server 安装手册 code-server install - Fedora, CentOS, RHEL, SUSE coder install.sh","link":"/vscode/cloud_ide.html"},{"title":"Web基础大全","text":"1. HTML 基础本文原文位于鹏叔的技术博客 - Web 基础大全, 请访问原文获取最新更新. 编者: 菲利英语团队 1.1. HTML 简介HTML 就一直被用作万维网的信息表示语言，使用 HTML 描述的文件需要通过 web 浏览器显示出效果, 被称为超文本标记语言。用 HTML5 编写的文件, 后缀以.htm 或.html 结尾. HTML 是一种建立网页文件的语言，通过标记式的指令(Tag)，将文字，图形、动画、声音、表格、链接、影像等内容显示出来。 1.2. HTML 整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;菲利英语&lt;/title&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=ZCOOL+KuaiLe&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script&gt; // JavaScript 代码 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;!-- 本站所有网页的统一主标题 --&gt; &lt;h1&gt;聆听电子天籁之音&lt;/h1&gt; &lt;/header&gt; &lt;nav&gt; &lt;!-- 本站统一的导航栏 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;!-- 共 n 个导航栏项目，省略…… --&gt; &lt;/ul&gt; &lt;form&gt; &lt;!-- 搜索栏是站点内导航的一个非线性的方式。 --&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; placeholder=&quot;要搜索的内容&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot; /&gt; &lt;/form&gt; &lt;/nav&gt; &lt;main&gt; &lt;!-- 网页主体内容 --&gt; &lt;article&gt; &lt;!-- 此处包含一个 article（一篇文章），内容略…… --&gt; &lt;/article&gt; &lt;aside&gt; &lt;!-- 侧边栏在主内容右侧 --&gt; &lt;h2&gt;相关链接&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt; &lt;!-- 侧边栏有 n 个超链接，略略略…… --&gt; &lt;/ul&gt; &lt;/aside&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 本站所有网页的统一页脚 --&gt; &lt;p&gt;© 2050 某某保留所有权利&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 以上是一个网页的基本结构, 麻雀虽小, 五脏俱全. 下面将逐一介绍. DOCTYPE &lt;!DOCTYPE html&gt; 文档类型, 这是必不可少的开头。 现在新增的网页都需要如示例一样定义文档类型, 否则将触发浏览器的怪异模式. DOCTYPE 的作用是启用浏览器的标准模式. 如果没有这一行文档说明, html 文档将被认为是 HTML 标准制定之前的遗留文档, 而触发浏览器的怪异模式去兼容它, 这显然不是我们期望的. 对于 DOCTYPE, 这里只做简单介绍, 后续有详细说明. html 标签 HTML 文档总是以&lt;html&gt;标签开始并以&lt;/html&gt;结束的, 也就是说，网页的内容全部全部包含在&lt; html&gt;与&lt; /html&gt;之间. 所有的 HTML 文件都有两个主要结构：头部 head 和主体 body。 head 标签 所有那些你加到页面中，且不向看客展示的页面元素，都以这个元素为容器。其中包含诸如提供给搜索引擎的关键字和页面描述、用作风格化页面的 CSS、字符集声明等等。 body 标签 该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。 1.3. html 头部1.3.1. 定义和用法&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 1.3.2. 标题&lt;title&gt; 标签定义了不同文档的标题。 &lt;title&gt; 在 HTML/XHTML 文档中是必须的。 &lt;title&gt; 元素: 定义了浏览器工具栏的标题当网页添加到收藏夹时，显示在收藏夹中的标题显示在搜索引擎结果页面的标题 1.3.3. &lt;base&gt; 元素 &lt;base&gt; 元素 指定用于一个文档中包含的所有相对 URL 的根 URL。一个页面最多只能使用一个&lt;base&gt;元素。 常见的 url 路径形式分别有相对路径与绝对路径，如果 base 标签指定了目标，浏览器将通过这个目标来解析当前文档中的所有相对路径，包括的标签有（a、img、link、form），也就是说，浏览器解析时会在路径前加上 base 给的目标，而页面中的相对路径也都转换成了绝对路径。使用了 base 标签就应带上 href 属性和 target 属性 一个文档的基本 URL，可以通过使用 document.baseURI (en-US) 的 JS 脚本查询。如果文档不包含 &lt;base&gt; 元素，baseURI 默认为 document.location.href。 说说 base href 属性： 比如由 base 制定了一个 URL 地址，接下来你所要调用的文件或图片等就无须再填写完整的地址，只需写上该文件名或图片名即可。 下面来简单的认识一下 base 标签的用法，链接到鹏叔的博客空间的 HTML 视频教程，完整地址https://pengtech.net/web/web_basic_1.html 123456&lt;head&gt; &lt;base href=&quot;https://pengtech.net/&quot; target=&quot;_blank&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;web/web_basic_1&quot;&gt;html基础教程&lt;/a&gt;&lt;/body&gt; base target 属性： target 属性是网页窗口的打开方式，在 base 标签中设置该属性，那么页面中所有的链接都将默认遵循这个方式来打开网页，分别有如下几种选择： _blank：在新窗口打开链接页面。 _parent:在上一级窗口中打开链接。 _self： 在当前窗口打开链接,此为默认值，可以省略。 _top： 在浏览器的整个窗口打开链接，忽略任何框架。 1.3.4. HTML &lt;link&gt; 元素&lt;link&gt; 标签定义了文档与外部资源之间的关系。 &lt;link&gt; 标签通常用于链接到样式表: 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; /&gt;&lt;/head&gt; rel 表示 “关系 (relationship) ” 它可能是&lt;link&gt;元素其中一个关键的特性——属性值表示&lt;link&gt;项的链接方式与包含它的文档之间的关系。你将在链接类型中看到很多不同类型的关系 1.3.5. HTML &lt;style&gt; 元素&lt;style&gt; 标签定义了 HTML 文档的样式文件引用地址. 在&lt;style&gt; 元素中你也可以直接添加样式来渲染 HTML 文档: 12345678910&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; body { background-color: yellow; } p { color: blue; } &lt;/style&gt;&lt;/head&gt; 1.3.6. HTML &lt;meta&gt; 元素meta 标签描述了一些基本的元数据。 &lt;meta&gt; 标签提供了元数据. 元数据也不显示在页面上，但会被浏览器解析。 META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面，搜索引擎（关键词），或其他 Web 服务。 随着 web 标准的发展, 越来越多的属性被加入到 meta 标签中来. &lt;meta&gt; 一般放置于 &lt;head&gt; 区域 1.3.6.1. &lt;meta&gt; 标签- 使用实例为搜索引擎定义关键词: &lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt; 为网页定义描述内容: &lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt; 定义网页作者: &lt;meta name=&quot;author&quot; content=&quot;eagle&quot;&gt; 每 30 秒钟刷新当前页面: &lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; 指定浏览器渲染方式 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 详细解释参考闷音的浅析网页 meta 标签中 X-UA-Compatible 属性的使用 或者这篇文章X-UA-Compatible 是什么（详解）注意事项： 根据概念，只能指定高版本 IE 浏览器使用低版本 IE 浏览器的渲染机制，而无法指定低版本浏览器采用高版本浏览器的渲染机制 根据官网定义 X-UA-compatible 标头不区分大小写；不过，它必须显示在网页中除 title 元素和其他 meta 元素以外的所有其他元素之前。如果不是的话，它不起作用 content 的内容是 IE=8，或者 IE=edge 等值，注意不是 IE8 或者直接写个 edge 的值，否则不起作用 添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。【大多数国产浏览器都是有谷歌内嵌的，所以建议默认加上】 设置文档的视宽缩放 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; 1.3.6.2. &lt;meta&gt; 标签- charset如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。 1.3.7. HTML &lt;script&gt; 元素&lt;script&gt;标签用于加载脚本文件，如：JavaScript。 &lt;script&gt; 元素在以后的章节中会详细描述。 1.3.8. HTML &lt;noscript&gt; 元素如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML &lt;noscript&gt; 元素中定义脚本未被执行时的替代内容。详细解释与使用说明请参考noscript. 1.4. 文字排版1.4.1. 标题 h1~h6 标题标签的特性: 加粗 标题标签独占一行 1.4.2. 段落和换行标签 段落标签: P 段落和段落之间有较大缝隙 换行标签: br 1.4.3. 文本格式化标签 粗体: strong 或者 b 斜体: em 或者 i 删除线: del 或者 s 下划线: ins 或者 u 1.5. 布局标签1.5.1. div 和 span div 是 division 的缩写, 有时候我们也习惯叫图层, 用于在页面上进行分割. DIV 元素是用来为 HTML 文档内大块（block-level）的内容提供结构和背景的元素。 span 意为跨度,跨距. 1.5.1.1. div 和 span 的区别div: 在 html 页面布局时，我们经常会使用到 div 标签和 span 标签，那么 div 标签和 span 标签之间有什么区别？ div 标签是块级(block)元素，拥有块级元素的特点。每对 div 标签（&lt;div&gt;&lt;/div&gt;）里的内容都可以占据一行，不会其他标签在一行显示；div 标签总是从新行开始显示； 且 div 标签可以通过 css 样式来设置自身的宽度（也可省略，当没有使用 css 自定义宽度时，div 标签的宽度为其的容器的 100%）、高度，且还可以设置标签之间的距离（外边距和内边距）； 我们还可以在 div 标签中，使用其他标签（行内元素、块级元素都行），比如：span 标签，p 标签，也可以是 div 标签 span: span 标签是行内(inline)元素，拥有行内元素的特点。span 标签元素会和其他标签元素会在一行显示（块级元素除外），不会另起一行显示。 span 标签的宽度、高度都无法通过 css 样式设置，它的宽高受其本身内容（文字、图片）限制，随着内容的宽高改变而改变；span 标签无法控制外边距和内边距，虽然可以设置左右的外边距和内边距，但上下的外边距和内边距无法设置。 关于块元素和行内元素以及 block-inline 的差别请参考鹏叔的技术博客 - block inline 和 inline-block 三者之间的区别 1.6. 图像处理1.6.1. 图像标签img 标签用于定义 html 中的图像例如: 1&lt;img src=&quot;path&quot; /&gt; img 是 image 的缩写, 意为图像 1.6.1.1. img 标签属性说明 src 是 img 标签的必须属性, 它用于指定图像文件的路径和文件名 alt 文本 替换文本,图像不能显示时的替代文字 title 提示文本, 鼠标放到图像上, 显示的文字 width 设置图像的宽度 height 设置图像的高度 border 设置图像边框的粗细 align 规定如何根据周围的文本来排列图像。(可以用css float属性替代) 例如 123456789&lt;!-- width height border 的单位为像素px --&gt;&lt;img src=&quot;photo.jpg&quot; alt=&quot;my favorite movie star&quot; title=&quot;andy liu&quot; width=&quot;500&quot; height=&quot;300&quot; border=&quot;5&quot;/&gt; 1.7. 超链接1.7.1. 超链接标签 在 html 标签中, a 标签用于定义超链接, 作用是从一个页面链接到另一个页面 a 为单词 anchor 的缩写, 意为: 锚例如: 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt; 文本或图像 &lt;/a&gt; 1.7.1.1. a 标签属性说明 href: 用于指定链接目标的 url 地址, target: 用于指定链接页面的打开方式, 其中_self 为默认值,_blank 为在新窗口中打开, target 有一下四种取值: _blank: 浏览器总在一个新打开、未命名的窗口中载入目标文档。 _self: 这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。 _parent: _top: 1.7.1.2. 链接分类 外部链接: 例如 https://philoenglish.com/ 内部链接: 例如: 1&lt;a href=&quot;home.html&quot;&gt;主页&lt;/a&gt; 空链接: 1&lt;a href=&quot;#&quot;&gt;开发中&lt;/a&gt; 下载链接: 1&lt;a href=&quot;artifacts.zip&quot;&gt;下载&lt;/a&gt; 网页元素链接: 在网页中的各种网页元素都可以被链接, 如文本, 图像, 音频, 视频都可以添加超链接, 例如: 1&lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;img.jpg&quot; /&gt; &lt;/a&gt; 锚点链接: 在链接文本的 href 属性中, 设置属性值为#名字的形式, 例如 1&lt;a href=&quot;#two&quot;&gt; 第二集&lt;/a&gt; 找到目标位置标签, 里面添加一个 id 属性=刚才的名字, 例如 1&lt;h3 id=&quot;two&quot;&gt;第二集介绍&lt;/h3&gt; 1.8. 注释和特殊字符注释: 1&lt;!-- 注释语句--&gt; 特殊字符: 1空格: &amp;nbsp; 大于号: &amp;gt; 特殊字符列表 HTML 原代码 显示结果 描述 &amp;lt; &lt; 小于号或显示标记 &amp;gt; &gt; 大于号或显示标记 &amp;amp; &amp; 可用于显示其它特殊字符 &amp;quot; “ 引号 &amp;reg; ® 已注册 &amp;copy; © 版权 &amp;trade; ™ 商标 &amp;ensp; &ensp; 半个空白位 &amp;emsp; &emsp; 一个空白位 &amp;nbsp; &nbsp; 不断行的空白 1.9. 表格1.9.1. 表格标签 table: tr: 行 table row th: 表头 table title td: 数据 table data 1.9.2. 表格属性 table 标签的属性 align: 表格对齐方式 选项 left, center, right border: 表格边框 cellpadding: 单元格内容和边框之间的距离 cellspacing: 单元格和单元格之间的距离 width: 实例: 123456789101112131415161718192021222324&lt;table align=&quot;center&quot; border=&quot;1&quot; cellpandding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;249&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;刘德华&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;56&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张学友&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1.9.3. 表格结构标签 为什么需要用结构标签? HTML 中的 thead、tbody 和 tfoot 元素用于根据表行的内容将其分组为逻辑(logical)部分。想要这样做的主要原因有两个： 允许正文独立于页眉和/或页脚进行滚动 为了更容易地将不同的样式规则应用于表的不同部分。 三个结构标签 thead: 表格头部区域 tbody: 表格主体区域 tfoot: 定义表格的页脚（脚注或表注）。该标签用于组合 HTML 表格中的表注内容。 示例: 123456789101112131415161718192021&lt;table border=&quot;1&quot;&gt; &lt;caption&gt; Council budget (in £) 2018 &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Items&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Expenditure&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;Donuts&lt;/th&gt; &lt;td&gt;3,000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;Stationery&lt;/th&gt; &lt;td&gt;18,000&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 效果: Council budget (in £) 2018 Items Expenditure Donuts 3,000 Stationery 18,000 1.9.4. 合并单元格 跨行合并: rowspan=”合并单元格的个数” 夸列合并: colspan=”合并单元格的个数” 示例: 12345678910111213141516&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;th&gt;Savings for holiday!&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;$50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果: Month Savings Savings for holiday! January $100 $50 February $80 1.10. 列表1.10.1. 无序列表实例: 12345&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt; 1.10.2. 有序列表实例: 12345&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt; 1.10.3. 自定义列表实例: 12345678&lt;dl&gt; &lt;dt&gt;列表项1&lt;/dt&gt; &lt;dd&gt;列表项1.1&lt;/dd&gt; &lt;dd&gt;列表项1.2&lt;/dd&gt; &lt;dt&gt;列表项2&lt;/dt&gt; &lt;dd&gt;列表项2.1&lt;/dd&gt; &lt;dd&gt;列表项2.2&lt;/dd&gt;&lt;/dl&gt; 1.11. 表单标签1.11.1. 表单域 form1&lt;form action=&quot;demo.php&quot; method=&quot;post&quot; name=&quot;name&quot;&gt;&lt;/form&gt; 1.11.2. 表单控件(表单元素)1.11.2.1. input 表单元素 input type: text password radio checkbox file hidden image reset submit: 提交表单按钮 button: 定义可点击按钮, 多数情况下通过 js 启动脚本 1.11.2.2. input 表单元素属性 name:定义表单元素的名称 value:规定 input 元素的值 checked:规定 input 元素首次加载时被选中 maxlength: 规定输入字段的字符的最大长度 autocomplete: 自动完成属性指定输入字段是否应启用自动完成。自动完成允许浏览器预测值。当用户开始键入字段时，浏览器应根据先前键入的值显示填充字段的选项。注意：自动完成属性适用于以下输入类型：text, search, url, tel, email, password, datepickers, range, and color.自动完成属性有两可选值(on|off), on 表示开启自动完成, off 表示关闭自动完成功能. 1.11.2.3. label 标签 label 标签经常和 input 标签搭配使用 label 标签为为 input 元素定义标注 label 标签用于绑定一个表单元素, 当点击 label 标签内的文本时, 浏览器就会自动将焦点转到或者选择对应的表单元素上, 用来增加用户体验. label 标签的 for 属性 实例: 12&lt;label for=&quot;sexRadio&quot;&gt; male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sexRadio&quot; /&gt; 核心: label 标签的 for 属性应当与相关元素的 id 属性相同. 1.11.2.4. select 表单控件 使用场景: 在页面中, 如果有多个选项让用户选择, 并且想要节约页面空间时, 我们可以使用 select 标签控件定义下拉列表. 语法: 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意事项: select 中至少包含一对 option 在 option 中添加 selected 属性设置默认选中 1.11.2.5. textarea 控件 实例: 1&lt;textarea cols=&quot;50&quot; rows=&quot;5&quot;&gt; 此处为默认输入文本&lt;/textarea&gt; 1.12. frame 标签 (HTML5 不支持)&lt;frame&gt; 标签定义 &lt;frameset&gt; 中的子窗口（框架）。 &lt;frameset&gt; 中的每个 &lt;frame&gt; 都可以设置不同的属性，比如 border、scrolling, noresize 等等。 注意 : HTML5 不支持 &lt;frame&gt; 标签。注释：如果您希望验证包含 frame 的页面，请确保 &lt;!DOCTYPE&gt; 被设置为 “HTML Frameset DTD” 或者 “XHTML Frameset DTD” 示例: 123456&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot;&gt; &lt;frame src=&quot;frame_b.htm&quot;&gt; &lt;frame src=&quot;frame_c.htm&quot;&gt;&lt;/frameset&gt; 1.13. 标签的常用属性很多 HTML 标签都有对应的属性，即写在标签开始部分中的属性名和属性值，如 a 的 href、img 的 src 等。这里再介绍 4 种重要而且通用的属性：id、class、name 和 style。 1.13.1. idid 属性可以给标签取一个 id, id 值应当在整个页面中独一无二，使用 id 可以有针对性地操作某一个标签，如控制样式、绑定事件等。另外，如果将 a 的 href 设置为#加上某一标签的 id，则单击链接后，页面将跳转到对应标签所在位置。 12&lt;p id=&quot;main&quot;&gt;这是最主要的一段话&lt;/p&gt;&lt;a href=&quot;#main&quot;&gt;跳到main所在位置&lt;/a&gt; 1.13.2. classclass 属性可以给标签去一个 class, 同一个 class 值可以用于多个标签, 从而使用 class 同时操作多个标签, 如控制它们的样式, 为它们绑定事件等. 12345&lt;p class=&quot;content&quot;&gt;这些段落都是普通内容&lt;/p&gt;&lt;p class=&quot;content&quot;&gt;这些段落都是普通内容&lt;/p&gt;&lt;p class=&quot;content&quot;&gt;这些段落都是普通内容&lt;/p&gt;&lt;p class=&quot;content&quot;&gt;这些段落都是普通内容&lt;/p&gt;&lt;p class=&quot;content&quot;&gt;这些段落都是普通内容&lt;/p&gt; 1.13.3. namename 属性和 class 类似，只是基于 name 控制相应的标签没有 class 那么方便，可以将 id、class 和 name 理解成一个人的身份证号、姓、名等。 1.13.4. stylestyle 属性可以为标签添加内联样式，即使用 CSS 的一种方法，等我们了解 CSS 之后再详细讨论，这里提供一个简单的示例。 1&lt;p style=&quot;color: red&quot;&gt;这是一段有颜值的内容&lt;/p&gt; titletitle：提供有关元素的额外信息，当鼠标悬停在元素上时，通常以工具提示的形式显示。 hrefhref：在&lt;a&gt;（锚）标签中指定链接的目标 URL。 例如，一个简单的带有属性的 HTML 元素可能看起来像这样： 1&lt;a href=&quot;https://www.example.com&quot; title=&quot;访问例子网站&quot;&gt;点击这里&lt;/a&gt; 在这个例子中，&lt;a&gt;标签有两个属性：href（指定链接的目标 URL）和title（提供当鼠标悬停在链接上时显示的额外信息）。属性值 &quot;Example Domain&quot; 和 &quot;访问例子网站&quot; 分别与它们的属性名称相关联，并被包含在引号中。 srcsrc：在&lt;img&gt;、&lt;script&gt;和&lt;iframe&gt;等标签中指定要嵌入的资源的路径。 altalt：为&lt;img&gt;标签定义图像的替代文本，如果图像无法显示，将显示该文本。 typetype：指定&lt;input&gt;标签的类型（例如text、password、submit等）。 placeholderplaceholder：为&lt;input&gt;和&lt;textarea&gt;元素提供提示文本，当输入字段为空时显示。 1.14. HTML 标签简写及全称下表列出了 HTML 标签简写及全称： 标签 英文全称 中文说明 a Anchor 锚 abbr Abbreviation 缩写词 acronym Acronym 取首字母的缩写词 address Address 地址 alt alter 替用(一般是图片显示不出的提示) b Bold 粗体（文本） bdo Direction of Text Display 文本显示方向 big Big 变大（文本） blockquote Block Quotation 区块引用语 br Break 换行 cell cell 巢 cellpadding cellpadding 巢补白 cellspacing cellspacing 巢空间 center Centered 居中（文本） cite Citation 引用 code Code 源代码（文本） dd Definition Description 定义描述 del Deleted 删除（的文本） dfn Defines a Definition Term 定义定义条目 div Division 分隔 dl Definition List 定义列表 dt Definition Term 定义术语 em Emphasized 加重（文本） font Font 字体 h1~h6 Header 1 to Header 6 标题 1 到标题 6 hr Horizontal Rule 水平尺 href hypertext reference 超文本引用 i Italic 斜体（文本） iframe Inline frame 定义内联框架 ins Inserted 插入（的文本） kbd Keyboard 键盘（文本） li List Item 列表项目 nl navigation lists 导航列表 ol Ordered List 排序列表 optgroup Option group 定义选项组 p Paragraph 段落 pre Preformatted 预定义格式（文本 ） q Quotation 引用语 rel Reload 加载 s/ strike Strikethrough 删除线 samp Sample 示例（文本) small Small 变小（文本） span Span 跨度范围 src Source 源文件链接 strong Strong 加重（文本） sub Subscripted 下标（文本） sup Superscripted 上标（文本） td table data cell 表格中的一个单元格 th table header cell 表格中的表头 tr table row 表格中的一行 tt Teletype 打印机（文本） u Underlined 下划线（文本） ul Unordered List 不排序列表 var Variable 变量（文本） 1.15. 查阅 html 参考文档 百度: http://www.baidu.com W3C: http://www.w3school.com.cn MDN: https://developer.mozilla.org/zh-CN/ 2. HTML5 的新特性2.1. 怪异模式和标准模式在很久以前的网络上，页面通常有两种版本：为网景（Netscape）的 Navigator 准备的版本，以及为微软（Microsoft）的 Internet Explorer 准备的版本。当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。 目前浏览器的排版引擎使用三种模式：怪异模式（Quirks mode）、接近标准模式（Almost standards mode）、以及标准模式（Standards mode）。在怪异模式下，排版会模拟 Navigator 4 与 Internet Explorer 5 的非标准行为。为了支持在网络标准被广泛采用前，就已经建好的网站，这么做是必要的。在标准模式下，行为即（但愿如此）由 HTML 与 CSS 的规范描述的行为。在接近标准模式下，只有少数的怪异行为被实现。 浏览器如何决定使用哪个模式？ 对 HTML 文件来说，浏览器使用文件开头的 DOCTYPE 来决定用怪异模式处理或标准模式处理。为了确保你的页面使用标准模式，请确认你的页面如同本范例一样拥有 DOCTYPE： 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 范例中的 DOCTYPE，，是所有可用的 DOCTYPE 之中最简单的，也是 HTML5 所推荐的。HTML 的早期变种也属于推荐标准，不过，当今的浏览器都会对这个 DOCTYPE 使用标准模式，就算是早已过时的 Internet Explorer 6 也一样。目前，并没有正当的理由，去使用其他更复杂的 DOCTYPE。如果你使用其他的 DOCTYPE，你可能会面临触发接近标准模式或者怪异模式的风险。 请确定你把 DOCTYPE 正确地置于 HTML 文件的顶端。如果有任何其他字符位于 DOCTYPE 之前，比如注释或 XML 声明，会导致 Internet Explorer 9 或更早期的浏览器触发怪异模式。 在 HTML5 中，DOCTYPE 唯一的作用是启用标准模式。更早期的 HTML 标准中，DOCTYPE 会附加其他意义，但没有任何浏览器会将 DOCTYPE 用于怪异模式和标准模式之间互换以外的用途。 更多关于浏览器排版引擎的说明, 可以参考怪异模式和标准模式 2.2. HTML 新增的语义化标签 header： 头部标签 nav： 导航标签 article： 内容标签 section： 定义文档某个区域 aside： 侧边栏标签 footer： 尾部标签 注意： 这种语义化标准主要针对搜索引擎的 这些新标签页面中可以使用多次 在 IE9 中，需要把这些元素转换为块级元素 其实，我们移动端更喜欢使用这些标签 2.3. 更多 HTML 语义化标签 标签 描述 &lt;article&gt; 定义页面独立的内容区域。 &lt;aside&gt; 定义页面的侧边栏内容。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;details&gt; 用于描述文档或文档某个部分的细节 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含 details 元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;footer&gt; 定义 section 或 document 的页脚。 &lt;header&gt; 定义了文档的头部区域 &lt;mark&gt; 定义带有记号的文本。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。 &lt;nav&gt; 定义导航链接的部分。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符）。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 &lt;rp&gt; 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 &lt;section&gt; 定义文档中的节（section、区段）。 &lt;time&gt; 定义日期或时间。 &lt;wbr&gt; 规定在文本中的何处适合添加换行符。 2.4. HTML 新增的多媒体标签新增的多媒体标签主要包含两个： 音频：audio 视频：video 使用它们可以很方便的在页面中嵌入音频和视频， 而不再去使用 flash 和其他浏览器插件。 2.4.1. video 标签1. 视频 video 当前 video 元素支持三种视频格式： 尽量使用 MP4 浏览器 MP4 WebM Ogg IE YES NO NO Chrome YES YES YES Firefox YES since 21， linux 30 YES YES Safari YES NO NO Opera YES since Opera 25 YES YES 语法 1&lt;video src=&quot;url&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; video 常用属性 属性 值 描述 autoplay autoplay 视频就绪自动播放，谷歌浏览器需要添加 muted 来解决自动播放问题 controls controls 向用户显示播放控件 width pixels 像素值 设置播放器宽度 height pixels 像素值 设置播放器高度 loop loop 是否循环播放 preload auto 预先加载视频 none 不应加载视频 规定是否预加载视频, 如果有了 autoplay, 就忽略该属性 src url 视频 url 地址 poster imagurl 加载等待的画面图片 muted muted 静音播放 2.4.2. audio 标签语法 1&lt;audio&gt;&lt;/audio&gt; 音频格式支持情况: Browser MP3 Wav Ogg IE YES NO NO Chrome YES YES YES Firefox YES YES YES Safari YES YES NO Opera YES YES YES video 常用属性 属性 值 描述 controls controls 向用户显示播放控件 loop loop 是否循环播放 src url 视频 url 地址 muted muted 静音播放 谷歌浏览器把音频和视频自动播放禁止了 2.5. 新增 input 标签 属性值 说明 type=&quot;email&quot; 限制用户输入必须为 Email 类型 type=&quot;url&quot; 限制用户输入必须为 url 类型 type=&quot;date&quot; 限制用户输入必须为日期类型 type=&quot;time&quot; 限制用户输入必须为时间类型 type=&quot;month&quot; 限制用户输入必须为月类型 type=&quot;week&quot; 限制用户输入必须为周类型 type=&quot;number&quot; 限制用户输入必须为数字类型 type=&quot;tel&quot; 手机号码 type=&quot;search&quot; 搜索框 type=&quot;color&quot; 生成一个颜色选择表单 2.6. HTML5 图形使用 HTML5 你可以简单的绘制图形: 使用 &lt;canvas&gt; 元素。使用内联 SVG。SVG 教程可以参考我的博客鹏叔的技术博客 - SVG使用 CSS3 2D 转换、CSS3 3D 转换。 3. CSS 基础3.1. CSS 简介 CSS 是层叠样式表(Cascading Style Sheets)的简称 有时我们也称之为 CSS 样式表或者级联样式表 CSS 也是一种标记语言 CSS 主要用于设置 HTML 页面的文本内容(字体, 大小, 对齐方式), 图片的外形(宽高, 边框样式, 边距等) 以及版面的布局和外观显示样式. 3.2. CSS 语法规范 CSS 规则由两个主要的部分构成, 选择器以及一条或多条样式申明 1234h1 { color: red; font-size: 25px;} 其中 h1 为选择器, 大括号里的内容为样式申明 选择器是用于指定 CSS 样式的 HTML 标签, 大括号内容是对对象设置的具体样式 属性和属性值以键值对的形式出现 属性是对指定的对象设置的样式属性, 例如字体大小, 文本颜色等 属性和属性值之间使用冒号”:”分割 多个键值对之间用英文”;”进行区分 3.3. CSS 代码风格3.3.1. 样式格式书写 紧凑格式 1234h3 { color: deeppink; font-size: 20px;} 展开格式 1234h3 { color: deeppink; font-size: 20px;} 强烈推荐第二种格式, 更直观 3.3.2. 样式大小写1234567h3 { color: pink;}H3 { color: pink;} 强烈推荐样式选择器、 属性名、 属性值关键字全部使用小写字母, 特殊情况除外. 3.3.3. 空格规范123h3 { color: pink;} 属性值前面, 冒号后面, 保留一个空格 选择器(标签)和大括号中间保留空格 3.4. CSS 基础选择器选择器参考文档 3.4.1. 标签选择器示例: 选择所有 &lt;p&gt; 元素。 123p { color: red;} 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 1234div,p { color: red;} 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素, 包括子元素和孙元素。 1234div,p { color: red;} 选择&lt;div&gt; 元素的所有&lt;p&gt;子元素, 不包括孙元素。 123div &gt; p { color: red;} 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 子元素。 123div + p { color: red;} 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。(p 和 ul 同级别, p 元素位于 ul 之前) 123p ~ ul { color: red;} 3.4.2. 类选择器示例 选择 class=”intro” 的所有元素。 123.intro { color: red;} 选择 class 属性中同时有 name1 和 name2 的所有元素 123.name1.name2 { color: red;} 3.4.3. 类选择器-多类名3.4.4. id 选择器 id 选择器 以 “#” 来定义 id 选择器经常和 javascript 搭配使用 3.4.5. 通配符选择器实例: 123* { margin: 0;} 3.5. CSS 字体属性3.5.1. 字体系列 font-family 中文字体, 或字体名称有多个单词组成最好使用双引号引起来 一般给 body 指定统字体来为页面设置统一的字体 如果设置了多个字体, 浏览器将会按顺序选择系统中存在的字体, 应用到文字上 实例: 123body { font-family: &quot;宋体&quot;, &quot;Microsoft Yahei&quot;, Arial, Helvetica, sans-serif;} 3.5.2. 字体大小 font-size实例: 123body { font-size: 18px;} 3.5.3. 字体粗细 font-weight取值范围&lt;font-weight-absolute&gt; = normal | bold | lighter | bolder| Numeric value&gt; 说明: 1. 数字 400 相当于 normal, 700 相当于 bold 2. lighter, bolder 不是绝对粗细, 是相对于父元素的粗细更细一些或更粗一些 3. 实际开发中更喜欢使用数字来表示粗细 实例: 1234567p { font-weight: bold;}p { font-weight: 700;} 3.5.4. 文字样式 font-styleCSS 使用 font-style 属性设置文本的风格说明: 取值范围: normal, italic, oblique, oblique 400deg; Italic 样式一般是指书写体，相比无样式的字体，通常会占用较少的高度，而 oblique 字形一般只是常规字形的倾斜版本。斜体（italic） 和倾斜体（oblique）都是通过人工倾斜常规字体的字形来模拟的（使用 font-synthesis 对此进行控制）。 如果关键字是 oblique，则可附加一个可选的角度。实例: 123p { font-style: normal;} 3.5.5. CSS 复合属性实例: 123p { font: normal 16px;} 3.6. CSS 文本属性CSS text(文本)属性可以定义文本的外观, 比如文本的颜色, 对齐方式, 装饰文本, 文本缩进, 行间距等 3.6.1. 文本颜色 color取值范围: 预定义的颜色值: red, green, blue 等等 16 进制颜色值: #FF0000 RGB 代码: rgb[255, 0, 0] 或 rgb[%100, 0, 0] 开发中最常用的是 16 进制颜色值 123div { color: red;} 3.6.2. 文本对齐 text-align text-align 属性用于设置元素内文本的水平对齐方式 取值范围: left, center, right 默认值为 left 3.6.3. 文本装饰 text-decoration text-decoration 属性规定添加到文本的修饰, 可以给文本添加下划线, 删除线, 上划线等. 取值范围: none, underline, overline, line-through 123div { text-decoration: underline;} 3.6.4. 文本缩进 取值: 缩进数值 10px, 2em 使文本的第一行缩进多少距离 123p { text-indent: 2em;} 3.6.5. 行间距 line-height123p { line-height: 26px;} 3.7. CSS 引入方式 内部样式表 12345&lt;style&gt; p { color: pink; }&lt;/style&gt; 外部样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot; /&gt; 内联方式内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS。 1&lt;div style=&quot;color:red; width:10px&quot;&gt;&lt;/div&gt; 3.8. Emmet 语法Emmet 语法的前身是 Zen coding, 它使用缩写, 来提高 html/css 的编写速度, Vscode 内部已经集成该语法. 快速生成 HTML 结构语法 快速生成 CSS 样式语法 3.8.1. 快速生成 HTML 结构语法 生成标签直接输入标签名按 tab 键即可, 比如 div 然后 tab 键, 就可以生成 1&lt;div&gt;&lt;/div&gt; 如果想要生成多个相同标签, 加上就可以了, 比如 div*3 就可以快速生成 3 个 div 如果有父子级关系的标签, 可以用&gt; 比如 ul&gt;li 就可以了 如果有兄弟关系的标签,用+就可以了比如 div+p 如果生成带有类名或者 id 名字的, 直接写.demo 或者#two tab 键就可以了 如果生成的 div 类名是有顺序的, 可以用自增符合$ 3.9. 复合选择器3.9.1. 什么是复合选择器在 CSS 中, 可以根据选择器的类型把选择器分为基础选择器和复合选择器, 复合选择器是建立在基础选择器之上, 对基本选择器进行组合形成的. 复合选择器可以更准确, 更高效选择目标元素 复合选择器是由两个或多个基础选择器, 通过不同的方式组合而成的 常用的复合选择器包括: 后代选择器, 子选择器, 并集选择器, 伪选择器 3.9.2. 后代选择器//TODO: 补充内容 3.9.3. 子元素选择器3.9.4. 伪类选择器 链接伪类 结构伪类 3.10. 元素显示模式3.10.1. 什么是元素显示模式 作用: 网页标签非常多, 在不同地方会用到不同类型的标签, 了解他们的特点可以更好的布局我们的网页. 元素显示模式就是元素以什么方式显示, 比如 div 自己占一行, 比如一行可以放多个 span HTML 元素一般分为块元素和行内元素两种类型 3.10.2. 块元素常见的块元素有 h1~h6, p, div, ul, ol, li 等, 其中 div 是最典型的块元素 块元素的特点: 比较霸道, 自己独占一行 高度, 宽度, 外边距以及内边距都可以控制 宽度默认是容器的 100% 是一个容器及盒子, 里面可以放行内或块级元素 注意: 文字类的元素不能使用块级元素 p 标签主要用于存放文字, 因此 p 里面不能放块级元素, 特别不能放 div 同理, h1~h6 等都是文字类块标签, 里面也不能放其他块级元素 3.10.3. 行内元素(内联元素)常见的行内元素有 a, strong, b, em, i, del, s, ins, u, span 等, 其中 span 标签是最典型的行内元素, 有的地方也将行内元素称为内联元素. 行内元素的特点: 相邻行内元素在一行上, 一行可以显示多个 高, 宽直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素 注意: 链接里面不能再放链接了 特殊情况 a 里面可以再放块级元素但是给 a 转换一下块级模式更安全 3.10.4. 行内块元素在行内元素中有几个特殊的标签 img, input, td 它们同时具有块元素和行内元素的特点, 有些资料称它们为行内块元素. 行内块元素的特点: 与行内元素相比，主要区别在于行内块元素允许在元素上设置宽度和高度。 同样，如果设置了 display: inline-block，将保留上下外边距/内边距，而 display: inline 则不会。 与 display: block 相比，主要区别在于 display：inline-block 在元素之后不添加换行符，因此该元素可以位于其他元素旁边。 3.11. CSS 背景通过 CSS 背景属性, 可以给页面元素添加背景样式.背景属性可以设置背景颜色, 背景图片, 背景平铺, 背景图片位置, 背景图像固定等. 3.11.1. 背景颜色123div { background-color: pink;} 3.11.2. 背景图片123div { background-image: url(path);} 3.11.3. 背景图片平铺取值范围: repeat-x, repeat-y, no-repeat, repeat 1background-repeat: repeat-x; 3.11.4. 背景图片位置利用 background-position 属性可以改变图片在背景中的位置. 1background-position: x y; 参数代表的意思是: x 坐标和 y 坐标, 可以使用方位名称或者精确单位 参数值 说明 length 百分数, 由浮点数和单位标识构成的长度值 position top center, bottom left, right center 方位名词 注意:参数是方位名词时: 如果是方位名词, right center 和 center right 是等价的. 如果只指定了一个方位名词, 另一个值省略, 则第二个默认居中对齐. 参数是精确单位: 如果参数是精确坐标, 那么第一个肯定是 x 坐标, 第二个一定是 y 坐标 混合形式: 第一参数一定是 x 坐标, 第二个参数是 y 坐标 实例: 12&lt;!-- 顶部居中 --&gt;background-position: center top; 12&lt;!-- 顶部居中 --&gt;background-position: top; 精确单位 12&lt;!-- x:20px y:50px --&gt;background-position: 20px 50px; 12&lt;!-- x:20px 垂直居中 --&gt;background-position: 20px; 混合形式 12&lt;!-- x:20px 垂直居中 --&gt;background-position: 20px center; 12&lt;!-- 水平居中 垂直20px --&gt;background-position: center 20px; 3.11.5. 背景图片固定(背景附着)background-attachment 属性设置背景图像是否固定或者随着页面的其他部分滚动. 取值范围: scroll: 背景图像是随对象内容滚动 fixed: 背景图像固定 3.11.6. 背景复合写法为了简化背景属性的代码, 我们可以将这些属性合并简写在同一个属性 background 中, 从而节约代码量, 当使用简写属性时, 没有特定的书写顺序, 一般习惯约定顺序为:background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置 例如: 1background: black url(images/bg.jpg) no-repeat fixed center top; 1background: transparent url(images/bg.jpg) repeat-x fixed top; 3.11.7. 背景色半透明CSS3 为我们提供了背景颜色半透明的效果 1background: rgba(0, 0, 0, 0.3); 最后一个参数是 alpha 透明度, 取值范围在 0-1 之间, 0 表示完全透明, 1 表示完全不透明 注意: CSS3 新增属性, 是 IE9+版本浏览器才支持的 但是现在实际开发中,我们不太关注兼容性写法了,可以放心使用 3.12. CSS 的三大特性CSS 有三个非常重要的特性: 层叠性, 继承性, 优先级. 3.12.1. 层叠性相同选择器给属性设置不同的样式, 此时一个样式就会覆盖(层叠)另一个冲突的样式. 层叠性主要解决样式冲突的问题. 层叠性原则: 样式冲突: 遵循的原则是就近原则, 哪个样式的结构近, 就执行哪个样式样式不冲突, 不会层叠 3.12.2. 继承性CSS 中的继承: 子标签会继承父标签的某些样式, 如文本颜色和字号等. 恰当地使用继承可以简化代码, 降低 css 样式的复杂性子元素可以继承父元素的样式(text-, font-,line-这些元素开头的可以继承, 以及 color 属性) 3.12.2.1. 行高的继承当行高是倍数值 例如: 123body { font: 12px/1.5 &quot;Microsoft YaHei&quot;;} 如上, 行高为 1.5 如果子元素例如 div 的字体大小为 14px, 那么 div 的实际行高为, 字体高度乘以从父元素继承来的行高 1.5 倍, 实际行高为 21px 123div { font-size: 14px;} 123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;一花一世界&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.12.3. 优先级当同一个元素指定多个选择器, 就会有优先级的产生 选择器相同, 则执行层叠性 选择器不同, 则根据选择器权重执行 选择器权重如下表所示 选择器 选择器权重 继承或者通配符 0,0,0,0 标签选择器 0,0,0,1 类选择器, 伪类选择器 0,0,1,0 ID 择器 0,1,0,0 行内样式 style=”” 1,0,0,0 !important 无穷大 优先级注意事项: 权重是由 4 组数字组成, 但是不会有进位. 可以理解为类选择器永远大于元素选择器, id 选择器永远大于类选择器, 以此类推. 等级判断从左向右, 如果某一位数值相同, 则判断下一位数值. 继承的权重是 0 3.12.3.1. 权重叠加权重叠加: 如果是复合选择器, 则会有权重叠加, 需要计算权重.例如 123456ul li { color: green;}li { color: red;} 如上所示,复合选择器 ul li 的权重为 0,0,0,1 + 0,0,0,1 = 0,0,0,2而选择器 li 的权重是 0,0,0,1 所以 ul li 选择器定义的字体颜色样式将生效 3.13. 盒子模型网页布局要学习三大核心, 盒子模型, 浮点和定位, 学习好盒子模型能非常好的帮助我们布局页面. 看透网页布局的本质网页布局过程 先准备好相关的网页元素, 网页元素基本都是盒子 box 利用 css 设置好盒子样式, 然后摆放到相应位置 往盒子里面装内容网页布局的核心本质: 就是利用 CSS 摆盒子 3.13.1. 盒子模型(Box Model) 组成所谓盒子模型: 就是把 HTML 页面中的布局元素看作是一个矩形的盒子, 也就是一个盛装内容的容器,CSS 盒子模型本质是一个盒子, 封装周围的 HTML 元素, 它包括: 边框, 外边距, 内边距, 和实际内容 3.13.2. 边框(border)border 可以设置元素的边框, 边框有三部分组成: 边框宽度(粗细) 边框样式, 边框颜色 border-style: none | solid | dashed | dotted | double border-color: 颜色值 border-width: 设置边框宽度 实例: 1234567div { width: 50px; height: 50px; border-color: red; border-width: 5px; border-style: solid;} 边框复合性写法 1border: 1px solid red; 没有顺序 border-top: border-bottom: border-right: border-left: 实例: 123div { border-top: 1px solid red;} 3.13.3. 表格的细线边框border-collapse 合并相邻的边框 3.13.4. 边框会影响盒子实际大小实际宽度 等于 width + border-width 3.13.5. 内边距(padding)padding-left padding-right padding-top padding-bottom padding 复合写法 panding: 5px; // 上下左右 5px panding: 5px 10px; // 上下 5px 左右 5px panding: 5px 6px 10px; // 上下 5px 左右 5px 3.13.6. padding 不会撑大盒子的情况如果盒子本身没有指定 width/height 属性, 则此时 padding 不会撑开盒子大小 3.13.7. 外边距(margin) margin-left margin-right margin-top margin-bottom 3.13.8. margin 复合写法 margin: 5px; // 上下左右 5px margin: 5px 10px; // 上下 5px 左右 5px margin: 5px 6px 10px; // 上 5px 左右 6px 下 10px 3.13.9. 外边距的典型应用外边距可以让块级盒子水平居中, 1234width: 100pxbackground-color: pink;margin-left: auto;margin-right: auto; 行内元素居中办法, 让父元素 text-align 等于 center 嵌套块元素垂直外边距的塌陷对于两个嵌套关系(父子关系)的块元素, 父元素有上外边距同时子元素也有上外边距, 此时父元素会塌陷较大的外边距. 外边距合并问题:解决方案: 可以为父元素定义上边框 可以为父元素定义上内边距 可以为父元素添加 overflow:hidden 还有其他方法, 比如浮动, 固定, 绝对定位盒子不会有塌陷的问题. 3.13.10. 清除盒子的内外边距1234* { margin: 0px; padding: 0px;} 注意: 行内元素为了照顾兼容性, 尽量只设置左右内外边距, 不要设置上下内外边距, 但是转换为块级和行内块元素就可以设置上下边距 3.13.11. 圆角边框在 CSS3 中, 新增圆角边框样式, 这样我们的盒子就可以变圆角了. 1border-radius: 10px; 1border-radius: 50%; 每个叫弧度不一样 1border-radius: 10px 30px 40px 50px; 1234border-top-right-radius: 10px;border-top-left-radius: 20px;border-bottom-right-radius: 10px;border-bottom-left-radius: 10px; 3.13.12. 盒子影子CSS3 中新增了盒子影子, 我们可以使用 box-shadow 属性添加阴影.语法: 12/*box-shadow: h-shadow v-shadow blur spread color inset;*/box-shadow: 10px 10px 10px 10px black inset; h-shadow: 必需, 水平阴影的位置, 允许负值. v-shadow: 必需, 垂直阴影的位置, 允许负值. blur: 可选, 模糊距离. spread: 可选, 阴影的尺寸. color: 可选, 阴影的颜色, 请参阅 CSS 颜色值 inset:可选, 将外部阴影改为内部阴影. 3.13.13. 文字阴影 text-shadow h-shadow: 必需, 水平阴影的位置, 允许负值. v-shadow: 必需, 垂直阴影的位置, 允许负值. blur: 可选, 模糊距离. color: 可选, 阴影的颜色, 请参阅 CSS 颜色值 12/*text-shadow: h-shadow v-shadow blur color;*/box-shadow: 10px 10px 10px black; 3.14. CSS 浮动3.14.1. 传统网页布局的三种方式网页布局的本质: 用 CSS 来摆放盒子, 把盒子摆放到相应位置.CSS 提供了三种传统布局方式简单说, 就是盒子如何进行排列顺序: 普通流(标准流) 浮动 定位 3.14.2. 普通流(标准流/文档流)所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行, 从上向下顺序排列. 常用元素: div, hr, p, h1~h6, ul, ol, dl, form, table 行内元素会按照顺序, 从左到右顺序排列, 碰到父元素边缘自动换行 常用元素: span, a, i, em 等 以上都是标准流布局, 标准流是最基本的布局方式. 这三种布局方式都是用来摆放盒子的, 盒子摆放到合适位置, 布局自然就完成了. 注意: 实际开发中, 一个页面基本都包含了这三种布局方式, 后面移动端学习新的布局方式. 3.14.3. 为什么需要浮动总结: 有很多布局效果, 标准流没有办法完成, 此时就可以利用浮动完成布局, 因为浮动可以改变元素标签默认的排列方式.浮动最典型的应用: 可以让多个块元素一行内排列显示.网页布局第一准则: 多个块级元素纵向排列选标准流, 多个块级元素横向排列使用浮动. 3.14.4. 什么是浮动float 属性 用于创建浮动框, 将其移动到一边, 直到左边缘或右边缘触及包含块或另一个浮动框的边缘.语法: 123选择器 { float: 属性值;} 属性值:none:元素不浮动, 默认值left:元素向左浮动right: 元素向右浮动 3.14.5. 浮动特性(重难点)加了浮动之后的元素, 会具有很多特性, 需要我们掌握的 浮动元素会脱离标准流 浮动的元素会一行内显示并且元素顶部对齐 浮动元素会具有行内块元素的特性 设置了浮动的元素最重要的特性 脱离标准流的控制浮动到指定位置 浮动的盒子不再保留原先的位置 浮动元素经常和标准流的父级搭配使用 3.14.6. 常见的网页布局3.14.7. 浮动布局注意点 浮动和标准流的父盒子搭配先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列位置 一个元素浮动, 理论上其余的兄弟也要浮动.一个盒子里面有多少个盒子, 如果其中一个盒子浮动了, 那么其他兄弟也应该浮动, 以防止引起问题.浮动的盒子只会影响浮动盒子后面的标准流, 不会影响前面的标准流. 3.14.8. 为什么要清除浮动我们不应该给父盒子高度 3.14.9. 清除浮动的本质清除浮动的本质是清除浮动元素造成的影响如果父盒子本身有高度, 则不需要清除浮动清除浮动后, 父级就会根据浮动子盒子自动检查高度, 父级有了高度, 就不会影响下面的标准流了 语法: 123选择器 { clear: 属性值;} 属性值: left: 不允许左侧有浮动元素,(清除左侧浮动的影响) right: 不允许右侧有浮动元素(清除右侧浮动的影响) both: 同时清除左右两侧浮动的影响 我们实际工作中, 几乎自用 clear:both 清除浮动的策略是: 闭合浮动 清除浮动的方法: 额外标签发也称为隔墙法, 是 W3C 推荐的做法. 父级添加 overflow 属性 父级添加 after 伪元素 父级添加双伪元素 3.15. 定位3.15.1. 为什么需要定位 浮动可以让多个块级盒子一行没有缝隙排列显示, 经常用于横向排列盒子. 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置, 并且可以压住其他盒子. 3.15.2. 定位组成定位: 将盒子定在某一个位置, 所以定位也是在摆放盒子, 按照定位的方式移动盒子. 定位=定位模式+边偏移定位模式用于指定一个元素在文档中的定位方式, 边偏移则决定了该元素的最终位置. 1. 定位模式定位模式决定元素的定位方式, 它可以通过 CSS 的 position 属性来设置, 其值可以分为四种: static: 静态定位, 静态定位是元素的默认定位方式, 无定位的意思. relative: 相对定位, 相对定位是元素在移动位置的时候, 是相对于它原来在标准流的位置来说的. absolute: 绝对定位, 绝对定位是元素在移动位置的时候, 是相对于它祖先元素来说的. fixed: 固定定位, 固定定位是元素固定于浏览器可视区域, 主要使用场景; 可以在浏览器页面滚动时元素位置不会改变. sticky: 粘性定位, 粘性定位可以被认为是相对定位和固定定位的混合. 边偏移边偏移就是定位的盒子移动到最终位置. 有 top, bottom, left 和 right 4 个属性. 变偏移属性 示例 描述 top top: 80px 顶部偏移量, 定义元素相对于其父元素上边线的距离 bottom bottom: 80px 底部偏移量, 定义元素相对于其父元素下边线的距离 left left: 80px 左侧偏移量, 定义元素相对于其父元素左边线的距 right right: 80px 右侧偏移量, 定义元素相对于其父元素右边线的距 3.15.3. 静态定位静态定位是元素的默认定位方式, 无定位的意思 语法: 123选择器 { position: static;} 静态定位按照标准流特性摆放位置, 它没有边偏移. 静态定位在布局时很少用到. 3.15.4. 相对定位 relative相对定位是元素在移动位置的时候, 是相对于它原来的位置来说的语法: 123选择器 { position: relative;} 相对定位的特点: 它是相对自己原来的位置来移动(移动位置的时候参照点事自己原来的位置) 原来在标准流的位置继续占有, 后面的盒子仍然以标准流的方式对待它. (不脱离标准流, 继续保留原来的位置) 3.15.5. 绝对定位 absolute绝对定位是元素在移动位置的时候, 是相对于它祖先元素来说的语法: 123选择器 { position: absolute;} 如果没有祖先元素或者祖先元素没有定位, 则以浏览器为准定位(Document 文档) 如果祖先元素有定位(相对, 绝对, 固定定位), 则以最近一级的有定位祖先元素为参考点移动位置. 绝对定位不再占用标准流中的位置. 3.15.6. 3.15.6.子绝父相弄清楚这个口诀, 就明白了绝对定位和相对定位的使用场景.这个子绝父相太重要了, 是我们学习定位的口诀, 是定位中最常用的一种方式, 这句话的意思是: 子级是绝对定位的话, 父级要用相对定位. 子级绝对定位, 不会占有位置, 可以放到父盒子里面任何一个地方, 不会影响其他兄弟盒子. 父盒子需要加定位限制子盒子在父盒子内显示. 父盒子布局时, 需要占有位置, 因此父亲只能是相对定位. 这就是子绝父相的由来,所以相对定位经常用来作为绝对定位的父级.总结: 因为父级需要占有位置, 因此是相对定位, 子盒子不需要占有位置, 则是绝对定位.当然, 子绝父相不是用于不变的, 如果父元素不需要占有位置, 子绝父相也会遇到. 3.15.7. 固定定位 fixed固定定位是元素固定于浏览器可视区域, 主要使用场景; 可以在浏览器页面滚动时元素位置不会改变.语法: 123选择器 { position: fixed;} 固定定位的特点: 以浏览器的可视窗口为参照点移动元素. 跟父元素没有任何关系 不随滚动条滚动. 固定定位不占有标准流中的位置. 固定定位也是脱离标准流的, 其实固定定位也可以看做是一种特殊的绝对定位. 3.15.8. 固定定位小技巧 固定在版心右侧小算法: 让固定定位的盒子 left:50%, 走到浏览器可视区域的一半位置 让固定定位的盒子 margin-left: 版心宽度的一半距离, 多走版心宽度的一半位置 3.15.9. 粘性定位 sticky粘性定位可以被认为是相对定位和固定定位的混合, sticky 粘性的语法 1234选择器 { position: sticky; top: 10px;} 粘性定位的特点: 以浏览器的可视窗口为参照点移动元素 粘性定位占有原先的位置 必须添加 top, left, right, bottom 其中的一个才有效. 跟页面滚动搭配使用, 兼容性较差, IE 不支持. 3.15.10. 定位的叠放次序在使用定位布局时, 可能会出现盒子重叠的情况. 此时, 可以使用 z-index 来控制盒子的前后次序(Z 轴)语法 123选择器 { z-index: 1;} 数值可以是正整数, 负整数或 0, 默认是 auto, 数值越大, 盒子越靠上如果属性值相同, 则按照书写顺序, 后来者居上数值后面不能加单位只有定位的盒子才有 z-index 3.15.11. 定位的拓展定位特殊性绝对定位和固定定位也和浮动类似 行内元素添加绝对定位或者固定定位, 可以直接设置高度和宽度. 块级元素添加绝对或者固定定位, 如果不给宽度或者高度, 默认大小是内容的大小. 脱标的盒子不会触发外边距塌陷. 浮动元素不同,只会压住它下面标准流的盒子, 但是不会压住下面标准流盒子里的文字(图片) 但是绝对定位(固定定位)会压住下面标准流所有的内容浮动之所以不会压住文字, 因为浮动产生的目的最初是为了做文字环绕效果的, 文字会围绕浮动元素. 3.15.12. 元素的显示和隐藏display:none 隐藏元素, 不再占用原来的位置 1display: none; visibility 可见性取值:visiblehidden visibility 隐藏元素后, 继续占用原来的位置 3.15.13. overflowoverflow 属性指定了如果内容溢出一个元素的框(超过其指定高度和宽度)时, 会发生什么.属性值: visible hidden: 超出的部分隐藏 scroll auto: 超出的时候显示滚动条, 不超出没有滚动条 一般情况下,我们都不想让溢出的内容显示出来, 因为溢出的部分会影响布局,但是如果有定位的盒子, 请慎用 overflow:hidden 因为它会隐藏多余的部分. 4. CSS 高级部分4.1. 精灵图4.1.1. 为什么需要精灵图一个网页中往往会应用很多小的背景图像作为修饰, 当网页中的图像过多时, 服务器就会频繁地接收和发送请求图片, 造成服务器请求压力过大, 这就大大降低页面加载速度. 因此, 为了有效地减少服务器接收和发送请求的次数, 提高网页的加载速度, 出现了 CSS 精灵技术(也称为 CSS Sprites) 核心原理: 将网页中的一些小背景图像整合到一张大图中, 这样服务器只需要一次请求就可以了. 4.1.2. 精灵图(sprites)的使用使用精灵图核心: 精灵技术主要针对背景图片使用, 就是把多个小背景整合到一张大图片中. 这个大图片也称为 sprites 精灵图 移动背景图片位置, 此时可以使用 background-position. 移动的距离就是这个图片的 x 和 y 坐标, 注意网页中的坐标有所不同. 4.1.3. 字体图标及参生和优点字体图标使用场景： 主要用于显示网页中通用， 常用的一下小图标。 精灵图是有诸多优点的，但是缺点也很明显。 图片文件还是比较大的。 图片本身放大和缩小会失真。 一旦图片制作完毕想要更换非常复杂。 此时， 有一种技术的出现很好的解决了以上问题， 就是字体图标 iconfont字体图标可以为前端工程师提供一种方便高效的图标使用方式， 展示的是图标， 本质属于字体。 字体图标的优点轻量级： 一个字体图标字体要比一系列图像要小， 一旦字体加载了， 图标就会马上渲染出来， 减少服务器服务器请求。灵活性： 本质其实是文字， 可以很随意的改变颜色， 产生阴影， 透明效果， 旋转等。兼容性： 几乎支持所有的浏览器， 请放心使用。注意： 字体图标不能替代精灵技术， 只是对工作中图标部分技术的提升和优化。总结： 如果遇到一些结构和样式比较简单的小图标， 就用字体图标。 如果遇到一些结构和样式复杂的，还是使用精灵图。 4.1.4. 字体图标字体图标是一些网页常见的小图标， 我们直接网上下载即可， 因此使用可以分为： 字体图标的下载 字体图标的引入（引入到 html 页面中） 字体图标的追加（以后添加新的小图标）推荐下载网站： icomoon http://icomoon.io icomoon 成立于 2011 年， 推出了第一个自定义图标字体生成器， 它允许用户选择所需要的图标， 是它们成一字型， 该字体库内容种类繁多， 非常全面， 唯一的遗憾是国外服务器， 打开网速较慢。 阿里 iconfont http://www.iconfont.cn这个是阿里妈妈 M2MUX 的一个 iconfont 字体图标字库， 包含了淘宝图标库和阿里妈妈图标库， 可以使用 AI 制作图标上传生成， 重点是免费！ //字体图标的引入 4.2. CSS 三角做法4.3. 用户界面-鼠标样式123li { cursor: default;} 属性值：defaultpointermovetextnot-allowded 5. CSS35.1. CSS3 新增属性选择器5.2. CSS3 新增结构伪类选择器5.3. CSS3 伪元素选择器伪元素选择器可以帮助我们利用 CSS 创建新标签元素, 而不需要 HTML 标签, 从而简化 HTML 结构.选择符合::before 在元素内部的前面插入内容::after 在元素内部的后面插入内容注意: before 和 after 创建一个元素, 但是属于行内伪元素 新创建的这个元素在文档中是找不到的, 所以我们称其为伪元素 语法: element::before {} before 和 after 必须有 content 属性 before 在父元素内容的前面创建元素, after 在父元素内容的后面创建元素 伪元素选择器和标签选择器一样, 权重为 1 5.4. CSS3 盒子模型 border-boxCSS3 中可以通过 box-sizing 来指定盒子模型, 有 2 个值: 即可指定为 content-box, border-box, 这样我们计算盒子大小的方式就发生了改变. 默认为 content-box可以分成两种情况: box-sizing:content-box 盒子大小为 width + padding + border (CSS3 出现以前, 默认的盒子模型) box-sizing: border-box 盒子大小为 width 5.5. CSS3 图片模糊处理 图片变模糊 计算盒子宽度 width: calc 函数 5.5.1. CSS3 滤镜 filterfilter CSS 属性将模糊或颜色偏移等图形效果应用于元素. 语法 1filter: 函数(); 例如 filter: blur(5px); blur模糊处理 数值越大越模糊 5.5.2. CSS3 calc 函数calc()此 CSS 函数让你在声明 CSS 属性值时执行一些计算 width: calc(100%-80px) 5.6. CSS3 的新特性5.6.1. CSS3 过渡过渡(transition) 是 CSS3 中具有颠覆性的新特性之一, 我们可以在不使用 Flash 动画或 javascript 的情况下, 当元素从一种样式变换为另一种样式时为元素添加效果.过渡动画: 是从一个状态渐渐的过渡到另外一个状态可以让我们页面更好看, 更动感十足, 虽然低版本浏览器不支持但是不会影响页面布局.经常和:hover 一起搭配使用 transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性: 想要变化的 css 属性, 宽度高度 背景颜色 内外边距都可以. 如果想要所有的属性都变化过渡, 写一个 all 就可以了. 多个属性使用逗号分割 花费时间: 单位是秒(必须写单位) 比如 0.5s 运动曲线: 默认是 ease (可以省略) 何时开始: 单位是秒(必须写单位), 可以设置延迟触发时间, 默认是 0s (可省略) 5.6.2. 狭义的 HTML5 和广义的 HTML5狭义的 HTML5 就是 HTML5 本身 广义的 HTML5 是 HTML5 本身+CSS3+Javascript 这个集合有时称为 HTML5 和它的朋友, 通常缩写为 HTML5 虽然 HTML5 的一些特性仍然不被某些浏览器支持, 但是它是一种发展趋势. HTML5 MDN 介绍:https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML 5.7. 2D 转换转换(transform) 是 CSS3 中具有颠覆性的特征之一, 可以实现元素的位移,旋转,缩放等效果.移动: translate旋转: rotate缩放:scale 5.7.1. 2D 转换之移动 translate2D 移动是 2D 转换里面的一种功能, 可以改变元素在页面中的位置, 类似定位语法 1234transform: translate(x,y);或者transform: translateX(n)transform: translateY(n) 移动盒子位置的方法: 定位, 盒子外边距, 2D 转换移动;重点:定义 2D 转换中的移动, 沿着 X 和 Y 轴移动元素translate 最大的优点: 不影响到其他元素的位置translate 中的百分比单位是相对于自身元素的 translate(50%, 50%)对行内元素是没有效果的 用 translate 让一个盒子水平垂直居中 12345678910p { position: absolute; top: 50%; left: 50% width: 200px; height: 200px; background: purple; /*translate中的百分比单位是相对于自身元素的 */ transform: translate(-50%;,-50%;);} 5.7.2. 2D 转换之选择 rotate2D 选择指的是让元素在 2 维平面内顺时针旋转或者逆时针旋转 1transform: rotate(度数); 重点: rotate 里面跟度数, 单位是 deg 比如 rotate(45deg)角度为正时,顺时针, 负值时为逆时针默认旋转的中心点是元素的中心点 5.7.3. 2D 转换中心点 transform-origin我们可以设置元素转换的中心点语法 1transform-origin: x y; 重点: 注意后面的参数 X 和 Y 用空格隔开xy 默认转换的中心点是元素的中心位置(50%, 50%)还可以给 x y 设置像素或者方位名词(top bottom left right center) 5.7.4. 2D 转换之缩放 scale1transform: scale(x, y); 注意:注意其中的 x 和 y 用逗号分隔tansform: scale(1,1) 宽度和高度都放大一倍, 相当于没有放大tansform: scale(2,2) 宽度和高度都放大 2 倍tansform: scale(2): 只写一个参数, 第二个参数则和第一个参数一样, 相当于 scale(2,2)tansform: scale(0.5, 0.5) 缩小相对于修改宽高缩放 scale 的优势: 可以设置转换中心点缩放, 默认以中心点缩放的, 而且不影响其他盒子 5.7.5. 2D 转换综合写法P365注意: 同时使用多个转换, 其格式为: transform: translate() rotate() scale() 等等 其顺序会影响转换的效果(先旋转会改变坐标轴方向) 当我们同时有位移和其他属性的时候, 记得要将位移放到最前面 5.7.6. 2D 转换总结 转换 transform 我们简单理解就是变形有 2D 和 3D 之分 我们暂且学了三个分别是位移 旋转和缩放 2D 移动 translate(x,y) 最大优势是不影响其他盒子, 里面参数用%, 是相对于自身宽度和高度来计算的 可以分开写比如 translateX(x) 和 translateY(y) 2D 旋转 rotate(度数) 可以实现旋转元素, 度数的单位是 deg 2D 缩放 scale(x,y) 里面的参数是数字不跟单位, 可以是小数, 最大优势是不影响其他盒子 设置转换中心点 transform-origin: x y; 参数可以是百分比, 像素或者方位名词 当我们进行综合写法, 同时有位移和其他属性的时候, 记得要将位移放在最前面 5.8. CSS3 动画动画(animation) 是 CSS3 中具有颠覆性的特性之一, 可通过设置多个节点来精确控制一个或一组动画, 常用来实现复杂的动画效果.相比较过渡, 动画可以实现更多变化, 更多控制连续自动播放等效果. 5.8.1. 动画的基本使用制作动画分为两步: 先定义动画 再使用动画 5.8.1.1. 用 keyframes 定义动画(类似定义类选择器)123456789@keyframes 动画名称 { 0% { width: 100px; } 100% { width: 200px; }} 动画序列 0%是动画的开始, 100%是动画的完成, 这样的规则就是动画序列. 在@keyframes 中规定某项 CSS 样式, 就能创建由当前样式逐渐改为新样式的动画效果. 动画是使元素从一种样式逐渐变化为另一种样式的效果, 您可以改变任意多的样式任意多的次数. 请用百分比来规定变化发生的时间, 或关键词 from 和 to, 等同于 0%和 100%. 5.8.1.2. 使用动画12345678910div { width: 200px; height: 200px; background-color: aqua; margin: 100px auto; /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间;} 5.8.2. 动画常用属性 属性 描述 @keyframes 定义动画 animation 所有动画属性的简写属性, 除了 animation-play-state 属性 animation-name 规定@keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒, 默认是 0 , (必须的值) animation-timing-function 规定动画的速度曲线, 默认是 ease animation-delay 规定动画何时开始, 默认为 0 animation-iteration-count 规定动画播放的次数, 默认是 1, 还有 infinite animation-direction 规定动画是否在下一个周期逆向播放, 默认是 normal, alternate 逆向播放 animation-play-state 规定动画是否正在运行或暂停, 默认是 running, 还有 pause animation-fill-mode 规定动画结束后状态, 保持 forwards, 回到起始 backwards 5.8.3. CSS3 动画简写12animation: name duration timing-function delay iteration-count direction fill-mode; 5.8.4. 速度曲线animation-timing-function: 规定动画的速度曲线, 默认是 ease 值 描述 linear 动画从头到尾是相同的, 匀速 ease 默认, 动画以低速开始, 然后加速, 在结束前变慢. ease-in 动画以低速开始. ease-out 动画以低速结束. ease-in-out 动画以低速开始和结束. steps 指定时间函数中的间隔数量. 步长 5.9. 3D 转换5.9.1. 认识 3D 转换5.9.2. 3D 转换 translate3d5.9.3. 透视 perspective在 2D 平面参数近大远小视觉立体, 但是只是二维效果的 如果想要在网页产生 3D 效果需要透视(理解成 3D 物体投影在 2D 平面内)模拟人类的视觉位置, 可以认为安排一只眼睛去看透视我们也称为视距: 视距就是人的眼睛到屏幕的距离距离视觉点越近的电脑平面成像越大, 越远越小透视的单位是像素 透视写在被观察元素的父盒子上面的d: 就是视距, 视距就是一个人的眼睛到屏幕的距离z: 就是 z 轴, 物体距离屏幕的距离, z 轴越大我们看到的物体越大. 5.9.3.1. 浏览器私有前缀浏览器私有前缀是为了兼容老版本的写法, 比较新版本的浏览器无须添加. 私有前缀 moz: 代表 firfox 浏览器私有属性 ms: 代表 ie 浏览器私有属性 webkit: 代表 safari, chrome 私有属性 o: 代表 opera 私有属性 6. 移动 web 开发流式布局学习目标: 能够知道移动 web 开发现状 能够写出标准的 viewport 能够使用移动 web 的调试方法 能够说出移动端常见的布局方案 能够描述流式布局 能够独立完成京东移动端首页 6.1. 移动端基础6.1.1. 移动端基础6.1.1.1. 浏览器现状PC 端常见浏览器360 浏览器, 谷歌浏览器, 火狐浏览器, QQ 浏览器, 百度浏览器, 搜狗浏览器, IE 浏览器. 移动端常见浏览器UC 浏览器, QQ 浏览器, 欧朋浏览器, 百度手机浏览器, 360 安全浏览器, 谷歌浏览器, 搜狗浏览器, 猎豹浏览器, 以及其他杂牌浏览器. 国内的 UC 和 QQ, 百度等手机浏览器都是根据 webkit 修改过来的内核, 国内尚无自主研发的内核, 就像国内的手机操作系统都是基于 Android 修改开发的一样. 总结: 兼容移动端主流浏览器, 处理 Webkit 内核浏览器即可. 6.1.1.2. 手机屏幕现状移动端设备屏幕尺寸非常多, 碎片化严重.Android 设备有多种分辨率: 480X800, 480X854, 540X960, 720X1280, 1080X1920, 还有传说中的 2K, 4K 屏.近年来 iPhone 的碎片化也加剧了, 其设备的主要分辨率有: 640X960, 640X1136, 750X1334, 1242X2208 等作为开发者无需关注这些分辨率, 因为我们常用的尺寸单位是 px 6.1.1.3. 常见移动端屏幕尺寸 设备 尺寸 开发尺寸 物理像素比(dpr) iphone 3G 3.5 320*480 1.0 iphone 4/4S 3.5 320*480 2.0 iphone 5/5S/5c 4.0 320*568 2.0 HTC One M8 4.5 360*640 3.0 iphone 6 4.7 375*667 2.0 Nexus 4 4.7 384*640 2.0 Nexus 5x 5.2 411*731 2.6 iphone6 Plus 5.5 414*736 3.0 Samsung Galaxy Note4 5.7 480*853 3.0 Sony Xperia Z Ultra 6.4 540*960 2.0 Nexus 7 7.0 600*960 1.3 iPad mini 7.9 768*1024 1.0 注: 以上数据均参考自:https://material.io/devices注: 作为前端开发, 不建议大家纠结 dp, dpi, ppi 等单位 6.1.1.4. 移动端调试方法 Chrome DevTools(谷歌浏览器)的模拟手机调试 搭建本地 web 服务器, 手机和服务器一个局域网, 通过手机访问服务器 使用外网服务, 直接 IP 或域名访问 6.2. 视口视口(viewport) 就是浏览器显示页面内容的屏幕区域, 视口可以分为布局视口, 视觉视口和理想视口 6.2.1. 布局视口 layout viewport 一般移动设备的浏览器都默认设置了一个布局视口, 用于解决早期的 PC 端页面在手机上显示的问题. IOS, Android 基本都将这个视口分辨率设置为 980px, 所以 PC 上的网页大多都能在手机上显示, 只不过元素看上去很小, 一般默认可以通过手动缩放网页. 6.2.2. 视距视口 visual viewport 字面意思, 它是用户正在看到的网站的区域. 注意: 是网站的区域. 我们可以通过缩放去操作视觉视口, 但不会影响布局视口, 布局视口仍保持原来的宽度. 6.2.3. 理想视口 ideal viewport 为了使网站在移动端有理想的浏览和阅读宽度而设定. 理想视口, 对设备来讲, 是最理想的视口尺寸 需要手动添加 meta 视口标签通知浏览器操作 meta 视口标签的主要目的: 布局视口的宽度应该与理想视口的宽度一致, 简单理解就是设备有多宽, 我们布局的视口就多宽. 6.2.4. meta 视口标签1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no initial-scale= 1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt; 属性 解释说明 width 宽度设置的是 viewport 宽度, 可以设置 device-width 特殊值 initial-scale 初始缩放比, 大于 0 的数字 maximum-scale 最大缩放比, 大于 0 的数字 minimum-scale 最小缩放比, 大于 0 的数字 user-scalable 用户是否可以缩放, yes 或者 no (1 或 0) 6.3. 二倍图6.3.1. 物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒, 是物理真实存在的. 这是厂商在出厂时就设置好了, 比如苹果 6\\7\\8 是 750*1334 我们开发时候的 1px 不是一定等于一个物理像素的 PC 端页面, 1 个 px 等于 1 个物理像素的, 但是移动端不尽相同 一个 px 的能显示的物理像素点的个数, 称为物理像素比或屏幕像素比 PC 端和早期的手机屏幕/普通手机屏幕: 1CSS 像素=1 物理像素 Retina 视网膜屏幕是一种显示技术, 可以将更多的物理像素点压缩至一块屏幕里, 从而达到更高的分辨率, 并提高屏幕显示的细腻程度. 6.4. 移动端开发选择 现在市场常见的移动端开发有单独制作移动端页面和响应式页面两种方案 6.5. 移动端技术解决方案6.5.1. 移动端浏览器 移动端浏览器基本以 webkit 内核为主, 因此我们考虑 webkit 兼容性问题. 我们可以放心使用 H5 标签和 CSS 样式 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 6.5.2. 初始化 normalize.css移动端 CSS 初始化推荐使用 normalize.cssNormalize.css: 保护了有价值的默认值Normalize.css: 修复了浏览器的 bugNormalize.css: 是模块化的Normalize.css: 有详细的文档 官网地址: http://necolas.github.it/normalize.css/ 6.5.3. CSS3 盒子模型 box-sizing传统模式宽度计算: 盒子的宽度 = CSS 中的 width+border+paddingCSS3 盒子模型: 盒子的宽度 = CSS 中设置的宽度 width 里面包含了 border 和 padding, 也就是说, 我们的 CSS3 中的盒子模型, padding 和 border 不会撑大盒子了 6.5.4. 特殊样式6.5.5. 移动端常见布局移动端技术选型移动端布局和以前我们学习的 PC 端有所区别: 单独制作移动端页面流式布局(百分比布局)flex 弹性布局less+rem+媒体查询混合布局 响应式页面兼容移动端媒体查询bootstrap 6.6. Flex 布局个人觉得弹性盒子, 或者弹性布局这种叫法并没有很好的表达出该单词在英文语境中的本意. 6.6.1. flex 布局父项常见属性6.6.1.1. 常见父项属性以下 6 个属性是对父元素设置的 flex-direction: 设置主轴方向 justify-content: 设置主轴上子元素排列方式 flex-wrap: 设置子元素是否换行 align-content: 设置侧轴上子元素的排列方式(多行) align-items: 设置侧轴上的子元素排列方式(单行) flex-flow: 复合属性, 相对于同时设置了 flex-direction 和 flex-wrap 6.6.1.2. 主轴和侧轴 (main-axis / cross-axis)在 flex 布局中,是分为主轴和侧轴两个方向, 同样的叫法有: 行和列, x 轴和 y 轴默认主轴方向是 x 轴, 水平向右默认侧轴方向是 y 轴方向, 水平向下 6.6.1.3. flex-direction 设置主轴方向属性值flex-direction 属性决定主轴的方向(即项目的排列方向)注意: 主轴和侧轴是会变化的, 就看 flex-direction 设置谁为主轴, 剩下的就是侧轴. 而我们的子元素是跟着主轴来排列的 属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从下到上 column-reverse 从上到下 6.6.1.4. justify-content: 设置主轴上子元素排列方式justify 英文解释:(printing) to adjust (printed lines) by spacing so that the lines will be of the correct length. 参考 rejustify, just 有正义, 刚好的意思, ify 是使得…怎么样的意思, 使得什么刚好.justify 是印刷术语: 通过调整打印线的间隙使得每行或列都有正确的宽度. 使得间距刚刚好. justify-content: 属性定义了项目在主轴上的对齐方式.注意: 使用这个属性之前一定要确定好主轴是哪个. 属性值 说明 flex-start 默认值, 从头部开始, 如果主轴是 x 轴, 则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐 (如果主轴是 x 轴则水平居中) space-around 平分剩余空间 space-between 先两边贴边再平分剩余空间 6.6.1.5. align-items: 设置侧轴上的子元素排列方式(单行)该属性是控制子项在侧轴上的排列方式, 在子项为单项的时候使用. 属性 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中 strech 拉伸(默认值) 6.6.1.6. align-content 设置侧轴上的子元素排列方式(多行)设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行), 在单行是没有效果的 属性 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中 strech 拉伸(默认值) space-around 平分剩余空间 space-around 先两边贴边再平分剩余空间 6.6.2. flex 子项常见属性flex 子项占的份数align-self 控制子项自己在侧轴的排列方式order 属性定义子项的排列顺序(前后顺序) 6.6.2.1. flex 属性flex 属性定义子项目分配剩余空间, 用 flex 来表示占多少份数. 123.item { flex: &lt;number&gt;; /* default 0 */} 6.6.2.2. align-self 控制子项自己在侧轴上的排列方式align-self 属性允许单个项目有与其他项目不一样的对齐方式, 可覆盖 align-items 属性. 默认值为 auto, 表示继承父元素的 align-items 属性, 如果没有父元素. 则等同于 stretch 123span:nth-child(2) { align-self: flex-end;} 6.6.2.3. order 属性 7. 响应式布局与 Bootstrap 框架7.1. rem 适配布局学习目标7.2. rem 布局开始方案? 页面布局文字能否随着屏幕大小变化而变化? 流式布局和 flex 布局主要针对于宽度布局, 那高度如何设置? 怎样让屏幕发生变化的时候元素高度和宽度等比例缩放? rem 单位rem(root em)是一个相对单位, 类似于 em, em 是父元素字体大小.不同的是 rem 的基准是相对于 html 元素的字体大小.比如, 根元素(html)设置 font-size:12px 非根元素设置 width:2rem, 则换算成 px 表示就是 24px. 7.3. 媒体查询7.3.1. 什么是媒体查询媒体查询(Media Query)是 CSS3 新语法. 使用@media 查询, 可以针对不同的媒体类型定义不同的样式@media 可以针对不同的屏幕尺寸设置不同的样式当你重置浏览器大小的过程中, 页面也会根据浏览器的宽度和高度重新渲染页面目前针对很多苹果手机, Android 手机, 平板等设备都用得到多媒体查询 7.3.2. 语法规范123@media mediatype and | not | only (media feature) { CSS-Code;} 用@media 开头 注意@符号mediatype 媒体类型关键字 and not onlymedia feature 媒体特性必须有小括号包含 媒体类型all: 用于所有设备print: 用于打印机和打印预览screen: 用于电脑屏幕, 平板电脑, 智能手机等 媒体特性:每种媒体类型都具有各自不同的特性, 根据不同媒体类型的媒体特性设置不同的展示风格, 我们暂且了解三个. 注意他们要加小括号包含width: 定义设备中页面可见区域的宽度min-width: 定义输出设备中页面最小可见区域宽度max-width: 定义输出设备中页面最大可见区域宽度 实例 123/* 这句话的意思是: 在我们屏幕上 并且 最大宽度是800像素时, 设置我们想要的样式*/@media screen and (max-width: 800px) {} 7.4. 媒体查询+rem 实现元素动态大小变化实例 1234567891011121314151617@media screen and (min-width: 320px) { html { font-size: 50px; }}@media screen and (min-width: 640px) { html { font-size: 100px; }}.top { height: 1rem; font-size: 0.5rem; background-color: green; color: #fff;} 7.5. 媒体查询 引入文件当样式比较繁多的时候, 我们可以针对不同的媒体使用不同的 stylesheets(样式表)原理, 就是直接在 link 中判断设备的尺寸, 然后引入不同的 css 文件 语法规范 12345&lt;link rel=&quot;stylesheet&quot; media=&quot;@media mediatype and | not | only (media feature)&quot; href=&quot;mystylesheet.css&quot;/&gt; 8. Less 基础8.1. 维护 css 的弊端CSS 是一门非程序式语言, 没有变量, 函数, SCOPE(作用域)等概念 CSS 需要书写大量看似没有逻辑的代码, CSS 冗余度是比较高的 不方便维护及扩展, 不利于复用 CSS 没有很好的计算能力 非前端开发工程师来讲, 往往会因为确实 CSS 编写经验而很难写出良好且易于维护的 CSS 代码项目. 8.2. less 介绍Less (Leaner Style Sheets) 是一门 CSS 扩展语言, 也成为 CSS 预处理器.作为 CSS 的一种形式的扩展, 它并没有减少 CSS 的功能, 而是在现有的 CSS 语法上, 为 CSS 加入程序式语言的特性.它在 CSS 的语法基础之上, 引入了变量, Mixin 混入, 运算以及函数等功能, 大大简化了 CSS 的编写, 并且降低了 CSS 的维护成本, 就像它的名称所说的那样, Less 可以让我们用更少的代码做更多的事情.less 中文网址: http://lesscss.cn常见的 CSS 预处理器:Sass, Less, Stylus 一句话: Less 是一门 CSS 预处理语言, 它扩展了 CSS 的动态特性. 8.3. Less 安装 安装 nodejs, 网址: http://nodejs.cn/download/ 检查是否安装成功, 使用 cmd 命令 node -v 基于 nodejs 在线安装 less, 使用 cmd 命令 ‘npm install -g less’ 即可 检查是否安装成功, 使用 cmd 命令 lessc -v 查看版本即可 8.4. less 使用我们首先新建一个后缀名为 less 的文件, 在这个 less 文件里面书写 less 语句 8.5. less 变量变量是指没有固定的值, 可以改变的. 因为我们 CSS 中的一些颜色和数值等经常使用. 1@变量名: 值; 变量命名规范必须有@为前缀不能包含特殊字符不能以数字开头大小写敏感 8.6. 编译本质上, less 包含一套自定义的语法及一个解析器, 用户根据这些语法定义自己的样式规则, 这些规则最终会通过解析器, 编译生成对应的 CSS 文件.所以, 我们需要把我们的 less 文件, 编译生成 css 文件, 这样我们的 html 页面才能使用. vscode 安装插件 Easy less 8.7. less 嵌套1 8.8. Less 运算9. sass 基础参考我的博客文章sass 学习笔记","link":"/web/web_basic_1.html"},{"title":"Vultr + Code-server 自建 Cloud IDE","text":"1. 前言Web IDE，顾名思义就是云端开发环境，把 IDE 部署在云上。打开浏览器，连上云 IDE，就可以方便敲代码跑程序。想象一下，带上一台 iPad 或者华为、小米平板，配上蓝牙键盘，坐在阴凉下，或者沙滩上，吹着海风，面朝大海敲代码，多么惬意。 另外如果选择的是国外的 VPS, 那么额外的好处就是，你的 IDE 天然的就在墙外面了，下载各种软件，依赖包，那些奇奇怪怪的问题就没有了，而且你也不存在违规的风险。 其实 Web IDE 很早就有，但那些都只能说是玩具，直到现在才有一些不错的产品推出，比如微软家的 Visual Studio Codespaces、coding.net 的 Cloud Studio、华为云 CloudIDE 等。不过，这些产品要么还在测试，要么免费用会有很多限制， 付费的产品价格不菲，目前还不是非常方便。 如果想要低成本愉快地使用，自己动手搭建是一个不错的方案。对配置要求不高的话，一年几十块一百多块就能买到廉价的 VPS 或者云主机就足够了。 自己 DIY 一套 Web IDE 比较成熟的方案有两个，code-server 和 Theia。毕竟 code-server 是基于 VS code 魔改的，与 vs code 的插件体系兼容性更好。所以更推荐 code-server。Theia 虽然有自己的插件体系，也宣称兼容 vs code 的插件，也是一套优秀的 WEB IDE 解决方案，但是兼容程度谁知道呢？ 下面使用三种方式在一台 2 核 2GB 内存 60 GB NVMe 的 Vultr VPS 上部署 code-server。这台 VPS 一月 18 刀，配置能满足基本的使用。 之所以选择Vultr.com的 VPS, 是因为它一次性赠送 300 美刀的试用金，有效期是一个月，我可以不用花一分钱，充分体验它的各种产品，花式折腾服务器，都不会捉襟见肘。 2. 申请云主机注册并创建 Vultr 主机可以参考我的文章 快速注册 Vultr 账号以及创建 Vultr VPS 主机类型选择（Type）： Cloud Computer - shared CPU 位置（Location）： New York 操作系统镜像(Image): AlmaLinux 版本 9 X86 硬件配置（plan）: Intel High Performance 2vCPUs 、2G 内存、60G NVMe 硬盘，4TB 流量 Additional Features: 自动备份取消，节省 3.6$/月，选中 IPv6, limited user login 主机名（Server Hostname &amp; Label）： 给主机取一个有意义的名字 主机创建完成后，进入主机详情页面，获取主机的 IPv6 地址、用户名、以及密码，后续步骤要用到。 Vultr 有一好处就是它会免费、自动给主机分配一个 IPv6 地址，而且流量非常丰富。操作系统镜像也不用花钱，不像国内的一些云厂商，每项资源都要花钱。 3. 登录到云主机123# 登陆主机，ipv6_address为创建主机后获得的ip地址ssh linuxuser@ipv6_address 4. 安装 Code-server这里只讲解以 rpm/deb 包安装方式，也是推荐的安装方式。其他如自动脚本安装，和 docker 安装在我的博客网站上有讲到，使用网站的查找功能通过关键字 code-server 在网站上找。 4.1. 下载安装包1234567# 适用于 x86_64硬件架构 Fedora, CentOS, RHEL, SUSE，Almalinux 等 Redhat 系列的操作系统curl -L --output /tmp/code-server-4.92.2-amd64.rpm https://github.com/coder/code-server/releases/download/v4.92.2/code-server-4.92.2-amd64.rpm# 适用于 x86_64硬件架构 Debian, Ubuntu等Debian系列操作系统curl -L --output /tmp/code-server_4.92.2_amd64.deb https://github.com/coder/code-server/releases/download/v4.92.2/code-server_4.92.2_amd64.deb 其中版本可以替换成自己需要的版本, 版本信息以及 release notes 可以到 code-server 项目的release 页面查询 4.2. 安装软件包1234567# 适用于 x86_64硬件架构 Fedora, CentOS, RHEL, SUSE，Almalinux 等 Redhat 系列的操作系统sudo rpm -i /tmp/code-server-4.92.2-amd64.rpm# 适用于 x86_64硬件架构 Debian, Ubuntu等Debian系列操作系统sudo dpkg -i /tmp/code-server_4.92.2_amd64.deb 4.3. 设置为开机启动1sudo systemctl enable --now code-server@$USER 4.4. 开放端口如果要允许外部电脑访问 code-server，这需要修改 IP 地址绑定并开发相应端口 vi ~/.config/code-server/config.yaml 123bind-addr: 0.0.0.0:8080 重启 code-server 服务 1sudo systemctl restart code-server@$USER 开放端口 12345678910# 检查防火墙是否开启sudo firewall-cmd --state# 显示默认区域的所有规则sudo firewall-cmd --list-all# 如果开启, 需放行80端口sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload 至此我们可以在 internet 上通过 ip 地址访问我们手动搭建的 IDE 了，当然为了方便，我们还可以购买域名，配置 dns 解析。 现在可以访问 http://[ipv6_address]:8080.密码可以在服务器端code-server的配置文件中找到 ~/.config/code-server/config.yaml 5. 安装插件以及配置 code-server打开访问 code-server, 例如 http://[ipv6_address]:8080 在服务器上执行以下命令，即可安装插件 例如： 12345678910111213code-server --install-extension eamodio.gitlenscode-server --install-extension esbenp.prettier-vscodecode-server --install-extension golang.gocode-server --install-extension k--kato.intellij-idea-keybcode-server --install-extension Mikael.Angular-BeastCodecode-server --install-extension mrmlnc.vscode-lebabcode-server --install-extension oderwat.indent-rainbowcode-server --install-extension stivo.tailwind-foldcode-server --install-extension vscode-icons-team.vscode-icode-server --install-extension wix.vscode-import-costcode-server --install-extension yzhang.markdown-all-in-onecode-server --install-extension zerefdev.todo-highlightercode-server --install-extension ginfuru.ginfuru-better-solarized-dark-theme code-server 配置，可参考我的博客 VSCode 基本配置指南 | 鹏叔的技术博客 以及 vscode 常用快捷键 | 鹏叔的技术博客 另外，若要获取最近更新，请访问本文的原文Vultr + Code-server 自建 Cloud IDE | 鹏叔的技术博客 最后，来一张截图作为这篇文章的结束。","link":"/vscode/cloud_ide_on_vultr.html"},{"title":"Fedora linux上安装 Visual Studio Code","text":"1. 介绍 2. 更新yum源 3. 安装vscode 4. 运行vscode 5. VS Code 更新 6. 相关阅读 1. 介绍Visual Studio Code 简称 VS Code 是微软开发的一款跨平台的源代码编辑器。 它具有内置的调试支持，嵌入式 Git 控件，语法突出显示，代码完成，代码重构和代码片段。 Visual Studio Marketplace 提供了许多插件和扩展来扩展VS代码的功能。 本教程将指导您如何从 Microsoft 的 VS Code 存储库在Fedora 29/30上安装 VS Code 代码编辑器。 2. 更新yum源Microsoft提供了官方存储库，可以轻松安装适用于 Fedora 操作系统的 Visual Studio 代码。 因此，您可以在系统上设置Microsoft存储库，以接收VS Code包。 首先通过以下命令切换到root用户。 123su - # 或者sudo bash 出于安全考虑，需要导入GPG key， 以防安装包被篡改。 12#rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo rpm --import https://packages.microsoft.com/yumrepos/vscode/repodata/repomd.xml.key 添加vscode的yum源 123456789cat &lt;&lt; EOF &gt; /etc/yum.repos.d/vscode.repo[vscode-yum]name=vscode-yumbaseurl=https://packages.microsoft.com/yumrepos/vscode/repo_gpgcheck=1gpgcheck=1enabled=1gpgkey=https://packages.microsoft.com/yumrepos/vscode/repodata/repomd.xml.keyEOF 说明: yum 源配置对openSUSE, SLE 或基于它们的发行版也是有效的, 安装命令如下.sudo zypper refreshsudo zypper install code 更新yum源缓存 1sudo dnf check-update 3. 安装vscode查看当前可用版本 123dnf list available code 使用dnf 命令在Fedora系统上安装vscode 1sudo dnf install --enablerepo=vscode-yum -y code 4. 运行vscode在Fedora系统上安装VS code后，可以从命令行通过运行code命令或在图形模式下单击VS代码图标启动它。 Fedora: Activities &gt;&gt; Search for Visual Studio Code. 5. VS Code 更新Microsoft 每月会发布 VS Code更新。 您可以使用以下命令更新 Visual Studio Code 版本。 1sudo dnf update --enablerepo=vscode-yum -y code 6. 相关阅读vscode基本配置指南 vscode常用快捷键 Vultr + Code-server 自建 Cloud IDE","link":"/vscode/how_to_install_vscode_on_fedora.html"},{"title":"如何升级vscode","text":"1. 介绍vscode 自从发布以来，用过的人都赞不绝口，占用空间小，速度快，功能强大。一般的编辑器都不能兼具”轻快小”与”功能强大”的优点，但 vscode 做到了。同时 vscode 还能保持很快的更新速度，几天就能更新一次版本，以很快的速度变得越来越好用。 2. 手动更新 vscode2.1. 使用 ZIP archive（文件替换） 下载更新包点击vscode菜单=&gt; help =&gt; download update 系统将会自动下载更新包 或者导航的vs code download, 下载对应的 zip 包 解压缩解压缩更新包 替换 vscode打开 vscode 的主目录, 将上一步解压缩后的文件对主目录下的文件进行替换. 重启 vscode, 更新完成","link":"/vscode/how_to_upgrade_vscode.html"},{"title":"vscode常用快捷键","text":"1. 介绍本文主要介绍 vscode 的一些常用快捷键的使用. 2. 打开命令面板 按下 F1 或 Ctrl+Shift+P 可以打开命令面板 在打开的输入框内，可以输入任何命令按一下 Backspace 会进入到 Ctrl+P 模式 在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors 或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 3. 打开配置文件 打开用户设置: Ctrl+Alt+s, 打开配置面板后, 右上角有个 Open Settings(json)可以打开 settings.json. 4. 编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 切出一个新的分栏编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个分栏编辑器之间切换： Ctrl+1 Ctrl+2 Ctrl+3 编辑器换位置， Ctrl+k 然后按 Left 或 Right 5. 显示相关 全屏：F11 zoomIn/zoomOut 放大或缩小窗口：Ctrl +、Ctrl - 侧边栏显/隐： Ctrl+B 显示资源管理器 Ctrl+Shift+E 显示搜索 Ctrl+Shift+F 显示 Git Ctrl+Shift+G 显示 Debug Ctrl+Shift+D 显示 Output Ctrl+Shift+U 隐藏 / 显示侧边栏：Ctrl + b 6. 查找替换 单个文件内查找 Ctrl+F 单个文件内查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 7. 修改默认快捷键打开默认键盘快捷方式设置：File -&gt; Preferences -&gt; Keyboard Shortcuts，或者：Alt+F -&gt; p -&gt; k修改 keybindings.json 8. 删除上一个单词要删除前一个单词，可以按 Ctrl + Backspace (Mac: option + delete)。这在你打错字的时候非常有用。 9. 配置参考keybindings.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798[ { &quot;key&quot;: &quot;ctrl+tab&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusNext&quot;, // 切换到下一个终端 &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+t&quot;, &quot;command&quot;: &quot;workbench.action.terminal.new&quot;, // 打开新的终端 &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+1&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex1&quot;, // 打开终端1 &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+2&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex2&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+3&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex3&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+4&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex4&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+5&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex5&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+6&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex6&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+7&quot;, &quot;command&quot;: &quot;workbench.action.terminal.focusAtIndex7&quot;, &quot;when&quot;: &quot;terminalFocus&quot; }, { &quot;key&quot;: &quot;ctrl+alt+m&quot;, &quot;command&quot;: &quot;workbench.action.toggleMaximizedPanel&quot; }, { &quot;key&quot;: &quot;ctrl+f5&quot;, &quot;command&quot;: &quot;workbench.action.reloadWindow&quot;, // 刷新settings.json &quot;when&quot;: &quot;editorTextFocus&quot; }, { &quot;key&quot;: &quot;alt+down&quot;, &quot;command&quot;: &quot;cursorColumnSelectDown&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;alt+left&quot;, &quot;command&quot;: &quot;cursorColumnSelectLeft&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;ctrl+shift+alt+pagedown&quot;, &quot;command&quot;: &quot;cursorColumnSelectPageDown&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;ctrl+shift+alt+pageup&quot;, &quot;command&quot;: &quot;cursorColumnSelectPageUp&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;alt+right&quot;, &quot;command&quot;: &quot;cursorColumnSelectRight&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;ctrl+shift+alt+up&quot;, &quot;command&quot;: &quot;cursorColumnSelectUp&quot;, &quot;when&quot;: &quot;textInputFocus&quot; }, { &quot;key&quot;: &quot;ctrl+shift+b&quot;, &quot;command&quot;: &quot;-workbench.action.tasks.build&quot; }, { &quot;key&quot;: &quot;ctrl+alt+r&quot;, &quot;command&quot;: &quot;workbench.files.action.showActiveFileInExplorer&quot; }, { &quot;key&quot;: &quot;ctrl+e&quot;, &quot;command&quot;: &quot;workbench.action.quickOpenLeastRecentlyUsedEditorInGroup&quot; }] 10. 参考文档 Visual Studio Code 常用快捷键 Key Bindings for Visual Studio Code 官方文档","link":"/vscode/vscode_hotkey.html"},{"title":"webpack+angularjs1.x+bootstrap4.x开发环境配置","text":"1. 说明1.1. 适用范围 本教程适用于 angularjs1.x 和 bootstrap4.x 1.2. 为什么要使用 webpack 传统 web 开发-编写 html 文件并手动引入 js 包, 已经不能适应现代 web 开发了, 具体体现在: 不能适应模块化编程的思想 不能很好的利用 nodejs 包 如果需要使用 less, sass, typescript, es5, es6 需要手动编译成源文件为 css, js 代码, 并打包. 为什么选择 webpack, 相对于 grunt 或 gulp 加 bower 组合, webpack 能更好的处理现代 web 开发中的痛点. 另外 bower 的官网已经推荐使用 yarn+webpack 组合了. 当然好处还有很多, 这里只是简单列举这些. 2. 前置条件 安装 nodejs, 并配置国内镜像源安装并配置 nodejs 请参考我的文章安装并配置 nodejs 安装 cnpm安装 cnpm 请参考我的文章安装并配置 nodejs 安装 webpack 1npm install -g webpack 3. 初始化 nodejs 项目创建一个新文件夹, 进入文件夹.初始化使用 npm init 命令, 具体如下 123456789101112131415161718192021222324252627282930313233343536373839$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (webpack3)version: (1.0.0)description: an example webpack projectentry point: (index.js)test command:git repository:keywords: webpack exampleauthor: eaglelicense: (ISC)About to write to C:\\dev\\code\\SandBox\\webpack3\\package.json:{ &quot;name&quot;: &quot;webpack3&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;an example webpack project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [ &quot;webpack&quot;, &quot;example&quot; ], &quot;author&quot;: &quot;eagle&quot;, &quot;license&quot;: &quot;ISC&quot;}Is this OK? (yes) yes 说明: 可以一路回车,使用默认参数; license 具体选用哪种 license, 可以参考SPDX 许可列表 其他参数不清楚怎样设置, 可以参考这篇文章-npm 配置项介绍 4. 引入工具包和项目依赖4.1. 引入开发需要用到的工具包4.1.1. 引入 webpack 工具包1cnpm install --save-dev webpack webpack-cli webpack-dev-server 4.1.2. 引入 webpack 插件4.1.2.1. 2.1 css 处理插件1cnpm install --save-dev css-loader mini-css-extract-plugin 4.1.2.2. 2.2 html 处理插件1cnpm install --save-dev html-webpack-plugin 4.2. 引入项目依赖 引入 angularjs 1cnpm install --save angular@1.8.2 注意: 这里的保存选项是 –save, 包依赖将被更新到 package.json 的 dependencies 区域. 引入 bootstrap4.x 及其依赖包 bootstrap 依赖 jquery 和 popper 1cnpm install --save bootstrap@4.6.0 jquery@3.6.0 popper.js@1.16.1 5. 写 webpack 配置创建 webpack.config.js, 并配置如下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const { resolve } = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = { //webpack的js入口, 里面定义打包资源 entry: &quot;./src/index.js&quot;, output: { //webpack3 为项目名, 可替换成你自己的项目名 filename: &quot;js/webpack3.bundle.js&quot;, path: resolve(__dirname, &quot;build&quot;), }, module: { rules: [ //loader的配置 { test: /\\.css$/, use: [ //创建style标签, 将js中的中的样式资源插入进去, 添加到head中生效, 本项目未用到, 本项目采用的是MiniCssExtractPlugin, 将css输出到独立的文件 //'style-loader', //将经过css-loader处理后的文件输出到独立的css文件, 该独立css在新建MiniCssExtractPlugin的时候已经指定, 请参考plugin区域 MiniCssExtractPlugin.loader, //将css文件变成commonjs模块加载js中, 里面内容是样式字符串 &quot;css-loader&quot;, ], }, ], }, plugins: [ //默认会创建一个空的html, 自动引入打包输出的所有资源(JS/CSS) new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot;, }), new MiniCssExtractPlugin({ //webpack3 为项目名 filename: &quot;css/webpack3.css&quot;, }), ], //开发服务器配置, 用来实现开发过程自动(自动编译, 自动打开浏览器, 自动更新浏览器) //特点,只会在内存中编译打包, 不会有任何输出. devServer: { static: { directory: resolve(__dirname, &quot;build&quot;), }, compress: true, port: 3000, //自动打开浏览器 open: true, }, mode: &quot;development&quot;,}; 6. 写一个简单的 angularjs创建 index.js, index.css 文件.项目的目录结构 123456789webpack3│ webpack.config.js│ package.jsonsrc│ index.html│ index.js│└─css index.css index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;box1&quot; class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot; class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box3&quot; class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box4&quot; class=&quot;col-xs-12 col-sm-6 col-md-3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; index.js 12345678910111213141516const Angular = require(&quot;angular&quot;);const $ = require(&quot;jquery&quot;);import &quot;bootstrap&quot;;import &quot;bootstrap/js/dist/util&quot;;import &quot;bootstrap/js/dist/dropdown&quot;;import &quot;bootstrap/dist/css/bootstrap.css&quot;;import &quot;./css/index.css&quot;;const ngModule = Angular.module(&quot;myApp&quot;, []);ngModule.controller(&quot;mainCtrl&quot;, [ &quot;$scope&quot;, &quot;$http&quot;, function ($scope, $http) { // console.log($scope); $scope.name = &quot;eagle&quot;; },]); css/index.css 1234567891011.row &gt; div { height: 150px;}.row &gt; div:nth-child(2n) { background-color: blue;}.row &gt; div:nth-child(2n + 1) { background-color: yellow;} 7. 打包, 运行结果打包程序 1webpack 程序将会打包到 build 目录下 12345678build│ index.html│├─css│ webpack3.css│└─js webpack3.bundle.js 在浏览器中查看 index.html, 效果如下 8. 配置 webpack dev server为什么要安装 dev server?如果没有 dev server, 我们每次修改后都要运行 webpack 去打一次包, 才能看到改动后的效果. 如果开启 dev server, 修改可以及时反映到界面上, 不用我们手动打包, 再点击运行. 方便开发. 8.1. 安装 webpack dev server 插件1cnpm install --save-dev webpack-dev-server 在引入工具包一节一节安装过, 这里可以忽略 8.2. 修改 webpack.config.js加入对 webpack dev server 支持 1234567891011//开发服务器配置, 用来实现开发过程自动(自动编译, 自动打开浏览器, 自动更新浏览器) //特点,只会在内存中编译打包, 不会有任何输出. devServer: { static: { directory: resolve(__dirname, 'build'), }, compress: true, port: 3000, //自动打开浏览器 open: true }, 运行 webpack dev server在 webpack 配置文件同级目录下运行 1webpack server","link":"/webpack/webpack_angularjs_bootstrap.html"},{"title":"VSCode安装和配置指南","text":"1. 介绍 2. Windows 上安装 VSCode 安装 2.1. 下载 VSCode 3. Fedora 上安装 VS Code 4. 如何打开配置 5. VScode 用户设置 5.1. 设置字体大小 5.2. 设置自动保存方式 5.3. 设置自动补全 5.4. 查询中过滤掉非必要的文件 5.5. 过滤文件 5.6. 关闭自动检测更新 5.7. 配置大小写转换快捷键 5.8. 配置快捷键 5.9. 安装与配置主题 5.10. 关闭 Open editor 5.11. 在侧边栏快速定位文件 5.12. vscode 整合 gitbash 5.13. vscode 高亮括号对 6. 安装 plugins 6.1. 插件列表 命令行安装插件 7. 配置 plugin 7.1. prettier - Code formatter 7.2. 配置 prettier tabwidth 8. 完整配置 9. 相关阅读 10. 参考文档 1. 介绍vscode 可以做很多事, 是真正的生产力工具, 但是如何将其配置得好用, 并符合自己的使用习惯, 却是很复杂的一件事. 它的默认模式就像一辆自动挡的汽车, 不做任何改动也能开着上路, 如果想压榨一下它的生产力, 还是要懂得一些配置相关的知识或技巧. 若需获取最近更新请访问原文, 原文位于鹏叔的技术博客 - vscode 基本配置指南. 相关阅读: vscode 常用快捷键 如何升级 vscode 2. Windows 上安装 VSCode 安装2.1. 下载 VSCodeVSCode 有两种版本 User Installer 版：会安装在当前计算机帐户目录,意味着如果使用另一个账号登陆计算机将无法使用别人安装的 vscode。 System Installer 版：安装在非用户目录,例如 C 盘根目录,任何帐户都可以使用。(建议使用此版本) vscode 默认提供的 User Installer 版,大多数人都是用的这个版本。 下载地址https://code.visualstudio.com/download 安装步骤: 双击 Installer 按指引安装 3. Fedora 上安装 VS CodeFedora 上安装 VS Code 可以参考我的文章 - Fedora linux 上安装 Visual Studio Code 4. 如何打开配置vscode 的配置入口并不在一个很显眼或很容易找到的地方, 它位于一个与配置不太关联的主菜单下的二级菜单, 这也是为什么此处要单独劈开一节介绍如何打开配置得原因. 打开方式 方法一:通过菜单打开设置菜单位于 文件-&gt;首选项-&gt;设置.打开用户设置。VScode 支持选择配置，也支持编辑 setting.json 文件修改默认配置。个人更倾向于编写 json 的方式进行配置. 方法二: 使用快捷键打开打开设置的快捷键通常为: Ctrl+Alt+s, 打开配置面板后, 右上角有个 Open Settings(json)可以打开 settings.json. vscode 有两种配置方式 一种是图形界面, 这种非常时候普通用户, 使用鼠标点击就能完成设置. vscode 也可以通过配置文件来进行配置, 配置文件为 json 格式的 settings.json 5. VScode 用户设置5.1. 设置字体大小（1）editor.fontsize 用来设置字体大小，可以设置 editor.fontSize : 14; 1&quot;editor.fontSize&quot;: 14, 5.2. 设置自动保存方式（2）files.autoSave 这个属性是表示文件是否进行自动保存，推荐设置为 onFocusChange——文件焦点变化时自动保存。 1&quot;files.autoSave&quot;:&quot;onFocusChange&quot;, 5.3. 设置自动补全（3）editor.tabCompletion 用来在出现推荐值时，按下 Tab 键是否自动填入最佳推荐值，推荐设置为 on; 5.4. 查询中过滤掉非必要的文件vscode 的搜索页面位于左侧, 本来就很窄很拥挤, 如果再出现一些明显非必要的结果,更显得拥挤不堪, 所以非常有必要做一些过滤, 这样每次的搜索可以直达目标, 省去一些手动折叠文件, 鼠标向下滚动等等操作, 非常有帮助. 当然你说连代码的产出物也是你搜索的范围, 目前来说我没有想出什么更好的办法, 只有使用快捷键打开配置, 将这些过滤条件关闭掉, 也不用重启, 每隔数秒配置会自动生效. 1234567&quot;search.exclude&quot;: { &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, &quot;build/&quot;: true, &quot;temp/&quot;: true, &quot;library/&quot;: true}, 5.5. 过滤文件有些文件是系统,或者某些工具使用的配置文件, 我们不常使用, 将其列在项目中会分散注意力, 其实我们完全可以将这些文件从项目文件中将其忽略掉, 比如.git 配置文件对象树, .idea 配置文件, 这些文件我们几乎平时很少修改, 也不必去关心, 可以将其设置为忽略. 1234&quot;files.exclude&quot;: { &quot;**/.git&quot;: true, &quot;**/.idea&quot;: true } 5.6. 关闭自动检测更新1&quot;extensions.autoCheckUpdates&quot;: false, 5.7. 配置大小写转换快捷键编辑 keybindings.json 12345678{ &quot;key&quot;: &quot;ctrl+shift+l&quot;, &quot;command&quot;: &quot;editor.action.transformToLowercase&quot;},{ &quot;key&quot;: &quot;ctrl+shift+u&quot;, &quot;command&quot;: &quot;editor.action.transformToUppercase&quot;} 5.8. 配置快捷键打开快捷键配置 file -&gt; preference -&gt; keyboard shotcuts也可以通过配置文件进行配置 keybindings.json 5.9. 安装与配置主题以安装 Solarized Dark+ 主题为例: 首先安装主题 点开左侧边栏的 extentions 搜索 Solarized 找到对应的插件然后安装 然后配置主题 打开颜色主题, 选择 Solarized 作为主题 或者使用快捷键 Ctl+Shift+p 打开命令面板,输入 color theme 然后选择 Solarized Dark+ 或者直接修改 settings.json 1&quot;workbench.colorTheme&quot;: &quot;Solarized Dark+&quot;, 5.10. 关闭 Open editoropen editor 对我来说其实没有什么用处, 而占有了太多的侧边栏位置将 workspace 视图挤得只有一点点, 而且在顶部. 如果谁有更好的办法, 可以在评论区留言告诉我, 在此表示感谢! 而我使用 workspace 的频率远远大于 open editor, 即使我需要看那些打开的文件, 我也可以使用快捷键打开 1&quot;explorer.openEditors.visible&quot;: 0 5.11. 在侧边栏快速定位文件虽然右键点击标签页,选择 reveal in sidebar 可以定位到侧边栏, 我希望给它定义一个快捷键, 这样可以减少鼠标操作.取这个功能 reveal 的首字母构成一个快捷键组合 Ctrl + Alt + r修改 keybindings.json 1234{ &quot;key&quot;: &quot;ctrl+alt+r&quot;, &quot;command&quot;: &quot;workbench.files.action.showActiveFileInExplorer&quot;} 参考文档: How to reveal current file in Explorer? 5.12. vscode 整合 gitbash打开用户设置: File -&gt; Preference -&gt; settings, 切换到 json 模式 添加如下配置到 Settings 并保存, 其中 bash.exe 的路径根据自己实际安装位置做相应替换. 123456&quot;terminal.integrated.profiles.windows&quot;: { &quot;Git-Bash&quot;: { &quot;path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\usr\\\\bin\\\\bash.exe&quot; } }, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git-Bash&quot; 5.13. vscode 高亮括号对安裝插件：Bracket Pair Colorizer 2 123456789101112131415// 開啟 bracket pair colorization；1.67 以上可省略此開啟設定&quot;editor.bracketPairColorization.enabled&quot;: true,&quot;editor.guides.bracketPairs&quot;:&quot;active&quot;,// 設定顏色&quot;workbench.colorCustomizations&quot;: { // 層級括號顏色，從 1 至 6 層，此處只設定了 5 層 &quot;editorBracketHighlight.foreground1&quot;: &quot;#ffd700&quot;, &quot;editorBracketHighlight.foreground2&quot;: &quot;#DC143C&quot;, &quot;editorBracketHighlight.foreground3&quot;: &quot;#87cefa&quot;, &quot;editorBracketHighlight.foreground4&quot;: &quot;#ffd700&quot;, &quot;editorBracketHighlight.foreground5&quot;: &quot;#da70d6&quot;, &quot;editorBracketHighlight.foreground6&quot;: &quot;#87cefa&quot;, // 異常括號的顏色，比如多出來的結尾括號 &quot;editorBracketHighlight.unexpectedBracket.foreground&quot;: &quot;#ff0000&quot;,} 参考文章:VS Code 開啟效能提升 1 萬倍的「內建」bracket pair colorization vscode1.60 原生高性能括号着色无缝迁移方案 6. 安装 pluginsAngular Snippets (Version 13)GoIntellij IDEA KeybindingsMarkdown Preview Mermaid Support 6.1. 插件列表 插件 版本 安装命令 描述 Angular Snippets (Version 13) v13.0.0 ext install johnpapa.Angular2 The extension for Visual Studio Code adds snippets for Angular for TypeScript and HTML gitlens v11.7.0 ext install eamodio.gitlens GitLens simply helps you better understand code. Quickly glimpse into whom, why, and when a line or code block was changed. Jump back through history to gain further insights as to how and why the code evolved. Effortlessly explore the history and evolution of a codebase. intellij-idea-keybindings v1.5.0 ext install k–kato.intellij-idea-keybindings Port of IntelliJ IDEA key bindings for VS Code. Includes keymaps for popular JetBrains products like IntelliJ Ultimate, WebStorm, PyCharm, PHP Storm, etc. lebab 2.6.0 ext install mrmlnc.vscode-lebab Lebab transpiles your ES5 code into readable ES2015 (sugar-syntax). It does exactly the opposite of what Babel does. markdown-mermaid v1.13.0 ext install bierner.markdown-mermaid Adds Mermaid diagram and flowchart support to VS Code’s builtin markdown preview bookmarks v13.2.2 ext install alefragnani.bookmarks Improve your Bookmarks experience with Tabnine code completions formate: CSS/LESS/SCSS formatter(not requried for me I have replaced the formatters with Prettier which is more powerful) v1.2.1 ext install mikebovenlander.formate Formate is an CSS/LESS/SCSS format extension to format properties and align property values to improve readability. Markdown All in One v3.4.0 ext install yzhang.markdown-all-in-one All you need for Markdown(keyboard shortcuts, table of contents, auto preview and more) mardownlint v0.47.0 ext install DavidAnson.vscode-markdownlint Markdown/CommonMark linting and style checking for Visual Studio Code Go v0.33.1 ext install golang.go Rich Go language support for Visual Studio Code Bracket Pair Colorizer v1.0.62 ext install CoenraadS.bracket-pair-colorizer Rich Go language support for Visual Studio Code rust-analyzer v0.3.1301 ext install rust-lang.rust-analyzer this extention provides support for the Rust programming language. Gradle Language Support v0.2.3 ext install naco-siren.gradle-language Gradle Language Support Import Cost v3.3.0 ext install wix.vscode-import-cost This extension will display inline in the editor the size of the imported package. The extension utilizes webpack in order to detect the imported size. Todo Highlighter v1.0.1 ext install zerefdev.todo-highlighter zerefdev.todo-highlighter Todo Tree v0.0.223 ext install Gruntfuggly.todo-tree This extension quickly searches (using ripgrep) your workspace for comment tags like TODO and FIXME, and displays them in a tree view in the activity bar. The view can be dragged out of the activity bar into the explorer pane (or anywhere else you would prefer it to be). Language Support for Java(TM) by Red Hat v0.2.3 ext install redhat.java Provides Java ™ language support via Eclipse ™ JDT Language Server, which utilizes Eclipse ™ JDT, M2Eclipse and Buildship. shell-format v7.2.5 ext install foxundermoon.shell-format A formatter for shell scripts, Dockerfile, gitignore, dotenv, /etc/hosts, jvmoptions, and other file types. CodeCursor(Cursor for VS Code) v0.4.0 ext install ktiays.aicursor Cursor integration for Visual Studio Code. vscode-icons v12.3.0 ext install vscode-icons-team.vscode-icons Bring icons to your Visual Studio Code and Icons Customization. Prettier - Code formatter v9.10.4 ext install esbenp.prettier-vscode Prettier is an opinionated code formatter.. Colorize v0.11.1 ext install kamikillerto.vscode-colorize Instantly visualize css colors in your css/sass/less/postcss/stylus/XML… files. indent-rainbow v8.3.1 ext install oderwat.indent-rainbow A simple extension to make indentation more readable. live server v5.7.9 ext install ritwickdey.LiveServer Launch a local development server with live reload feature for static &amp; dynamic pages. Thunder Client v2.10.0 ext install rangav.vscode-thunder-client Thunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design. Angular Language Service v17.3.2 ext install Angular.ng-template Angular Language Service. Tailwind CSS IntelliSense v0.10.5 ext install bradlc.vscode-tailwindcss Tailwind CSS IntelliSense XML v0.26.1 ext install redhat.vscode-xml XML Language Support by Red Ha Ctrl+shift+p 或者按 F1 打開命令行提示框， 輸入安裝命令進行插件安裝 命令行安装插件你知道你可以从终端安装 VSCode 插件吗？不过，现在你知道了！ 要从你的终端安装扩展程序，你需要知道扩展程序名称和发布者名称，再按照 发布者名称.扩展程序名称 的顺序找到它。 先了解一下 vscode 插件相关命令 123456789101112131415161718192021# 查看已安装的所有插件的列表code --list-extensions# 安装插件# 请将&lt;插件名称&gt;替换为您要安装的插件的实际名称，将[版本号]替换为您要安装的特定版本号。# 例如，如果要安装名为&quot;Path Intellisense&quot;的插件，版本号为&quot;1.2.3&quot;，则命令如下：# code --install-extension path-intellisense@1.2.3code --install-extension &lt;插件名称&gt;@[版本号]# 安装最新版的插件code --install-extension &lt;插件名称&gt;# 要禁用单个插件，可以使用以下命令code --disable-extension &lt;在这里输入插件的ID&gt;# 如果要禁用所有插件，可以使用以下命令code --disable-extensions# 卸载个插件，可以使用以下命令code --uninstall-extension &lt;在这里输入插件的ID&gt; command lines to install necessary vscode plugins 12345678910111213141516171819202122232425code --install-extension johnpapa.Angular2code --install-extension ryanolsonx.solarizedcode --install-extension eamodio.gitlenscode --install-extension k--kato.intellij-idea-keybindingscode --install-extension bierner.markdown-mermaidcode --install-extension alefragnani.bookmarkscode --install-extension yzhang.markdown-all-in-onecode --install-extension DavidAnson.vscode-markdownlintcode --install-extension golang.gocode --install-extension naco-siren.gradle-languagecode --install-extension wix.vscode-import-costcode --install-extension zerefdev.todo-highlightercode --install-extension Gruntfuggly.todo-treecode --install-extension redhat.javacode --install-extension foxundermoon.shell-formatcode --install-extension vscode-icons-team.vscode-iconscode --install-extension esbenp.prettier-vscodecode --install-extension kamikillerto.vscode-colorizecode --install-extension oderwat.indent-rainbowcode --install-extension ritwickdey.LiveServercode --install-extension rangav.vscode-thunder-clientcode --install-extension Angular.ng-templatecode --install-extension redhat.vscode-xml 7. 配置 plugin7.1. prettier - Code formatterprettier 很强大, 配置也很灵活, 但是它的默认配置用起来并不是很顺手.要配置一套适合自己项目的 prettier 几乎可以用一个文章的内容进行介绍. 7.2. 配置 prettier tabwidthprettier 的默认 tabwidth 为 2 个字符, 这对大多数文档类型都不适合, 所以要将其修改为合适的字符. 例如: 1&quot;prettier.tabWidth&quot;: 4, 但是不同的文档类型, 可能需要 tabWidth. 此时可以在项目的根目录放置一个 prettier 配置文件, 为不同的文档类型定义不同的 tabwidth. prettier.config.js 123456789101112module.exports = { tabWidth: 4, overrides: [ { files: &quot;*.md&quot;, options: { tabWidth: 2, }, }, ],}; prettier.config.js 是一个用 JavaScript 格式编写的配置文件。它也可以放在项目的根目录或任何子目录中。Prettier 将自动搜索此文件并使用它来配置自己。如果您的项目中同时有.pareterrc 和.pareter.config.js 文件，则以.pareterconfig.js 为优先。也可以使用.prettierrc 作为配置文件, 但是写法稍有不同.参考文档 https://prettier.io/docs/en/configuration.html#configuration-overrides 8. 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111{ &quot;editor.minimap.enabled&quot;: false, &quot;editor.fontSize&quot;: 14, &quot;breadcrumbs.enabled&quot;: true, &quot;editor.renderControlCharacters&quot;: true, &quot;editor.renderWhitespace&quot;: &quot;none&quot;, &quot;workbench.colorTheme&quot;: &quot;Solarized Dark+&quot;, &quot;update.mode&quot;: &quot;none&quot;, &quot;explorer.confirmDelete&quot;: false, &quot;explorer.confirmDragAndDrop&quot;: false, &quot;extensions.autoCheckUpdates&quot;: false, &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, &quot;search.exclude&quot;: { &quot;**/node_modules&quot;: true, &quot;**/bower_components&quot;: true, //hexo 生成的文件 &quot;**/db.json&quot;: true, // tauri mobile build &amp; cache &quot;**/android/app/build/&quot;: true, &quot;**/android/**/build/&quot;: true, &quot;**/.angular/cache/&quot;: true, //hexo 生成的文件 &quot;public/**/*&quot;: true, &quot;build/&quot;: true, &quot;temp/&quot;: true, &quot;library/&quot;: true, &quot;**/*.anim&quot;: true, &quot;.deploy_git/&quot;: true, &quot;**/dist&quot;: true, &quot;src-tauri/target/&quot;: true }, &quot;files.exclude&quot;: { &quot;**/.git&quot;: true, &quot;**/.idea&quot;: true, &quot;**/.classpath&quot;: true, &quot;**/.project&quot;: true, &quot;**/.settings&quot;: true, &quot;**/.angular&quot;: true }, &quot;gitlens.currentLine.scrollable&quot;: false, &quot;gitlens.currentLine.pullRequests.enabled&quot;: false, &quot;gitlens.currentLine.enabled&quot;: false, &quot;gitlens.hovers.currentLine.over&quot;: &quot;line&quot;, &quot;gitlens.codeLens.enabled&quot;: false, &quot;workbench.editor.pinnedTabSizing&quot;: &quot;shrink&quot;, &quot;workbench.editor.highlightModifiedTabs&quot;: true, &quot;workbench.editor.labelFormat&quot;: &quot;short&quot;, &quot;workbench.settings.settingsSearchTocBehavior&quot;: &quot;hide&quot;, &quot;workbench.editor.wrapTabs&quot;: false, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;editor.indentSize&quot;: &quot;tabSize&quot;, // 開啟 bracket pair colorization；1.67 以上可省略此開啟設定 &quot;editor.bracketPairColorization.enabled&quot;: true, &quot;editor.guides.bracketPairs&quot;: &quot;active&quot;, // 設定顏色 &quot;workbench.colorCustomizations&quot;: { // 層級括號顏色，從 1 至 6 層，此處只設定了 5 層 &quot;editorBracketHighlight.foreground1&quot;: &quot;#ffd700&quot;, &quot;editorBracketHighlight.foreground2&quot;: &quot;#DC143C&quot;, &quot;editorBracketHighlight.foreground3&quot;: &quot;#87cefa&quot;, &quot;editorBracketHighlight.foreground4&quot;: &quot;#ffd700&quot;, &quot;editorBracketHighlight.foreground5&quot;: &quot;#da70d6&quot;, &quot;editorBracketHighlight.foreground6&quot;: &quot;#87cefa&quot;, // 異常括號的顏色，比如多出來的結尾括號 &quot;editorBracketHighlight.unexpectedBracket.foreground&quot;: &quot;#ff0000&quot; }, &quot;terminal.integrated.profiles.windows&quot;: { &quot;Git-Bash&quot;: { &quot;path&quot;: &quot;C:\\\\Program Files\\\\Git\\\\usr\\\\bin\\\\bash.exe&quot; } }, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git-Bash&quot;, // prettier Code formatter 配置 &quot;prettier.tabWidth&quot;: 4, &quot;prettier.embeddedLanguageFormatting&quot;: &quot;off&quot;, &quot;[typescript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[json]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[html]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[xml]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;redhat.vscode-xml&quot; }, &quot;[javascript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[css]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[scss]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[markdown]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.tabSize&quot;: 2 }, &quot;[python]&quot;: { &quot;editor.formatOnType&quot;: true }, &quot;editor.formatOnSaveMode&quot;: &quot;modificationsIfAvailable&quot;, &quot;editor.trimAutoWhitespace&quot;: false, &quot;typescript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;, &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;, // fix vscode hotkeys overrided by other app issue on fedora &quot;keyboard.dispatch&quot;: &quot;keyCode&quot;} 9. 相关阅读 Vultr + Code-server 自建 Cloud IDE vscode 常用快捷键 Fedora linux 上安装 Visual Studio Code 如何升级 vscode 10. 参考文档VScode 用户设置 如何安装 VSCode 扩展 | Linux 中国","link":"/vscode/vscode_install_and_config.html"},{"title":"webpack中使用环境变量","text":"1. 背景介绍由于前端项目在不同的阶段需要连接不同的后端服务器, 在没有引入环境变量前, 需要手动修改服务器地址. 经常容易出错, 而且不利于便于自动化打包. 所以这里引入 DefinePlugin 便于引入环境变量进行环境区分. 2. DefinePlugin可以利用 webpack 本身自带的 process.env 创建一个在编译时可以配置的全局常量。主要针对我们在编译时，区分 开发、测试、生产环境。而 webpack.DefinePlugin 提供的可以在浏览器环境里拿到。 3. 引入依赖使用 webpack.DefinePlugin 之前需要先引入 webpack 这个包首先在 npm 项目中引入依赖, package.json 1&quot;webpack&quot;: &quot;^5.52.0&quot;, 对于 webpack5 还需要引入 process 包 123npm i --save-dev process# 或者cnpm i --save-dev process 当前 2010/12/10, process 的最新版本是 0.11.10 1&quot;process&quot;: &quot;^0.11.10&quot;, 在 webpack 配置中引入包, 例如我的配置文件为 webpack.config.bash.js 1const webpack = require(&quot;webpack&quot;); 4. 示例4.1. 如何定义变量12345new webpack.DefinePlugin({ 'PROCESS.VERSION': JSON.stringify( '1.0.0'), 'PROCESS.APIURL': JSON.stringify( 'http://localhost'), 'PROCESS.ENVIRONMENT': '&quot;dev&quot;' }) 值格式：因为 DefinePlugin 直接做的文本替换,给定的值必须包含字符串本身内的实际引号。比如:‘“production”’, 或者使用 JSON.stringify(‘production’) 建格式：键值都是一个标志符或者多个用 . 连接起来的标志符 注意前面的 key 也要加单引号 4.2. 如何调用变量在其他 js 里，就可以直接使用，比如： 123import process from &quot;process&quot;;const env = PROCESS.ENVIRONMENT;console.log(PROCESS.ENVIRONMENT); 对于 webpack5 需要安装 process 包, 并在调用前 import process 包 4.3. 如何结合操作系统环境变量或命令行参数首先我们要将定义环境变量的做一些修改, 如下 12345new webpack.DefinePlugin({ 'PROCESS.VERSION': JSON.stringify( '1.0.0'), 'PROCESS.APIURL': JSON.stringify(process.env.APIURL || 'http://localhost'), 'PROCESS.ENVIRONMENT': '&quot;dev&quot;' }) 这样我在命令行传入的参数, 就可以传递给 PROCESS.APIURL, 这样我在整个项目得编译阶段就可以使用该环境变量了可以这样传 1webpack --env.APIURL=http://dev.example.com --config webpack.config.dev.js 或者使用 cross-env 传递参数 1cross-env APIURL=http://dev.example.com npx webpack --config webpack.config.dev.js 5. 参考文档webpack.DefinePlugin 使用介绍 Passing the NODE_ENV value using Webpack via DefinePluginHow to use environment variables with Webpack 使用环境变量 webpack 设置和获取命令行动态传参的 4 种方法","link":"/webpack/webpack_env_variables.html"},{"title":"chocolatey安装和使用","text":"1. 什么是 ChocolateyChocolatey 是一种软件管理解决方案，不同于您在 Windows 上体验过的任何解决方案。 可以这样想 - 您使用一个小 PowerShell 创建一个软件部署包，然后您可以将它部署到任何拥有 Windows 的地方（例如 Puppet、SCCM、Altiris、Connectwise Automate 等)。 2. 为什么要安装 chocolatey?2.1. chocolatey 需要解决的问题我们经常听说管理 Windows 软件可能是一种令人沮丧或耗时的体验。 此外，各团队可能有一些自动化安装 windows 软件的方法方法，但是互相之间存在很多差异。 即使较新的自动化运维 (DevOps) 和配置管理工具仍然不能以简单且可维护的方式完全解决 Windows 软件管理问题。各种 windows 软件管理方法共同的挑战包括: 时间: 人工安装软件是耗时和低效地. 复杂性: 在当今的 IT 环境下, 传统的安装工具显得太复杂低效率 成本: 在没有标准包管理的情况下部署和管理 Windows 软件会导致额外的开销. 为了解决以上问题, chocolatey 应运而生, 将成为安装包管理软件中最好的选择. 3. 为什么选择 chocolatey3.1. 简化复杂流程，节省时间和精力虽然市面上有许多不同的安装程序格式和多种部署 Windows 软件的方法。 在 Windows 上部署没有包管理的软件可能既复杂又耗时。系统工程师可能会花费数小时手动部署和配置 Windows 软件。 传统工具不是为现代自动化和 DevOps 方法构建的，这可能会使在整个环境中实现一致性和可观测性变得困难。Chocolatey 通过简单、可重复和自动化的方法简化了这一过程，使用通用包装格式 Nuget 来管理 Windows 软件的所有方面。 无论您是管理本机安装程序、zip、脚本、运行时二进制文件还是内部开发的应用程序，Chocolatey 都将它们视为一等公民，并为您提供一致、统一的软件管理方法！ 3.2. 一次编写，随处部署，随心所欲，然后简单地跟踪和管理Chocolatey 的目标是在 Windows 操作系统上实现从安装到升级和卸载的整个软件生命周期的自动化。 我们的目标是通过一个统一的界面简化复杂的流程，让您可以控制混乱。Chocolatey for Business 允许组织采用 DevOps 方法来轻松管理您的 Windows 环境，更快、更可靠地向服务器和最终用户交付应用程序。 通过利用 PowerShell 提供自动化的软件管理指令，Chocolatey 的内置函数将复杂的任务变成了单行函数调用。 4. Chocolatey 特性4.1. Deploy Anywhere You Have Windows/Cloud Ready能部署到任何有 windows 的地方（除了 Nano）,包括 Server.Core 和 Windows Docker 容器。 Windows 7+/Windows 2003+。 需要 PowerShell v2+（不包括 PowerShell 6）和 Microsoft .NET Framework 4.x。 您可以在本地部署到 Azure、AWS 或您可能正在查看的任何云提供商。 4.2. Deploy with Everything (能和任何自动部署工具整合)任何可以管理节点或进行远程部署的东西都可以通过命令、批处理或脚本来使用 Chocolatey。 Ansible、Chef、PowerShell DSC、Puppet 或 Salt 等完整配置管理解决方案通常具有提供程序/模块，允许您使用它们的语言来管理 Chocolatey 安装/配置和软件。 4.3. All Software Is a First Class Citizen您知道对于大多数软件安装器来说，他们只管理已经安装的软件的添加和删除, 而 Chocolatey 把这一切都考虑进去了，因为 Windows 软件不仅仅是安装程序，而且要考虑软件的安全。 因此，只需一个简单的解决方案即可部署您的安装程序、脚本、zip、运行时二进制文件以及内部软件。 然后依靠报告和软件库信息来了解您正在管理的软件的所有方面。 5. Chocolatey 安装前提条件5.1. 安装要求Chocolatey 对内存的要求比较低. 对系统的要求: Windows 7 以上或者 Windows 2003+ (Server Core 也包括在内, 但是不包括 Windows Nano Server); 需要已经安装 Windows PowerShell v2+ (PowerShell Core aka PowerShell 6 暂且不被支持);.NET Framework 4.x 以上; 空间要求 Chocolatey CLI 对默认安装大概为 15 MB 左右。 Chocolatey GUI 在默认安装中占用另外 50-100 MB 的空间。 Chocolatey Agent 大约需要 10 MB。 5.2. Chocolatey 组成Chocolatey CLI 又名 choco（或 choco.exe）是一个客户端（不是 Windows 服务），它提供 Chocolatey 的核心和本地安装包的安装存储。 这点很重要，因为 Chocolatey 管理包，而不是直接管理程序和功能 - 程序和功能仅限于具有“安装程序”的软件，而 Chocolatey 将 Windows 软件的所有方面都视为一等公民（zip、脚本、二进制文件、安装程序），因此 它需要分别跟踪和管理这些东西。 Chocolatey GUI 是一个在用户运行时运行的应用程序（也不是 Windows 服务）。 Chocolatey Agent（又名 Chocolatey-agent）是 Chocolatey for Business 中提供的一项 Windows 服务。 它用于自助安装和 Chocolatey 中央管理。 6. 安装 Chocolatey安装 Chocolatey 有多种方法, 可以从以下方法中任选一种进行安装: 方法一：以管理员身份打开 cmd.exe（很重要），执行以下代码 1@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; 方法二：以管理员身份打开 powershell.exe,执行以下代码 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 方法三：直接打开https://chocolatey.org/install.ps1,复制内容到本地新建 install.psl 文件，执行安装。 在有的时候，因为电脑安装防火墙的原因，可能会导致前两个方法出现问题，但是方法三不存在此问题，最好用 powershell.exe 来执行 install.psl 脚本，可以看到安装的完整过程。 方法四: 以管理员身份打开 Powershell，然后输入以下命令： 123iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) 说明 iex（Invoke-Expression 的别名）：用来把字符串当作命令执行。 方法五: Chocolatey 的作者还专门为安装脚本创建了一个短网址。使用短网址安装更加简洁. 123iwr https://cin.st | iex 说明 iwr(Invoke-WebRequest 的别名): 用于从 Internet 上的网页获取内容。 7. Chocolatey 的使用 查看帮助 123456789# 查看Chocolatey自身的帮助信息choco -?# 查看Chocolatey子命令的帮助信息# 例如: choco search -?choco command -? 安装软件 123choco install something 安装指定版本 123choco install something --version x.y.z 查找软件 1choco search cntlm 如果不习惯命令行方式, 也可以在 chocolatey 官网查找软件包, 网站位于chocolatey packages 查找软件, 精确匹配软件名 1choco search -e cntlm 查找所有可用版本 1choco search --all -e cntlm 或者到官方网站上去搜索可用版本 搜索软件是否存在，包名是什么。 查看软件详细信息。 1choco info cntlm 列出 Windows 系统已安装的软件 1choco list -lo choco 配置列表 1choco config list 升级软件 1choco upgrade git 卸载软件 1choco uninstall git 7.1. 创建快捷方式通过 Chocolatey 安装的程序, 通常在 windows 搜索界面是不会显示的, 查找起来不方便, 此时需要到软件安装目录创建一个桌面快捷方式. 此时可以进入 ChocolateyInstall 指定的目录, 进入安装包所在目录, 右击可执行文件创建桌面快捷方式. 123# 查找安装包位置echo %ChocolateyInstall% 7.2. 安装 chocolatey 图形化管理工具12# 安装之后输入 chocolateygui 打开图形界面安装你想安装的软件即可choco install chocolateygui 7.3. 配置统一环境更改本地仓库方法一：cmd.exe 管理员模式下执行以下指令 setx ChocolateyInstall D:\\Chocolatey /M 方法二：powershell.exe 管理员模式下执行以下指令 &amp; setx.exe ChocolateyInstall D:\\Chocolatey /M 设定成功提示： search - searches remote or local packages (alias for list) list - lists remote or local packages find - searches remote or local packages (alias for search) info - retrieves package information. Shorthand for choco search pkgname –exact –verbose install - installs packages from various sources pin - suppress upgrades for a package outdated - retrieves packages that are outdated. Similar to upgrade all –noop upgrade - upgrades packages from various sources uninstall - uninstalls a package pack - packages nuspec, scripts, and other Chocolatey package resources into a nupkg file push - pushes a compiled nupkg to a source new - generates files necessary for a chocolatey package from a template source - view and configure default sources sources - view and configure default sources (alias for source) config - Retrieve and configure config file settings feature - view and configure choco features features - view and configure choco features (alias for feature) setapikey - retrieves, saves or deletes an apikey for a particular source (alias for apikey) apikey - retrieves, saves or deletes an apikey for a particular source unpackself - re-installs Chocolatey base files version - [DEPRECATED] will be removed in v1 - use choco outdated or cup &lt;pkg|all&gt; -whatif instead update - [DEPRECATED] RESERVED for future use (you are looking for upgrade, these are not the droids you are looking for) support - provides support information help - displays top level help information for choco export - exports list of currently installed packages download - downloads packages - optionally internalizing all remote resources synchronize - synchronizes against system installed software - generates missing packages sync - synchronizes against system installed software - generates missing packages optimize - optimizes installation, reducing space usage 8. 关联阅读chocolatey 安装和使用 Windows 下搭建 WSL Linux 开发环境 cygwin install and configuration Cmder 安装与配置 Win11 怎么把软件添加到开机自启动中 9. 参考文档https://blog.csdn.net/m0_49183941/article/details/107482650","link":"/windows/chocolatey_installation.html"},{"title":"Cmder安装与配置","text":"1. 前言相信很多开发者都在寻找一款在Windows下理想的命令行工具, 因为Windows10包括10之前自带的命令行工具真的是弱爆了, 而且它20多年都不曾经发生过太大的改变. 这种状况在应用软件快速发展的时代对很多人来说是不能忍受的, 即使在Windows 11中自带了一个叫terminal的工具, 虽然很强大但是我仍然没有打算使用它, 请容许我大胆的臆测一下它, 可能是因为WSL推出后微软实在觉得之前命令行工具太过简陋, 然后推出了Windows Powershell, 但是powershell还是难堪大任, 于是模仿市面上流行的终端推出了, terminal这样一款命令行工具. 至于之后会不会跟CMD一样数十年不再改进? 需要打一个大大的问号. 即使在Window 11已经捆绑了一种Terminal终端工具的前提下, 我还是详细专业的事情还是要交给专业的人去做, 一群对终端有追求的人才能打造一款极致的终端工具. 所以我选择Cmder这样一款命令行工具. 为什么选择Cmder? 我选择的软件的标准, 首先需要考虑的一点是它是开源的还是闭源的. 并不是说闭源的不考虑, 同等需求下, 如果有开源软件能满足条件, 首先考虑开源软件. 如果没有开源的方案再从闭源软件中选择. 出发点主要是开源软件的生命力更顽强, 软件生命周期更长, 而且它可以凝聚更多人的智慧. 人生苦短, 我选择开源. 虽然如此, 日常工作生活中我也不排斥闭源软件, 比如Jetbrains系列, MS Excel, Outlook, Teams, Power Pointer, Skype, Wechat, QQ Music等等. Cmder源代码托管在github上, 这里是它的代码仓库-cmder. 其次要考虑是否满足需求? 这一点也可以表示为为什么我对某一款自带的, 容易获得的软件不满. 首先要支持支持tab分页、同屏多端口, 支持自定terminal，无论是CMD、PowerShell、bash都可以. 绿色软件, 解压就可以使用, 不需要管理员权限. 最好有丰富的颜色主题, 可以替换为喜欢的皮肤. 字符集可调整, 兼容尽可能多的字符集, 不要出现显示乱码, 最好能智能选择字符集. 2. 问题排查 问题1 : 1237zip or Winrar not found! Not installed? 原因: Cmder在更新时, 需要用到解压工具, 默认为7zip或者Winrar, 当检查到更新, 但是没有找到解压工具, 就会弹出此种错误. 解决办法: 在settings-&gt;general -&gt; update 将解压工具设置为本机安装的解压工具, 或者停止自动检测更新即可. 停止自动检测的方法 将do automatic check on 这一项上的钩钩都取消掉. 3. 关联阅读chocolatey安装和使用 Windows下搭建WSL Linux开发环境 cygwin install and configuration Cmder安装与配置 Win11怎么把软件添加到开机自启动中","link":"/windows/cmder_install_configuration.html"},{"title":"cygwin install and configuration","text":"1. cygwin 介绍Cygwin 是一个在 windows 平台上运行的类 UNIX 模拟环境，是 cygnus solutions 公司开发的自由软件（该公司开发的著名工具还有 eCos，不过现已被 Redhat 收购）。它对于学习 UNIX/Linux 操作环境，或者从 UNIX 到 Windows 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 GNU 工具集在 Windows 上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对 Cygwin 产生了兴趣Cygwin 提供一个 UNIX 模拟 DLL 以及在其上层构建的多种可以在 Linux 系统中找到的软件包，在 Windows XP SP3 以上的版本提供良好的支持。Cygwin 主要由 Red Hat 及其下属社区负责维护。 2. 安装2.1. 下载安装文件下载 Cygwin 可以到它的官方网站下载. 有32 位的安装程序和64 位的安装程序,本教程使用的是 64 位的安装程序. 2.2. 开始安装 下载完安装程序后,双击安装程序 setup-x86_64.exe 进行安装. 当安装到 Choose a download source 的时候 如果是首次安装选择 install from internet 如果以前安装过已经安装过并且之前下载的 package 还存在,可以选择 install from Local Directory 当安装 Select Root Install Directory 时 选择 root Directory, 这个 root directy 即相当于 linux 的根目录(/) install for 推荐选择 for all 当安装到 select local package Directory 时 选择一个 local 目录, 这个目录是用来保存从 internet 上下载的包,应用程序,dll 等等的, 作为前面 download source 下载的本地缓存 建议每次都使用相同的 local 目录, 避免反复从 internet 下载必须的包. 当安装到 Choose A Download site 时 可以选择一个国内的镜像站点, 网速较快, 比如网易镜像https://mirrors.163.com, 阿里云镜像 https://mirros.aliyun.com, 中科大镜像https://mirros.ustc.edu.cn/, 东软信息学院https://mirrors.neusoft.edu.cn/, 上海交通大学 https://mirros.sjtug.sjtu.edu.cn 其他可以使用默认值 安装过程首先会去镜像站点下载软件包列表, 软件包列表下载完成后, 会弹出选择框允许让用户绝对选用安装哪些额外的 package 有些额外的包比如 ssh, curl, wget, expect, tmux 不在默认安装列表中, 建议手动勾选进行安装. 一切设定完成后,程序开始下载 package, 并缓存在 local package directory 以备以后重用, 以及立即执行安装过程. 3. 如何通过 tar 包安装额外程序有些程序在镜像站点上无法找到, 但是存在可用的 tar 包, 那么可用把 tar 包下载到本地, 然后打开 cygwin 使用 cygwin 默认安装的解压程序进行安装. 4. 关联阅读chocolatey 安装和使用 Windows 下搭建 WSL Linux 开发环境 cygwin install and configuration Cmder 安装与配置 Win11 怎么把软件添加到开机自启动中 5. 参考文档Tmux in Cygwin","link":"/windows/cygwin-install-and-configuration.html"},{"title":"Win11怎么把软件添加到开机自启动中","text":"1. 前言把程序设置为开机自启或取消一些开机自选项, 对我个人来说是一个很重要的功能, 因为它能提高我的专注力. 很多时候, 我们容易被一些琐碎的事情给诱惑.不知道大家有没有仔细观察或回味自己使用电脑的习惯. 根据我以前的经验, 按下开机键后, 经过一个不算漫长的等待, 真正进入 windows 界面后, 我们往往会短暂的忘记或刻意的不想把注意力集中到我们开机前想干的事情上. 开机后往往第一件事查看一下邮件, 检查一下聊天软件上的, 看看今天都发生了哪些新闻. 等这些事情完成后, 才会或者才可能想起我们开机前想要干的事情.如果这段时间中再弹个窗, 提示软件需要杀毒, 升级某娱乐明星又爆出了什么大瓜, 某电视剧又更新到多少级了, 一断被这些信息给吸引了, 对于自制力不强的人们来说,今天这一天可能就尽是去打蚊子拍苍蝇去了, 一天又荒废了. 而将重要的应用程序放置在开机启动项，并在开机后直接弹出应用界面，可以让我们立即专注到重要事情，并有效缓解注意力被分散的状况。 而此时有一个干净高效的自启动项设置, 往往有助于屏蔽这些干扰, 或提醒自己该干正事了. 2. 如何设置开机启动 首先要创建一个程序启动的快捷方式, 可找到程序所在位置, 右击程序在弹出的快捷方式中选择创建桌面快捷方式. 这一步的的目的不是为了创建桌面快捷方式, 而是为了获得一个桌面快捷方式, 一旦完成可以将快捷方式删除. 将快捷方式拷贝到 windows 的开机启动项. 开机项位置位于C:\\Users\\&lt;user_name&gt;\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 3. 如何删除开启启动项目开机启动项主要位于两个位置, 一个是上一节讲到的用户的开机启动项. 打开启动项位置后, 将启动项删除即可. 还有一个是系统开机启动项目, 位置位于设置-&gt;应用-&gt;启动, 将不需要删除的项目关闭即可 4. 后记Windows 能把自动开机启动做得如此的隐蔽和不方便, 都值得写一篇文章来介绍, 也是着实是不容易呀, 不知道他们是怎么想的. 5. 关联阅读chocolatey 安装和使用 Windows 下搭建 WSL Linux 开发环境 cygwin install and configuration Cmder 安装与配置","link":"/windows/windows_prog_autostart.html"},{"title":"Windows下搭建WSL Linux开发环境","text":"1. 前言WSL（Windows Subsyetem for Linux，适用于 Linux 的 Windows 子系统），是 Microsoft 公司于 2016 年在 Windows 10 平台发布的一项新功能，其使得用户可以在 Windows 操作系统上运行 ELF 格式的 Linux 可执行文件。 WSL 目前已发布两代产品：WSL 1 和 WSL 2。WSL 1 实现了 Linux 兼容层，将 Linux 系统调用转换为 Windows NT 系统调用；而 WSL 2 则利用 Windows 的 Hyper-V 功能，通过虚拟化技术直接运行 Linux 虚拟机，更接近原生 Linux 操作系统体验。 2. 前提条件您必须运行 Windows 10 版本 2004 及更高版本（Build 19041 及更高版本）或 Windows 11 才能使用以下命令。如果您使用的是早期版本，请参阅手动安装页面。 3. 开启 WSL 特性和虚拟机特性以管理员身份打开 powershell, 开启 WSL 特性, 启动虚拟机 在安装 WSL 之前，首先运行以下命令来确认是否已启用“适用于 Linux 的 Windows 子系统”： 命令输出State : Disabled 表示未启用 12345678910111213141516PS C:\\Windows\\system32&gt; Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-LinuxFeatureName : Microsoft-Windows-Subsystem-LinuxDisplayName : 适用于 Linux 的 Windows 子系统Description : 提供服务和环境以在 Windows 上运行本机用户模式 Linux shell 和工具。RestartRequired : PossibleState : DisabledCustomProperties : ServerComponent\\Description : 提供服务和环境以在 Windows 上运行本机用户模式 Linux shell 和工具。 ServerComponent\\DisplayName : 适用于 Linux 的 Windows 子系统 ServerComponent\\Id : 1033 ServerComponent\\Type : Feature ServerComponent\\UniqueName : Microsoft-Windows-Subsystem-Linux ServerComponent\\Deploys\\Update\\Name : Microsoft-Windows-Subsystem-Linux 开启 WSL 特性, 123456789101112PS C:\\Windows\\system32&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart部署映像服务和管理工具版本: 10.0.22000.653映像版本: 10.0.22000.2295启用一个或多个功能[==========================100.0%==========================]操作成功完成。 开启虚拟机特性 12345678910PS C:\\Windows\\system32&gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart部署映像服务和管理工具版本: 10.0.22000.653映像版本: 10.0.22000.2295启用一个或多个功能[==========================100.0%==========================]操作成功完成。 开启新特性后需要重启电脑 4. 安装 Linux 内核更新包下载并安装 Linux 内核更新包 如果处理器是 x64 架构的选择: Linux 内核更新包 x64 如果处理器是 ARM 架构，Linux 内核更新包 arm64 下载后双击安装, 安装包有五百多兆, 安装需要一些时间. 将 WSL2 设置为默认的 WSL 123wsl --set-default-version 2 5. 安装 Ubuntu打开 Windows store 搜索 Unbuntu 点击安装(Get) 安装完成后点击打开, 如果你关闭了 windows store 界面, 也可以在开始菜单搜索 ubuntu 并打开. 首次打开需要进行初始化, 初始化需要一些时间, 等待初始化完成. 初始化完成后需要设置用户名密码; 设置完用户名密码, 就可以使用 Ubuntu 了. 至此 Ubuntu 安装就算安装完成了. 我也准备了一些关于使用 linux 的文章, 内容包括安装各类开发软件, 数据库等等方面, 有兴趣的同学可以访问鹏叔的技术博客 - linux 专题. 6. 使用 WSL 管理虚拟机WSL 的底层技术实际是 Micrsoft hyper-v, 一款虚拟机管理软件, 类似 wmware 和 virtualbox, 和 linux 平台的 kvm. wsl 就是管理虚拟机的命令行工具(command line interface). 在 Powershell 下面还可以对 Linux 进行一些管理工作, 例如生成快照, 恢复快照, 启动虚拟机, 关闭虚拟机. 以普通用户身份打开 Powershell 1234567891011121314151617181920212223242526272829303132333435363738# 查看当前已安装的linux子系统以及状态wsl --list --verbose# 查看可安装的Linux版本wsl --list --online# wsl镜像导出wsl --export &lt;发行版名称&gt; &lt;导出的文件名&gt;# 例如wsl --export ubuntu c:\\tmp\\ubuntu.tar# 镜像导入# 语法wsl --import &lt;发行版名称&gt; &lt;安装位置&gt; &lt;tar 文件名&gt;# 例如wsl --import ubuntu-copy c:\\users\\yourname\\ubuntu c:\\tmp\\ubuntu.tar# 安装不同的linux发行版, 以Debian为例wsl --install -d Debian# 关闭linux子系统, 以ubuntu为例wsl --terminate ubuntu# 运行特定的 Linux 发行版，请将 &lt;Distribution Name&gt; 替换为目标发行版的名称wsl --distribution &lt;Distribution Name&gt; --user &lt;User Name&gt;# 注销（卸载）当前安装的Linux的Windows子系统, 以ubuntu为例wsl --unregister Ubuntu# 终止所有 WSL 实例和 WSL 2 轻量级实用工具虚拟机wsl --shutdown# 查找 Linux 发行版的 .vhdx文件和磁盘路径# 若要查找 Linux 分发版的 .vhdx 文件和目录路径，请打开 PowerShell 并使用以下命令，将 &lt;distribution-name&gt; 替换为实际的Linux发行版名称：(Get-ChildItem -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss | Where-Object { $_.GetValue(&quot;DistributionName&quot;) -eq &lt;distribution-name&gt; }).GetValue(&quot;BasePath&quot;) + &quot;\\ext4.vhdx&quot; 7. 安装 WSLg(可选)Windows Subsystem for Linux GUI 是在 WSL 中使用 Linux 图形界面程序的一种方式，可以在 WSL 中任意使用 Linux 的图形界面程序。 WSLg 需要电脑已经安装了 WSL 2 内核组件。 查看本机的显卡品牌: 按 Ctrl+alt+delete，打开任务管理器，进入“性能”，查看“GPU”，记住右上角显示的 GPU 厂家。支持该功能的显卡厂商必须是 Intel、AMD 和 NVIDIA 中的一个。 安装虚拟显卡驱动 进入 https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps#prerequisites，安装适合自己的 GPU 的虚拟显卡驱动，并重启电脑。 更新 wsl 内核版本 使用管理员 / Administrator 身份或 Administrator 用户打开 cmd 或 powershell，运行： 1wsl --update 如果有更新，等待更新完成，然后运行： 1wsl --shutdown 将 WSL 2 关机以重启 检查是否安装成功 打开自己的 WSL 2，任意寻找一款 GUI 程序（例如 gedit），观察是否能够启动成功（每次开机初次启动可能会有较长的冷启动时间，需要耐心等待）。 以 gedit 为例，执行： 123&gt; sudo apt update -y&gt; sudo apt install -y gedit&gt; gedit 8. troubleshooting 问题 1: WslRegisterDistribution failed with error: 0x80370102 出现这个问题的原因是没有开启 windows 虚拟机特性, 开启虚拟机特性并重启即可解决问题. 12# 开启虚拟机特性dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 问题 2: 执行命令 wsl --list --online 时报错”无法解析服务器的名称或地址” 原因: 这个问题是由于安装包地址被墙了的缘故，最终的解决方案，具体原因参考wsl.exe –list –online 报错:无法解析服务器的名称或地址 解决办法:可以到https://ipaddress.com这个网站上找到 raw.githubusercontent.com 对应的 ip 地址, 在你电脑上 ping 查到的地址 -t，看哪个地址能连接上. 例如: 185.199.108.133 可以 ping 通, 接下来设置本地解析. 修改 C:\\Windows\\System32\\Drivers\\etc\\hosts, 在在 hosts 中增加： 1185.199.108.133 raw.githubusercontent.com 问题 3: 当再次进入 linux 时出现”适用于 Linux 的 Windows 子系统实例已终止” 解决办法: 重启 LxssManager 服务;管理员模式打开终端，输入 123456#停止LxssManager服务net stop LxssManager#启动LxssManager服务net start LxssManager 9. 关联阅读chocolatey 安装和使用 Windows 下搭建 WSL Linux 开发环境 cygwin install and configuration Cmder 安装与配置 Win11 怎么把软件添加到开机自启动中 10. 参考文档使用 Windows 构建高效的 Linux 开发环境 solve 0X80370102 How to install Linux on Windows with WSL Manual installation steps for older versions of WSL WSL 安装与使用 WSL 2 的安装过程（以及介绍）","link":"/windows/wsl_install.html"},{"title":"Vultr 部署 Wordpress 博客","text":"昨天我获得了 Vultr.com 300 美金的试用金，限期 1 个月。 这两天一直在琢磨如何把这 300 美金霍霍完，免得过期浪费。于是把之前一些好玩的东西从家里的服务器迁移到了 Vultr 上，昨天用 Vultr vps 搭建了一个了一个 WEB IDE, 过程记录在这篇文章里Vultr + Code-server 自建 Cloud IDE。 Vultr 账号申请以及创建VPS过程参考这篇文章 快速注册 Vultr 账号以及创建 Vultr VPS。 今天用 Vultr vps 结合 wordpress 搭建了一个动态博客网站（当然 wordpress 不只是能搭建博客这么简单）， 顺便将之前的文章更新了一遍。以下是搭建的全过程。 明天打算将 kubernetes 集群也搬上 Vultr，关注我的博客，鹏叔将利用这波优惠，继续探索一些新花样。 1. 搭建 wordpress 网站先决条件一台 VPS 或虚拟机，VPS 获取过程可参考快速注册 Vultr 账号以及创建 Vultr VPS 好处申请后是 80 端口是开放的，免费送两个公网IP, 一个IPv4的，一个IPv6，再也不用做内网穿透了那么麻烦了，搭建完成后做一下 DNS 绑定，网站就是上线了。 操作系统建议安装: AlmaLinux OS 9。系统权限：用户有 sudo command 权限。 2. 登录到Vultr VPS123# 登陆主机，ipv6_address为创建主机后获得的ip地址ssh linuxuser@ip_address 3. 更新 DNF 存储库缓存安装 wordpress 之前，更新一下 DNF 缓存 123sudo dnf update 4. 安装要求安装 WordPress 之前，服务器要求具备两个基本元素： PHP 版本: 7.4 或更高版本 MySQL 数据库: 版本: MySQL 5.7 or MariaDB version 10.3 5. 安装 PHP 和 PHP 扩展安装 PHP 和其他支持包，请运行以下命令： 123sudo dnf install -y php php-curl php-bcmath php-gd php-soap php-zip php-mbstring php-mysqlnd php-xml php-intl php-zip 验证 php 是否安装成功, 要验证已安装的 PHP 版本，请运行以下命令： 123php -v 输出如下： 123456PHP 8.0.30 (cli) (built: Aug 3 2023 17:13:08) ( NTS gcc x86_64 )Copyright (c) The PHP GroupZend Engine v4.0.30, Copyright (c) Zend Technologies with Zend OPcache v8.0.30, Copyright (c), by Zend Technologies 配置 php-php-fpm, 由于我们将使用 nginx 作为 web 服务器，而 php-fpm 默认的是 apache 服务器， 所以需要将 php-fpm 的默认用户和组修改为 nginx 修改 run-as 用户为 nginx 与 nginx web server 保持一致避免后面 upload 文件出现权限问题. sudo vi /etc/php-fpm.d/www.conf 123456789; Unix user/group of processes; Note: The user is mandatory. If the group is not set, the default user's group; will be used.; RPM: apache user chosen to provide access to the same directories as httpduser = nginx; RPM: Keep a group allowed to write in log dir.group = nginx 设置开机启动并运行 php-fpm 服务 123systemctl enable --now php-fpm 6. 安装 mariaDB在 AlmaLinux 9 上安装 mariaDB 可以参考在Linux（AlmaLinux 9）上安装MariaDB | 鹏叔的技术博客 安装完成后创建 wordpress 数据库 要登录 MariaDB shell，请运行以下命令。然后系统将提示您输入 MariaDB root 密码： 1sudo mysql -u root -p 要创建数据库和数据库用户，请运行以下命令。记得将 DB_password 替换为强大而安全的密码： 12CREATE DATABASE wordpress_db;CREATE USER 'wordpress_user'@'localhost' IDENTIFIED BY 'DB_password'; 然后，运行以下命令授予并刷新数据库用户所有权限： 12GRANT ALL ON wordpress_db.* TO 'wordpress_user'@'localhost';FLUSH PRIVILEGES; 您还可以用您的数据库详细信息替换 wordpress_db 和 wordpress_user 。 要退出 MySQL 命令提示符，请运行以下命令： 1exit 输出如下： 123456789101112131415161718192021222324~]# sudo mysql -u root -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 8Server version: 10.3.35-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; CREATE DATABASE wordpress_db;Query OK, 1 row affected (0.000 sec)MariaDB [(none)]&gt; CREATE USER 'wordpress_user'@'localhost' IDENTIFIED BY 'DB_password';Query OK, 0 rows affected (0.000 sec)MariaDB [(none)]&gt; GRANT ALL ON wordpress_db.* TO 'wordpress_user'@'localhost';Query OK, 0 rows affected (0.000 sec)MariaDB [(none)]&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.000 sec)MariaDB [(none)]&gt; exitBye 数据库用户名，密码后续要用到。 7. 安装 wordpress下载 wordpress 123456# 下载最新版本的wordpress使用wget -O /tmp/wordpress-latest.zip https://wordpress.org/latest.zip# 下载指定版本的wordpress使用，点击这里查看历史版本# https://wordpress.org/download/releases/wget -O /tmp/wordpress-&lt;version&gt;.zip https://wordpress.org/wordpress-&lt;version&gt;.zip 解压缩 123sudo unzip -d /var/www /tmp/wordpress-latest.zip 并将/var/www/wordpress 的 owner 修改为 nginx 1sudo chown -R nginx:nginx /var/www/wordpress 修改 wordpress 配置文件 12345sudo cp /var/www/wordpress/p-config-sample.php /var/www/wordpress/wp-config.phpsudo vi /var/www/wordpress/wp-config.php 123456789101112131415...define('DB_NAME', 'wordpress_db');/** MySQL database username */define('DB_USER', 'wordpress_user');/** MySQL database password */define('DB_PASSWORD', 'DB_password');...define('FS_METHOD', 'direct'); 修改wp-config.php的owner 1234chown nginx:nginx /var/www/wordpress/wp-config.php 将配置文件里面的这一部分删除 123456789101112define('AUTH_KEY', 'put your unique phrase here');define('SECURE_AUTH_KEY', 'put your unique phrase here');define('LOGGED_IN_KEY', 'put your unique phrase here');define('NONCE_KEY', 'put your unique phrase here');define('AUTH_SALT', 'put your unique phrase here');define('SECURE_AUTH_SALT', 'put your unique phrase here');define('LOGGED_IN_SALT', 'put your unique phrase here');define('NONCE_SALT', 'put your unique phrase here'); 8. 安装 nginx安装 nginx 可以参考我的博客Almalinux 9 nginx 安装教程 9. 配置 nginx修改 /etc/nginx/conf.d/wordpress.conf, 新建一个 server 或在已有 server 基础上修改如下 123sudo vi /etc/nginx/conf.d/wordpress.conf 1234567891011121314151617181920212223242526272829303132333435363738server { listen 80; server_name localhost; root /var/www/wordpress; index index.html index.htm index.php; location / { try_files $uri $uri/ /index.html index.php; } location ~ \\.php$ { include fastcgi_params; fastcgi_pass unix:/run/php-fpm/www.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location = /favicon.ico { log_not_found off; access_log off; } location = /robots.txt { allow all; log_not_found off; access_log off; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log_not_found off; }} nginx 与 php 的协作机制以及 nginx 参数的详细讲解, 请参考Nginx 和 PHP 的配置 使配置生效: 1234567nginx -s reload# 或者 重启nginxsystemctl restart nginx 如果一切顺利的话, 重启后即可打开浏览器访问 wordpress 网站了 如果出现问题, 可以查看 nginx 的访问日志和错误日志以及 php-fpm 的相关日志 nginx 的日志位于 /var/login/nginx php-fpm 的日志位于/var/log/php-fpm 10. WordPress 安装向导最后，打开 Web 浏览器并输入安装 WordPress 的服务器的域名，例如http://your-server-ip-address或http://your-domain.com。 输入您创建的数据库详细信息。然后单击“提交”按钮。 然后选择一个主题，安装一些插件，就可以慢慢将自己的博客搭建起来了。 11. 相关文章更多 linux 相关知识, 请参考鹏叔的技术博客 - linux, 获取实时更新的博客文章. 12. 参考文档Centos7 上安装 wordpress How to Install WordPress on Linux (AlmaLinux) BuddyPress 安装指南 建站教程（三）：在 Ubuntu 上配置 Nginx+MySQL+PHP7 如何在 CentOS 7 上安装使用 Nginx 的 WordPress Nginx 和 PHP 的配置 CentOS7 安装和配置 ftp 服务,ftp 命令详解","link":"/wordpress/deploy_wordpress_on_vps.html"},{"title":"Centos7 上安装 wordpress","text":"1. 前言当前环境说明: OS: Centos 7.9 2. 安装要求安装 WordPress 之前，服务器要求具备两个基本元素： PHP 版本: 7.4 或更高版本 MySQL 数据库: 版本: MySQL 5.7 or MariaDB version 10.3 数据库用以存储所有 BuddyPress 数据 如果没有已创建的数据库，可以创建一个用户具有所有权限（比如说更新、插入、删除、选择）的数据库。 记住系统提供的用户名/密码以及数据库名称。 3. 安装 PHP为什么要安装 php73 在不更新 yum 源的情况下, centos7 上能安装的 php 为 5.4 版本, 目前已经与最新版本的 wordpress(目前是 6.2.2 版本)不兼容, 是用旧版本会遇到 php 文件无法正确解析的情况, 所以需要安装新版的 php, 经测试 php73 是一个被较好兼容的版本. 安装 REMI yum 源 12345# CentOS 7yum install -y http://rpms.remirepo.net/enterprise/remi-release-7.rpm# CentOS 6yum install -y http://rpms.remirepo.net/enterprise/remi-release-6.rpm 安装 PHP 软件 1yum install -y php73-php-fpm php73-php-cli php73-php-bcmath php73-php-gd php73-php-json php73-php-mbstring php73-php-mcrypt php73-php-mysqlnd php73-php-opcache php73-php-pdo php73-php-pecl-crypto php73-php-pecl-mcrypt php73-php-pecl-geoip php73-php-recode php73-php-snmp php73-php-soap php73-php-xmll 查看 php 是否安装成功 12345$php73 -vPHP 7.3.33 (cli) (built: Feb 14 2023 14:26:12) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies 配置 php73-php-fpm 修改 run-as 用户为 nginx 与 nginx web server 保持一致避免后面 upload 文件出现权限问题. vi /etc/opt/remi/php73/php-fpm.d/www.conf 123456789; Unix user/group of processes; Note: The user is mandatory. If the group is not set, the default user's group; will be used.; RPM: apache user chosen to provide access to the same directories as httpduser = nginx; RPM: Keep a group allowed to write in log dir.group = nginx 设置开机启动、运行服务 1234systemctl enable php73-php-fpmsystemctl start php73-php-fpm 4. 安装 mariaDB在 centos 上安装 mariaDB 可以参考鹏叔的技术博客 安装完成后创建一个新的 wordpress 数据库 123CREATE DATABASE wordpress 5. 下载 wordpress下载 12cd /tmpwget https://wordpress.org/latest.zip 解压缩 123unzip -d /var/www /tmp/latest.zip 并将/var/www/wordpress 的 owner 修改为 nginx 1chown -R nginx:nginx /var/www/wordpress 6. 安装 nginx安装 nginx 可以参考我的博客nginx 安装教程 7. 配置 nginx修改 /etc/nginx/conf.d/default.conf, 新建一个 server 或在已有 server 基础上修改如下 12345678910111213141516171819server { listen 80; server_name localhost; root /var/www/wordpress; location / { index index.php index.html index.htm; } location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }} nginx 与 php 的协作机制以及 nginx 参数的详细讲解, 请参考Nginx 和 PHP 的配置 使配置生效: 1234567nginx -s reload# 或者 重启nginxsystemctl restart nginx 如果一切顺利的话, 重启后即可打开浏览器访问 wordpress 网站了 如果出现问题, 可以查看 nginx 的访问日志和错误日志以及 php-fpm 的相关日志 nginx 的日志位于 /var/login/nginx php-fpm 的日志位于/var/log/php-fpm 8. 相关文章更多 linux 相关知识, 请参考鹏叔的技术博客 - linux, 获取实时更新的博客文章. 9. 参考文档BuddyPress 安装指南 建站教程（三）：在 Ubuntu 上配置 Nginx+MySQL+PHP7 如何在 CentOS 7 上安装使用 Nginx 的 WordPress Nginx 和 PHP 的配置 CentOS7 安装和配置 ftp 服务,ftp 命令详解","link":"/wordpress/install_buddypress.html"}],"tags":[{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Gemini AI","slug":"Gemini-AI","link":"/tags/Gemini-AI/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"angularjs","slug":"angularjs","link":"/tags/angularjs/"},{"name":"material design","slug":"material-design","link":"/tags/material-design/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"pagination","slug":"pagination","link":"/tags/pagination/"},{"name":"Astro","slug":"Astro","link":"/tags/Astro/"},{"name":"Comments","slug":"Comments","link":"/tags/Comments/"},{"name":"Giscus","slug":"Giscus","link":"/tags/Giscus/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Ansible","slug":"Ansible","link":"/tags/Ansible/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"MariaDB","slug":"MariaDB","link":"/tags/MariaDB/"},{"name":"Almalinux","slug":"Almalinux","link":"/tags/Almalinux/"},{"name":"pgadmin","slug":"pgadmin","link":"/tags/pgadmin/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"source_control","slug":"source-control","link":"/tags/source-control/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"firefox","slug":"firefox","link":"/tags/firefox/"},{"name":"gitlab","slug":"gitlab","link":"/tags/gitlab/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"swagger","slug":"swagger","link":"/tags/swagger/"},{"name":"GORM","slug":"GORM","link":"/tags/GORM/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Seo","slug":"Seo","link":"/tags/Seo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"Helm","slug":"Helm","link":"/tags/Helm/"},{"name":"fedora","slug":"fedora","link":"/tags/fedora/"},{"name":"virualbox","slug":"virualbox","link":"/tags/virualbox/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"Fedora","slug":"Fedora","link":"/tags/Fedora/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"NAS","slug":"NAS","link":"/tags/NAS/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"Vultr","slug":"Vultr","link":"/tags/Vultr/"},{"name":"design","slug":"design","link":"/tags/design/"},{"name":"Material","slug":"Material","link":"/tags/Material/"},{"name":"Matrix","slug":"Matrix","link":"/tags/Matrix/"},{"name":"element-web","slug":"element-web","link":"/tags/element-web/"},{"name":"v2rayA","slug":"v2rayA","link":"/tags/v2rayA/"},{"name":"v2ray","slug":"v2ray","link":"/tags/v2ray/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"TLS","slug":"TLS","link":"/tags/TLS/"},{"name":"Macos","slug":"Macos","link":"/tags/Macos/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Redhat","slug":"Redhat","link":"/tags/Redhat/"},{"name":"v2rayNG","slug":"v2rayNG","link":"/tags/v2rayNG/"},{"name":"v2rayN","slug":"v2rayN","link":"/tags/v2rayN/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"pnpm","slug":"pnpm","link":"/tags/pnpm/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"product","slug":"product","link":"/tags/product/"},{"name":"marketing","slug":"marketing","link":"/tags/marketing/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"strapi","slug":"strapi","link":"/tags/strapi/"},{"name":"CMS","slug":"CMS","link":"/tags/CMS/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"tailwindcss","slug":"tailwindcss","link":"/tags/tailwindcss/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"tauri","slug":"tauri","link":"/tags/tauri/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"vmware","slug":"vmware","link":"/tags/vmware/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"chartjs","slug":"chartjs","link":"/tags/chartjs/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"blog","slug":"blog","link":"/tags/blog/"}],"categories":[{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"android","slug":"OS/android","link":"/categories/OS/android/"},{"name":"angularjs","slug":"web/angularjs","link":"/categories/web/angularjs/"},{"name":"angular","slug":"web/angular","link":"/categories/web/angular/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"SEO","slug":"web/SEO","link":"/categories/web/SEO/"},{"name":"devops","slug":"devops","link":"/categories/devops/"},{"name":"browser","slug":"web/browser","link":"/categories/web/browser/"},{"name":"Astro","slug":"tools/Astro","link":"/categories/tools/Astro/"},{"name":"database","slug":"database","link":"/categories/database/"},{"name":"windows","slug":"OS/windows","link":"/categories/OS/windows/"},{"name":"ansible","slug":"devops/ansible","link":"/categories/devops/ansible/"},{"name":"docker","slug":"devops/docker","link":"/categories/devops/docker/"},{"name":"git","slug":"tools/git","link":"/categories/tools/git/"},{"name":"gitlab","slug":"devops/gitlab","link":"/categories/devops/gitlab/"},{"name":"postgresql","slug":"database/postgresql","link":"/categories/database/postgresql/"},{"name":"language","slug":"language","link":"/categories/language/"},{"name":"mariadb","slug":"database/mariadb","link":"/categories/database/mariadb/"},{"name":"hexo","slug":"tools/hexo","link":"/categories/tools/hexo/"},{"name":"javascript","slug":"web/javascript","link":"/categories/web/javascript/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"maven","slug":"tools/maven","link":"/categories/tools/maven/"},{"name":"k8s","slug":"devops/k8s","link":"/categories/devops/k8s/"},{"name":"linux","slug":"OS/linux","link":"/categories/OS/linux/"},{"name":"backend","slug":"backend","link":"/categories/backend/"},{"name":"material design","slug":"web/material-design","link":"/categories/web/material-design/"},{"name":"golang","slug":"language/golang","link":"/categories/language/golang/"},{"name":"IM","slug":"IM","link":"/categories/IM/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"nodejs","slug":"web/nodejs","link":"/categories/web/nodejs/"},{"name":"build tools","slug":"devops/build-tools","link":"/categories/devops/build-tools/"},{"name":"others","slug":"web/others","link":"/categories/web/others/"},{"name":"design","slug":"web/design","link":"/categories/web/design/"},{"name":"rust","slug":"language/rust","link":"/categories/language/rust/"},{"name":"CMS","slug":"web/CMS","link":"/categories/web/CMS/"},{"name":"css","slug":"web/css","link":"/categories/web/css/"},{"name":"tauri","slug":"web/tauri","link":"/categories/web/tauri/"},{"name":"java","slug":"language/java","link":"/categories/language/java/"},{"name":"typescript","slug":"language/typescript","link":"/categories/language/typescript/"},{"name":"components","slug":"web/components","link":"/categories/web/components/"},{"name":"html","slug":"web/html","link":"/categories/web/html/"},{"name":"vscode","slug":"tools/vscode","link":"/categories/tools/vscode/"},{"name":"build tools","slug":"web/build-tools","link":"/categories/web/build-tools/"},{"name":"vpn","slug":"network/vpn","link":"/categories/network/vpn/"},{"name":"dns","slug":"network/dns","link":"/categories/network/dns/"},{"name":"frp","slug":"network/frp","link":"/categories/network/frp/"},{"name":"v2ray","slug":"network/v2ray","link":"/categories/network/v2ray/"},{"name":"English","slug":"others/English","link":"/categories/others/English/"},{"name":"movies","slug":"others/movies","link":"/categories/others/movies/"},{"name":"marketing","slug":"others/marketing","link":"/categories/others/marketing/"}],"pages":[{"title":"","text":"435d23664caba1c1e000c1f56ecbab03","link":"/baidu_verify_codeva-1TKHma47RE.html"},{"title":"Angular合集","text":"Angular 样式隔离 Angular 17 有哪些更新? Angular 16 有哪些更新? Angular 15 有哪些更新? Angular 14 有哪些更新 使用Angular实现面包屑导航 Angular Flex Layout使用详解 Angular中的JIT与AOT 如何手动引导 Angular 应用程序 使用Angular制作Github pages网站 应用angular material design Angular Material 2 自定义主题 Angular Material 3 自定义主题 深度刨析@angular/platform-browser-dynamic Angular platform是什么? Angular如何配置多套环境 Angular实现登录保护 创建Angular项目 Angular guard介绍 Angular CLI 安装和使用 深度刨析NgModule Angular2中的路由 Angular Async Pipe详解 深入了解 Angular 异步管道 Angular async pipe中的异常处理 异步初始化MatPaginator 在TypeScript和Angular中使用Getter和Setter Angular上传图片 在Angular中使用async-await特性 Angular图表库介绍 Angular中使用forroot和forchild 自己动手写一个Angular 日志框架 如何在Angular应用中使用Ng2-charts 如何在Angular应用中使用Ngx-charts？ Angular结合quill实现富文本编辑器 Angular PWA Angular injectable接口 将ngx-datatable替换为Angular material table Angular sweetalert2 MDC-based Angular Material组件迁移 Angular service worker介绍 Angular universal服务器端渲染与预渲染 Angular SEO 友好的编码实践 使用mat-paginator在Angular mat表中进行服务器端分页 在Angular中使用TailwindCSS 使用Angular Universal时的重要注意事项 使用Gradle整合angular和Spring boot Angular应用如何使用百度统计 SEO教程 Angular Sentry前端错误监控 Angular独立组件介绍 如何替换 Angular 的CanActivate接口 webpack+angularjs1.x+bootstrap4.x开发环境配置 如何从Angularjs 升级到 Angular 从Angular 13升级到Angular 15 一步一步升级到Angular 17 一步一步升级到Angular 16","link":"/angular/"},{"title":"categories","text":"","link":"/categories/"},{"title":"backend","text":"1. 操作系统1.1. linux linux环境下创建rpm仓库 如何制作RPM安装包 Linux下安装gradle 在fedora35上安装virtualbox linux命令行连接wifi Linux文件目录结构详解 linux上ifconfig命令详解 linux上的rsync命令详解 Linux expect 详解 Msys2安装教程 CentOS7搭建NAS文件共享存储 使用Terraform在ESXI上创建虚拟机 Ubuntu服务器安装图形化界面 1.2. windows chocolatey安装和使用 cygwin install and configuration 2. 数据库2.1. PostgreSQL Linux上安装PostgreSQL PostgreSQL基础 PostgreSQL高级篇 从Mariadb迁移到postgresql PostgreSQL备份与恢复 2.2. mysql Centos7上安装MariaDB 3. Network frp内网穿透 使用WireGuard内网穿透 v2rayN 安装与配置 4. 容器技术4.1. k8s 创建kubernetes集群 5. 编程语言5.1. golang Golang 运算符 安装Golang 5.2. java JDK17安装 如何在springboot中配置多个数据源 如何手动创建一个springBoot项目 如何使用Maven结合IDEA进行Debug 如何通过表名获取所有字段信息 java实现websocket的五种方式 使用stomp实现服务器端向web客户端推送数据 5.3. rust Rust 编程语言入门教程 6. 软件工程化 gitlab安装升级及迁移 gitlab-runner安装与配置 破解Gitlab ee 15 企业版 GitLab集成PlantUML 使用gitlab issue board的四种方式 gitlab CICD基础","link":"/backend/"},{"title":"online TV","text":"Watch TV on Linux open a terminal and run the following command, then you will be able watch TV on linux 123456789# CGTN:totem https://ottrrs.hl.chinamobile.com/yinhe/88888888/224/3221225602/index.m3u8#CNN International:totem https://stream1.freetv.fun/6fc4928b85e47e1afd5807e1ac5bc63be0a770009d26c46905ddfd87d4bcc25a.m3u8","link":"/freeTV/"},{"title":"友情链接","text":".friends { display: flex; align-items: stretch; justify-content: space-between; flex-wrap: wrap; margin: -6px; } .friends .friend { margin: 6px; min-width: 240px; flex: 1; display: flex; align-items: center; justify-content: center; border-radius: 10px; border: 1px solid rgba(200, 200, 200, 0.2); background-color: rgba(200, 200, 200, 0.1); position: relative; } .friends .friend.friend-empty { border: none; background: none; } .friends .friend .friend-avatar { flex-shrink: 0; margin: 8px; width: 60px; height: 60px; line-height: 60px; border-radius: 30px; background-color: rgba(200, 200, 200, 0.2); background-size: cover; background-position: center; font-size: 24px; text-align: center; } .friends .friend .friend-detail { flex: 1; width: 0; display: flex; flex-direction: column; margin: 8px 8px 8px 0; } .friends .friend .friend-pop { position: absolute; width: 100%; left: 0; bottom: 0; } .friends .friend .friend-pop div { position: absolute; width: 100%; top: 8px; left: 0; padding: 8px; color: rgba(255, 255, 255, 0.9); border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 10; user-select: none; pointer-events: none; transition: opacity 0.5s; opacity: 0; } .friends .friend:hover .friend-pop div { opacity: 1; } 菲利英语&nbsp; philoenglish.com 签名: 菲利英语 Angular复兴 ngrevive.com 签名: Angular复兴 技术创作者导航站 blognav.cn 签名: 技术创作者导航站 独钓寒江雪 jiangxueqiao.com 签名: 孤舟蓑笠翁，独钓寒江雪。一位优秀的博主。 原紫番的互联网自留地 yuanzifan.com 站长原梓番，身份复杂，是职业写手、业余编剧、红梅卡梅隆、测试工程师、数据库管理员、命理师、自媒体博主、博客站长、阿迪王。 优秀技术人 Respect 廖雪峰的官方网站 liaoxuefeng.com 签名: 廖雪峰的官方网站 Java 全栈知识体系 pdai.tech 签名: Java 全栈知识体系 Javaᶜⁿ 面试突击 javacn.site 签名: Javaᶜⁿ 面试突击 小傅哥 bugstack 虫洞栈 bugstack.cn 签名: 小傅哥 bugstack 虫洞栈 老卫（柳伟卫）的博客 关注编程、系统架构、性能优化 签名: 老卫（柳伟卫）的博客 程序猿DD 程序员、阿里云MVP、腾讯云TVP 签名: 程序猿DD 赵化冰的博客 赵化冰，程序员, 开源爱好者，生活探险家 | 这里是 赵化冰 的博客，与你一起发现更大的世界。 赵化冰的网络日志, 赵化冰的博客, Zhaohuabing Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice, Envoy, Envoy Gateway 思维风暴 tkstorm.com 思维风暴 ManateeLazyCat manateelazycat.github.io 一个放荡不羁、 努力追求简单生活的人 李文周的博客 liwenzhou.com 总结Go语言学习之路，提供免费的Go语言学习教程，希望与大家一起学习进步。 汪志成@北京智座科技 ralph.wang 26年码农，六边形战士。 ## 希望之星 This Cute World thiscute.world This Cute World 友情链接互换如贵站符合以下条件: ✅ 网站在 Google 或者 bing.com 有 3 页以上的收录；✅ 贵站在全球范围内能够正常访问；✅ 贵站已添加本站友情链接, 并且不是 nofollow link。 并希望交换友情链接, 敬请在评论区留言。 本站友链信息如下： 网站名称：鹏叔的技术博客网站地址：https://pengtech.net网站图标：https://pengtech.net/img/avatar.png网站简介：鹏叔的技术博客，致力于为广大技术爱好者提供优质技术文章。","link":"/friends/"},{"title":"frontend","text":"1. 前端基础 Web基础大全 2. CSS sass学习笔记 3. javascript JavaScript之this关键字 javascript 内置对象 4. HTML Web基础大全 5. 前端框架 Angular Flex Layout使用详解 Angular中的JIT与AOT 应用angular material design 深度刨析@angular/platform-browser-dynamic Angular platform是什么? Angular如何配置多套环境 Angular实现登录保护 创建Angular项目 Angular guard介绍 Angular CLI 安装和使用 如何从Angularjs 升级到 Angular 深度刨析NgModule Angular2中的路由 Angular结合quill实现富文本编辑器 Angular injectable接口 MDC-based Angular Material组件迁移 Angular service worker介绍 Angular universal服务器端渲染与预渲染 从Angular 13升级到Angular 15 在Angular中使用TailwindCSS 使用Angular Universal时的重要注意事项 使用Gradle整合angular和Spring boot SEO教程 6. 前端设计风格 Material Design 基础 - Layout Material Design基础 - Surfaces Material Design基础 - 响应式布局网格 Material Design基础 - Pixel Density Material Design 基础 - Component behavior Material Design 基础 - 导航 Material Design 基础 - Elevation（标高） Material Design基础 - 光线和阴影 Material Design简介 Material Design 基础 - 颜色 Material Design基础 - spacing methods Material Design 基础 - Applying density Material Design 基础 - 文字排版 Angular Material实现typeahead简单示例 7. 前端工程化 webpack+angularjs1.x+bootstrap4.x开发环境配置 webpack中使用环境变量 如何发布一个nodejs模块 安装并配置nodejs 如何创建Nodejs模块基础篇","link":"/frontend/"},{"title":"gitlab 合集","text":"vscode相关文章链接: 破解Gitlab ee 15 企业版 gitlab安装升级及迁移 使用gitlab issue board的四种方式 GitLab集成PlantUML gitlab-runner安装与配置 gitlab CICD基础","link":"/gitlab/"},{"title":"golang合集","text":"golang基础 Golang 运算符 安装Golang","link":"/golang/"},{"title":"hexo 专题","text":"使用 Hexo 快速搭建自己的博客系统 16 款精美的 hexo 博客主题推荐 Hexo配置Next主题 Hexo 配置 Icarus 主题 Hexo博客添加评论功能 Hexo博客搜索引擎优化 Hexo命令详解 Hexo中插入mermaid图表","link":"/hexo/"},{"title":"java合集","text":"java基础 JDK17安装 如何在springboot中配置多个数据源 如何手动创建一个springBoot项目 如何使用Maven结合IDEA进行Debug 如何通过表名获取所有字段信息 java实现websocket的五种方式 使用stomp实现服务器端向web客户端推送数据","link":"/java/"},{"title":"Linux合集","text":"linux环境下创建rpm仓库 如何制作RPM安装包 Linux下安装gradle 在fedora35上安装virtualbox linux命令行连接wifi Linux文件目录结构详解 linux上ifconfig命令详解 linux上的rsync命令详解 Linux expect 详解 Msys2安装教程 CentOS7搭建NAS文件共享存储 使用Terraform在ESXI上创建虚拟机 Ubuntu服务器安装图形化界面 Centos7上源码安装git2.x 使用WireGuard内网穿透 Linux上安装PostgreSQL PostgreSQL基础 PostgreSQL高级篇 从Mariadb迁移到postgresql PostgreSQL备份与恢复 Centos7上安装MariaDB","link":"/linux/"},{"title":"Material design合集","text":"Material Design简介 Material Design 3介绍 Material 3 基础 更好的大屏幕设计 Material Design基础 - Surfaces Material Design 基础 - Elevation（标高） Material Design基础 - 光线和阴影 Material Design 基础 - 颜色 Material Design基础 - spacing methods Material Design 基础 - Applying density Material Design基础 - 响应式布局网格 Material Design基础 - Pixel Density Material Design 基础 - Component behavior Material Design 基础 - 导航 Material Design 基础 - Layout Material Design 基础 - 文字排版 Angular Material实现typeahead简单示例","link":"/material-design/"},{"title":"音乐","text":"","link":"/music/"},{"title":"rust合集","text":"rust基础 Rust 编程语言入门教程","link":"/rust/"},{"title":"tags","text":"","link":"/tags/"},{"title":"开发工具","text":".tools { display: flex; align-items: stretch; justify-content: space-between; flex-wrap: wrap; margin: -6px; } .tools .tool { margin: 6px; min-width: 240px; flex: 1; display: flex; align-items: center; justify-content: center; border-radius: 10px; border: 1px solid rgba(200, 200, 200, 0.2); background-color: rgba(200, 200, 200, 0.1); position: relative; } .tools .tool.tool-empty { border: none; background: none; } .tools .tool .tool-avatar { flex-shrink: 0; margin: 8px; width: 60px; height: 60px; line-height: 60px; border-radius: 30px; background-color: rgba(200, 200, 200, 0.2); background-size: cover; background-position: center; font-size: 24px; text-align: center; } .tools .tool .tool-detail { flex: 1; width: 0; display: flex; flex-direction: column; margin: 8px 8px 8px 0; } .tools .tool .tool-pop { position: absolute; width: 100%; left: 0; bottom: 0; } .tools .tool .tool-pop div { position: absolute; width: 100%; top: 8px; left: 0; padding: 8px; color: rgba(255, 255, 255, 0.9); border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 10; user-select: none; pointer-events: none; transition: opacity 0.5s; opacity: 0; } .tools .tool:hover .tool-pop div { opacity: 1; } 聊天 AI ChatGPT OpenAI 旗下 AI 聊天对话工具 OpenAI 旗下 AI 聊天对话工具 Gemini Google 旗下 AI 聊天对话工具 Google 旗下 AI 聊天对话工具 Copilot 微软旗下的日常 AI 助手 微软旗下的日常 AI 助手 文心一言 百度旗下 AI 聊天对话工具 百度旗下 AI 聊天对话工具 通义千问 阿里巴巴旗下 AI 聊天对话工具 阿里巴巴旗下 AI 聊天对话工具 讯飞星火 科大讯飞星火认知 AI 大模型 科大讯飞星火认知 AI 大模型 Kimi(月之暗面) Kimi（月之暗面）是月之暗面（Moonshot AI）公司推出的一款智能助手 Kimi（月之暗面）是月之暗面（Moonshot AI）公司推出的一款智能助手 腾讯混元 腾讯混元是腾讯自主研发的通用大语言模型 腾讯混元是腾讯自主研发的通用大语言模型 绘画 AI Midjourney AI 图像和插画生成工具 AI 图像和插画生成工具 Adobe Firefly Adobe 推出的 AI 图像生成和编辑工具 Adobe 推出的 AI 图像生成和编辑工具 Stable Diffusion 最强开源 AI 绘画工具 最强开源 AI 绘画工具 Microsoft Designer 微软推出的在线设计海报和宣传图工具 微软推出的在线设计海报和宣传图工具 文心一格 百度出品的 AI 绘画工具 百度出品的 AI 绘画工具 搜索引擎 Presearch Presearch是一个去中心化的搜索引擎。 Presearch是一个去中心化的搜索引擎，旨在保护用户隐私并提供加密货币奖励。用户在使用Presearch进行搜索时，可获得PRE加密代币，这些代币可用于购买服务或兑换其他加密货币 (Presearch)。Presearch集成了多种搜索引擎接口，包括Google、DuckDuckGo等，甚至还包括一些区块链工具，如Etherscan (Iridiumcao) 技术社区 稀土掘金 一个帮助开发者成长的社区 一个帮助开发者成长的社区 V2EX 创意工作者们的社区 创意工作者们的社区 思否 中国领先的开发者技术社区 中国领先的开发者技术社区 博客园 开发者的网上家园 开发者的网上家园 W2Solo 中文独立开发者社区 中文独立开发者社区 电鸭社区 专注远程工作招聘交流 专注远程工作招聘交流 StackOverflow 全球最大的技术问答社区 全球最大的技术问答社区 开源中国 目前国内最大的开源技术社区 目前国内最大的开源技术社区 InfoQ 一个实践驱动的技术社区资讯站点 一个实践驱动的技术社区资讯站点 51CTO 中国领先的 IT 技术网站 中国领先的 IT 技术网站 CSDN 中文最大的技术社区 中文最大的技术社区 部署托管 GitHub Pages 通过 GitHub 托管和发布的公共网页 通过 GitHub 托管和发布的公共网页 Cloudflare Pages Create full-stack applications that are instantly deployed to the Cloudflare global network. Create full-stack applications that are instantly deployed to the Cloudflare global network. Vercel Vercel's Frontend Cloud provides the developer experience and infrastructure to build, scale, and secure a faster, more personalized web. Netlify Netlify is the essential platform for the delivery of exceptional and dynamic web experiences, without limitations. Netlify is the essential platform for the delivery of exceptional and dynamic web experiences, without limitations. Railway Railway is the cloud for building, shipping, and monitoring applications. Railway is the cloud for building, shipping, and monitoring applications. Zeabur Say goodbye to deployment hassles. With Zeabur, bring your coding genius to life swiftly and smoothly. Say goodbye to deployment hassles. With Zeabur, bring your coding genius to life swiftly and smoothly. 站长工具 百度统计 百度统计是百度推出的一款免费、专业、稳定且安全的网站流量分析工具。 百度统计是百度推出的一款免费、专业、稳定且安全的网站流量分析工具。 Google AdSense Google公司推出的一项针对网站发布商的互联网广告服务。 Google公司推出的一项针对网站发布商的互联网广告服务。 Google AdSense 一个功能强大的广告管理平台，专为拥有大量直销业务的大型发布商设计。 Google公司推出的一个功能强大的广告管理平台，专为拥有大量直销业务的大型发布商设计。 Google Analytics Google Analytics 是谷歌提供的一款免费的网络分析工具。 Google Analytics 是谷歌提供的一款免费的网络分析工具，广泛用于网站和应用程序的数据收集与分析。它能够帮助用户了解网站的流量来源、访问者行为、受众特征等关键信息，从而优化网站性能和用户体验。 Ahrefs Ahrefs是一款功能强大的数字营销工具，专为跨境电商独立站的维护者以及SEO推广运营人员设计。 Ahrefs是一款功能强大的数字营销工具，专为跨境电商独立站的维护者以及SEO推广运营人员设计。 SEMrush SEMrush 是一款全面且强大的在线市场营销和SEO（搜索引擎优化）分析工具，专为营销人员、网站所有者和SEO专家设计。 SEMrush 是一款全面且强大的在线市场营销和SEO（搜索引擎优化）分析工具，专为营销人员、网站所有者和SEO专家设计。 similarWeb SimilarWeb是一款功能强大的网站数据分析工具，它提供了丰富的数据和分析功能，帮助用户深入了解网站性能、流量来源、用户行为以及竞争对手情况。 SimilarWeb是一款功能强大的网站数据分析工具，它提供了丰富的数据和分析功能，帮助用户深入了解网站性能、流量来源、用户行为以及竞争对手情况。 其他未编排presearch Presearch 是一个去中心化的搜索引擎，旨在保护用户隐私并提供加密货币奖励。用户在使用 Presearch 进行搜索时，可获得 PRE 加密代币，这些代币可用于购买服务或兑换其他加密货币 (Presearch)。Presearch 集成了多种搜索引擎接口，包括 Google、DuckDuckGo 等，甚至还包括一些区块链工具，如 Etherscan (Iridiumcao)。 wolai draw.io 在线便签 在线 markdown 免费的矢量图下载网站:SVG Repo 爱盼-网盘资源搜索 网页版的 Photoshop:photopea 字节跳动旗下的在线翻译网站，免登录: 火山在线翻译 在线免费生成 Logo 的网站，通过简单的属性选项即可创造出个性化的 Logo LogoCook 匿名的免费文章发布网站，支持文字和图片。telegra 提供数据暂存和传送服务，免登录，最大可支持 50MB 的内容，支持密码保护，且国内网络可访问。网络剪切板 提供数据暂存和传送服务，免登录，最大可支持 200MB 的内容，但国内网络无法访问。Catbox 在线 3D 全景游览故宫。全景故宫 旋元佑进阶文法 旋元佑进阶文法","link":"/tools/"},{"title":"v2rayA科学上网合集","text":"v2rayA 安装与配置Linux, Windows, MacOS 上安装与配置 v2rayA 2024 科学上网秘籍：v2rayA 安装与配置指南 for Windows、Linux、Macos、Android Windows 上安装与配置 v2rayN v2rayN 安装与配置 Android 手机上安装与配置 v2rayNG Android 上安装与配置 v2rayNG Windows 上安装与配置 v2rayA Windows 上安装与配置 v2rayA","link":"/v2rayA/"},{"title":"vscode合集","text":"vscode相关文章链接: vscode常用快捷键 VSCode安装和配置指南 Fedora linux上安装 Visual Studio Code 如何升级vscode","link":"/vscode/"}]}