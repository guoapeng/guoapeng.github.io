<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="hwu96hHsSnPefhY5oj_Q2reBfC1YuVkwbsuPeuAjSls"><meta name="baidu-site-verification" content="codeva-1TKHma47RE"><script>!function(t,e,n,c,r,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/cnl2uzz0vb?ref=bwt",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,a)}(window,document,"clarity","script")</script><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CPingFang+SC:300,300italic,400,400italic,700,700italic%7CMicrosoft+YaHei:300,300italic,400,400italic,700,700italic%7Csans-serif:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.pengtech.net","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":"enable","bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="上个月是 Angular 红盾诞生 13 周年。AngularJS 是新一波 JavaScript 框架的起点，旨在支持对丰富 Web 体验日益增长的需求。今天，我们凭借新的外观和一系列前瞻性功能，通过版本 17 带领大家走向未来，为性能和开发人员体验设定了新标准。"><meta property="og:type" content="article"><meta property="og:title" content="Angular 17 有哪些更新?"><meta property="og:url" content="https://www.pengtech.net/angular/angular_17_update.html"><meta property="og:site_name" content="鹏叔的技术博客"><meta property="og:description" content="上个月是 Angular 红盾诞生 13 周年。AngularJS 是新一波 JavaScript 框架的起点，旨在支持对丰富 Web 体验日益增长的需求。今天，我们凭借新的外观和一系列前瞻性功能，通过版本 17 带领大家走向未来，为性能和开发人员体验设定了新标准。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.pengtech.net/images/angular17/Angular17_logo.png"><meta property="og:image" content="https://www.pengtech.net/images/angular17/angular_new_branding.bin"><meta property="og:image" content="https://www.pengtech.net/images/angular17/angular_dev_overview.bin"><meta property="og:image" content="https://www.pengtech.net/images/angular17/deferred_loading.webp"><meta property="og:image" content="https://www.pengtech.net/images/angular17/ng_new_enable_ssr_ssg.bin"><meta property="og:image" content="https://www.pengtech.net/images/angular17/Vite_and_esbuild.webp"><meta property="og:image" content="https://www.pengtech.net/images/angular17/compare_ng_build_pipeline.webp"><meta property="og:image" content="https://www.pengtech.net/images/angular17/angular_devtools.bin"><meta property="article:published_time" content="2023-11-05T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-01T18:12:12.565Z"><meta property="article:author" content="鹏叔"><meta property="article:tag" content="web"><meta property="article:tag" content="Angular"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.pengtech.net/images/angular17/Angular17_logo.png"><link rel="canonical" href="https://www.pengtech.net/angular/angular_17_update.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.pengtech.net/angular/angular_17_update.html","path":"angular/angular_17_update.html","title":"Angular 17 有哪些更新?"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Angular 17 有哪些更新? | 鹏叔的技术博客</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZZTM0Y954E"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-ZZTM0Y954E","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?1da0f55a32eb17a877b1b18efa3d0406"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i> <span class="site-title h1">鹏叔的技术博客</span> <i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">日拱一卒，功不唐捐!</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-angular"><a href="/angular/" rel="section"><i class="fa fa-th fa-fw"></i>angular</a></li><li class="menu-item menu-item-material-design"><a href="/material-design/" rel="section"><i class="fa fa-th fa-fw"></i>material-design</a></li><li class="menu-item menu-item-linux"><a href="/linux/" rel="section"><i class="fa fa-cube fa-fw"></i>linux</a></li><li class="menu-item menu-item-gitlab"><a href="/gitlab/" rel="section"><i class="fa fa-th fa-fw"></i>gitlab</a></li><li class="menu-item menu-item-frontend"><a href="/frontend/" rel="section"><i class="fa fa-mobile fa-fw"></i>frontend</a></li><li class="menu-item menu-item-backend"><a href="/backend/" rel="section"><i class="fa fa-mobile fa-fw"></i>backend</a></li><li class="menu-item menu-item-vscode"><a href="/vscode/" rel="section"><i class="fa fa-th fa-fw"></i>vscode</a></li><li class="menu-item menu-item-hexo"><a href="/hexo/" rel="section"><i class="fa fa-sitemap fa-fw"></i>hexo</a></li><li class="menu-item menu-item-java"><a href="/java/" rel="section"><i class="fa fa-coffee fa-fw"></i>java</a></li><li class="menu-item menu-item-golang"><a href="/golang/" rel="section"><i class="fa fa-cloud fa-fw"></i>golang</a></li><li class="menu-item menu-item-v2raya"><a href="/v2rayA/" rel="section"><i class="fa fa-cloud fa-fw"></i>v2rayA</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%93%81%E7%89%8C%E5%BD%A2%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">1. 面向未来的品牌形象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%96%87%E6%A1%A3"><span class="nav-number">2.</span> <span class="nav-text">2. 面向未来的文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E7%BD%AE%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">3. 内置控制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. 条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B0%9D%E8%AF%95%E5%86%85%E7%BD%AE%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. 尝试内置控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%B0%86%E4%BC%9A%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. 接下来我们将会做些什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%AF%E5%BB%B6%E8%BF%9F%E8%A7%86%E5%9B%BE-Deferrable-views"><span class="nav-number">4.</span> <span class="nav-text">4. 可延迟视图(Deferrable views)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%8F%AF%E5%BB%B6%E8%BF%9F%E8%A7%86%E5%9B%BE%E5%B0%86%E4%BC%9A%E5%A6%82%E4%BD%95%E5%8F%91%E5%B1%95%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. 下一步可延迟视图将会如何发展？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%B7%B7%E5%90%88%E6%B8%B2%E6%9F%93%E4%BD%93%E9%AA%8C"><span class="nav-number">5.</span> <span class="nav-text">5. 改进的混合渲染体验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Hydration-%E4%BB%8E%E5%BC%80%E5%8F%91%E8%80%85%E9%A2%84%E8%A7%88%E7%89%88%E6%AF%95%E4%B8%9A"><span class="nav-number">6.</span> <span class="nav-text">6. Hydration 从开发者预览版毕业</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8-SSR-%E9%83%A8%E7%BD%B2%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">7. 使用 SSR 部署您的应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">8.</span> <span class="nav-text">8. 新的生命周期钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%96%B0%E9%A1%B9%E7%9B%AE%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8-Vite-%E5%92%8C-esbuild"><span class="nav-number">9.</span> <span class="nav-text">9. 新项目默认使用 Vite 和 esbuild</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-DevTools-%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%B0%83%E8%AF%95"><span class="nav-number">10.</span> <span class="nav-text">10. DevTools 中的依赖注入调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E4%BB%8E%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%97%B6%E5%B0%B1%E4%BD%BF%E7%94%A8-Standalone-API"><span class="nav-number">11.</span> <span class="nav-text">11. 从项目创建时就使用 Standalone API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-reactivity-%E7%9A%84%E5%90%8E%E7%BB%AD%E8%AE%A1%E5%88%92"><span class="nav-number">12.</span> <span class="nav-text">12. reactivity 的后续计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-testing-%E7%9A%84%E5%90%8E%E7%BB%AD%E8%AE%A1%E5%88%92"><span class="nav-number">13.</span> <span class="nav-text">13. testing 的后续计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Material-3-%E7%9A%84%E5%90%8E%E7%BB%AD%E8%AE%A1%E5%88%92"><span class="nav-number">14.</span> <span class="nav-text">14. Material 3 的后续计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C%E6%94%B9%E5%96%84"><span class="nav-number">15.</span> <span class="nav-text">15. 开发体验改善</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%A7%86%E5%9B%BE%E8%BD%AC%E6%8D%A2%E6%94%AF%E6%8C%81"><span class="nav-number">16.</span> <span class="nav-text">16. 实验性视图转换支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%9B%BE%E5%83%8F%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E9%A2%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">17.</span> <span class="nav-text">17. 图像指令中的自动预连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E6%A8%A1%E5%9D%97"><span class="nav-number">18.</span> <span class="nav-text">18. 延迟加载动画模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E8%BE%93%E5%85%A5%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-number">19.</span> <span class="nav-text">19. 输入值转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E4%BD%9C%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84-Style-%E5%92%8C-styleUrls"><span class="nav-number">20.</span> <span class="nav-text">20. 作为字符串的 Style 和 styleUrls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E7%A4%BE%E5%8C%BAschematics"><span class="nav-number">21.</span> <span class="nav-text">21. 社区schematics</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-Angular-%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%9F%B9%E8%AE%AD"><span class="nav-number">22.</span> <span class="nav-text">22. Angular 开发人员培训</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E7%A4%BE%E5%8C%BA%E4%BA%AE%E7%82%B9"><span class="nav-number">23.</span> <span class="nav-text">23. 社区亮点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E7%94%A8-Angular-%E6%9E%84%E5%BB%BA%E6%9C%AA%E6%9D%A5"><span class="nav-number">24.</span> <span class="nav-text">24. 用 Angular 构建未来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">25.</span> <span class="nav-text">25. 参考文档</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="鹏叔" src="/imgs/avatar.gif"><p class="site-author-name" itemprop="name">鹏叔</p><div class="site-description" itemprop="description">鹏叔的技术博客, 鹏叔的技术博客, 收集鹏叔在日常工作中整理的技术博客, 内容包括前端javascript, material design, typescript, css, html, 后端golang, java, 数据库等.</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">249</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">76</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/guoapeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;guoapeng" rel="noopener external nofollow" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:guoapeng@gmail.com" title="E-Mail → mailto:guoapeng@gmail.com" rel="noopener external nofollow" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener external nofollow" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://philoenglish.com/" title="https:&#x2F;&#x2F;philoenglish.com" target="_blank">菲利英语</a></li></ul></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.pengtech.net/angular/angular_17_update.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/imgs/avatar.gif"><meta itemprop="name" content="鹏叔"><meta itemprop="description" content="鹏叔的技术博客, 鹏叔的技术博客, 收集鹏叔在日常工作中整理的技术博客, 内容包括前端javascript, material design, typescript, css, html, 后端golang, java, 数据库等."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鹏叔的技术博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Angular 17 有哪些更新?</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-11-06 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-06T00:00:00+08:00">2023-11-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-05-02 02:12:12" itemprop="dateModified" datetime="2024-05-02T02:12:12+08:00">2024-05-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/frontend/" itemprop="url" rel="index"><span itemprop="name">frontend</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>上个月是 Angular 红盾诞生 13 周年。AngularJS 是新一波 JavaScript 框架的起点，旨在支持对丰富 Web 体验日益增长的需求。今天，我们凭借新的外观和一系列前瞻性功能，通过版本 17 带领大家走向未来，为性能和开发人员体验设定了新标准。</p><span id="more"></span><p><img src="https://www.pengtech.net/images/angular17/Angular17_logo.png" alt="Angular red shield"></p><p>在 v17 中，我们很高兴地介绍：</p><ul><li>可延迟视图(Deferrable views)将性能和开发人员体验提升到一个新的水平</li><li>在公共基准测试中，通过内置控制流循环，运行时间提高了 90%</li><li>混合渲染的构建速度提高了 87%，客户端渲染的构建速度提高了 67%</li><li>全新的外观反映了 Angular 的未来特征</li><li>全新的互动学习之旅</li><li>以及许多其他功能和改进！</li></ul><h2 id="1-面向未来的品牌形象"><a href="#1-面向未来的品牌形象" class="headerlink" title="1. 面向未来的品牌形象"></a>1. 面向未来的品牌形象</h2><p>在过去的几个版本中，Angular 的复兴一直在全力推进中。我们一直在通过 signal-based 反应性、水合(hydration)、独立组件(standalone components)、指令组合和许多其他功能等改进来加快势头。尽管 Angular 发展迅速，但它的品牌却未能跟上—从 AngularJS 早期以来，它几乎一模一样。</p><p>今天，您喜爱的、经过数百万开发者考验的框架焕然一新，反映了其面向未来的开发者体验和性能！</p><p><img src="https://www.pengtech.net/images/angular17/angular_new_branding.bin" alt="Angular red shield"></p><h2 id="2-面向未来的文档"><a href="#2-面向未来的文档" class="headerlink" title="2. 面向未来的文档"></a>2. 面向未来的文档</h2><p>与新品牌一起，我们还为 Angular 文档开发了一个新网站 — angular.dev。对于新的文档网站，我们采用了新的结构、新的指南、改进的内容，并构建了一个交互式学习之旅平台，让您可以直接在浏览器中按照自己的节奏学习 Angular 和 Angular CLI。</p><p>新的交互式学习体验由 WebContainers 提供支持，让您可以在任何现代 Web 浏览器中使用 Angular CLI 的强大功能！</p><p><img src="https://www.pengtech.net/images/angular17/angular_dev_overview.bin" alt="Angular dev overview"></p><p>今天，我们将推出 angular.dev 的 Beta 预览版，并计划将其设为 v18 中 Angular 的默认网站。您可以在“宣布 angular.dev”中了解有关 Angular 新外观和<a target="_blank" rel="noopener" href="https://blog.angular.io/announcing-angular-dev-1e1205fa3039">angular.dev 的更多信息</a>。”</p><p>现在让我深入了解 v17 的功能，我们迫不及待地想告诉您！</p><h2 id="3-内置控制流程"><a href="#3-内置控制流程" class="headerlink" title="3. 内置控制流程"></a>3. 内置控制流程</h2><p>为了改善开发人员体验，我们发布了新的块模板语法，通过简单的声明性 API 为您提供强大的功能。在底层，Angular 编译器将语法转换为高效的 JavaScript 指令，可以执行控制流、延迟加载等。</p><p>我们使用新的块语法来实现优化的内置控制流。在进行用户研究后，我们发现许多开发人员都在为*ngIf、*ngSwitch 和 *ngFor 而苦苦挣扎。自 2016 年开始使用 Angular 并在过去 5 年里成为 Angular 团队的一员，我个人仍然需要查找*ngFor 和的语法 trackBy。在收集了社区、合作伙伴的反馈并进行了用户体验研究之后，我们为 Angular 开发了一个新的内置控制流程！</p><p>内置控制流程可以：</p><ul><li><p>更符合人体工程学的语法，更接近 JavaScript，因此更直观，减少帮助文档的查找</p></li><li><p>得益于更优化的类型收敛（type narrowing），类型检查得到了很好的改善</p></li><li><p>内置控制流是构建阶段核心处理的部分，除了大大减少运行时的消耗（甚至直接消失）之外，还将使你的应用程序包大小整体减少 30KB 之多，从而进一步提高应用的核心网络指标（Core Web Vital）的得分</p></li><li><p>无需额外导入，即可在模版中通过变量来使用</p></li><li><p>我们稍后会介绍显着的性能改进</p></li></ul><h3 id="3-1-条件语句"><a href="#3-1-条件语句" class="headerlink" title="3.1. 条件语句"></a>3.1. 条件语句</h3><p>让我们看一下内置控制流中的 if 与 *ngIf 的 side by side 比较</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;loggedIn; else anonymousUser&quot;</span>&gt;</span>The user is logged in<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">anonymousUser</span>&gt;</span> The user is not logged in <span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用内置控制流 if 语句，此条件将如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="keyword">if</span> (loggedIn) &#123;</span><br><span class="line">  The user is logged <span class="keyword">in</span></span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">  The user is not logged <span class="keyword">in</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@else 与传统的 else 子句相比，能够直接提供内容是对 ngIf 一个重大的简化。当前的控制流也使得拥有@else if 条件语句变得轻而易举，这在历史版本中几乎是是不可能的。</p><p>ngSwitch 人体工学改进的更加明显：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngSwitch</span>]=<span class="string">&quot;accessLevel&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">admin-dashboard</span> *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;admin&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">moderator-dashboard</span> *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;moderator&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-dashboard</span> *<span class="attr">ngSwitchDefault</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过内置控制流程，它变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@<span class="keyword">switch</span> (accessLevel) &#123;   @<span class="keyword">case</span> ( <span class="string">&#x27;admin&#x27;</span> )   &#123; <span class="xml"><span class="tag">&lt;<span class="name">admin-dashboard</span>/&gt;</span></span> &#125; @<span class="keyword">case</span> (   <span class="string">&#x27; moderator &#x27;</span> ) &#123; <span class="xml"><span class="tag">&lt;<span class="name">moderator-dashboard</span>/&gt;</span></span> &#125; @<span class="keyword">default</span> &#123; &lt; user -dashboard/&gt; &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新的控制流可以在各个流程分支中更好地缩小类型，使用 ngSwitch 是做不到这一点的.</p><h3 id="3-2-for-循环"><a href="#3-2-for-循环" class="headerlink" title="3.2. for 循环"></a>3.2. for 循环</h3><p>我最喜欢的更新之一是我们引入的内置 for 循环，它除了开发人员体验改进之外，还将 Angular 的渲染速度推向了另一个水平！</p><p>其基本语法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> (user <span class="keyword">of</span> users; track user.id) &#123;</span><br><span class="line">  &#123;&#123; user.name &#125;&#125;</span><br><span class="line">&#125; @empty &#123;</span><br><span class="line">  Empty list <span class="keyword">of</span> users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 ngFor 时我们经常看到应用程序由于缺乏 trackBy 功能而出现性能问题。一些区别是@for，track 是强制性的，以确保快速比较性能。此外，它更容易使用，因为它只是一个表达式而不是组件类中的方法。内置@for 循环还具有通过 optional @empty 快捷处理空集合。</p><p>@for 语句使用了新的 diffing 算法，并且与 ngFor 相比具有更优化的实现，这使得社区框架基准测试的运行时间提高了 90% ！</p><h3 id="3-3-尝试内置控制流"><a href="#3-3-尝试内置控制流" class="headerlink" title="3.3. 尝试内置控制流"></a>3.3. 尝试内置控制流</h3><p>内置控制流现已在 v17 的开发者预览版中提供！</p><p>内置控制流的设计目标之一是实现完全自动化的迁移。要在现有项目中尝试它，请使用以下迁移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate @angular/core:control-flow</span><br></pre></td></tr></table></figure><h3 id="3-4-接下来我们将会做些什么"><a href="#3-4-接下来我们将会做些什么" class="headerlink" title="3.4. 接下来我们将会做些什么"></a>3.4. 接下来我们将会做些什么</h3><p>您已经可以使用带有最新语言服务的内置控制流，我们与 JetBrains 密切合作，以便在他们的产品中提供更好的支持。我们还与 Prettier 的 Sosuke Suzuki 联系，以确保 Angular 模板的格式正确。</p><p>ngIf 与、ngFor、ngSwitch 和相比内置控制流处理 content projection 的方式仍然存在一些差异，我们将在接下来的几个月内解决这些问题。除此之外，我们对内置控制流的实现和稳定性充满信心，所以您今天就可以尝试一下！我们希望将其保留在开发者预览版中，直到下一个主要版本，以便我们可以为潜在的向后不兼容修复打开大门，以便我们找到更多进一步增强开发者体验的机会.</p><h2 id="4-可延迟视图-Deferrable-views"><a href="#4-可延迟视图-Deferrable-views" class="headerlink" title="4. 可延迟视图(Deferrable views)"></a>4. 可延迟视图(Deferrable views)</h2><p>现在让我们谈谈延迟加载的未来！利用新的块语法，我们开发了一种新的强大机制，您可以使用它来使您的应用程序更快。在博客文章的开头，我说过可延迟视图将性能和开发人员体验提升到了一个新的水平，因为它们通过前所未有的人体工程学实现了声明性和强大的延迟加载(deferred loading)。</p><p><img src="https://www.pengtech.net/images/angular17/deferred_loading.webp" alt="deferred loading"></p><p>假设您有一个博客，并且您想延迟加载用户评论列表。目前，您必须在使用的 ViewContainerRef 同时管理清理的所有复杂性、管理加载错误、显示占位符等。处理各种极端情况可能会导致一些复杂度高极高的代码，这将难以测试和调试。</p><p>新的可延迟视图允许您使用一行声明性代码延迟加载注释列表及其所有传递依赖项：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@defer</span> &#123;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">comment-list</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个 DOM 元素进入视口时开始延迟加载组件涉及许多更重要的逻辑和 IntersectionObserver API。Angular 使 IntersectionObservers 的使用变得简单到只需要添加可延迟视图触发器即可！</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@defer</span> (on viewport) &#123;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">comment-list</span> /&gt;</span></span></span><br><span class="line">&#125; <span class="meta">@placeholder</span> &#123;</span><br><span class="line">  &lt;!-- A placeholder content to show until the comments load --&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;comments-placeholder.png&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，Angular 首先渲染占位符块的内容。当它在视口中可见时，组件就会开始加载<comment-list>。加载完成后，Angular 会删除占位符并渲染组件。</p><p>还有用于加载和错误状态的块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@defer</span> (on viewport) &#123;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">comment-list</span>/&gt;</span></span></span><br><span class="line">&#125; <span class="meta">@loading</span> &#123;</span><br><span class="line">  Loading…</span><br><span class="line">&#125; <span class="meta">@error</span> &#123;</span><br><span class="line">  Loading failed :(</span><br><span class="line">&#125; <span class="meta">@placeholder</span> &#123;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;comments-placeholder.png&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure><p>就是这样！Angular 为您管理了大量的复杂性。</p><p>可延迟视图提供了更多触发器：</p><ul><li>on idle- 当浏览器不做任何繁重的工作时延迟加载块</li><li>on immediate— 自动开始延迟加载，不阻塞浏览器</li><li>on timer(<time>)— 使用计时器延迟加载</time></li><li>on viewport 并且 on viewport(<ref>)- 视口还允许指定锚元素的引用。当锚元素可见时，Angular 将延迟加载组件并渲染它</ref></li><li>on interaction 并且 on interaction(<ref>)- 使您能够在用户与特定元素交互时启动延迟加载</ref></li><li>on hoverand on hover(<ref>)- 当用户悬停元素时触发延迟加载</ref></li><li>when<expr>— 使您能够通过布尔表达式指定您自己的条件</expr></li></ul><p>可延迟视图还提供了在渲染依赖项之前预取依赖项的能力。添加预取就像 prefetch 向 defer 块添加语句一样简单，并且支持所有相同的触发器。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@defer</span> (on viewport; prefetch on idle) &#123;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">comment-list</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天，可延迟视图在 v17 的开发者预览版中可用！[<a target="_blank" rel="noopener" href="https://angular.io/guide/defer">了解有关本指南</a>中该功能的更多信息。</p><h3 id="4-1-下一步可延迟视图将会如何发展？"><a href="#4-1-下一步可延迟视图将会如何发展？" class="headerlink" title="4.1. 下一步可延迟视图将会如何发展？"></a>4.1. 下一步可延迟视图将会如何发展？</h3><p>可延迟视图已准备好使用，我们强烈鼓励您尝试一下！我们将它们保留在开发人员预览中的原因是这样我们可以收集更多反馈并在 API 表面中引入更改，直到我们将它们锁定为像框架的其余部分一样遵循语义版本控制。</p><p>目前，服务器端渲染将渲染指定的占位符。一旦框架加载应用程序并对其进行水合，可延迟视图将按照我们上面描述的方式工作。</p><p>下一步，我们将探索在服务器上渲染延迟块内的内容，并在客户端上启用部分水合作用。在这种情况下，客户端不会下载延迟视图的代码，直到触发器请求它。此时，Angular 将下载相关的 JavaScript 并仅对视图的这一部分进行水合。</p><p>还将有许多令人兴奋的信号互操作性，敬请期待！</p><h2 id="5-改进的混合渲染体验"><a href="#5-改进的混合渲染体验" class="headerlink" title="5. 改进的混合渲染体验"></a>5. 改进的混合渲染体验</h2><p>今天，我们通过以下一行提示让开发人员开启服务器端渲染 (SSR) 和静态站点生成（SSG 或预渲染）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ng new</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.pengtech.net/images/angular17/ng_new_enable_ssr_ssg.bin" alt="ng new enable ssr and ssg"></p><p>这是我们长期以来一直想要做出的改变，但首先我们希望对 Angular 的 SSR 开发人员体验充满信心。</p><p>或者，您可以通过以下方式在新项目中启用 SSR：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new my-app --ssr</span><br></pre></td></tr></table></figure><h2 id="6-Hydration-从开发者预览版毕业"><a href="#6-Hydration-从开发者预览版毕业" class="headerlink" title="6. Hydration 从开发者预览版毕业"></a>6. Hydration 从开发者预览版毕业</h2><p>在过去的 6 个月里，我们看到数千个应用程序采用了水合作用。今天，我们很高兴地宣布，水合作用已不再是开发者预览版，并且在所有使用服务器端渲染的新应用程序中默认启用！</p><p>新的 @angular/ssr 包<br>我们将 Angular 通用存储库移至 Angular CLI 存储库，并使服务器端渲染成为我们工具产品中更不可或缺的一部分！</p><p>从今天开始，要向现有应用程序添加混合渲染支持，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ng add @angular/ssr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此命令将生成服务器入口点，添加 SSR 和 SSG 构建功能，并默认启用水合。@angular/ssr 提供与@nguniversal/express-engine 当前处于维护模式的功能等效的功能。如果您使用的是 express-engine，Angular CLI 会自动将您的代码更新为@angular/ssr.</p><p>从旧平台迁移到最新的 Angular 混合渲染解决方案后，Virgin Media O2 的销售额增长了 112%。NgOptimizedImage 通过与 Angular SSR 和 DOM Hydration 结合使用，累积布局偏移平均减少了 99.4% 。</p><h2 id="7-使用-SSR-部署您的应用程序"><a href="#7-使用-SSR-部署您的应用程序" class="headerlink" title="7. 使用 SSR 部署您的应用程序"></a>7. 使用 SSR 部署您的应用程序</h2><p>为了进一步增强开发人员体验，我们与云提供商密切合作，以实现顺利部署到他们的平台。</p><p>Firebase 现在将通过其新的框架感知 CLI 的早期预览版，以接近零的配置自动识别和部署您的 Angular 应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">firebase experiments:<span class="built_in">enable</span> webframeworks</span><br><span class="line">firebase init hosting</span><br><span class="line">firebase deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>框架感知(framework-aware)的 CLI 可识别 SSR、i18n、图像优化等的使用，使您能够在经济高效的无服务器基础设施上提供高性能的 Web 应用程序。</p><p>对于那些拥有复杂 Angular monorepos 或只是喜欢本机工具的人，AngularFire 允许使用以下方式部署到 Firebase ng deploy：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ng add @angular/fire</span><br><span class="line">ng deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了能够部署到边缘工作人员，我们在 Angular 的服务器端渲染中启用了 ECMAScript 模块支持，引入了 fetch 后端 HttpClient，并与 CloudFlare 合作来简化流程。</p><h2 id="8-新的生命周期钩子"><a href="#8-新的生命周期钩子" class="headerlink" title="8. 新的生命周期钩子"></a>8. 新的生命周期钩子</h2><p>为了提高 Angular 的 SSR 和 SSG 的性能，从长远来看，我们希望摆脱 DOM 模拟和直接 DOM 操作。同时，在大多数应用程序的生命周期中，它们需要与元素交互以实例化第三方库、测量元素大小等。</p><p>为了实现这一点，我们开发了一组新的生命周期挂钩：</p><ul><li>afterRender— 注册每次应用程序完成渲染时调用的回调</li><li>afterNextRender— 注册一个回调，以便在下次应用程序完成渲染时调用</li></ul><p>只有浏览器才会调用这些钩子，这使您能够将自定义 DOM 逻辑安全地直接插入组件中。例如，如果您想实例化一个图表库，您可以使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&quot;my-chart-cmp&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div #chart&gt;&#123;&#123; ... &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChartCmp</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">&quot;chart&quot;</span>) chartRef: ElementRef;</span><br><span class="line">  chart: MyChart | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    afterNextRender(</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chart = <span class="keyword">new</span> MyChart(<span class="built_in">this</span>.chartRef.nativeElement);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">phase</span>: AfterRenderPhase.Write &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个钩子都支持一个阶段值（例如读、写），Angular 将使用该阶段值来安排回调以减少布局抖动并提高性能。</p><h2 id="9-新项目默认使用-Vite-和-esbuild"><a href="#9-新项目默认使用-Vite-和-esbuild" class="headerlink" title="9. 新项目默认使用 Vite 和 esbuild"></a>9. 新项目默认使用 Vite 和 esbuild</h2><p><img src="https://www.pengtech.net/images/angular17/Vite_and_esbuild.webp" alt="Angular red shield"></p><p>如果没有对 Angular CLI 的构建管道进行根本性的改变，我们从一开始就无法在 Angular 中启用 SSR！</p><p>在 v16 中，我们引入了 esbuild 和 Vite 支持的构建体验的开发者预览版。从那时起，许多开发人员和一些企业合作伙伴都尝试了它，报告称他们的一些应用程序的构建时间缩短了 67% ！今天，我们很高兴地宣布，新的应用程序构建器已从开发者预览版中毕业，并且默认为所有新应用程序启用！</p><p>此外，我们还更新了使用混合渲染时的构建管道。借助 SSR 和 SSG，您可以观察到 ng build 的速度提高了 87%，ng serve 时修改刷新 loop 速度提高了 80%。</p><p><img src="https://www.pengtech.net/images/angular17/compare_ng_build_pipeline.webp" alt="Angular red shield"></p><p>在未来的次要版本中，我们将提供 schematics，以使用混合渲染（​​ 使用 SSG 或 SSR 进行客户端渲染）自动迁移现有项目。如果您今天想测试新的应用程序构建器，请查看我们<a target="_blank" rel="noopener" href="https://angular.io/guide/esbuild">文档中的指南</a>。</p><h2 id="10-DevTools-中的依赖注入调试"><a href="#10-DevTools-中的依赖注入调试" class="headerlink" title="10. DevTools 中的依赖注入调试"></a>10. DevTools 中的依赖注入调试</h2><p>去年，我们展示了 Angular DevTools 中依赖注入调试功能的预览。在过去的几个月里，我们实现了全新的调试 API，使我们能够插入框架的运行时并检查注入器树。</p><p>基于这些 API，我们构建了一个检查用户界面，允许您预览：</p><ul><li>组件检查器中组件的依赖关系</li><li>注入器树和依赖解析路径</li><li>在各个注入器中声明的 Providers</li></ul><p>您可以在下面的动画中快速预览这些功能。在 angular.io 上了解有关<a target="_blank" rel="noopener" href="https://angular.io/guide/devtools">Angular DevTools 的更多信息</a>。</p><p><img src="https://www.pengtech.net/images/angular17/angular_devtools.bin" alt="Angular red shield"></p><p>下一步，我们将完善 UI 并致力于更好地可视化注入器层次结构、providers 及其分辨率。</p><h2 id="11-从项目创建时就使用-Standalone-API"><a href="#11-从项目创建时就使用-Standalone-API" class="headerlink" title="11. 从项目创建时就使用 Standalone API"></a>11. 从项目创建时就使用 Standalone API</h2><p>在过去一年半的时间里收集了独立组件、指令和管道的反馈并完善了它们的 DevEx 后，我们有信心从一开始就在所有新应用程序中启用它们。所有 ng generate 命令现在都将构建独立组件、指令和管道。</p><p>与此同时，我们还重新审视了 Angular.io 和 Angular.dev 的整个文档，以确保一致的学习体验、开发实践和建议。</p><p>在可预见的将来，我们将保留 NgModules，但看到新的独立 API 的好处，我们强烈建议您逐步将项目迁移到它们。我们还提供了一个示意图，可以为您自动完成大部分工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng generate @angular/core:standalone</span><br></pre></td></tr></table></figure><p>有关更多信息，请查看我们的<a target="_blank" rel="noopener" href="https://angular.io/guide/standalone-migration">迁移指南</a>。</p><h2 id="12-reactivity-的后续计划"><a href="#12-reactivity-的后续计划" class="headerlink" title="12. reactivity 的后续计划"></a>12. reactivity 的后续计划</h2><p>Angular 新的基于信号的reactive系统是我们在该框架中所做的最大转变之一。为了确保与基于 Zone.js 的变更检测的向后兼容性和互操作性，我们一直在努力制作原型并设计前进的道路。</p><p>今天，我们很高兴地宣布 Angular Signals 实现已通过开发者预览版。目前，我们将将该 effect 函数保留在开发人员预览状态下，以便我们可以进一步迭代其语义。</p><p>在接下来的几个月中，我们将开始推出基于信号的输入、视图查询等功能。到明年 5 月，在 Angular v18 中，我们将提供许多功能来进一步改善开发人员使用 Signals 的体验。</p><h2 id="13-testing-的后续计划"><a href="#13-testing-的后续计划" class="headerlink" title="13. testing  的后续计划"></a>13. testing 的后续计划</h2><p>我们将继续试验 Jest，并确保我们构建一个高性能、灵活且直观的解决方案，足以满足开发人员的需求。我们还开始尝试 Web Test Runner，并为初始实施提供了一个开放的 PR 。在不久的将来，我们可能会首先关注 Web Test Runner，以解锁那些渴望摆脱 Karma 的项目。</p><h2 id="14-Material-3-的后续计划"><a href="#14-Material-3-的后续计划" class="headerlink" title="14. Material 3 的后续计划"></a>14. Material 3 的后续计划</h2><p>我们一直在与 Google 的 Material Design 团队努力合作，重构 Angular Material 的内部结构，以纳入Design token，该系统将为组件提供更多的自定义选项并启用Material 3支持。虽然我们还没有准备好为 v17 提供设计令牌和 M3 支持，但我们预计很快会在 v17 小版本中提供这些功能。</p><p>在 2022 年第四季度，我们宣布推出基于 MDC 的新 Angular Material 组件，并弃用具有相同功能但 DOM 结构和样式不同的旧组件。我们在 v15 中弃用了旧组件，并将在 v17 中删除。即使它们不属于 Angular Material v17 包的一部分，您仍然可以将应用程序更新到 Angular v17 并使用 v16 Angular Material 包。在 v18 之前，这将是一个选项，之后 Angular Material v16 将不再与较新版本的 Angular 兼容。我们还与HeroDevs的合作伙伴合作，他们将提供无休止的付费支持，以防您暂时无法执行迁移。</p><h2 id="15-开发体验改善"><a href="#15-开发体验改善" class="headerlink" title="15. 开发体验改善"></a>15. 开发体验改善</h2><p>除了所有这些面向未来的功能之外，我们还从待办事项中提供了一系列较小的开发人员体验增强功能！</p><h2 id="16-实验性视图转换支持"><a href="#16-实验性视图转换支持" class="headerlink" title="16. 实验性视图转换支持"></a>16. 实验性视图转换支持</h2><p><a target="_blank" rel="noopener" href="https://developer.chrome.com/docs/web-platform/view-transitions/">视图转换 API</a>可在更改 DOM 时实现平滑转换。在 Angular 路由器中，我们现在通过该withViewTransitions功能提供对此 API 的直接支持。使用此功能，您可以使用浏览器的本机功能在路线之间创建动画过渡。</p><p>您现在可以通过在引导期间在路由器的提供程序声明中配置此功能来将此功能添加到您的应用程序中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bootstrapApplication(App, &#123;</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">    provideRouter(routes, withViewTransitions()),</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>withViewTransitions接受带有 property 的可选配置对象onViewTransitionCreated，这是一个为您提供一些额外控制的回调：</p><ul><li>决定是否要跳过特定动画</li><li>向文档添加类以自定义动画并在动画完成时删除这些类</li><li>等等。</li></ul><h2 id="17-图像指令中的自动预连接"><a href="#17-图像指令中的自动预连接" class="headerlink" title="17. 图像指令中的自动预连接"></a>17. 图像指令中的自动预连接</h2><p>Angular 图像指令现在会自动为您作为参数提供给图像加载器的域生成预连接链接。如果图像指令无法自动识别源并且未检测到 LCP 图像的预连接链接，它将在开发过程中发出警告。</p><p>在<a target="_blank" rel="noopener" href="https://angular.io/guide/image-directive">图像指令指南</a>中了解有关此功能的更多信息。</p><h2 id="18-延迟加载动画模块"><a href="#18-延迟加载动画模块" class="headerlink" title="18. 延迟加载动画模块"></a>18. 延迟加载动画模块</h2><p>此功能可以使您的初始捆绑包（压缩后的 16KB）减少 60KB。社区贡献者Matthieu Riegler提出并实现了一项功能，允许您通过异步提供程序函数延迟加载动画模块：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; provideAnimationsAsync &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser/animations-async&#x27;</span>;</span><br><span class="line"></span><br><span class="line">bootstrapApplication(RootCmp, &#123;</span><br><span class="line">  <span class="attr">providers</span>: [provideAnimationsAsync()]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="19-输入值转换"><a href="#19-输入值转换" class="headerlink" title="19. 输入值转换"></a>19. 输入值转换</h2><p>常见的模式是具有接收布尔输入的组件。然而，这对如何将值传递给此类组件设置了限制。例如，如果我们对 Expander 组件有以下定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">standalone</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-expander&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`…`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Expander</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>() expanded: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>…我们尝试将其用作：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;my-expander expanded/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您将收到“字符串不可分配给布尔值”的错误。输入值转换允许您通过配置输入装饰器来解决此问题：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">standalone</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;my-expander&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`…`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Expander</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>(&#123; <span class="attr">transform</span>: booleanAttribute &#125;) expanded: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以在 GitHub 上找到原始功能请求 -<a target="_blank" rel="noopener" href="https://github.com/angular/angular/issues/14761">布尔属性作为 HTML 二进制属性</a>。</p><h2 id="20-作为字符串的-Style-和-styleUrls"><a href="#20-作为字符串的-Style-和-styleUrls" class="headerlink" title="20. 作为字符串的 Style 和 styleUrls"></a>20. 作为字符串的 Style 和 styleUrls</h2><p>Angular 组件支持每个组件多个样式表。然而，绝大多数情况下，当我想要设置组件的样式时，我会创建一个数组，其中包含指向内联样式或引用外部样式表的单个元素。一项新功能使您可以切换：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">styles</span>: [<span class="string">`</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;styles.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换到更简单、更符合逻辑的形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">styles</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">styleUrl</span>: <span class="string">&#x27;styles.css&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当您使用数组时，我们仍然支持多个样式表。这更符合人体工程学，更直观，并且与自动格式化工具配合使用效果更好。</p><h2 id="21-社区schematics"><a href="#21-社区schematics" class="headerlink" title="21. 社区schematics"></a>21. 社区schematics</h2><p>为了支持社区schematics的开发，我们提供了一些实用方法作为@schematics/angular/utility. 现在，您可以将表达式直接导入到 Angular 应用程序的根目录中，并将providers添加到 Angular 应用程序的package.json文件.</p><p>您可以在文档中的schematics指南中了解更多信息。</p><h2 id="22-Angular-开发人员培训"><a href="#22-Angular-开发人员培训" class="headerlink" title="22. Angular 开发人员培训"></a>22. Angular 开发人员培训</h2><p>我们与EdTech交互式平台 SoloLearn 合作，基于我们最近开发的“ Angular 简介”课程开发了新的 Angular 培训。他们创建了一个互动学习之旅，在过去两个月内覆盖了超过 7 万人！</p><p>请参阅我们<a target="_blank" rel="noopener" href="https://blog.angular.io/new-free-interactive-angular-course-for-beginners-on-sololearn-7a4c4f91810a">最近的公告</a>了解更多信息</p><h2 id="23-社区亮点"><a href="#23-社区亮点" class="headerlink" title="23. 社区亮点"></a>23. 社区亮点</h2><p>我们要感谢 346 位贡献者，是他们让 Angular v17 变得如此特别！我们想列出一些亮点：</p><ul><li><p>HttpClient现在可以使用 fetch 作为后端，这是使 Angular 能够在边缘工作线程中运行的功能之一。我们要感谢Matthieu Riegler的帮助</p></li><li><p>Matthieu 还启用了自定义功能，HttpTransferCache允许对发布请求指定标头、过滤器和缓存</p></li><li><p>Cédric Exbrayat 在新的应用程序构建器中引入了支持namedChunks</p></li><li><p>Thomas Laforge的Angular Challenges是一个优秀的资源网站，它一直在帮助 Angular 开发人员达到新的水平</p></li><li><p><a target="_blank" rel="noopener" href="https://analogjs.org/">AnalogJS</a>一直在稳步发展并接近 1.0。祝贺布兰登·罗伯茨所做的出色工作！</p></li><li><p>祝贺Santosh Yadav的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3qBXWUpoPHo">Angular 初学者课程</a>浏览量达到 100 万次</p></li></ul><h2 id="24-用-Angular-构建未来"><a href="#24-用-Angular-构建未来" class="headerlink" title="24. 用 Angular 构建未来"></a>24. 用 Angular 构建未来</h2><p>在过去的六个月里，我们一直在继续 Angular 的复兴，发布了一些功能，以提供更好的开发人员体验和性能。今天，我们很高兴在 Angular 更新的品牌和angular.dev 的学习体验中体现出这种势头。</p><p>在下一个发布周期中，预计 Angular 基于信号的反应性、混合渲染和学习之旅将发生大量演变。</p><p>我们很荣幸能够成为您使用 Angular 构建未来的旅程的一部分！谢谢你！</p><h2 id="25-参考文档"><a href="#25-参考文档" class="headerlink" title="25. 参考文档"></a>25. 参考文档</h2><p><a target="_blank" rel="noopener" href="https://medium.com/angular-blog/introducing-angular-v17-4d7033312e4b">Introducing Angular v17</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>鹏叔</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.pengtech.net/angular/angular_17_update.html" title="Angular 17 有哪些更新?">https://www.pengtech.net/angular/angular_17_update.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener external nofollow" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/web/" rel="tag"><i class="fa fa-tag"></i> web</a> <a href="/tags/Angular/" rel="tag"><i class="fa fa-tag"></i> Angular</a> <a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/nodejs/install_nvm_on_centos.html" rel="prev" title="Centos上安装nvm"><i class="fa fa-chevron-left"></i> Centos上安装nvm</a></div><div class="post-nav-item"><a href="/angular/angular_16_update.html" rel="next" title="Angular 16 有哪些更新?">Angular 16 有哪些更新? <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">鹏叔</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.3m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">19:54</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener external nofollow" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener external nofollow" target="_blank">NexT.Mist</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-615fe625918d4f20" async></script></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.2/dist/mermaid.min.js","integrity":"sha256-UIQPVkGifpwMvDH5yGgORJ9sSTDq38zz6BGU6dNaKhM="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"guoapeng/guoapeng.github.io","issue_term":"pathname","theme":"github-light","cdn":"https://utteranc.es/client.js"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>